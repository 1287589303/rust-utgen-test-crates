[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    let flags2 = Flags { multi_line: Some(true), ..Flags::default() };",
          "    let frame2 = HirFrame::Group { old_flags: flags2 };",
          "    assert_eq!(frame2.unwrap_group(), flags2);",
          "    let flags3 = Flags { dot_matches_new_line: Some(true), ..Flags::default() };",
          "    let frame3 = HirFrame::Group { old_flags: flags3 };",
          "    assert_eq!(frame3.unwrap_group(), flags3);",
          "    let flags4 = Flags { swap_greed: Some(true), ..Flags::default() };",
          "    let frame4 = HirFrame::Group { old_flags: flags4 };",
          "    assert_eq!(frame4.unwrap_group(), flags4);",
          "    let flags5 = Flags { unicode: Some(true), ..Flags::default() };",
          "    let frame5 = HirFrame::Group { old_flags: flags5 };",
          "    assert_eq!(frame5.unwrap_group(), flags5);",
          "    let flags6 = Flags { crlf: Some(true), ..Flags::default() };",
          "    let frame6 = HirFrame::Group { old_flags: flags6 };",
          "    assert_eq!(frame6.unwrap_group(), flags6);",
          "    let flags7 = Flags { case_insensitive: None, ..Flags::default() };",
          "    let frame7 = HirFrame::Group { old_flags: flags7 };",
          "    assert_eq!(frame7.unwrap_group(), flags7);",
          "    let result = std::panic::catch_unwind(|| {",
          "    let frame_invalid = HirFrame::Expr(Hir { kind: HirKind::Seq, props: Properties::default() });",
          "    frame_invalid.unwrap_group();",
          "    });",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    let flags2 = Flags { multi_line: Some(true), ..Flags::default() };",
          "    let frame2 = HirFrame::Group { old_flags: flags2 };",
          "    assert_eq!(frame2.unwrap_group(), flags2);",
          "    let flags3 = Flags { dot_matches_new_line: Some(true), ..Flags::default() };",
          "    let frame3 = HirFrame::Group { old_flags: flags3 };",
          "    assert_eq!(frame3.unwrap_group(), flags3);",
          "    let flags4 = Flags { swap_greed: Some(true), ..Flags::default() };",
          "    let frame4 = HirFrame::Group { old_flags: flags4 };",
          "    assert_eq!(frame4.unwrap_group(), flags4);",
          "    let flags5 = Flags { unicode: Some(true), ..Flags::default() };",
          "    let frame5 = HirFrame::Group { old_flags: flags5 };",
          "    assert_eq!(frame5.unwrap_group(), flags5);",
          "    let flags6 = Flags { crlf: Some(true), ..Flags::default() };",
          "    let frame6 = HirFrame::Group { old_flags: flags6 };",
          "    assert_eq!(frame6.unwrap_group(), flags6);",
          "    let flags7 = Flags { case_insensitive: None, ..Flags::default() };",
          "    let frame7 = HirFrame::Group { old_flags: flags7 };",
          "    assert_eq!(frame7.unwrap_group(), flags7);",
          "    let result = std::panic::catch_unwind(|| {",
          "    let frame_invalid = HirFrame::Expr(Hir { kind: HirKind::Seq, props: Properties::default() });",
          "    frame_invalid.unwrap_group();",
          "    });",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { multi_line: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frame.unwrap_group(), Flags { multi_line: Some(true), ..Flags::default() });"
        ],
        "code": [
          "{",
          "    let flags = Flags { multi_line: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "    assert_eq!(frame.unwrap_group(), Flags { multi_line: Some(true), ..Flags::default() });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { dot_matches_new_line: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    assert!(matches!(frame, HirFrame::Group { old_flags: _ }));",
          "    assert!(frame.unwrap_group().dot_matches_new_line.is_some());",
          "    assert_eq!(frame.unwrap_group().dot_matches_new_line, Some(true));"
        ],
        "code": [
          "{",
          "    let flags = Flags { dot_matches_new_line: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    assert!(matches!(frame, HirFrame::Group { old_flags: _ }));",
          "    assert!(frame.unwrap_group().dot_matches_new_line.is_some());",
          "    assert_eq!(frame.unwrap_group().dot_matches_new_line, Some(true));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { swap_greed: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    let flags = Flags { swap_greed: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    frame.unwrap_group();"
        ],
        "code": [
          "{",
          "    let flags = Flags { swap_greed: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "    let flags = Flags { swap_greed: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    frame.unwrap_group();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    assert!(matches!(frame, HirFrame::Group { old_flags }));",
          "    let expected_flags = Flags { unicode: Some(true), ..Flags::default() };",
          "    assert_eq!(frame.unwrap_group(), expected_flags);",
          "    let unwrapped_flags = frame.unwrap_group();",
          "    assert!(unwrapped_flags.unicode.is_some());",
          "    assert!(unwrapped_flags.case_insensitive.is_none());",
          "    assert!(unwrapped_flags.multi_line.is_none());",
          "    assert!(unwrapped_flags.dot_matches_new_line.is_none());",
          "    assert!(unwrapped_flags.swap_greed.is_none());",
          "    assert!(unwrapped_flags.crlf.is_none());"
        ],
        "code": [
          "{",
          "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    assert!(matches!(frame, HirFrame::Group { old_flags }));",
          "    let expected_flags = Flags { unicode: Some(true), ..Flags::default() };",
          "    assert_eq!(frame.unwrap_group(), expected_flags);",
          "    let unwrapped_flags = frame.unwrap_group();",
          "    assert!(unwrapped_flags.unicode.is_some());",
          "    assert!(unwrapped_flags.case_insensitive.is_none());",
          "    assert!(unwrapped_flags.multi_line.is_none());",
          "    assert!(unwrapped_flags.dot_matches_new_line.is_none());",
          "    assert!(unwrapped_flags.swap_greed.is_none());",
          "    assert!(unwrapped_flags.crlf.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { crlf: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    let flags = Flags { crlf: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    let flags2 = Flags { case_insensitive: Some(false), ..Flags::default() };",
          "    let frame2 = HirFrame::Group { old_flags: flags2 };",
          "    assert_eq!(frame2.unwrap_group(), flags2);",
          "    let flags3 = Flags { multi_line: Some(true), ..Flags::default() };",
          "    let frame3 = HirFrame::Group { old_flags: flags3 };",
          "    assert_eq!(frame3.unwrap_group(), flags3);",
          "    let flags4 = Flags { dot_matches_new_line: Some(false), ..Flags::default() };",
          "    let frame4 = HirFrame::Group { old_flags: flags4 };",
          "    assert_eq!(frame4.unwrap_group(), flags4);",
          "    let flags5 = Flags { swap_greed: Some(true), ..Flags::default() };",
          "    let frame5 = HirFrame::Group { old_flags: flags5 };",
          "    assert_eq!(frame5.unwrap_group(), flags5);",
          "    let flags6 = Flags { unicode: Some(true), ..Flags::default() };",
          "    let frame6 = HirFrame::Group { old_flags: flags6 };",
          "    assert_eq!(frame6.unwrap_group(), flags6);"
        ],
        "code": [
          "{",
          "    let flags = Flags { crlf: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "    let flags = Flags { crlf: Some(true), ..Flags::default() };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    let flags2 = Flags { case_insensitive: Some(false), ..Flags::default() };",
          "    let frame2 = HirFrame::Group { old_flags: flags2 };",
          "    assert_eq!(frame2.unwrap_group(), flags2);",
          "    let flags3 = Flags { multi_line: Some(true), ..Flags::default() };",
          "    let frame3 = HirFrame::Group { old_flags: flags3 };",
          "    assert_eq!(frame3.unwrap_group(), flags3);",
          "    let flags4 = Flags { dot_matches_new_line: Some(false), ..Flags::default() };",
          "    let frame4 = HirFrame::Group { old_flags: flags4 };",
          "    assert_eq!(frame4.unwrap_group(), flags4);",
          "    let flags5 = Flags { swap_greed: Some(true), ..Flags::default() };",
          "    let frame5 = HirFrame::Group { old_flags: flags5 };",
          "    assert_eq!(frame5.unwrap_group(), flags5);",
          "    let flags6 = Flags { unicode: Some(true), ..Flags::default() };",
          "    let frame6 = HirFrame::Group { old_flags: flags6 };",
          "    assert_eq!(frame6.unwrap_group(), flags6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags {",
          "        case_insensitive: Some(false),",
          "        multi_line: Some(false),",
          "        dot_matches_new_line: Some(false),",
          "        swap_greed: Some(false),",
          "        unicode: Some(false),",
          "        crlf: Some(false),",
          "    };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    let frame_invalid = HirFrame::Expr(Hir { kind: HirKind::Literal, props: Properties::default() });",
          "    let panic = std::panic::catch_unwind(|| { frame_invalid.unwrap_group(); });",
          "    assert!(panic.is_err());",
          "    let frame_empty = HirFrame::Group { old_flags: Flags::default() };",
          "    assert_eq!(frame_empty.unwrap_group(), Flags::default());"
        ],
        "code": [
          "{",
          "    let flags = Flags {",
          "        case_insensitive: Some(false),",
          "        multi_line: Some(false),",
          "        dot_matches_new_line: Some(false),",
          "        swap_greed: Some(false),",
          "        unicode: Some(false),",
          "        crlf: Some(false),",
          "    };",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "    let frame_invalid = HirFrame::Expr(Hir { kind: HirKind::Literal, props: Properties::default() });",
          "    let panic = std::panic::catch_unwind(|| { frame_invalid.unwrap_group(); });",
          "    assert!(panic.is_err());",
          "    let frame_empty = HirFrame::Group { old_flags: Flags::default() };",
          "    assert_eq!(frame_empty.unwrap_group(), Flags::default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags::default();",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frame.unwrap_group(), flags);"
        ],
        "code": [
          "{",
          "    let flags = Flags::default();",
          "    let frame = HirFrame::Group { old_flags: flags };",
          "    frame.unwrap_group();",
          "    assert_eq!(frame.unwrap_group(), flags);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]