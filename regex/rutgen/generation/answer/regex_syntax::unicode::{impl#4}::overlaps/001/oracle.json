[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    let start_end = 'a';",
          "    case_folder.overlaps(start_end, start_end);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(case_folder.overlaps('a', 'a'), true);",
          "    assert_eq!(case_folder.overlaps('b', 'b'), true);",
          "    assert_eq!(case_folder.overlaps('z', 'z'), false);",
          "    assert_eq!(case_folder.overlaps('A', 'A'), false);",
          "    assert_eq!(case_folder.overlaps('c', 'c'), false);"
        ],
        "code": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    let start_end = 'a';",
          "    case_folder.overlaps(start_end, start_end);",
          "    assert_eq!(case_folder.overlaps('a', 'a'), true);",
          "    assert_eq!(case_folder.overlaps('b', 'b'), true);",
          "    assert_eq!(case_folder.overlaps('z', 'z'), false);",
          "    assert_eq!(case_folder.overlaps('A', 'A'), false);",
          "    assert_eq!(case_folder.overlaps('c', 'c'), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('a', 'b');",
          "}"
        ],
        "oracle": [
          "    case_folder.overlaps('a', 'a'); // Test with start equal to end where mapping exists",
          "    case_folder.overlaps('b', 'b'); // Test with start equal to end where mapping exists",
          "    case_folder.overlaps('a', 'b'); // Test with inclusive range having multiple mappings",
          "    case_folder.overlaps('c', 'c'); // Test with start equal to end where no mapping exists",
          "    case_folder.overlaps('a', 'c'); // Test with range that includes both mapped and unmapped",
          "    case_folder.overlaps('z', 'z'); // Test with start equal to end for high codepoint with no mapping",
          "    case_folder.overlaps('a', 'd'); // Test with ranges extending beyond existing mappings",
          "    case_folder.overlaps('\\0', '\\0'); // Test with start equal to end at boundary codepoint",
          "    case_folder.overlaps('A', 'Z'); // Test with ranges that are outside the existing table",
          "    case_folder.overlaps('\\u{100}', '\\u{200}'); // Test with a range that is well beyond any mapping"
        ],
        "code": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('a', 'b');",
          "    case_folder.overlaps('a', 'a'); // Test with start equal to end where mapping exists",
          "    case_folder.overlaps('b', 'b'); // Test with start equal to end where mapping exists",
          "    case_folder.overlaps('a', 'b'); // Test with inclusive range having multiple mappings",
          "    case_folder.overlaps('c', 'c'); // Test with start equal to end where no mapping exists",
          "    case_folder.overlaps('a', 'c'); // Test with range that includes both mapped and unmapped",
          "    case_folder.overlaps('z', 'z'); // Test with start equal to end for high codepoint with no mapping",
          "    case_folder.overlaps('a', 'd'); // Test with ranges extending beyond existing mappings",
          "    case_folder.overlaps('\\0', '\\0'); // Test with start equal to end at boundary codepoint",
          "    case_folder.overlaps('A', 'Z'); // Test with ranges that are outside the existing table",
          "    case_folder.overlaps('\\u{100}', '\\u{200}'); // Test with a range that is well beyond any mapping",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('\\u{0000}', '\\u{0000}');",
          "}"
        ],
        "oracle": [
          "    assert!(case_folder.overlaps('\\u{0000}', '\\u{0000}') == false);",
          "    assert!(case_folder.overlaps('a', 'a') == true);",
          "    assert!(case_folder.overlaps('b', 'b') == true);",
          "    assert!(case_folder.overlaps('c', 'c') == false);",
          "    assert!(case_folder.overlaps('a', 'b') == true);",
          "    assert!(case_folder.overlaps('z', 'z') == false);"
        ],
        "code": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('\\u{0000}', '\\u{0000}');",
          "    assert!(case_folder.overlaps('\\u{0000}', '\\u{0000}') == false);",
          "    assert!(case_folder.overlaps('a', 'a') == true);",
          "    assert!(case_folder.overlaps('b', 'b') == true);",
          "    assert!(case_folder.overlaps('c', 'c') == false);",
          "    assert!(case_folder.overlaps('a', 'b') == true);",
          "    assert!(case_folder.overlaps('z', 'z') == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('\\u{10FFFF}', '\\u{10FFFF}');",
          "}"
        ],
        "oracle": [
          "    assert_eq!(case_folder.overlaps('\\u{10FFFF}', '\\u{10FFFF}'), false);",
          "    case_folder.overlaps('a', 'a');",
          "    assert!(case_folder.overlaps('b', 'b'));",
          "    assert!(!case_folder.overlaps('c', 'd'));",
          "    case_folder.overlaps('\\u{0000}', '\\u{007F}');",
          "    case_folder.overlaps('\\u{0041}', '\\u{0041}');",
          "    assert!(case_folder.overlaps('a', 'b'));",
          "    assert!(case_folder.overlaps('A', 'B'));",
          "    case_folder.overlaps('\\u{007F}', '\\u{007F}');"
        ],
        "code": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('\\u{10FFFF}', '\\u{10FFFF}');",
          "    assert_eq!(case_folder.overlaps('\\u{10FFFF}', '\\u{10FFFF}'), false);",
          "    case_folder.overlaps('a', 'a');",
          "    assert!(case_folder.overlaps('b', 'b'));",
          "    assert!(!case_folder.overlaps('c', 'd'));",
          "    case_folder.overlaps('\\u{0000}', '\\u{007F}');",
          "    case_folder.overlaps('\\u{0041}', '\\u{0041}');",
          "    assert!(case_folder.overlaps('a', 'b'));",
          "    assert!(case_folder.overlaps('A', 'B'));",
          "    case_folder.overlaps('\\u{007F}', '\\u{007F}');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('c', 'd');",
          "}"
        ],
        "oracle": [
          "    case_folder.overlaps('a', 'a'); // expected: true",
          "    case_folder.overlaps('b', 'b'); // expected: true",
          "    case_folder.overlaps('c', 'c'); // expected: false",
          "    case_folder.overlaps('d', 'd'); // expected: false",
          "    case_folder.overlaps('e', 'e'); // expected: false",
          "    case_folder.overlaps('A', 'A'); // expected: false",
          "    case_folder.overlaps('B', 'B'); // expected: false",
          "    case_folder.overlaps('z', 'z'); // expected: false",
          "    case_folder.overlaps('x', 'y'); // expected: false",
          "    case_folder.overlaps('a', 'b'); // expected: true",
          "    case_folder.overlaps('b', 'c'); // expected: true",
          "    case_folder.overlaps('c', 'e'); // expected: false"
        ],
        "code": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('b', &['B'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('c', 'd');",
          "    case_folder.overlaps('a', 'a'); // expected: true",
          "    case_folder.overlaps('b', 'b'); // expected: true",
          "    case_folder.overlaps('c', 'c'); // expected: false",
          "    case_folder.overlaps('d', 'd'); // expected: false",
          "    case_folder.overlaps('e', 'e'); // expected: false",
          "    case_folder.overlaps('A', 'A'); // expected: false",
          "    case_folder.overlaps('B', 'B'); // expected: false",
          "    case_folder.overlaps('z', 'z'); // expected: false",
          "    case_folder.overlaps('x', 'y'); // expected: false",
          "    case_folder.overlaps('a', 'b'); // expected: true",
          "    case_folder.overlaps('b', 'c'); // expected: true",
          "    case_folder.overlaps('c', 'e'); // expected: false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('c', &['C'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('a', 'c');",
          "}"
        ],
        "oracle": [
          "    assert!(case_folder.overlaps('a', 'a'));",
          "    assert!(case_folder.overlaps('b', 'b'));",
          "    assert!(case_folder.overlaps('c', 'c'));",
          "    assert!(!case_folder.overlaps('d', 'e'));",
          "    assert!(case_folder.overlaps('a', 'c'));",
          "    assert!(!case_folder.overlaps('z', 'z'));",
          "    assert!(case_folder.overlaps('c', 'c'));",
          "    assert!(case_folder.overlaps('a', 'c'));"
        ],
        "code": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[('a', &['A']), ('c', &['C'])];",
          "    let mut case_folder = SimpleCaseFolder { table, last: None, next: 0 };",
          "    case_folder.overlaps('a', 'c');",
          "    assert!(case_folder.overlaps('a', 'a'));",
          "    assert!(case_folder.overlaps('b', 'b'));",
          "    assert!(case_folder.overlaps('c', 'c'));",
          "    assert!(!case_folder.overlaps('d', 'e'));",
          "    assert!(case_folder.overlaps('a', 'c'));",
          "    assert!(!case_folder.overlaps('z', 'z'));",
          "    assert!(case_folder.overlaps('c', 'c'));",
          "    assert!(case_folder.overlaps('a', 'c'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]