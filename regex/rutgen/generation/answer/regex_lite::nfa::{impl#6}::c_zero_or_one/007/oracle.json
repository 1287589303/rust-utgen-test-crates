[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"a*\"));",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(Box::new(hir::Repetition {",
          "            min: 0,",
          "            max: None,",
          "            greedy: true,",
          "            sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })",
          "        })),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    ",
          "    let _ = compiler.c_zero_or_one(&hir, true);",
          "}"
        ],
        "oracle": [
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"a*\"));",
          "    let hir = Hir {",
          "    kind: HirKind::Repetition(Box::new(hir::Repetition {",
          "    min: 0,",
          "    max: None,",
          "    greedy: true,",
          "    sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })",
          "    })),",
          "    is_start_anchored: false,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: None,",
          "    };",
          "    let result = compiler.c_zero_or_one(&hir, true);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, expected_start_state_id);",
          "    assert_eq!(thompson_ref.end, expected_end_state_id);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"a*\"));",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(Box::new(hir::Repetition {",
          "            min: 0,",
          "            max: None,",
          "            greedy: true,",
          "            sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })",
          "        })),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    ",
          "    let _ = compiler.c_zero_or_one(&hir, true);",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"a*\"));",
          "    let hir = Hir {",
          "    kind: HirKind::Repetition(Box::new(hir::Repetition {",
          "    min: 0,",
          "    max: None,",
          "    greedy: true,",
          "    sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })",
          "    })),",
          "    is_start_anchored: false,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: None,",
          "    };",
          "    let result = compiler.c_zero_or_one(&hir, true);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, expected_start_state_id);",
          "    assert_eq!(thompson_ref.end, expected_end_state_id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"a*\"));",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(Box::new(hir::Repetition {",
          "            min: 0,",
          "            max: None,",
          "            greedy: false,",
          "            sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })",
          "        })),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    ",
          "    let _ = compiler.c_zero_or_one(&hir, false);",
          "}"
        ],
        "oracle": [
          "    assert!(compiler.add(State::Splits { targets: vec![], reverse: true }).is_ok());",
          "    assert!(compiler.c(&hir).is_ok());",
          "    assert!(compiler.add_empty().is_ok());",
          "    let splits = compiler.add(State::Splits { targets: vec![], reverse: true }).unwrap();",
          "    let compiled = compiler.c(&hir).unwrap();",
          "    let empty = compiler.add_empty().unwrap();",
          "    assert!(compiler.patch(splits, compiled.start).is_ok());",
          "    assert!(compiler.patch(splits, empty).is_ok());",
          "    assert!(compiler.patch(compiled.end, empty).is_ok());",
          "    let result = compiler.c_zero_or_one(&hir, false).unwrap();",
          "    assert_eq!(result, ThompsonRef { start: splits, end: empty });"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"a*\"));",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(Box::new(hir::Repetition {",
          "            min: 0,",
          "            max: None,",
          "            greedy: false,",
          "            sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })",
          "        })),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    ",
          "    let _ = compiler.c_zero_or_one(&hir, false);",
          "    assert!(compiler.add(State::Splits { targets: vec![], reverse: true }).is_ok());",
          "    assert!(compiler.c(&hir).is_ok());",
          "    assert!(compiler.add_empty().is_ok());",
          "    let splits = compiler.add(State::Splits { targets: vec![], reverse: true }).unwrap();",
          "    let compiled = compiler.c(&hir).unwrap();",
          "    let empty = compiler.add_empty().unwrap();",
          "    assert!(compiler.patch(splits, compiled.start).is_ok());",
          "    assert!(compiler.patch(splits, empty).is_ok());",
          "    assert!(compiler.patch(compiled.end, empty).is_ok());",
          "    let result = compiler.c_zero_or_one(&hir, false).unwrap();",
          "    assert_eq!(result, ThompsonRef { start: splits, end: empty });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"\")); // empty pattern",
          "",
          "    let hir = Hir { ",
          "        kind: HirKind::Empty, ",
          "        is_start_anchored: false, ",
          "        is_match_empty: true, ",
          "        static_explicit_captures_len: None ",
          "    };",
          "    ",
          "    let _ = compiler.c_zero_or_one(&hir, true);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(compiler.add(State::Splits { targets: vec![], reverse: false }), Ok(_)));",
          "    assert!(matches!(compiler.c(&hir), Ok(_)));",
          "    assert!(matches!(compiler.add_empty(), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, compiled.start), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, empty), Ok(_)));",
          "    assert!(matches!(compiler.patch(compiled.end, empty), Ok(_)));",
          "    let result = compiler.c_zero_or_one(&hir, true);",
          "    assert!(matches!(result, Ok(ThompsonRef { start: _, end: _ })));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"\")); // empty pattern",
          "",
          "    let hir = Hir { ",
          "        kind: HirKind::Empty, ",
          "        is_start_anchored: false, ",
          "        is_match_empty: true, ",
          "        static_explicit_captures_len: None ",
          "    };",
          "    ",
          "    let _ = compiler.c_zero_or_one(&hir, true);",
          "    assert!(matches!(compiler.add(State::Splits { targets: vec![], reverse: false }), Ok(_)));",
          "    assert!(matches!(compiler.c(&hir), Ok(_)));",
          "    assert!(matches!(compiler.add_empty(), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, compiled.start), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, empty), Ok(_)));",
          "    assert!(matches!(compiler.patch(compiled.end, empty), Ok(_)));",
          "    let result = compiler.c_zero_or_one(&hir, true);",
          "    assert!(matches!(result, Ok(ThompsonRef { start: _, end: _ })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"a\"));",
          "",
          "    let hir = Hir { ",
          "        kind: HirKind::Char('a'), ",
          "        is_start_anchored: false, ",
          "        is_match_empty: false, ",
          "        static_explicit_captures_len: None ",
          "    };",
          "    ",
          "    let _ = compiler.c_zero_or_one(&hir, false);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(compiler.c_zero_or_one(&hir, false).is_ok(), true);",
          "    assert_eq!(compiler.nfa.borrow().states.len(), initial_state_count + 1);",
          "    assert!(matches!(compiler.nfa.borrow().states[last_state_index], State::Splits { targets: _, reverse: true }));",
          "    assert!(matches!(compiler.c(&hir), Ok(_)));",
          "    assert!(matches!(compiler.add_empty(), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, compiled.start), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, empty), Ok(_)));",
          "    assert!(matches!(compiler.patch(compiled.end, empty), Ok(_)));",
          "    let result = compiler.c_zero_or_one(&hir, false).unwrap();",
          "    assert_eq!(result.start, splits);",
          "    assert_eq!(result.end, empty);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"a\"));",
          "",
          "    let hir = Hir { ",
          "        kind: HirKind::Char('a'), ",
          "        is_start_anchored: false, ",
          "        is_match_empty: false, ",
          "        static_explicit_captures_len: None ",
          "    };",
          "    ",
          "    let _ = compiler.c_zero_or_one(&hir, false);",
          "    assert_eq!(compiler.c_zero_or_one(&hir, false).is_ok(), true);",
          "    assert_eq!(compiler.nfa.borrow().states.len(), initial_state_count + 1);",
          "    assert!(matches!(compiler.nfa.borrow().states[last_state_index], State::Splits { targets: _, reverse: true }));",
          "    assert!(matches!(compiler.c(&hir), Ok(_)));",
          "    assert!(matches!(compiler.add_empty(), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, compiled.start), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, empty), Ok(_)));",
          "    assert!(matches!(compiler.patch(compiled.end, empty), Ok(_)));",
          "    let result = compiler.c_zero_or_one(&hir, false).unwrap();",
          "    assert_eq!(result.start, splits);",
          "    assert_eq!(result.end, empty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"[a-z]\"));",
          "",
          "    let class = hir::Class { ranges: vec![('a', 'z')] };",
          "    let hir = Hir { ",
          "        kind: HirKind::Class(Box::new(class)), ",
          "        is_start_anchored: false, ",
          "        is_match_empty: false, ",
          "        static_explicit_captures_len: None ",
          "    };",
          "",
          "    let _ = compiler.c_zero_or_one(&hir, true);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(compiler.add(State::Splits { targets: vec![], reverse: false }), Ok(_)));",
          "    assert!(matches!(compiler.c(&hir), Ok(_)));",
          "    assert!(matches!(compiler.add_empty(), Ok(_)));",
          "    let splits = compiler.add(State::Splits { targets: vec![], reverse: false }).unwrap();",
          "    let compiled = compiler.c(&hir).unwrap();",
          "    let empty = compiler.add_empty().unwrap();",
          "    assert!(matches!(compiler.patch(splits, compiled.start), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, empty), Ok(_)));",
          "    assert!(matches!(compiler.patch(compiled.end, empty), Ok(_)));",
          "    assert_eq!(compiler.c_zero_or_one(&hir, true).unwrap(), Ok(ThompsonRef { start: splits, end: empty }));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let compiler = Compiler::new(config, String::from(\"[a-z]\"));",
          "",
          "    let class = hir::Class { ranges: vec![('a', 'z')] };",
          "    let hir = Hir { ",
          "        kind: HirKind::Class(Box::new(class)), ",
          "        is_start_anchored: false, ",
          "        is_match_empty: false, ",
          "        static_explicit_captures_len: None ",
          "    };",
          "",
          "    let _ = compiler.c_zero_or_one(&hir, true);",
          "    assert!(matches!(compiler.add(State::Splits { targets: vec![], reverse: false }), Ok(_)));",
          "    assert!(matches!(compiler.c(&hir), Ok(_)));",
          "    assert!(matches!(compiler.add_empty(), Ok(_)));",
          "    let splits = compiler.add(State::Splits { targets: vec![], reverse: false }).unwrap();",
          "    let compiled = compiler.c(&hir).unwrap();",
          "    let empty = compiler.add_empty().unwrap();",
          "    assert!(matches!(compiler.patch(splits, compiled.start), Ok(_)));",
          "    assert!(matches!(compiler.patch(splits, empty), Ok(_)));",
          "    assert!(matches!(compiler.patch(compiled.end, empty), Ok(_)));",
          "    assert_eq!(compiler.c_zero_or_one(&hir, true).unwrap(), Ok(ThompsonRef { start: splits, end: empty }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]