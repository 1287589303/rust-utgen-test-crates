[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config::default();",
          "    let nfa = NFA::default();",
          "    let mut builder = InternalBuilder {",
          "        dfa: DFA {",
          "            config: config.clone(),",
          "            nfa,",
          "            table: vec![],",
          "            starts: vec![],",
          "            min_match_id: StateID::new(0),",
          "            classes: ByteClasses([0; 256]),",
          "            stride2: 8,",
          "            quitset: ByteSet::default(),",
          "            cache_capacity: 0,",
          "        },",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 10],",
          "        stack: vec![],",
          "        seen: SparseSet {",
          "            len: 0,",
          "            dense: vec![],",
          "            sparse: vec![],",
          "        },",
          "        matched: false,",
          "        config,",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    let nfa_id = StateID::new(5);",
          "    let result = builder.add_dfa_state_for_nfa_state(nfa_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Err(BuildError { kind: BuildErrorKind::TooManyStates }));",
          "    builder.nfa_to_dfa_id[nfa_id] = DEAD;",
          "    assert!(builder.uncompiled_nfa_ids.is_empty());",
          "    assert_eq!(builder.dfa.table.len(), 0);",
          "    assert_eq!(builder.stack.len(), 0);",
          "    assert!(!builder.matched);"
        ],
        "code": [
          "{",
          "    let config = Config::default();",
          "    let nfa = NFA::default();",
          "    let mut builder = InternalBuilder {",
          "        dfa: DFA {",
          "            config: config.clone(),",
          "            nfa,",
          "            table: vec![],",
          "            starts: vec![],",
          "            min_match_id: StateID::new(0),",
          "            classes: ByteClasses([0; 256]),",
          "            stride2: 8,",
          "            quitset: ByteSet::default(),",
          "            cache_capacity: 0,",
          "        },",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 10],",
          "        stack: vec![],",
          "        seen: SparseSet {",
          "            len: 0,",
          "            dense: vec![],",
          "            sparse: vec![],",
          "        },",
          "        matched: false,",
          "        config,",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    let nfa_id = StateID::new(5);",
          "    let result = builder.add_dfa_state_for_nfa_state(nfa_id);",
          "    assert_eq!(result, Err(BuildError { kind: BuildErrorKind::TooManyStates }));",
          "    builder.nfa_to_dfa_id[nfa_id] = DEAD;",
          "    assert!(builder.uncompiled_nfa_ids.is_empty());",
          "    assert_eq!(builder.dfa.table.len(), 0);",
          "    assert_eq!(builder.stack.len(), 0);",
          "    assert!(!builder.matched);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config::default();",
          "    let nfa = NFA::default();",
          "    let mut builder = InternalBuilder {",
          "        dfa: DFA {",
          "            config: config.clone(),",
          "            nfa,",
          "            table: vec![],",
          "            starts: vec![],",
          "            min_match_id: StateID::new(0),",
          "            classes: ByteClasses([0; 256]),",
          "            stride2: 8,",
          "            quitset: ByteSet::default(),",
          "            cache_capacity: 0,",
          "        },",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 10],",
          "        stack: vec![],",
          "        seen: SparseSet {",
          "            len: 0,",
          "            dense: vec![],",
          "            sparse: vec![],",
          "        },",
          "        matched: false,",
          "        config,",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    builder.dfa.table = vec![Transition(0); Transition::STATE_ID_LIMIT]; // Fill to exceed capacity",
          "    let nfa_id = StateID::new(6);",
          "    let result = builder.add_dfa_state_for_nfa_state(nfa_id);",
          "}"
        ],
        "oracle": [
          "    let mut builder = InternalBuilder { nfa_to_dfa_id: vec![DEAD; 10], ... }; // Precondition: empty DFA states",
          "    builder.nfa_to_dfa_id[StateID::new(6)] = StateID::new(1); // Existing DFA state for nfa_id 6",
          "    assert_eq!(builder.add_dfa_state_for_nfa_state(StateID::new(6)), Ok(StateID::new(1))); // Existing state is returned",
          "    ",
          "    let result = builder.add_empty_state(); // Precondition: Adding exceeds limits",
          "    assert!(result.is_err()); // Expected error when adding a new DFA state exceeds capacity",
          "    assert_eq!(result.err().unwrap().kind, BuildErrorKind::TooManyStates); // Verify error type"
        ],
        "code": [
          "{",
          "    let config = Config::default();",
          "    let nfa = NFA::default();",
          "    let mut builder = InternalBuilder {",
          "        dfa: DFA {",
          "            config: config.clone(),",
          "            nfa,",
          "            table: vec![],",
          "            starts: vec![],",
          "            min_match_id: StateID::new(0),",
          "            classes: ByteClasses([0; 256]),",
          "            stride2: 8,",
          "            quitset: ByteSet::default(),",
          "            cache_capacity: 0,",
          "        },",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 10],",
          "        stack: vec![],",
          "        seen: SparseSet {",
          "            len: 0,",
          "            dense: vec![],",
          "            sparse: vec![],",
          "        },",
          "        matched: false,",
          "        config,",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    builder.dfa.table = vec![Transition(0); Transition::STATE_ID_LIMIT]; // Fill to exceed capacity",
          "    let nfa_id = StateID::new(6);",
          "    let result = builder.add_dfa_state_for_nfa_state(nfa_id);",
          "    let mut builder = InternalBuilder { nfa_to_dfa_id: vec![DEAD; 10], ... }; // Precondition: empty DFA states",
          "    builder.nfa_to_dfa_id[StateID::new(6)] = StateID::new(1); // Existing DFA state for nfa_id 6",
          "    assert_eq!(builder.add_dfa_state_for_nfa_state(StateID::new(6)), Ok(StateID::new(1))); // Existing state is returned",
          "    ",
          "    let result = builder.add_empty_state(); // Precondition: Adding exceeds limits",
          "    assert!(result.is_err()); // Expected error when adding a new DFA state exceeds capacity",
          "    assert_eq!(result.err().unwrap().kind, BuildErrorKind::TooManyStates); // Verify error type",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]