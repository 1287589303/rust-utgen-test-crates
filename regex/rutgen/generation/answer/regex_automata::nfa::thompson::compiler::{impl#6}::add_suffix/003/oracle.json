[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::default();",
          "    let mut state = Utf8State {",
          "        compiled: Utf8BoundedMap::default(),",
          "        uncompiled: vec![Utf8Node {",
          "            trans: vec![],",
          "            last: None,",
          "        }],",
          "    };",
          "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
          "",
          "    let ranges = vec![Utf8Range {",
          "        start: 0x61, // 'a'",
          "        end: 0x61,   // 'a'",
          "    }];",
          "    ",
          "    compiler.add_suffix(&ranges);",
          "}"
        ],
        "oracle": [
          "    assert!(!ranges.is_empty()); // Precondition: ranges.is_empty() at line 1820 is false",
          "    assert!(self.state.uncompiled[last].last.is_none()); // Precondition: self.state.uncompiled[last].last.is_none() at line 1827 is true",
          "    assert!(ranges.len() == 1); // Precondition: r in &ranges[1..] at line 1832 is false (no additional ranges)"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::default();",
          "    let mut state = Utf8State {",
          "        compiled: Utf8BoundedMap::default(),",
          "        uncompiled: vec![Utf8Node {",
          "            trans: vec![],",
          "            last: None,",
          "        }],",
          "    };",
          "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
          "",
          "    let ranges = vec![Utf8Range {",
          "        start: 0x61, // 'a'",
          "        end: 0x61,   // 'a'",
          "    }];",
          "    ",
          "    compiler.add_suffix(&ranges);",
          "    assert!(!ranges.is_empty()); // Precondition: ranges.is_empty() at line 1820 is false",
          "    assert!(self.state.uncompiled[last].last.is_none()); // Precondition: self.state.uncompiled[last].last.is_none() at line 1827 is true",
          "    assert!(ranges.len() == 1); // Precondition: r in &ranges[1..] at line 1832 is false (no additional ranges)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::default();",
          "    let mut state = Utf8State {",
          "        compiled: Utf8BoundedMap::default(),",
          "        uncompiled: vec![Utf8Node {",
          "            trans: vec![],",
          "            last: None,",
          "        }],",
          "    };",
          "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
          "",
          "    let ranges = vec![",
          "        Utf8Range {",
          "            start: 0x62, // 'b'",
          "            end: 0x62,   // 'b'",
          "        },",
          "        Utf8Range {",
          "            start: 0x63, // 'c'",
          "            end: 0x63,   // 'c'",
          "        },",
          "    ];",
          "",
          "    compiler.add_suffix(&ranges);",
          "}"
        ],
        "oracle": [
          "    assert!(!ranges.is_empty());",
          "    assert!(self.state.uncompiled[last].last.is_none());",
          "    assert_eq!(self.state.uncompiled[last].last, None);",
          "    assert!(self.state.uncompiled.len() > 0);",
          "    assert_eq!(self.state.uncompiled[0].trans.len(), 0);",
          "    assert_eq!(self.state.uncompiled[0].last, Some(Utf8LastTransition { start: 0x62, end: 0x62 }));",
          "    assert_eq!(self.state.uncompiled.len(), 2);",
          "    assert_eq!(self.state.uncompiled[1].last, Some(Utf8LastTransition { start: 0x63, end: 0x63 }));"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::default();",
          "    let mut state = Utf8State {",
          "        compiled: Utf8BoundedMap::default(),",
          "        uncompiled: vec![Utf8Node {",
          "            trans: vec![],",
          "            last: None,",
          "        }],",
          "    };",
          "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
          "",
          "    let ranges = vec![",
          "        Utf8Range {",
          "            start: 0x62, // 'b'",
          "            end: 0x62,   // 'b'",
          "        },",
          "        Utf8Range {",
          "            start: 0x63, // 'c'",
          "            end: 0x63,   // 'c'",
          "        },",
          "    ];",
          "",
          "    compiler.add_suffix(&ranges);",
          "    assert!(!ranges.is_empty());",
          "    assert!(self.state.uncompiled[last].last.is_none());",
          "    assert_eq!(self.state.uncompiled[last].last, None);",
          "    assert!(self.state.uncompiled.len() > 0);",
          "    assert_eq!(self.state.uncompiled[0].trans.len(), 0);",
          "    assert_eq!(self.state.uncompiled[0].last, Some(Utf8LastTransition { start: 0x62, end: 0x62 }));",
          "    assert_eq!(self.state.uncompiled.len(), 2);",
          "    assert_eq!(self.state.uncompiled[1].last, Some(Utf8LastTransition { start: 0x63, end: 0x63 }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]