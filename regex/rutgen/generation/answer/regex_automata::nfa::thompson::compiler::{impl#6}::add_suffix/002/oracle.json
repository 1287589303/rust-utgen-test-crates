[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::default();",
          "    let mut state = Utf8State {",
          "        compiled: Utf8BoundedMap::default(),",
          "        uncompiled: vec![Utf8Node { trans: vec![], last: None }],",
          "    };",
          "    let mut compiler = Utf8Compiler {",
          "        builder: &mut builder,",
          "        state: &mut state,",
          "        target: StateID(0),",
          "    };",
          "    ",
          "    let ranges = vec![",
          "        Utf8Range { start: 0x61, end: 0x61 }, // 'a'",
          "        Utf8Range { start: 0x62, end: 0x62 }, // 'b'",
          "    ];",
          "    ",
          "    compiler.add_suffix(&ranges);",
          "}"
        ],
        "oracle": [
          "    assert!(!ranges.is_empty());",
          "    assert!(self.state.uncompiled[last].last.is_none());",
          "    let last = self.state.uncompiled.len().checked_sub(1).expect(\"non-empty nodes\");",
          "    self.state.uncompiled[last].last = Some(Utf8LastTransition { start: ranges[0].start, end: ranges[0].end });",
          "    assert!(self.state.uncompiled[last].last.is_some());",
          "    let ranges = vec![Utf8Range { start: 0x61, end: 0x61 }, Utf8Range { start: 0x62, end: 0x62 }];",
          "    assert_eq!(self.state.uncompiled.len(), 1);",
          "    assert_eq!(self.state.uncompiled[1].last.as_ref().unwrap().start, 0x62);",
          "    assert_eq!(self.state.uncompiled[1].last.as_ref().unwrap().end, 0x62);",
          "    assert!(self.state.uncompiled[0].last.is_some());",
          "    assert!(self.state.uncompiled[1].last.is_some());",
          "    let ranges_empty: Vec<Utf8Range> = vec![];",
          "    assert!(ranges_empty.is_empty());"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::default();",
          "    let mut state = Utf8State {",
          "        compiled: Utf8BoundedMap::default(),",
          "        uncompiled: vec![Utf8Node { trans: vec![], last: None }],",
          "    };",
          "    let mut compiler = Utf8Compiler {",
          "        builder: &mut builder,",
          "        state: &mut state,",
          "        target: StateID(0),",
          "    };",
          "    ",
          "    let ranges = vec![",
          "        Utf8Range { start: 0x61, end: 0x61 }, // 'a'",
          "        Utf8Range { start: 0x62, end: 0x62 }, // 'b'",
          "    ];",
          "    ",
          "    compiler.add_suffix(&ranges);",
          "    assert!(!ranges.is_empty());",
          "    assert!(self.state.uncompiled[last].last.is_none());",
          "    let last = self.state.uncompiled.len().checked_sub(1).expect(\"non-empty nodes\");",
          "    self.state.uncompiled[last].last = Some(Utf8LastTransition { start: ranges[0].start, end: ranges[0].end });",
          "    assert!(self.state.uncompiled[last].last.is_some());",
          "    let ranges = vec![Utf8Range { start: 0x61, end: 0x61 }, Utf8Range { start: 0x62, end: 0x62 }];",
          "    assert_eq!(self.state.uncompiled.len(), 1);",
          "    assert_eq!(self.state.uncompiled[1].last.as_ref().unwrap().start, 0x62);",
          "    assert_eq!(self.state.uncompiled[1].last.as_ref().unwrap().end, 0x62);",
          "    assert!(self.state.uncompiled[0].last.is_some());",
          "    assert!(self.state.uncompiled[1].last.is_some());",
          "    let ranges_empty: Vec<Utf8Range> = vec![];",
          "    assert!(ranges_empty.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::default();",
          "    let mut state = Utf8State {",
          "        compiled: Utf8BoundedMap::default(),",
          "        uncompiled: vec![Utf8Node { trans: vec![], last: None }],",
          "    };",
          "    let mut compiler = Utf8Compiler {",
          "        builder: &mut builder,",
          "        state: &mut state,",
          "        target: StateID(0),",
          "    };",
          "    ",
          "    let ranges = vec![",
          "        Utf8Range { start: 0x61, end: 0x61 }, // 'a'",
          "        Utf8Range { start: 0x62, end: 0x62 }, // 'b'",
          "        Utf8Range { start: 0x63, end: 0x63 }, // 'c'",
          "    ];",
          "",
          "    compiler.add_suffix(&ranges);",
          "}"
        ],
        "oracle": [
          "    assert!(!ranges.is_empty());",
          "    assert!(self.state.uncompiled[last].last.is_none());",
          "    assert!(r in &ranges[1..]);",
          "    assert!(!(r in &ranges[1..]));"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::default();",
          "    let mut state = Utf8State {",
          "        compiled: Utf8BoundedMap::default(),",
          "        uncompiled: vec![Utf8Node { trans: vec![], last: None }],",
          "    };",
          "    let mut compiler = Utf8Compiler {",
          "        builder: &mut builder,",
          "        state: &mut state,",
          "        target: StateID(0),",
          "    };",
          "    ",
          "    let ranges = vec![",
          "        Utf8Range { start: 0x61, end: 0x61 }, // 'a'",
          "        Utf8Range { start: 0x62, end: 0x62 }, // 'b'",
          "        Utf8Range { start: 0x63, end: 0x63 }, // 'c'",
          "    ];",
          "",
          "    compiler.add_suffix(&ranges);",
          "    assert!(!ranges.is_empty());",
          "    assert!(self.state.uncompiled[last].last.is_none());",
          "    assert!(r in &ranges[1..]);",
          "    assert!(!(r in &ranges[1..]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]