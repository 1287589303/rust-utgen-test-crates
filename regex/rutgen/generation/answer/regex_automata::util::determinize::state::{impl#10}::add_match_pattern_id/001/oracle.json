[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut vec = Vec::new();",
          "    let mut repr_vec = ReprVec(&mut vec);",
          "    repr_vec.set_has_pattern_ids(); // Setting has_pattern_ids to true",
          "    ",
          "    let pid = PatternID(1.into()); // Using a valid, non-zero PatternID",
          "    repr_vec.add_match_pattern_id(pid);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(repr_vec.repr().has_pattern_ids(), true);",
          "    assert_eq!(repr_vec.repr().is_match(), true);",
          "    assert_eq!(vec.len() % PatternID::SIZE, 0);",
          "    assert_eq!(vec.len(), PatternID::SIZE + 4);",
          "    assert_eq!(u32::from_ne_bytes(vec[vec.len()-4..vec.len()].try_into().unwrap()), pid.as_u32());",
          "    assert!(vec[0] & (1 << 0) > 0);",
          "    assert!(vec[0] & (1 << 1) > 0);"
        ],
        "code": [
          "{",
          "    let mut vec = Vec::new();",
          "    let mut repr_vec = ReprVec(&mut vec);",
          "    repr_vec.set_has_pattern_ids(); // Setting has_pattern_ids to true",
          "    ",
          "    let pid = PatternID(1.into()); // Using a valid, non-zero PatternID",
          "    repr_vec.add_match_pattern_id(pid);",
          "    assert_eq!(repr_vec.repr().has_pattern_ids(), true);",
          "    assert_eq!(repr_vec.repr().is_match(), true);",
          "    assert_eq!(vec.len() % PatternID::SIZE, 0);",
          "    assert_eq!(vec.len(), PatternID::SIZE + 4);",
          "    assert_eq!(u32::from_ne_bytes(vec[vec.len()-4..vec.len()].try_into().unwrap()), pid.as_u32());",
          "    assert!(vec[0] & (1 << 0) > 0);",
          "    assert!(vec[0] & (1 << 1) > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut vec = Vec::new();",
          "    let mut repr_vec = ReprVec(&mut vec);",
          "    repr_vec.set_has_pattern_ids(); // Setting has_pattern_ids to true",
          "",
          "    let pid = PatternID(u32::MAX.into()); // Using the maximum valid PatternID",
          "    repr_vec.add_match_pattern_id(pid);",
          "}"
        ],
        "oracle": [
          "    assert!(repr_vec.repr().has_pattern_ids());",
          "    assert_eq!(vec.len(), PatternID::SIZE + 4);",
          "    assert_eq!(vec[0], 1);",
          "    assert_eq!(vec[1], 0);",
          "    assert_eq!(vec[2], 0);",
          "    assert_eq!(vec[3], 0);",
          "    assert_eq!(vec[4], u32::MAX);",
          "    assert!(repr_vec.repr().is_match());",
          "    assert!(repr_vec.repr().match_pattern_ids().is_some());",
          "    assert_eq!(repr_vec.repr().match_pattern_ids().unwrap().len(), 1);",
          "    assert_eq!(repr_vec.repr().match_pattern(0), pid);"
        ],
        "code": [
          "{",
          "    let mut vec = Vec::new();",
          "    let mut repr_vec = ReprVec(&mut vec);",
          "    repr_vec.set_has_pattern_ids(); // Setting has_pattern_ids to true",
          "",
          "    let pid = PatternID(u32::MAX.into()); // Using the maximum valid PatternID",
          "    repr_vec.add_match_pattern_id(pid);",
          "    assert!(repr_vec.repr().has_pattern_ids());",
          "    assert_eq!(vec.len(), PatternID::SIZE + 4);",
          "    assert_eq!(vec[0], 1);",
          "    assert_eq!(vec[1], 0);",
          "    assert_eq!(vec[2], 0);",
          "    assert_eq!(vec[3], 0);",
          "    assert_eq!(vec[4], u32::MAX);",
          "    assert!(repr_vec.repr().is_match());",
          "    assert!(repr_vec.repr().match_pattern_ids().is_some());",
          "    assert_eq!(repr_vec.repr().match_pattern_ids().unwrap().len(), 1);",
          "    assert_eq!(repr_vec.repr().match_pattern(0), pid);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut vec = Vec::new();",
          "    let mut repr_vec = ReprVec(&mut vec);",
          "    repr_vec.set_has_pattern_ids(); // Setting has_pattern_ids to true",
          "",
          "    let pid1 = PatternID(1.into()); // First valid, non-zero PatternID",
          "    let pid2 = PatternID(2.into()); // Second valid, non-zero PatternID",
          "    ",
          "    repr_vec.add_match_pattern_id(pid1);",
          "    repr_vec.add_match_pattern_id(pid2);",
          "}"
        ],
        "oracle": [
          "    repr_vec.repr().has_pattern_ids() == true",
          "    repr_vec.repr().is_match() == true",
          "    vec.len() == 8 // 4 bytes for each PatternID plus the bit flags",
          "    vec[0..4] == [0, 0, 0, 1] // First PatternID (pid1) encoded as u32",
          "    vec[4..8] == [0, 0, 0, 2] // Second PatternID (pid2) encoded as u32"
        ],
        "code": [
          "{",
          "    let mut vec = Vec::new();",
          "    let mut repr_vec = ReprVec(&mut vec);",
          "    repr_vec.set_has_pattern_ids(); // Setting has_pattern_ids to true",
          "",
          "    let pid1 = PatternID(1.into()); // First valid, non-zero PatternID",
          "    let pid2 = PatternID(2.into()); // Second valid, non-zero PatternID",
          "    ",
          "    repr_vec.add_match_pattern_id(pid1);",
          "    repr_vec.add_match_pattern_id(pid2);",
          "    repr_vec.repr().has_pattern_ids() == true",
          "    repr_vec.repr().is_match() == true",
          "    vec.len() == 8 // 4 bytes for each PatternID plus the bit flags",
          "    vec[0..4] == [0, 0, 0, 1] // First PatternID (pid1) encoded as u32",
          "    vec[4..8] == [0, 0, 0, 2] // Second PatternID (pid2) encoded as u32",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]