[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet::empty();",
          "    let _iter = look_set.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.set, look_set);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet::empty();",
          "    let _iter = look_set.iter();",
          "    assert_eq!(_iter.set, look_set);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::new(); // Assuming Look has a `new()` method",
          "    let look_set = LookSet::singleton(look);",
          "    let _iter = look_set.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.set, look_set);",
          "    assert!(_iter.set.len() == 1);",
          "    assert!(!_iter.set.is_empty());",
          "    assert!(_iter.set.contains(look));",
          "    assert!(_iter.set.contains_anchor() == look_set.contains_anchor());",
          "    assert!(_iter.set.contains_word() == look_set.contains_word());"
        ],
        "code": [
          "{",
          "    let look = Look::new(); // Assuming Look has a `new()` method",
          "    let look_set = LookSet::singleton(look);",
          "    let _iter = look_set.iter();",
          "    assert_eq!(_iter.set, look_set);",
          "    assert!(_iter.set.len() == 1);",
          "    assert!(!_iter.set.is_empty());",
          "    assert!(_iter.set.contains(look));",
          "    assert!(_iter.set.contains_anchor() == look_set.contains_anchor());",
          "    assert!(_iter.set.contains_word() == look_set.contains_word());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: u32::MAX }; // Full 32-bit range",
          "    let _iter = look_set.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.set.bits, u32::MAX);",
          "    assert!(!_iter.set.is_empty());",
          "    assert_eq!(_iter.set.len(), 32);",
          "    assert!(_iter.set.contains_anchor());",
          "    assert!(_iter.set.contains_word());",
          "    assert!(_iter.set.contains_word_unicode());",
          "    assert!(_iter.set.contains_word_ascii());"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: u32::MAX }; // Full 32-bit range",
          "    let _iter = look_set.iter();",
          "    assert_eq!(_iter.set.bits, u32::MAX);",
          "    assert!(!_iter.set.is_empty());",
          "    assert_eq!(_iter.set.len(), 32);",
          "    assert!(_iter.set.contains_anchor());",
          "    assert!(_iter.set.contains_word());",
          "    assert!(_iter.set.contains_word_unicode());",
          "    assert!(_iter.set.contains_word_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: 0 }; // Minimum bits value",
          "    let _iter = look_set.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.set.bits, 0);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: 0 }; // Minimum bits value",
          "    let _iter = look_set.iter();",
          "    assert_eq!(_iter.set.bits, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: u32::MAX }; // Maximum u32 bits value",
          "    let _iter = look_set.iter();",
          "}"
        ],
        "oracle": [
          "    assert!(_iter.set == look_set);",
          "    assert!(_iter.set.bits == u32::MAX);",
          "    assert_eq!(std::mem::size_of_val(&_iter), std::mem::size_of::<LookSetIter>());"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: u32::MAX }; // Maximum u32 bits value",
          "    let _iter = look_set.iter();",
          "    assert!(_iter.set == look_set);",
          "    assert!(_iter.set.bits == u32::MAX);",
          "    assert_eq!(std::mem::size_of_val(&_iter), std::mem::size_of::<LookSetIter>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]