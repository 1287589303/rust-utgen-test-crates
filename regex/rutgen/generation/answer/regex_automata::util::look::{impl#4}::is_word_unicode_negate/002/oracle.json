[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"hello\\xFF\"; // valid UTF-8 before invalid byte",
          "    let at: usize = 5; // at > 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at).unwrap(), false);",
          "    ",
          "    let at: usize = 0; // at == 0",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    ",
          "    let haystack: &[u8] = b\"hello\"; // valid UTF-8",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    ",
          "    let haystack: &[u8] = b\"hello\\xFF\"; // valid UTF-8 before invalid byte",
          "    let at: usize = 5; // at > 0",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    ",
          "    let haystack: &[u8] = b\"\\xFF\"; // invalid UTF-8",
          "    let at: usize = 0; // at == 0",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    ",
          "    let haystack: &[u8] = b\"hello\\xFFworld\"; // valid UTF-8 before invalid byte",
          "    let at: usize = 5; // at > 0",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at).unwrap(), false);",
          "    ",
          "    assert!(matcher.is_word_unicode_negate(b\"abc\\xFFdef\", 3).is_ok()); // utf8.decode returns None",
          "    assert!(matcher.is_word_unicode_negate(b\"abc\\xFFdef\", 2).is_err()); // utf8.decode_last returns None",
          "    assert!(matcher.is_word_unicode_negate(b\"abc\\xFFdef\", 1).is_err()); // is_word_char::rev returns Err/None"
        ],
        "code": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"hello\\xFF\"; // valid UTF-8 before invalid byte",
          "    let at: usize = 5; // at > 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at).unwrap(), false);",
          "    ",
          "    let at: usize = 0; // at == 0",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    ",
          "    let haystack: &[u8] = b\"hello\"; // valid UTF-8",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    ",
          "    let haystack: &[u8] = b\"hello\\xFF\"; // valid UTF-8 before invalid byte",
          "    let at: usize = 5; // at > 0",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    ",
          "    let haystack: &[u8] = b\"\\xFF\"; // invalid UTF-8",
          "    let at: usize = 0; // at == 0",
          "    assert!(matcher.is_word_unicode_negate(haystack, at).is_ok());",
          "    ",
          "    let haystack: &[u8] = b\"hello\\xFFworld\"; // valid UTF-8 before invalid byte",
          "    let at: usize = 5; // at > 0",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at).unwrap(), false);",
          "    ",
          "    assert!(matcher.is_word_unicode_negate(b\"abc\\xFFdef\", 3).is_ok()); // utf8.decode returns None",
          "    assert!(matcher.is_word_unicode_negate(b\"abc\\xFFdef\", 2).is_err()); // utf8.decode_last returns None",
          "    assert!(matcher.is_word_unicode_negate(b\"abc\\xFFdef\", 1).is_err()); // is_word_char::rev returns Err/None",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\\xFFworld\"; // invalid UTF-8 before valid byte",
          "    let at: usize = 0; // at = 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at), Ok(false)); // at == 0 case",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"\\xC3\\x28\", 2), Ok(false)); // invalid UTF-8",
          "    assert!(matcher.is_word_unicode_negate(b\"hello\\xFF\", 5).is_err()); // boundary with invalid byte",
          "    assert!(matcher.is_word_unicode_negate(b\"helloðŸŒ\", 5).is_ok()); // valid UTF-8 with emoji at the end",
          "    assert!(matcher.is_word_unicode_negate(b\"abc\", 0).is_err()); // test with at = 0",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"word\", 2), Ok(true)); // valid UTF-8 at the middle"
        ],
        "code": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\\xFFworld\"; // invalid UTF-8 before valid byte",
          "    let at: usize = 0; // at = 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at), Ok(false)); // at == 0 case",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"\\xC3\\x28\", 2), Ok(false)); // invalid UTF-8",
          "    assert!(matcher.is_word_unicode_negate(b\"hello\\xFF\", 5).is_err()); // boundary with invalid byte",
          "    assert!(matcher.is_word_unicode_negate(b\"helloðŸŒ\", 5).is_ok()); // valid UTF-8 with emoji at the end",
          "    assert!(matcher.is_word_unicode_negate(b\"abc\", 0).is_err()); // test with at = 0",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"word\", 2), Ok(true)); // valid UTF-8 at the middle",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\\xFF\\xFF\"; // invalid UTF-8 sequence",
          "    let at: usize = 1; // at > 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "}"
        ],
        "oracle": [
          "    matcher.set_line_terminator(b'\\n');",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"\\xFF\\xFF\", 1).is_ok(), true);",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"\\xFF\\xFF\", 1).unwrap(), false);",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"\\xFFabc\\xFF\", 3).unwrap(), true);",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"abc\\xFF\", 0).unwrap(), false);",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"abc\", 3).unwrap(), false);"
        ],
        "code": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\\xFF\\xFF\"; // invalid UTF-8 sequence",
          "    let at: usize = 1; // at > 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "    matcher.set_line_terminator(b'\\n');",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"\\xFF\\xFF\", 1).is_ok(), true);",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"\\xFF\\xFF\", 1).unwrap(), false);",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"\\xFFabc\\xFF\", 3).unwrap(), true);",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"abc\\xFF\", 0).unwrap(), false);",
          "    assert_eq!(matcher.is_word_unicode_negate(b\"abc\", 3).unwrap(), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\"; // empty haystack",
          "    let at: usize = 0; // at = 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "}"
        ],
        "oracle": [
          "    matcher.is_word_unicode_negate(haystack, at).is_err();",
          "    matcher.is_word_unicode_negate(haystack, at).map_err(|e| assert!(matches!(e, UnicodeWordBoundaryError(_))));",
          "    haystack = b\"abc\"; // valid UTF-8",
          "    at = 1; // at > 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "    haystack = b\"\\xFFabc\"; // invalid UTF-8",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap_err();",
          "    at = haystack.len(); // at = haystack.len()",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();"
        ],
        "code": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\"; // empty haystack",
          "    let at: usize = 0; // at = 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "    matcher.is_word_unicode_negate(haystack, at).is_err();",
          "    matcher.is_word_unicode_negate(haystack, at).map_err(|e| assert!(matches!(e, UnicodeWordBoundaryError(_))));",
          "    haystack = b\"abc\"; // valid UTF-8",
          "    at = 1; // at > 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "    haystack = b\"\\xFFabc\"; // invalid UTF-8",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap_err();",
          "    at = haystack.len(); // at = haystack.len()",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"hello\"; // valid UTF-8 only",
          "    let at: usize = 5; // at > 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "}"
        ],
        "oracle": [
          "    matcher.set_line_terminator(10);",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at), Ok(true));",
          "    let haystack_invalid_utf8: &[u8] = b\"\\xFFhello\";",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack_invalid_utf8, at), Ok(false));",
          "    let haystack_edge_case: &[u8] = b\"hello\\xFF\";",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack_edge_case, at), Ok(false));",
          "    let haystack_empty: &[u8] = b\"\";",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack_empty, at), Ok(false));",
          "    let at_zero: usize = 0;",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at_zero), Ok(true));"
        ],
        "code": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"hello\"; // valid UTF-8 only",
          "    let at: usize = 5; // at > 0",
          "    matcher.is_word_unicode_negate(haystack, at).unwrap();",
          "    matcher.set_line_terminator(10);",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at), Ok(true));",
          "    let haystack_invalid_utf8: &[u8] = b\"\\xFFhello\";",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack_invalid_utf8, at), Ok(false));",
          "    let haystack_edge_case: &[u8] = b\"hello\\xFF\";",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack_edge_case, at), Ok(false));",
          "    let haystack_empty: &[u8] = b\"\";",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack_empty, at), Ok(false));",
          "    let at_zero: usize = 0;",
          "    assert_eq!(matcher.is_word_unicode_negate(haystack, at_zero), Ok(true));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]