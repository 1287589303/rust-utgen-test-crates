[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = [",
          "        0u8, 0, 0, 0,  // StartKind::Both",
          "        0u8, 0, 0, 0,  // StartByteMap (valid data, first 256 bytes to follow)",
          "        0u8, 0, 0, 0,  // stride (valid)",
          "        0u32.to_ne_bytes(),  // pattern_len (valid)",
          "        1u32.to_ne_bytes(),  // universal_unanchored (valid)",
          "        2u32.to_ne_bytes(),  // universal_anchored (valid)",
          "        // Start State IDs for Start::Both (8 entries)",
          "    ];",
          "    let alignment_padded_data = [0u8; (8 + 2 * 6 + 0) * 4];  // Assumed alignment and padding",
          "    let mut slice: &[u8] = &alignment_padded_data;",
          "    ",
          "    let _ = StartTable::<&[u32]>::from_bytes_unchecked(slice);",
          "}"
        ],
        "oracle": [
          "    let data = [0u8, 0, 0, 0, 0u8, 0, 0, 0, 0u8, 0, 0, 0, 0u32.to_ne_bytes(), 1u32.to_ne_bytes(), 2u32.to_ne_bytes()];",
          "    let alignment_padded_data = [0u8; (8 + 2 * 6 + 0) * 4];",
          "    let mut slice: &[u8] = &alignment_padded_data;",
          "    let result = StartTable::<&[u32]>::from_bytes_unchecked(slice);",
          "    assert!(result.is_ok());",
          "    ",
          "    let data_invalid_stride = [0u8, 0, 0, 0, 0u8, 0, 0, 0, 1u8, 0, 0, 0, 0u32.to_ne_bytes(), 1u32.to_ne_bytes(), 2u32.to_ne_bytes()];",
          "    let mut slice_invalid_stride: &[u8] = &alignment_padded_data;",
          "    let result_invalid_stride = StartTable::<&[u32]>::from_bytes_unchecked(slice_invalid_stride);",
          "    assert!(result_invalid_stride.is_err());",
          "    ",
          "    let data_invalid_pattern_len = [0u8, 0, 0, 0, 0u8, 0, 0, 0, 0u8, 0, 0, 0, u32::MAX.to_ne_bytes(), 1u32.to_ne_bytes(), 2u32.to_ne_bytes()];",
          "    let mut slice_invalid_pattern_len: &[u8] = &alignment_padded_data;",
          "    let result_invalid_pattern_len = StartTable::<&[u32]>::from_bytes_unchecked(slice_invalid_pattern_len);",
          "    assert!(result_invalid_pattern_len.is_err());",
          "    ",
          "    let data_invalid_universal_anchored = [0u8, 0, 0, 0, 0u8, 0, 0, 0, 0u8, 0, 0, 0, 1u32.to_ne_bytes(), u32::MAX.to_ne_bytes(), 0u32.to_ne_bytes()];",
          "    let mut slice_invalid_universal_anchored: &[u8] = &alignment_padded_data;",
          "    let result_invalid_universal_anchored = StartTable::<&[u32]>::from_bytes_unchecked(slice_invalid_universal_anchored);",
          "    assert!(result_invalid_universal_anchored.is_err());"
        ],
        "code": [
          "{",
          "    let data = [",
          "        0u8, 0, 0, 0,  // StartKind::Both",
          "        0u8, 0, 0, 0,  // StartByteMap (valid data, first 256 bytes to follow)",
          "        0u8, 0, 0, 0,  // stride (valid)",
          "        0u32.to_ne_bytes(),  // pattern_len (valid)",
          "        1u32.to_ne_bytes(),  // universal_unanchored (valid)",
          "        2u32.to_ne_bytes(),  // universal_anchored (valid)",
          "        // Start State IDs for Start::Both (8 entries)",
          "    ];",
          "    let alignment_padded_data = [0u8; (8 + 2 * 6 + 0) * 4];  // Assumed alignment and padding",
          "    let mut slice: &[u8] = &alignment_padded_data;",
          "    ",
          "    let _ = StartTable::<&[u32]>::from_bytes_unchecked(slice);",
          "    let data = [0u8, 0, 0, 0, 0u8, 0, 0, 0, 0u8, 0, 0, 0, 0u32.to_ne_bytes(), 1u32.to_ne_bytes(), 2u32.to_ne_bytes()];",
          "    let alignment_padded_data = [0u8; (8 + 2 * 6 + 0) * 4];",
          "    let mut slice: &[u8] = &alignment_padded_data;",
          "    let result = StartTable::<&[u32]>::from_bytes_unchecked(slice);",
          "    assert!(result.is_ok());",
          "    ",
          "    let data_invalid_stride = [0u8, 0, 0, 0, 0u8, 0, 0, 0, 1u8, 0, 0, 0, 0u32.to_ne_bytes(), 1u32.to_ne_bytes(), 2u32.to_ne_bytes()];",
          "    let mut slice_invalid_stride: &[u8] = &alignment_padded_data;",
          "    let result_invalid_stride = StartTable::<&[u32]>::from_bytes_unchecked(slice_invalid_stride);",
          "    assert!(result_invalid_stride.is_err());",
          "    ",
          "    let data_invalid_pattern_len = [0u8, 0, 0, 0, 0u8, 0, 0, 0, 0u8, 0, 0, 0, u32::MAX.to_ne_bytes(), 1u32.to_ne_bytes(), 2u32.to_ne_bytes()];",
          "    let mut slice_invalid_pattern_len: &[u8] = &alignment_padded_data;",
          "    let result_invalid_pattern_len = StartTable::<&[u32]>::from_bytes_unchecked(slice_invalid_pattern_len);",
          "    assert!(result_invalid_pattern_len.is_err());",
          "    ",
          "    let data_invalid_universal_anchored = [0u8, 0, 0, 0, 0u8, 0, 0, 0, 0u8, 0, 0, 0, 1u32.to_ne_bytes(), u32::MAX.to_ne_bytes(), 0u32.to_ne_bytes()];",
          "    let mut slice_invalid_universal_anchored: &[u8] = &alignment_padded_data;",
          "    let result_invalid_universal_anchored = StartTable::<&[u32]>::from_bytes_unchecked(slice_invalid_universal_anchored);",
          "    assert!(result_invalid_universal_anchored.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = [",
          "        1u8, 0, 0, 0,  // StartKind::Unanchored",
          "        0u8, 0, 0, 0,  // StartByteMap (valid data)",
          "        0u8, 0, 0, 0,  // stride (valid)",
          "        1u32.to_ne_bytes(),  // pattern_len (valid)",
          "        3u32.to_ne_bytes(),  // universal_unanchored (valid)",
          "        4u32.to_ne_bytes(),  // universal_anchored (valid)",
          "        // Start State IDs (8 entries)",
          "    ];",
          "    let alignment_padded_data = [0u8; (8 + 2 * 6 + 1) * 4]; // Assume alignment and padding",
          "    let mut slice: &[u8] = &alignment_padded_data;",
          "",
          "    let _ = StartTable::<&[u32]>::from_bytes_unchecked(slice);",
          "}"
        ],
        "oracle": [
          "    let data = [",
          "    1u8, 0, 0, 0,  // StartKind::Unanchored",
          "    ];",
          "    let result = StartKind::from_bytes(&data).is_ok();",
          "    assert!(result);",
          "    ",
          "    let data = [",
          "    0u8, 0, 0, 0,  // StartByteMap (valid data)",
          "    ];",
          "    let result = StartByteMap::from_bytes(&data).is_ok();",
          "    assert!(result);",
          "    ",
          "    let data = [",
          "    0u8, 0, 0, 0,  // stride (valid)",
          "    ];",
          "    let result = wire::try_read_u32_as_usize(&data, \"start table stride\").is_ok();",
          "    assert!(result);",
          "    ",
          "    let stride = Start::len();",
          "    assert_eq!(stride, 6);",
          "    ",
          "    let data = [",
          "    1u32.to_ne_bytes(),  // pattern_len (valid)",
          "    ];",
          "    let result = wire::try_read_u32_as_usize(&data, \"start table patterns\").is_ok();",
          "    assert!(result);",
          "    ",
          "    let maybe_pattern_len = 1u32;",
          "    assert_ne!(maybe_pattern_len, u32::MAX);",
          "    ",
          "    let pattern_len_exceeds_limit = false;",
          "    assert!(!pattern_len_exceeds_limit);",
          "    ",
          "    let data = [",
          "    3u32.to_ne_bytes(),  // universal_unanchored (valid)",
          "    ];",
          "    let result = wire::try_read_u32(&data, \"universal unanchored start\").is_ok();",
          "    assert!(result);",
          "    ",
          "    let universal_unanchored = 3u32;",
          "    assert_ne!(universal_unanchored, u32::MAX);",
          "    ",
          "    let result = StateID::try_from(universal_unanchored).is_ok();",
          "    assert!(result.is_ok());",
          "    ",
          "    let data = [",
          "    4u32.to_ne_bytes(),  // universal_anchored (valid)",
          "    ];",
          "    let result = wire::try_read_u32(&data, \"universal anchored start\").is_ok();",
          "    assert!(result);",
          "    ",
          "    let universal_anchored = 4u32;",
          "    assert_ne!(universal_anchored, u32::MAX);",
          "    ",
          "    let result = StateID::try_from(universal_anchored).is_err();",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let data = [",
          "        1u8, 0, 0, 0,  // StartKind::Unanchored",
          "        0u8, 0, 0, 0,  // StartByteMap (valid data)",
          "        0u8, 0, 0, 0,  // stride (valid)",
          "        1u32.to_ne_bytes(),  // pattern_len (valid)",
          "        3u32.to_ne_bytes(),  // universal_unanchored (valid)",
          "        4u32.to_ne_bytes(),  // universal_anchored (valid)",
          "        // Start State IDs (8 entries)",
          "    ];",
          "    let alignment_padded_data = [0u8; (8 + 2 * 6 + 1) * 4]; // Assume alignment and padding",
          "    let mut slice: &[u8] = &alignment_padded_data;",
          "",
          "    let _ = StartTable::<&[u32]>::from_bytes_unchecked(slice);",
          "    let data = [",
          "    1u8, 0, 0, 0,  // StartKind::Unanchored",
          "    ];",
          "    let result = StartKind::from_bytes(&data).is_ok();",
          "    assert!(result);",
          "    ",
          "    let data = [",
          "    0u8, 0, 0, 0,  // StartByteMap (valid data)",
          "    ];",
          "    let result = StartByteMap::from_bytes(&data).is_ok();",
          "    assert!(result);",
          "    ",
          "    let data = [",
          "    0u8, 0, 0, 0,  // stride (valid)",
          "    ];",
          "    let result = wire::try_read_u32_as_usize(&data, \"start table stride\").is_ok();",
          "    assert!(result);",
          "    ",
          "    let stride = Start::len();",
          "    assert_eq!(stride, 6);",
          "    ",
          "    let data = [",
          "    1u32.to_ne_bytes(),  // pattern_len (valid)",
          "    ];",
          "    let result = wire::try_read_u32_as_usize(&data, \"start table patterns\").is_ok();",
          "    assert!(result);",
          "    ",
          "    let maybe_pattern_len = 1u32;",
          "    assert_ne!(maybe_pattern_len, u32::MAX);",
          "    ",
          "    let pattern_len_exceeds_limit = false;",
          "    assert!(!pattern_len_exceeds_limit);",
          "    ",
          "    let data = [",
          "    3u32.to_ne_bytes(),  // universal_unanchored (valid)",
          "    ];",
          "    let result = wire::try_read_u32(&data, \"universal unanchored start\").is_ok();",
          "    assert!(result);",
          "    ",
          "    let universal_unanchored = 3u32;",
          "    assert_ne!(universal_unanchored, u32::MAX);",
          "    ",
          "    let result = StateID::try_from(universal_unanchored).is_ok();",
          "    assert!(result.is_ok());",
          "    ",
          "    let data = [",
          "    4u32.to_ne_bytes(),  // universal_anchored (valid)",
          "    ];",
          "    let result = wire::try_read_u32(&data, \"universal anchored start\").is_ok();",
          "    assert!(result);",
          "    ",
          "    let universal_anchored = 4u32;",
          "    assert_ne!(universal_anchored, u32::MAX);",
          "    ",
          "    let result = StateID::try_from(universal_anchored).is_err();",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = [",
          "        2u8, 0, 0, 0,  // StartKind::Anchored",
          "        0u8, 0, 0, 0,  // StartByteMap (valid data)",
          "        0u8, 0, 0, 0,  // stride (valid)",
          "        2u32.to_ne_bytes(),  // pattern_len (valid)",
          "        5u32.to_ne_bytes(),  // universal_unanchored (valid)",
          "        6u32.to_ne_bytes(),  // universal_anchored (valid)",
          "        // Start State IDs (8 entries)",
          "    ];",
          "    let alignment_padded_data = [0u8; (8 + 2 * 6 + 2) * 4]; // Assume alignment and padding",
          "    let mut slice: &[u8] = &alignment_padded_data;",
          "",
          "    let _ = StartTable::<&[u32]>::from_bytes_unchecked(slice);",
          "}"
        ],
        "oracle": [
          "    let kind_ok = StartKind::from_bytes(slice).is_ok();",
          "    let start_map_ok = StartByteMap::from_bytes(slice).is_ok();",
          "    let stride_ok = wire::try_read_u32_as_usize(slice, \"start table stride\").is_ok();",
          "    let stride_valid = stride == Start::len();",
          "    let pattern_len_ok = wire::try_read_u32_as_usize(slice, \"start table patterns\").is_ok();",
          "    let pattern_len_not_max = maybe_pattern_len.as_u32() != u32::MAX;",
          "    let pattern_len_valid = !pattern_len.map_or(false, |len| len > PatternID::LIMIT);",
          "    let universal_unanchored_ok = wire::try_read_u32(slice, \"universal unanchored start\").is_ok();",
          "    let universal_unanchored_not_max = universal_unanchored != u32::MAX;",
          "    let universal_unanchored_valid = StateID::try_from(universal_unanchored).is_ok();",
          "    let universal_anchored_ok = wire::try_read_u32(slice, \"universal anchored start\").is_ok();",
          "    let universal_anchored_not_max = universal_anchored != u32::MAX;",
          "    let universal_anchored_invalid = StateID::try_from(universal_anchored).is_err();"
        ],
        "code": [
          "{",
          "    let data = [",
          "        2u8, 0, 0, 0,  // StartKind::Anchored",
          "        0u8, 0, 0, 0,  // StartByteMap (valid data)",
          "        0u8, 0, 0, 0,  // stride (valid)",
          "        2u32.to_ne_bytes(),  // pattern_len (valid)",
          "        5u32.to_ne_bytes(),  // universal_unanchored (valid)",
          "        6u32.to_ne_bytes(),  // universal_anchored (valid)",
          "        // Start State IDs (8 entries)",
          "    ];",
          "    let alignment_padded_data = [0u8; (8 + 2 * 6 + 2) * 4]; // Assume alignment and padding",
          "    let mut slice: &[u8] = &alignment_padded_data;",
          "",
          "    let _ = StartTable::<&[u32]>::from_bytes_unchecked(slice);",
          "    let kind_ok = StartKind::from_bytes(slice).is_ok();",
          "    let start_map_ok = StartByteMap::from_bytes(slice).is_ok();",
          "    let stride_ok = wire::try_read_u32_as_usize(slice, \"start table stride\").is_ok();",
          "    let stride_valid = stride == Start::len();",
          "    let pattern_len_ok = wire::try_read_u32_as_usize(slice, \"start table patterns\").is_ok();",
          "    let pattern_len_not_max = maybe_pattern_len.as_u32() != u32::MAX;",
          "    let pattern_len_valid = !pattern_len.map_or(false, |len| len > PatternID::LIMIT);",
          "    let universal_unanchored_ok = wire::try_read_u32(slice, \"universal unanchored start\").is_ok();",
          "    let universal_unanchored_not_max = universal_unanchored != u32::MAX;",
          "    let universal_unanchored_valid = StateID::try_from(universal_unanchored).is_ok();",
          "    let universal_anchored_ok = wire::try_read_u32(slice, \"universal anchored start\").is_ok();",
          "    let universal_anchored_not_max = universal_anchored != u32::MAX;",
          "    let universal_anchored_invalid = StateID::try_from(universal_anchored).is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]