[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind_value: u8 = 0; // StartKind::Both",
          "    let start_map_bytes: [u8; 256] = [0; 256]; // valid StartByteMap",
          "    let stride: u32 = 6; // valid stride",
          "    let pattern_len: u32 = 5; // valid pattern length",
          "    let universal_unanchored: u32 = 1; // valid StateID, not MAX",
          "    let universal_anchored: u32 = 2; // valid StateID, not MAX",
          "",
          "    let valid_start_ids: [u32; 12] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; // 12 valid StateIDs",
          "",
          "    let mut slice: Vec<u8> = Vec::new();",
          "    slice.push(kind_value);",
          "    slice.extend_from_slice(&start_map_bytes);",
          "    slice.extend_from_slice(&stride.to_le_bytes());",
          "    slice.extend_from_slice(&pattern_len.to_le_bytes());",
          "    slice.extend_from_slice(&universal_unanchored.to_le_bytes());",
          "    slice.extend_from_slice(&universal_anchored.to_le_bytes());",
          "    slice.extend_from_slice(&valid_start_ids.concat()); // concatenate into valid slice",
          "",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&mut slice) };",
          "}"
        ],
        "oracle": [
          "    plaintext",
          "    let kind_result = StartKind::from_bytes(&slice);",
          "    assert!(kind_result.is_ok());",
          "    ",
          "    let start_map_result = StartByteMap::from_bytes(&slice[1..]);",
          "    assert!(start_map_result.is_ok());",
          "    ",
          "    let stride_result = wire::try_read_u32_as_usize(&slice[1 + start_map_bytes.len()..], \"start table stride\");",
          "    assert!(stride_result.is_ok());",
          "    ",
          "    let stride_value = stride_result.unwrap().0;",
          "    assert_eq!(stride_value, 6);",
          "    ",
          "    let patterns_result = wire::try_read_u32_as_usize(&slice[1 + start_map_bytes.len() + 4..], \"start table patterns\");",
          "    assert!(patterns_result.is_ok());",
          "    ",
          "    let maybe_pattern_len = patterns_result.unwrap().0;",
          "    assert_ne!(maybe_pattern_len.as_u32(), u32::MAX);",
          "    ",
          "    let pattern_len_check = maybe_pattern_len <= PatternID::LIMIT;",
          "    assert!(pattern_len_check);",
          "    ",
          "    let universal_unanchored_result = wire::try_read_u32(&slice[1 + start_map_bytes.len() + 8..], \"universal unanchored start\");",
          "    assert!(universal_unanchored_result.is_ok());",
          "    ",
          "    let universal_unanchored_value = universal_unanchored_result.unwrap().0;",
          "    assert_ne!(universal_unanchored_value, u32::MAX);",
          "    ",
          "    let state_id_result = StateID::try_from(universal_unanchored_value);",
          "    assert!(state_id_result.is_err());"
        ],
        "code": [
          "{",
          "    let kind_value: u8 = 0; // StartKind::Both",
          "    let start_map_bytes: [u8; 256] = [0; 256]; // valid StartByteMap",
          "    let stride: u32 = 6; // valid stride",
          "    let pattern_len: u32 = 5; // valid pattern length",
          "    let universal_unanchored: u32 = 1; // valid StateID, not MAX",
          "    let universal_anchored: u32 = 2; // valid StateID, not MAX",
          "",
          "    let valid_start_ids: [u32; 12] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; // 12 valid StateIDs",
          "",
          "    let mut slice: Vec<u8> = Vec::new();",
          "    slice.push(kind_value);",
          "    slice.extend_from_slice(&start_map_bytes);",
          "    slice.extend_from_slice(&stride.to_le_bytes());",
          "    slice.extend_from_slice(&pattern_len.to_le_bytes());",
          "    slice.extend_from_slice(&universal_unanchored.to_le_bytes());",
          "    slice.extend_from_slice(&universal_anchored.to_le_bytes());",
          "    slice.extend_from_slice(&valid_start_ids.concat()); // concatenate into valid slice",
          "",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&mut slice) };",
          "    plaintext",
          "    let kind_result = StartKind::from_bytes(&slice);",
          "    assert!(kind_result.is_ok());",
          "    ",
          "    let start_map_result = StartByteMap::from_bytes(&slice[1..]);",
          "    assert!(start_map_result.is_ok());",
          "    ",
          "    let stride_result = wire::try_read_u32_as_usize(&slice[1 + start_map_bytes.len()..], \"start table stride\");",
          "    assert!(stride_result.is_ok());",
          "    ",
          "    let stride_value = stride_result.unwrap().0;",
          "    assert_eq!(stride_value, 6);",
          "    ",
          "    let patterns_result = wire::try_read_u32_as_usize(&slice[1 + start_map_bytes.len() + 4..], \"start table patterns\");",
          "    assert!(patterns_result.is_ok());",
          "    ",
          "    let maybe_pattern_len = patterns_result.unwrap().0;",
          "    assert_ne!(maybe_pattern_len.as_u32(), u32::MAX);",
          "    ",
          "    let pattern_len_check = maybe_pattern_len <= PatternID::LIMIT;",
          "    assert!(pattern_len_check);",
          "    ",
          "    let universal_unanchored_result = wire::try_read_u32(&slice[1 + start_map_bytes.len() + 8..], \"universal unanchored start\");",
          "    assert!(universal_unanchored_result.is_ok());",
          "    ",
          "    let universal_unanchored_value = universal_unanchored_result.unwrap().0;",
          "    assert_ne!(universal_unanchored_value, u32::MAX);",
          "    ",
          "    let state_id_result = StateID::try_from(universal_unanchored_value);",
          "    assert!(state_id_result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind_value: u8 = 1; // StartKind::Unanchored",
          "    let start_map_bytes: [u8; 256] = [1; 256]; // valid StartByteMap",
          "    let stride: u32 = 6; // valid stride",
          "    let pattern_len: u32 = u32::MAX - 1; // valid pattern length within limits",
          "    let universal_unanchored: u32 = 1; // valid StateID, not MAX",
          "    let universal_anchored: u32 = 2; // valid StateID, not MAX",
          "",
          "    let valid_start_ids: [u32; 12] = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]; // 12 valid StateIDs",
          "",
          "    let mut slice: Vec<u8> = Vec::new();",
          "    slice.push(kind_value);",
          "    slice.extend_from_slice(&start_map_bytes);",
          "    slice.extend_from_slice(&stride.to_le_bytes());",
          "    slice.extend_from_slice(&pattern_len.to_le_bytes());",
          "    slice.extend_from_slice(&universal_unanchored.to_le_bytes());",
          "    slice.extend_from_slice(&universal_anchored.to_le_bytes());",
          "    slice.extend_from_slice(&valid_start_ids.concat()); // concatenate into valid slice",
          "",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&mut slice) };",
          "}"
        ],
        "oracle": [
          "    let kind_value: u8 = 1; // StartKind::Unanchored",
          "    let start_map_bytes: [u8; 256] = [1; 256]; // valid StartByteMap",
          "    let stride: u32 = 6; // valid stride",
          "    let pattern_len: u32 = u32::MAX - 1; // valid pattern length within limits",
          "    let universal_unanchored: u32 = 1; // valid StateID, not MAX",
          "    let universal_anchored: u32 = 2; // valid StateID, not MAX",
          "    let valid_start_ids: [u32; 12] = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]; // 12 valid StateIDs",
          "    ",
          "    let mut slice: Vec<u8> = Vec::new();",
          "    slice.push(kind_value);",
          "    slice.extend_from_slice(&start_map_bytes);",
          "    slice.extend_from_slice(&stride.to_le_bytes());",
          "    slice.extend_from_slice(&pattern_len.to_le_bytes());",
          "    slice.extend_from_slice(&universal_unanchored.to_le_bytes());",
          "    slice.extend_from_slice(&universal_anchored.to_le_bytes());",
          "    slice.extend_from_slice(&valid_start_ids.concat()); // concatenate into valid slice",
          "    ",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, slice.len());",
          "    assert_eq!(start_table.kind, StartKind::Unanchored);",
          "    assert_eq!(start_table.stride, 6);",
          "    assert_eq!(start_table.pattern_len, Some((u32::MAX - 1) as usize));",
          "    assert_eq!(start_table.universal_start_unanchored, Some(StateID(1)));",
          "    assert_eq!(start_table.universal_start_anchored, Some(StateID(2)));",
          "    assert_eq!(start_table.table.len(), 12);  // Valid start IDs count",
          "    assert_eq!(start_table.table[0], 12);  // Check first valid StateID",
          "    assert_eq!(start_table.table[1], 13);  // Check second valid StateID",
          "    assert_eq!(start_table.table[11], 23);  // Check last valid StateID"
        ],
        "code": [
          "{",
          "    let kind_value: u8 = 1; // StartKind::Unanchored",
          "    let start_map_bytes: [u8; 256] = [1; 256]; // valid StartByteMap",
          "    let stride: u32 = 6; // valid stride",
          "    let pattern_len: u32 = u32::MAX - 1; // valid pattern length within limits",
          "    let universal_unanchored: u32 = 1; // valid StateID, not MAX",
          "    let universal_anchored: u32 = 2; // valid StateID, not MAX",
          "",
          "    let valid_start_ids: [u32; 12] = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]; // 12 valid StateIDs",
          "",
          "    let mut slice: Vec<u8> = Vec::new();",
          "    slice.push(kind_value);",
          "    slice.extend_from_slice(&start_map_bytes);",
          "    slice.extend_from_slice(&stride.to_le_bytes());",
          "    slice.extend_from_slice(&pattern_len.to_le_bytes());",
          "    slice.extend_from_slice(&universal_unanchored.to_le_bytes());",
          "    slice.extend_from_slice(&universal_anchored.to_le_bytes());",
          "    slice.extend_from_slice(&valid_start_ids.concat()); // concatenate into valid slice",
          "",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&mut slice) };",
          "    let kind_value: u8 = 1; // StartKind::Unanchored",
          "    let start_map_bytes: [u8; 256] = [1; 256]; // valid StartByteMap",
          "    let stride: u32 = 6; // valid stride",
          "    let pattern_len: u32 = u32::MAX - 1; // valid pattern length within limits",
          "    let universal_unanchored: u32 = 1; // valid StateID, not MAX",
          "    let universal_anchored: u32 = 2; // valid StateID, not MAX",
          "    let valid_start_ids: [u32; 12] = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]; // 12 valid StateIDs",
          "    ",
          "    let mut slice: Vec<u8> = Vec::new();",
          "    slice.push(kind_value);",
          "    slice.extend_from_slice(&start_map_bytes);",
          "    slice.extend_from_slice(&stride.to_le_bytes());",
          "    slice.extend_from_slice(&pattern_len.to_le_bytes());",
          "    slice.extend_from_slice(&universal_unanchored.to_le_bytes());",
          "    slice.extend_from_slice(&universal_anchored.to_le_bytes());",
          "    slice.extend_from_slice(&valid_start_ids.concat()); // concatenate into valid slice",
          "    ",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, slice.len());",
          "    assert_eq!(start_table.kind, StartKind::Unanchored);",
          "    assert_eq!(start_table.stride, 6);",
          "    assert_eq!(start_table.pattern_len, Some((u32::MAX - 1) as usize));",
          "    assert_eq!(start_table.universal_start_unanchored, Some(StateID(1)));",
          "    assert_eq!(start_table.universal_start_anchored, Some(StateID(2)));",
          "    assert_eq!(start_table.table.len(), 12);  // Valid start IDs count",
          "    assert_eq!(start_table.table[0], 12);  // Check first valid StateID",
          "    assert_eq!(start_table.table[1], 13);  // Check second valid StateID",
          "    assert_eq!(start_table.table[11], 23);  // Check last valid StateID",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind_value: u8 = 2; // StartKind::Anchored",
          "    let start_map_bytes: [u8; 256] = [2; 256]; // valid StartByteMap",
          "    let stride: u32 = 6; // valid stride",
          "    let pattern_len: u32 = 0; // no patterns",
          "    let universal_unanchored: u32 = 1; // valid StateID, not MAX",
          "    let universal_anchored: u32 = 2; // valid StateID, not MAX",
          "",
          "    let valid_start_ids: [u32; 12] = [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]; // 12 valid StateIDs",
          "",
          "    let mut slice: Vec<u8> = Vec::new();",
          "    slice.push(kind_value);",
          "    slice.extend_from_slice(&start_map_bytes);",
          "    slice.extend_from_slice(&stride.to_le_bytes());",
          "    slice.extend_from_slice(&pattern_len.to_le_bytes());",
          "    slice.extend_from_slice(&universal_unanchored.to_le_bytes());",
          "    slice.extend_from_slice(&universal_anchored.to_le_bytes());",
          "    slice.extend_from_slice(&valid_start_ids.concat()); // concatenate into valid slice",
          "",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&mut slice) };",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(start_table.kind, StartKind::Anchored);",
          "    assert_eq!(start_table.stride, 6);",
          "    assert_eq!(start_table.pattern_len, None);",
          "    assert_eq!(start_table.universal_start_unanchored, Some(StateID(1)));",
          "    assert_eq!(start_table.universal_start_anchored, Some(StateID(2)));",
          "    assert_eq!(bytes_read, slice.len());"
        ],
        "code": [
          "{",
          "    let kind_value: u8 = 2; // StartKind::Anchored",
          "    let start_map_bytes: [u8; 256] = [2; 256]; // valid StartByteMap",
          "    let stride: u32 = 6; // valid stride",
          "    let pattern_len: u32 = 0; // no patterns",
          "    let universal_unanchored: u32 = 1; // valid StateID, not MAX",
          "    let universal_anchored: u32 = 2; // valid StateID, not MAX",
          "",
          "    let valid_start_ids: [u32; 12] = [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]; // 12 valid StateIDs",
          "",
          "    let mut slice: Vec<u8> = Vec::new();",
          "    slice.push(kind_value);",
          "    slice.extend_from_slice(&start_map_bytes);",
          "    slice.extend_from_slice(&stride.to_le_bytes());",
          "    slice.extend_from_slice(&pattern_len.to_le_bytes());",
          "    slice.extend_from_slice(&universal_unanchored.to_le_bytes());",
          "    slice.extend_from_slice(&universal_anchored.to_le_bytes());",
          "    slice.extend_from_slice(&valid_start_ids.concat()); // concatenate into valid slice",
          "",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(start_table.kind, StartKind::Anchored);",
          "    assert_eq!(start_table.stride, 6);",
          "    assert_eq!(start_table.pattern_len, None);",
          "    assert_eq!(start_table.universal_start_unanchored, Some(StateID(1)));",
          "    assert_eq!(start_table.universal_start_anchored, Some(StateID(2)));",
          "    assert_eq!(bytes_read, slice.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]