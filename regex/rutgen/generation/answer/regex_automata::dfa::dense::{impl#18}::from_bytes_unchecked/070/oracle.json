[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_kind_value: u32 = 0; // Representing StartKind::Both",
          "    let start_map_values: [u8; 256] = [0; 256]; // All values as Start::NonWordByte",
          "    let stride: u32 = 8; // Valid stride (equal to Start::len())",
          "    let pattern_len: u32 = 0; // Pattern length less than PatternID::LIMIT",
          "    let universal_unanchored: u32 = 1; // Valid value",
          "    let universal_anchored: u32 = 1; // Valid value",
          "",
          "    let length = 4 + 256 + 4 + 4 + 4 + 4 * (pattern_len as usize);",
          "    let mut slice = Vec::with_capacity(length);",
          "    ",
          "    slice.extend(&start_kind_value.to_le_bytes()); // StartKind",
          "    slice.extend(&start_map_values); // StartByteMap",
          "    slice.extend(&stride.to_le_bytes()); // stride",
          "    slice.extend(&pattern_len.to_le_bytes()); // pattern_len",
          "    slice.extend(&universal_unanchored.to_le_bytes()); // universal_unanchored",
          "    slice.extend(&universal_anchored.to_le_bytes()); // universal_anchored",
          "",
          "    let table: &[u8] = &slice;",
          "    ",
          "    // Call the function under test",
          "    unsafe {",
          "        let _result = StartTable::<&[u32]>::from_bytes_unchecked(table);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let start_kind_value: u32 = 0; // Representing StartKind::Both",
          "    let start_map_values: [u8; 256] = [0; 256]; // All values as Start::NonWordByte",
          "    let stride: u32 = 8; // Valid stride (equal to Start::len())",
          "    let pattern_len: u32 = 0; // Pattern length less than PatternID::LIMIT",
          "    let universal_unanchored: u32 = 1; // Valid value",
          "    let universal_anchored: u32 = 1; // Valid value",
          "    ",
          "    let length = 4 + 256 + 4 + 4 + 4 + 4 * (pattern_len as usize);",
          "    let mut slice = Vec::with_capacity(length);",
          "    ",
          "    slice.extend(&start_kind_value.to_le_bytes()); // StartKind",
          "    slice.extend(&start_map_values); // StartByteMap",
          "    slice.extend(&stride.to_le_bytes()); // stride",
          "    slice.extend(&pattern_len.to_le_bytes()); // pattern_len",
          "    slice.extend(&universal_unanchored.to_le_bytes()); // universal_unanchored",
          "    slice.extend(&universal_anchored.to_le_bytes()); // universal_anchored",
          "    ",
          "    let table: &[u8] = &slice;",
          "    ",
          "    // Verify StartKind::from_bytes(slice) is Ok/Some.",
          "    let (kind, nr) = StartKind::from_bytes(&slice[..4]).unwrap();",
          "    ",
          "    // Verify StartByteMap::from_bytes(slice) is Ok/Some.",
          "    let (start_map, nr) = StartByteMap::from_bytes(&slice[4..260]).unwrap();",
          "    ",
          "    // Verify wire::try_read_u32_as_usize(slice, \"start table stride\") is Ok/Some.",
          "    let (stride_value, nr) = wire::try_read_u32_as_usize(&slice[260..264], \"start table stride\").unwrap();",
          "    assert_eq!(stride_value, stride as usize);",
          "    ",
          "    // Verify stride != Start::len() is false.",
          "    assert_eq!(stride_value, Start::len());",
          "    ",
          "    // Verify wire::try_read_u32_as_usize(slice, \"start table patterns\") is Ok/Some.",
          "    let (maybe_pattern_len, nr) = wire::try_read_u32_as_usize(&slice[264..268], \"start table patterns\").unwrap();",
          "    ",
          "    // Verify maybe_pattern_len.as_u32() == u32::MAX is false.",
          "    assert_ne!(maybe_pattern_len.as_u32(), u32::MAX);",
          "    ",
          "    // Verify pattern_len.map_or(false, |len| len > PatternID::LIMIT) is false.",
          "    assert!(maybe_pattern_len <= PatternID::LIMIT);",
          "    ",
          "    // Verify wire::try_read_u32(slice, \"universal unanchored start\") is Ok/Some.",
          "    let (universal_unanchored_value, nr) = wire::try_read_u32(&slice[268..272], \"universal unanchored start\").unwrap();",
          "    ",
          "    // Verify universal_unanchored == u32::MAX is false.",
          "    assert_ne!(universal_unanchored_value, u32::MAX);",
          "    ",
          "    // Verify StateID::try_from(universal_unanchored).map_err(|e| DeserializeError::state_id_error(e, \"universal unanchored start\")) is Ok/Some.",
          "    let universal_start_unanchored = StateID::try_from(universal_unanchored_value).unwrap();",
          "    ",
          "    // Verify wire::try_read_u32(slice, \"universal anchored start\") is Ok/Some.",
          "    let (universal_anchored_value, nr) = wire::try_read_u32(&slice[272..276], \"universal anchored start\").unwrap();",
          "    ",
          "    // Verify universal_anchored == u32::MAX is false.",
          "    assert_ne!(universal_anchored_value, u32::MAX);",
          "    ",
          "    // Verify StateID::try_from(universal_anchored).map_err(|e| DeserializeError::state_id_error(e, \"universal anchored start\")) is Ok/Some.",
          "    let universal_start_anchored = StateID::try_from(universal_anchored_value).unwrap();",
          "    ",
          "    // Verify wire::mul(stride, pattern_len.unwrap_or(0), \"invalid pattern length\") is Ok/Some.",
          "    let pattern_table_size = wire::mul(stride as usize, pattern_len as usize, \"invalid pattern length\").unwrap();",
          "    ",
          "    // Verify wire::mul(2, stride, \"start state stride too big\") is Err/None.",
          "    assert!(wire::mul(2, stride as usize, \"start state stride too big\").is_ok());"
        ],
        "code": [
          "{",
          "    let start_kind_value: u32 = 0; // Representing StartKind::Both",
          "    let start_map_values: [u8; 256] = [0; 256]; // All values as Start::NonWordByte",
          "    let stride: u32 = 8; // Valid stride (equal to Start::len())",
          "    let pattern_len: u32 = 0; // Pattern length less than PatternID::LIMIT",
          "    let universal_unanchored: u32 = 1; // Valid value",
          "    let universal_anchored: u32 = 1; // Valid value",
          "",
          "    let length = 4 + 256 + 4 + 4 + 4 + 4 * (pattern_len as usize);",
          "    let mut slice = Vec::with_capacity(length);",
          "    ",
          "    slice.extend(&start_kind_value.to_le_bytes()); // StartKind",
          "    slice.extend(&start_map_values); // StartByteMap",
          "    slice.extend(&stride.to_le_bytes()); // stride",
          "    slice.extend(&pattern_len.to_le_bytes()); // pattern_len",
          "    slice.extend(&universal_unanchored.to_le_bytes()); // universal_unanchored",
          "    slice.extend(&universal_anchored.to_le_bytes()); // universal_anchored",
          "",
          "    let table: &[u8] = &slice;",
          "    ",
          "    // Call the function under test",
          "    unsafe {",
          "        let _result = StartTable::<&[u32]>::from_bytes_unchecked(table);",
          "    }",
          "    let start_kind_value: u32 = 0; // Representing StartKind::Both",
          "    let start_map_values: [u8; 256] = [0; 256]; // All values as Start::NonWordByte",
          "    let stride: u32 = 8; // Valid stride (equal to Start::len())",
          "    let pattern_len: u32 = 0; // Pattern length less than PatternID::LIMIT",
          "    let universal_unanchored: u32 = 1; // Valid value",
          "    let universal_anchored: u32 = 1; // Valid value",
          "    ",
          "    let length = 4 + 256 + 4 + 4 + 4 + 4 * (pattern_len as usize);",
          "    let mut slice = Vec::with_capacity(length);",
          "    ",
          "    slice.extend(&start_kind_value.to_le_bytes()); // StartKind",
          "    slice.extend(&start_map_values); // StartByteMap",
          "    slice.extend(&stride.to_le_bytes()); // stride",
          "    slice.extend(&pattern_len.to_le_bytes()); // pattern_len",
          "    slice.extend(&universal_unanchored.to_le_bytes()); // universal_unanchored",
          "    slice.extend(&universal_anchored.to_le_bytes()); // universal_anchored",
          "    ",
          "    let table: &[u8] = &slice;",
          "    ",
          "    // Verify StartKind::from_bytes(slice) is Ok/Some.",
          "    let (kind, nr) = StartKind::from_bytes(&slice[..4]).unwrap();",
          "    ",
          "    // Verify StartByteMap::from_bytes(slice) is Ok/Some.",
          "    let (start_map, nr) = StartByteMap::from_bytes(&slice[4..260]).unwrap();",
          "    ",
          "    // Verify wire::try_read_u32_as_usize(slice, \"start table stride\") is Ok/Some.",
          "    let (stride_value, nr) = wire::try_read_u32_as_usize(&slice[260..264], \"start table stride\").unwrap();",
          "    assert_eq!(stride_value, stride as usize);",
          "    ",
          "    // Verify stride != Start::len() is false.",
          "    assert_eq!(stride_value, Start::len());",
          "    ",
          "    // Verify wire::try_read_u32_as_usize(slice, \"start table patterns\") is Ok/Some.",
          "    let (maybe_pattern_len, nr) = wire::try_read_u32_as_usize(&slice[264..268], \"start table patterns\").unwrap();",
          "    ",
          "    // Verify maybe_pattern_len.as_u32() == u32::MAX is false.",
          "    assert_ne!(maybe_pattern_len.as_u32(), u32::MAX);",
          "    ",
          "    // Verify pattern_len.map_or(false, |len| len > PatternID::LIMIT) is false.",
          "    assert!(maybe_pattern_len <= PatternID::LIMIT);",
          "    ",
          "    // Verify wire::try_read_u32(slice, \"universal unanchored start\") is Ok/Some.",
          "    let (universal_unanchored_value, nr) = wire::try_read_u32(&slice[268..272], \"universal unanchored start\").unwrap();",
          "    ",
          "    // Verify universal_unanchored == u32::MAX is false.",
          "    assert_ne!(universal_unanchored_value, u32::MAX);",
          "    ",
          "    // Verify StateID::try_from(universal_unanchored).map_err(|e| DeserializeError::state_id_error(e, \"universal unanchored start\")) is Ok/Some.",
          "    let universal_start_unanchored = StateID::try_from(universal_unanchored_value).unwrap();",
          "    ",
          "    // Verify wire::try_read_u32(slice, \"universal anchored start\") is Ok/Some.",
          "    let (universal_anchored_value, nr) = wire::try_read_u32(&slice[272..276], \"universal anchored start\").unwrap();",
          "    ",
          "    // Verify universal_anchored == u32::MAX is false.",
          "    assert_ne!(universal_anchored_value, u32::MAX);",
          "    ",
          "    // Verify StateID::try_from(universal_anchored).map_err(|e| DeserializeError::state_id_error(e, \"universal anchored start\")) is Ok/Some.",
          "    let universal_start_anchored = StateID::try_from(universal_anchored_value).unwrap();",
          "    ",
          "    // Verify wire::mul(stride, pattern_len.unwrap_or(0), \"invalid pattern length\") is Ok/Some.",
          "    let pattern_table_size = wire::mul(stride as usize, pattern_len as usize, \"invalid pattern length\").unwrap();",
          "    ",
          "    // Verify wire::mul(2, stride, \"start state stride too big\") is Err/None.",
          "    assert!(wire::mul(2, stride as usize, \"start state stride too big\").is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_kind_value: u32 = 1; // Representing StartKind::Unanchored",
          "    let start_map_values: [u8; 256] = [1; 256]; // All values as Start::WordByte",
          "    let stride: u32 = 8; // Valid stride (equal to Start::len())",
          "    let pattern_len: u32 = 1; // Pattern length less than PatternID::LIMIT",
          "    let universal_unanchored: u32 = 2; // Valid value",
          "    let universal_anchored: u32 = 2; // Valid value",
          "",
          "    let length = 4 + 256 + 4 + 4 + 4 + 4 * (pattern_len as usize);",
          "    let mut slice = Vec::with_capacity(length);",
          "    ",
          "    slice.extend(&start_kind_value.to_le_bytes()); // StartKind",
          "    slice.extend(&start_map_values); // StartByteMap",
          "    slice.extend(&stride.to_le_bytes()); // stride",
          "    slice.extend(&pattern_len.to_le_bytes()); // pattern_len",
          "    slice.extend(&universal_unanchored.to_le_bytes()); // universal_unanchored",
          "    slice.extend(&universal_anchored.to_le_bytes()); // universal_anchored",
          "",
          "    let table: &[u8] = &slice;",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        let _result = StartTable::<&[u32]>::from_bytes_unchecked(table);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let start_kind_value: u32 = 1; // Representing StartKind::Unanchored",
          "    let start_map_values: [u8; 256] = [1; 256]; // All values as Start::WordByte",
          "    let stride: u32 = 8; // Valid stride (equal to Start::len())",
          "    let pattern_len: u32 = 1; // Pattern length less than PatternID::LIMIT",
          "    let universal_unanchored: u32 = 2; // Valid value",
          "    let universal_anchored: u32 = 2; // Valid value",
          "    ",
          "    let length = 4 + 256 + 4 + 4 + 4 + 4 * (pattern_len as usize);",
          "    let mut slice = Vec::with_capacity(length);",
          "    ",
          "    slice.extend(&start_kind_value.to_le_bytes()); // StartKind",
          "    slice.extend(&start_map_values); // StartByteMap",
          "    slice.extend(&stride.to_le_bytes()); // stride",
          "    slice.extend(&pattern_len.to_le_bytes()); // pattern_len",
          "    slice.extend(&universal_unanchored.to_le_bytes()); // universal_unanchored",
          "    slice.extend(&universal_anchored.to_le_bytes()); // universal_anchored",
          "    ",
          "    let table: &[u8] = &slice;",
          "    ",
          "    // Call the function under test",
          "    unsafe {",
          "    let _result = StartTable::<&[u32]>::from_bytes_unchecked(table);",
          "    }",
          "    ",
          "    // Verify that result is Ok and check the properties of the StartTable",
          "    assert!(_result.is_ok());",
          "    let (start_table, _) = _result.unwrap();",
          "    assert_eq!(start_table.kind, StartKind::Unanchored);",
          "    assert_eq!(start_table.stride, 8);",
          "    assert_eq!(start_table.pattern_len, Some(1));",
          "    assert_eq!(start_table.universal_start_unanchored, Some(StateID(2)));",
          "    assert_eq!(start_table.universal_start_anchored, Some(StateID(2)));"
        ],
        "code": [
          "{",
          "    let start_kind_value: u32 = 1; // Representing StartKind::Unanchored",
          "    let start_map_values: [u8; 256] = [1; 256]; // All values as Start::WordByte",
          "    let stride: u32 = 8; // Valid stride (equal to Start::len())",
          "    let pattern_len: u32 = 1; // Pattern length less than PatternID::LIMIT",
          "    let universal_unanchored: u32 = 2; // Valid value",
          "    let universal_anchored: u32 = 2; // Valid value",
          "",
          "    let length = 4 + 256 + 4 + 4 + 4 + 4 * (pattern_len as usize);",
          "    let mut slice = Vec::with_capacity(length);",
          "    ",
          "    slice.extend(&start_kind_value.to_le_bytes()); // StartKind",
          "    slice.extend(&start_map_values); // StartByteMap",
          "    slice.extend(&stride.to_le_bytes()); // stride",
          "    slice.extend(&pattern_len.to_le_bytes()); // pattern_len",
          "    slice.extend(&universal_unanchored.to_le_bytes()); // universal_unanchored",
          "    slice.extend(&universal_anchored.to_le_bytes()); // universal_anchored",
          "",
          "    let table: &[u8] = &slice;",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        let _result = StartTable::<&[u32]>::from_bytes_unchecked(table);",
          "    }",
          "    let start_kind_value: u32 = 1; // Representing StartKind::Unanchored",
          "    let start_map_values: [u8; 256] = [1; 256]; // All values as Start::WordByte",
          "    let stride: u32 = 8; // Valid stride (equal to Start::len())",
          "    let pattern_len: u32 = 1; // Pattern length less than PatternID::LIMIT",
          "    let universal_unanchored: u32 = 2; // Valid value",
          "    let universal_anchored: u32 = 2; // Valid value",
          "    ",
          "    let length = 4 + 256 + 4 + 4 + 4 + 4 * (pattern_len as usize);",
          "    let mut slice = Vec::with_capacity(length);",
          "    ",
          "    slice.extend(&start_kind_value.to_le_bytes()); // StartKind",
          "    slice.extend(&start_map_values); // StartByteMap",
          "    slice.extend(&stride.to_le_bytes()); // stride",
          "    slice.extend(&pattern_len.to_le_bytes()); // pattern_len",
          "    slice.extend(&universal_unanchored.to_le_bytes()); // universal_unanchored",
          "    slice.extend(&universal_anchored.to_le_bytes()); // universal_anchored",
          "    ",
          "    let table: &[u8] = &slice;",
          "    ",
          "    // Call the function under test",
          "    unsafe {",
          "    let _result = StartTable::<&[u32]>::from_bytes_unchecked(table);",
          "    }",
          "    ",
          "    // Verify that result is Ok and check the properties of the StartTable",
          "    assert!(_result.is_ok());",
          "    let (start_table, _) = _result.unwrap();",
          "    assert_eq!(start_table.kind, StartKind::Unanchored);",
          "    assert_eq!(start_table.stride, 8);",
          "    assert_eq!(start_table.pattern_len, Some(1));",
          "    assert_eq!(start_table.universal_start_unanchored, Some(StateID(2)));",
          "    assert_eq!(start_table.universal_start_anchored, Some(StateID(2)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]