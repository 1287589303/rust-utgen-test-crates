[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&slice) };",
          "}"
        ],
        "oracle": [
          "    let slice: [u8; 256] = [0; 256];",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&slice) };",
          "    let slice: [u8; 256] = [0; 256];",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    // Assuming the first 8 bytes for stride, followed by necessary valid bytes ",
          "    // up to the minimum required for alignment failure.",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[4..8].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[8..16].copy_from_slice(&[u8::MAX; 8]);",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "}"
        ],
        "oracle": [
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[4..8].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[8..16].copy_from_slice(&[u8::MAX; 8]);",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "    ",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap(), DeserializeError::alignment_mismatch(size_of::<StateID>(), valid_bytes.as_ptr().as_usize() % size_of::<StateID>()));",
          "    ",
          "    let invalid_slice: &[u8] = &[1, 2, 3, 4, 5, 6, 7];",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(invalid_slice) };",
          "    assert!(result.is_err());",
          "    assert!(matches!(result.err().unwrap(), DeserializeError::buffer_too_small(\"start ID table\")));",
          "    ",
          "    let valid_slice: &[u8] = &valid_bytes;",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(valid_slice) };",
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, valid_slice.len());"
        ],
        "code": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    // Assuming the first 8 bytes for stride, followed by necessary valid bytes ",
          "    // up to the minimum required for alignment failure.",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[4..8].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[8..16].copy_from_slice(&[u8::MAX; 8]);",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[4..8].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[8..16].copy_from_slice(&[u8::MAX; 8]);",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "    ",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap(), DeserializeError::alignment_mismatch(size_of::<StateID>(), valid_bytes.as_ptr().as_usize() % size_of::<StateID>()));",
          "    ",
          "    let invalid_slice: &[u8] = &[1, 2, 3, 4, 5, 6, 7];",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(invalid_slice) };",
          "    assert!(result.is_err());",
          "    assert!(matches!(result.err().unwrap(), DeserializeError::buffer_too_small(\"start ID table\")));",
          "    ",
          "    let valid_slice: &[u8] = &valid_bytes;",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(valid_slice) };",
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, valid_slice.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes()); // StartKind::Both",
          "    valid_bytes[4..260].fill(1); ",
          "    valid_bytes[260..264].copy_from_slice(&u32::MAX.to_le_bytes()); // universal unanchored",
          "    valid_bytes[264..268].copy_from_slice(&u32::MAX.to_le_bytes()); // universal anchored",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "}"
        ],
        "oracle": [
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[4..260].fill(1);",
          "    valid_bytes[260..264].copy_from_slice(&u32::MAX.to_le_bytes());",
          "    valid_bytes[264..268].copy_from_slice(&u32::MAX.to_le_bytes());",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().1, expected_bytes_read);",
          "    assert!(result.unwrap().0.kind == StartKind::Both);",
          "    assert!(result.unwrap().0.universal_start_unanchored.is_none());",
          "    assert!(result.unwrap().0.universal_start_anchored.is_none());",
          "    assert_eq!(result.unwrap().0.pattern_len, None);",
          "    assert!(result.unwrap().0.stride == valid_stride_value);",
          "    assert!(result.unwrap().0.table.len() == expected_table_length);"
        ],
        "code": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes()); // StartKind::Both",
          "    valid_bytes[4..260].fill(1); ",
          "    valid_bytes[260..264].copy_from_slice(&u32::MAX.to_le_bytes()); // universal unanchored",
          "    valid_bytes[264..268].copy_from_slice(&u32::MAX.to_le_bytes()); // universal anchored",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes());",
          "    valid_bytes[4..260].fill(1);",
          "    valid_bytes[260..264].copy_from_slice(&u32::MAX.to_le_bytes());",
          "    valid_bytes[264..268].copy_from_slice(&u32::MAX.to_le_bytes());",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().1, expected_bytes_read);",
          "    assert!(result.unwrap().0.kind == StartKind::Both);",
          "    assert!(result.unwrap().0.universal_start_unanchored.is_none());",
          "    assert!(result.unwrap().0.universal_start_anchored.is_none());",
          "    assert_eq!(result.unwrap().0.pattern_len, None);",
          "    assert!(result.unwrap().0.stride == valid_stride_value);",
          "    assert!(result.unwrap().0.table.len() == expected_table_length);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes()); // StartKind::Both",
          "    valid_bytes[4..260].fill(1); ",
          "    valid_bytes[260..264].copy_from_slice(&u32::MAX.to_le_bytes()); // universal unanchored",
          "    valid_bytes[264..268].copy_from_slice(&u32::MAX.to_le_bytes()); // universal anchored",
          "    valid_bytes[268..272].copy_from_slice(&(8u32).to_le_bytes()); // stride of 8",
          "    valid_bytes[272..276].copy_from_slice(&(u32::MAX).to_le_bytes()); // maybe_pattern_len",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, 276);",
          "    assert_eq!(start_table.kind, StartKind::Both);",
          "    assert_eq!(start_table.stride, 8);",
          "    assert!(start_table.pattern_len.is_none());",
          "    assert!(start_table.universal_start_unanchored.is_none());",
          "    assert!(start_table.universal_start_anchored.is_none());",
          "    assert_eq!(start_table.table.len(), 16);  // 2 * stride for both unanchored and anchored",
          "    assert_eq!(start_table.table[0], 1);",
          "    assert_eq!(start_table.table[4], 1);"
        ],
        "code": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes()); // StartKind::Both",
          "    valid_bytes[4..260].fill(1); ",
          "    valid_bytes[260..264].copy_from_slice(&u32::MAX.to_le_bytes()); // universal unanchored",
          "    valid_bytes[264..268].copy_from_slice(&u32::MAX.to_le_bytes()); // universal anchored",
          "    valid_bytes[268..272].copy_from_slice(&(8u32).to_le_bytes()); // stride of 8",
          "    valid_bytes[272..276].copy_from_slice(&(u32::MAX).to_le_bytes()); // maybe_pattern_len",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) };",
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, 276);",
          "    assert_eq!(start_table.kind, StartKind::Both);",
          "    assert_eq!(start_table.stride, 8);",
          "    assert!(start_table.pattern_len.is_none());",
          "    assert!(start_table.universal_start_unanchored.is_none());",
          "    assert!(start_table.universal_start_anchored.is_none());",
          "    assert_eq!(start_table.table.len(), 16);  // 2 * stride for both unanchored and anchored",
          "    assert_eq!(start_table.table[0], 1);",
          "    assert_eq!(start_table.table[4], 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes()); // StartKind::Both",
          "    valid_bytes[4..260].fill(1); ",
          "    valid_bytes[260..264].copy_from_slice(&u32::MAX.to_le_bytes()); // universal unanchored",
          "    valid_bytes[264..268].copy_from_slice(&u32::MAX.to_le_bytes()); // universal anchored",
          "    valid_bytes[268..272].copy_from_slice(&(8u32).to_le_bytes()); // stride of 8",
          "    valid_bytes[272..276].copy_from_slice(&(u32::MAX).to_le_bytes()); // maybe_pattern_len",
          "    valid_bytes[276..280].fill(0); // Align memory incorrectly",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) }; ",
          "}"
        ],
        "oracle": [
          "    let valid_bytes: Vec<u8> = vec![0; 256];",
          "    assert!(StartKind::from_bytes(&valid_bytes).is_ok());",
          "    assert!(StartByteMap::from_bytes(&valid_bytes).is_ok());",
          "    let (_, _) = wire::try_read_u32_as_usize(&valid_bytes, \"start table stride\").unwrap();",
          "    assert_eq!(8, Start::len());",
          "    assert!(wire::try_read_u32_as_usize(&valid_bytes, \"start table patterns\").is_ok());",
          "    assert_eq!(u32::MAX, valid_bytes[272..276].as_u32());",
          "    assert!(!pattern_len.map_or(false, |len| len > PatternID::LIMIT));",
          "    assert!(wire::try_read_u32(&valid_bytes, \"universal unanchored start\").is_ok());",
          "    assert_eq!(u32::MAX, valid_bytes[260..264].as_u32());",
          "    assert!(wire::try_read_u32(&valid_bytes, \"universal anchored start\").is_ok());",
          "    assert_eq!(u32::MAX, valid_bytes[264..268].as_u32());",
          "    assert!(wire::mul(8, 0, \"invalid pattern length\").is_ok());",
          "    assert!(wire::mul(2, 8, \"start state stride too big\").is_ok());",
          "    assert!(wire::add(wire::mul(2, 8, \"start state stride too big\").unwrap(), pattern_table_size, \"invalid 'any' pattern starts size\").is_ok());",
          "    assert!(wire::mul(start_state_len, StateID::SIZE, \"pattern table bytes length\").is_ok());",
          "    assert!(wire::check_slice_len(&valid_bytes, table_bytes_len, \"start ID table\").is_ok());",
          "    assert!(wire::check_alignment::<StateID>(&valid_bytes).is_err());"
        ],
        "code": [
          "{",
          "    let slice: [u8; 256] = [0; 256];",
          "    let mut valid_bytes = vec![0u8; 256];",
          "    valid_bytes[0..4].copy_from_slice(&0u32.to_le_bytes()); // StartKind::Both",
          "    valid_bytes[4..260].fill(1); ",
          "    valid_bytes[260..264].copy_from_slice(&u32::MAX.to_le_bytes()); // universal unanchored",
          "    valid_bytes[264..268].copy_from_slice(&u32::MAX.to_le_bytes()); // universal anchored",
          "    valid_bytes[268..272].copy_from_slice(&(8u32).to_le_bytes()); // stride of 8",
          "    valid_bytes[272..276].copy_from_slice(&(u32::MAX).to_le_bytes()); // maybe_pattern_len",
          "    valid_bytes[276..280].fill(0); // Align memory incorrectly",
          "    let result = unsafe { StartTable::<&[u32]>::from_bytes_unchecked(&valid_bytes) }; ",
          "    let valid_bytes: Vec<u8> = vec![0; 256];",
          "    assert!(StartKind::from_bytes(&valid_bytes).is_ok());",
          "    assert!(StartByteMap::from_bytes(&valid_bytes).is_ok());",
          "    let (_, _) = wire::try_read_u32_as_usize(&valid_bytes, \"start table stride\").unwrap();",
          "    assert_eq!(8, Start::len());",
          "    assert!(wire::try_read_u32_as_usize(&valid_bytes, \"start table patterns\").is_ok());",
          "    assert_eq!(u32::MAX, valid_bytes[272..276].as_u32());",
          "    assert!(!pattern_len.map_or(false, |len| len > PatternID::LIMIT));",
          "    assert!(wire::try_read_u32(&valid_bytes, \"universal unanchored start\").is_ok());",
          "    assert_eq!(u32::MAX, valid_bytes[260..264].as_u32());",
          "    assert!(wire::try_read_u32(&valid_bytes, \"universal anchored start\").is_ok());",
          "    assert_eq!(u32::MAX, valid_bytes[264..268].as_u32());",
          "    assert!(wire::mul(8, 0, \"invalid pattern length\").is_ok());",
          "    assert!(wire::mul(2, 8, \"start state stride too big\").is_ok());",
          "    assert!(wire::add(wire::mul(2, 8, \"start state stride too big\").unwrap(), pattern_table_size, \"invalid 'any' pattern starts size\").is_ok());",
          "    assert!(wire::mul(start_state_len, StateID::SIZE, \"pattern table bytes length\").is_ok());",
          "    assert!(wire::check_slice_len(&valid_bytes, table_bytes_len, \"start ID table\").is_ok());",
          "    assert!(wire::check_alignment::<StateID>(&valid_bytes).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]