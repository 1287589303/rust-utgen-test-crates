[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        // StartKind::Both (0)",
          "        0, 0, 0, 0,",
          "        // Valid StartByteMap entries (first 256 bytes)",
          "        [0u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "        // Stride (6)",
          "        6, 0, 0, 0,",
          "        // Patterns (0)",
          "        0, 0, 0, 0,",
          "    ].concat();",
          "",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    let _ = result.unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(unsafe { StartTable::from_bytes_unchecked(&slice) }.is_ok(), true);",
          "    assert_eq!(unsafe { StartKind::from_bytes(&slice[0..4]) }.is_ok(), true);",
          "    assert_eq!(unsafe { StartByteMap::from_bytes(&slice[4..260]) }.is_ok(), true);",
          "    assert_eq!(unsafe { wire::try_read_u32_as_usize(&slice[260..264], \"start table stride\") }.is_ok(), true);",
          "    assert_eq!(unsafe { wire::try_read_u32_as_usize(&slice[264..268], \"start table patterns\") }.is_err(), true);"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        // StartKind::Both (0)",
          "        0, 0, 0, 0,",
          "        // Valid StartByteMap entries (first 256 bytes)",
          "        [0u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "        // Stride (6)",
          "        6, 0, 0, 0,",
          "        // Patterns (0)",
          "        0, 0, 0, 0,",
          "    ].concat();",
          "",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    let _ = result.unwrap();",
          "    assert_eq!(unsafe { StartTable::from_bytes_unchecked(&slice) }.is_ok(), true);",
          "    assert_eq!(unsafe { StartKind::from_bytes(&slice[0..4]) }.is_ok(), true);",
          "    assert_eq!(unsafe { StartByteMap::from_bytes(&slice[4..260]) }.is_ok(), true);",
          "    assert_eq!(unsafe { wire::try_read_u32_as_usize(&slice[260..264], \"start table stride\") }.is_ok(), true);",
          "    assert_eq!(unsafe { wire::try_read_u32_as_usize(&slice[264..268], \"start table patterns\") }.is_err(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        // StartKind::Unanchored (1)",
          "        1, 0, 0, 0,",
          "        // Valid StartByteMap entries (first 256 bytes)",
          "        [1u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "        // Stride (6)",
          "        6, 0, 0, 0,",
          "        // Patterns (None, represented by u32::MAX)",
          "        255, 255, 255, 255,",
          "    ].concat();",
          "",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    let _ = result.unwrap();",
          "}"
        ],
        "oracle": [
          "    let slice: &[u8] = &[",
          "    // StartKind::Unanchored (1)",
          "    1, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [1u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Stride (6)",
          "    6, 0, 0, 0,",
          "    // Patterns (None, represented by u32::MAX)",
          "    255, 255, 255, 255,",
          "    ].concat();",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, slice.len());",
          "    assert_eq!(start_table.kind, StartKind::Unanchored);",
          "    assert_eq!(start_table.stride, 6);",
          "    assert!(start_table.pattern_len.is_none());"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        // StartKind::Unanchored (1)",
          "        1, 0, 0, 0,",
          "        // Valid StartByteMap entries (first 256 bytes)",
          "        [1u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "        // Stride (6)",
          "        6, 0, 0, 0,",
          "        // Patterns (None, represented by u32::MAX)",
          "        255, 255, 255, 255,",
          "    ].concat();",
          "",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    let _ = result.unwrap();",
          "    let slice: &[u8] = &[",
          "    // StartKind::Unanchored (1)",
          "    1, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [1u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Stride (6)",
          "    6, 0, 0, 0,",
          "    // Patterns (None, represented by u32::MAX)",
          "    255, 255, 255, 255,",
          "    ].concat();",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_ok());",
          "    let (start_table, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, slice.len());",
          "    assert_eq!(start_table.kind, StartKind::Unanchored);",
          "    assert_eq!(start_table.stride, 6);",
          "    assert!(start_table.pattern_len.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        // StartKind::Anchored (2)",
          "        2, 0, 0, 0,",
          "        // Valid StartByteMap entries (first 256 bytes)",
          "        [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "        // Wrong Stride (4)",
          "        4, 0, 0, 0,",
          "        // Patterns (None, represented by u32::MAX)",
          "        255, 255, 255, 255,",
          "    ].concat();",
          "",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "}"
        ],
        "oracle": [
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Valid Stride (6)",
          "    6, 0, 0, 0,",
          "    // Patterns (None, represented by u32::MAX)",
          "    255, 255, 255, 255,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Stride mismatch (7)",
          "    7, 0, 0, 0,",
          "    // Patterns (None, represented by u32::MAX)",
          "    255, 255, 255, 255,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "    ",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Valid Stride (6)",
          "    6, 0, 0, 0,",
          "    // Valid Patterns (1)",
          "    1, 0, 0, 0,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Valid Stride (6)",
          "    6, 0, 0, 0,",
          "    // Invalid Patterns (greater than LIMIT)",
          "    10, 0, 0, 0,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "    ",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Invalid StartByteMap entries (includes invalid config)",
          "    [10u8; 256].as_slice().to_vec(),",
          "    // Valid Stride (6)",
          "    6, 0, 0, 0,",
          "    // Valid Patterns (1)",
          "    1, 0, 0, 0,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        // StartKind::Anchored (2)",
          "        2, 0, 0, 0,",
          "        // Valid StartByteMap entries (first 256 bytes)",
          "        [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "        // Wrong Stride (4)",
          "        4, 0, 0, 0,",
          "        // Patterns (None, represented by u32::MAX)",
          "        255, 255, 255, 255,",
          "    ].concat();",
          "",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Valid Stride (6)",
          "    6, 0, 0, 0,",
          "    // Patterns (None, represented by u32::MAX)",
          "    255, 255, 255, 255,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Stride mismatch (7)",
          "    7, 0, 0, 0,",
          "    // Patterns (None, represented by u32::MAX)",
          "    255, 255, 255, 255,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "    ",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Valid Stride (6)",
          "    6, 0, 0, 0,",
          "    // Valid Patterns (1)",
          "    1, 0, 0, 0,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Valid StartByteMap entries (first 256 bytes)",
          "    [2u8; 256].map(|x| (x % 6) as u8).as_slice().to_vec(),",
          "    // Valid Stride (6)",
          "    6, 0, 0, 0,",
          "    // Invalid Patterns (greater than LIMIT)",
          "    10, 0, 0, 0,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "    ",
          "    let slice: &[u8] = &[",
          "    // StartKind::Anchored (2)",
          "    2, 0, 0, 0,",
          "    // Invalid StartByteMap entries (includes invalid config)",
          "    [10u8; 256].as_slice().to_vec(),",
          "    // Valid Stride (6)",
          "    6, 0, 0, 0,",
          "    // Valid Patterns (1)",
          "    1, 0, 0, 0,",
          "    ];",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]