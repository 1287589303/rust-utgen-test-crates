[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = b\"Bruce Springsteen\";",
          "    let mut input = Input::new(&haystack).set_anchored(Anchored::No);",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 2],",
          "        explicit_slot_len: 2,",
          "    };",
          "    let mut caps = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![None; 2],",
          "    };",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![],",
          "        starts: vec![],",
          "        min_match_id: StateID::default(),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 0,",
          "        stride2: 0,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "",
          "    dfa.captures(&mut cache, input, &mut caps);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(input.get_anchored(), Anchored::Yes));",
          "    assert_eq!(caps.get_match(), Some(Match::must(0, 0..17)));",
          "    assert_eq!(caps.get_group(1), Some(Span::from(0..5)));",
          "    assert_eq!(caps.get_group_by_name(\"last\"), Some(Span::from(6..17)));",
          "    assert_eq!(cache.explicit_slot_len, 2);",
          "    assert!(cache.explicit_slots.iter().all(|slot| slot.is_none()));"
        ],
        "code": [
          "{",
          "    let haystack = b\"Bruce Springsteen\";",
          "    let mut input = Input::new(&haystack).set_anchored(Anchored::No);",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 2],",
          "        explicit_slot_len: 2,",
          "    };",
          "    let mut caps = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![None; 2],",
          "    };",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![],",
          "        starts: vec![],",
          "        min_match_id: StateID::default(),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 0,",
          "        stride2: 0,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "",
          "    dfa.captures(&mut cache, input, &mut caps);",
          "    assert!(matches!(input.get_anchored(), Anchored::Yes));",
          "    assert_eq!(caps.get_match(), Some(Match::must(0, 0..17)));",
          "    assert_eq!(caps.get_group(1), Some(Span::from(0..5)));",
          "    assert_eq!(caps.get_group_by_name(\"last\"), Some(Span::from(6..17)));",
          "    assert_eq!(cache.explicit_slot_len, 2);",
          "    assert!(cache.explicit_slots.iter().all(|slot| slot.is_none()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let haystack = b\"Bruce Springsteen\";",
          "    let mut input = Input::new(&haystack).set_anchored(Anchored::No);",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 2],",
          "        explicit_slot_len: 2,",
          "    };",
          "    let mut caps = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![None; 2],",
          "    };",
          "    let dfa = DFA {",
          "        config: Config {",
          "            match_kind: Some(MatchKind::Anchored),",
          "            ..Config::default()",
          "        },",
          "        nfa: NFA::default(),",
          "        table: vec![],",
          "        starts: vec![],",
          "        min_match_id: StateID::default(),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 0,",
          "        stride2: 0,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "",
          "    dfa.captures(&mut cache, input, &mut caps);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(input.get_anchored(), Anchored::Yes);",
          "    assert!(matches!(cache.explicit_slots.len(), 2));",
          "    assert!(caps.get_match().is_none());",
          "    assert_eq!(caps.slots.len(), 2);",
          "    assert!(caps.get_group(1).is_none());",
          "    assert!(caps.get_group_by_name(\"last\").is_none());",
          "    assert!(caps.pid.is_none());",
          "    assert!(matches!(dfa.config.match_kind, Some(MatchKind::Anchored)));",
          "    assert!(caps.group_info.is_default());"
        ],
        "code": [
          "{",
          "    let haystack = b\"Bruce Springsteen\";",
          "    let mut input = Input::new(&haystack).set_anchored(Anchored::No);",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 2],",
          "        explicit_slot_len: 2,",
          "    };",
          "    let mut caps = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![None; 2],",
          "    };",
          "    let dfa = DFA {",
          "        config: Config {",
          "            match_kind: Some(MatchKind::Anchored),",
          "            ..Config::default()",
          "        },",
          "        nfa: NFA::default(),",
          "        table: vec![],",
          "        starts: vec![],",
          "        min_match_id: StateID::default(),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 0,",
          "        stride2: 0,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "",
          "    dfa.captures(&mut cache, input, &mut caps);",
          "    assert_eq!(input.get_anchored(), Anchored::Yes);",
          "    assert!(matches!(cache.explicit_slots.len(), 2));",
          "    assert!(caps.get_match().is_none());",
          "    assert_eq!(caps.slots.len(), 2);",
          "    assert!(caps.get_group(1).is_none());",
          "    assert!(caps.get_group_by_name(\"last\").is_none());",
          "    assert!(caps.pid.is_none());",
          "    assert!(matches!(dfa.config.match_kind, Some(MatchKind::Anchored)));",
          "    assert!(caps.group_info.is_default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]