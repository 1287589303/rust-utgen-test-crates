[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Empty(Box::new(Span::default()));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion::default()))) == Ok(())",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl::default()))) == Ok(())",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode::default()))) == Ok(())",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Group(Box::new(Group::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat::default()))) == Ok(())"
        ],
        "code": [
          "{",
          "    let ast = Ast::Empty(Box::new(Span::default()));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion::default()))) == Ok(())",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl::default()))) == Ok(())",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode::default()))) == Ok(())",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Group(Box::new(Group::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation::default()))) == Ok(())",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat::default()))) == Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Flags(Box::new(SetFlags {",
          "        span: Span::default(),",
          "        flags: Flags::default(),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Dot(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Alternation(Box::new(Alternation { branches: vec![] }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Concat(Box::new(Concat { parts: vec![] }))), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::Flags(Box::new(SetFlags {",
          "        span: Span::default(),",
          "        flags: Flags::default(),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Dot(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Alternation(Box::new(Alternation { branches: vec![] }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Concat(Box::new(Concat { parts: vec![] }))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Literal(Box::new(Literal {",
          "        span: Span::default(),",
          "        kind: LiteralKind::Verbatim,",
          "        c: 'a',",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // Precondition: Ast matches Ast::Empty(_)",
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(), Ok(())); // Expected return value: Ok(())"
        ],
        "code": [
          "{",
          "    let ast = Ast::Literal(Box::new(Literal {",
          "        span: Span::default(),",
          "        kind: LiteralKind::Verbatim,",
          "        c: 'a',",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // Precondition: Ast matches Ast::Empty(_)",
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(), Ok(())); // Expected return value: Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Dot(Box::new(Span::default()));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))) }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))) }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation { arms: vec![Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))] }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat { parts: vec![Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))] }))).unwrap(); // Expected: Ok(())"
        ],
        "code": [
          "{",
          "    let ast = Ast::Dot(Box::new(Span::default()));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))) }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))) }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation { arms: vec![Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))] }))).unwrap(); // Expected: Ok(())",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat { parts: vec![Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))] }))).unwrap(); // Expected: Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Assertion(Box::new(Assertion {",
          "        span: Span::default(),",
          "        kind: AssertionKind::StartLine,",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default() }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Default, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation { span: Span::default(), ast: vec![Ast::Empty(Box::new(Span::default()))] }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat { span: Span::default(), ast: vec![Ast::Empty(Box::new(Span::default()))] }))).unwrap() == Ok(())"
        ],
        "code": [
          "{",
          "    let ast = Ast::Assertion(Box::new(Assertion {",
          "        span: Span::default(),",
          "        kind: AssertionKind::StartLine,",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default() }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Default, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation { span: Span::default(), ast: vec![Ast::Empty(Box::new(Span::default()))] }))).unwrap() == Ok(())",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat { span: Span::default(), ast: vec![Ast::Empty(Box::new(Span::default()))] }))).unwrap() == Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::ClassPerl(Box::new(ClassPerl {",
          "        span: Span::default(),",
          "        kind: ClassPerlKind::Digit,",
          "        negated: false,",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags {",
          "    span: Span::default(),",
          "    flags: Flags::default(),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal {",
          "    span: Span::default(),",
          "    kind: LiteralKind::Verbatim,",
          "    c: 'a',",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion {",
          "    span: Span::default(),",
          "    kind: AssertionKind::StartLine,",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl {",
          "    span: Span::default(),",
          "    kind: ClassPerlKind::Word,",
          "    negated: false,",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode {",
          "    span: Span::default(),",
          "    negated: true,",
          "    kind: ClassUnicodeKind::Named('A'),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed {",
          "    span: Span::default(),",
          "    negated: false,",
          "    kind: ClassSet::default(),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition {",
          "    span: Span::default(),",
          "    op: RepetitionOp::ZeroOrMore,",
          "    greedy: true,",
          "    ast: Box::new(Ast::Literal(Box::new(Literal {",
          "    span: Span::default(),",
          "    kind: LiteralKind::Meta,",
          "    c: 'b',",
          "    }))),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Group(Box::new(Group {",
          "    span: Span::default(),",
          "    kind: GroupKind::Default,",
          "    ast: Box::new(Ast::Empty(Box::new(Span::default()))),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation::default()))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat::default()))).unwrap(); // Expected: Ok(())"
        ],
        "code": [
          "{",
          "    let ast = Ast::ClassPerl(Box::new(ClassPerl {",
          "        span: Span::default(),",
          "        kind: ClassPerlKind::Digit,",
          "        negated: false,",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags {",
          "    span: Span::default(),",
          "    flags: Flags::default(),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal {",
          "    span: Span::default(),",
          "    kind: LiteralKind::Verbatim,",
          "    c: 'a',",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion {",
          "    span: Span::default(),",
          "    kind: AssertionKind::StartLine,",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl {",
          "    span: Span::default(),",
          "    kind: ClassPerlKind::Word,",
          "    negated: false,",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode {",
          "    span: Span::default(),",
          "    negated: true,",
          "    kind: ClassUnicodeKind::Named('A'),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed {",
          "    span: Span::default(),",
          "    negated: false,",
          "    kind: ClassSet::default(),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition {",
          "    span: Span::default(),",
          "    op: RepetitionOp::ZeroOrMore,",
          "    greedy: true,",
          "    ast: Box::new(Ast::Literal(Box::new(Literal {",
          "    span: Span::default(),",
          "    kind: LiteralKind::Meta,",
          "    c: 'b',",
          "    }))),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Group(Box::new(Group {",
          "    span: Span::default(),",
          "    kind: GroupKind::Default,",
          "    ast: Box::new(Ast::Empty(Box::new(Span::default()))),",
          "    }))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation::default()))).unwrap(); // Expected: Ok(())",
          "    ",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat::default()))).unwrap(); // Expected: Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::ClassUnicode(Box::new(ClassUnicode {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassUnicodeKind::OneLetter('a'),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Dot(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: false, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Alternation(Box::new(Alternation { arms: vec![Ast::Empty(Box::new(Span::default()))] }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Concat(Box::new(Concat { parts: vec![Ast::Empty(Box::new(Span::default()))] }))), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::ClassUnicode(Box::new(ClassUnicode {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassUnicodeKind::OneLetter('a'),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Dot(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: false, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Alternation(Box::new(Alternation { arms: vec![Ast::Empty(Box::new(Span::default()))] }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Concat(Box::new(Concat { parts: vec![Ast::Empty(Box::new(Span::default()))] }))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::ClassBracketed(Box::new(ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassSet::Normal,",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation { span: Span::default(), asts: vec![Ast::Empty(Box::new(Span::default()))] }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat { span: Span::default(), asts: vec![Ast::Empty(Box::new(Span::default()))] }))).unwrap(); // Expecting Ok(());"
        ],
        "code": [
          "{",
          "    let ast = Ast::ClassBracketed(Box::new(ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassSet::Normal,",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation { span: Span::default(), asts: vec![Ast::Empty(Box::new(Span::default()))] }))).unwrap(); // Expecting Ok(())",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat { span: Span::default(), asts: vec![Ast::Empty(Box::new(Span::default()))] }))).unwrap(); // Expecting Ok(());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Repetition(Box::new(Repetition {",
          "        span: Span::default(),",
          "        op: RepetitionOp::ZeroOrMore,",
          "        greedy: true,",
          "        ast: Box::new(Ast::Empty(Box::new(Span::default()))),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::Repetition(Box::new(Repetition {",
          "        span: Span::default(),",
          "        op: RepetitionOp::ZeroOrMore,",
          "        greedy: true,",
          "        ast: Box::new(Ast::Empty(Box::new(Span::default()))),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Group(Box::new(Group {",
          "        span: Span::default(),",
          "        kind: GroupKind::Capture,",
          "        ast: Box::new(Ast::Empty(Box::new(Span::default()))),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Dot(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Alternation(Box::new(Alternation { branches: Vec::new() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Concat(Box::new(Concat { expressions: Vec::new() }))), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::Group(Box::new(Group {",
          "        span: Span::default(),",
          "        kind: GroupKind::Capture,",
          "        ast: Box::new(Ast::Empty(Box::new(Span::default()))),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Dot(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Alternation(Box::new(Alternation { branches: Vec::new() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Concat(Box::new(Concat { expressions: Vec::new() }))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Alternation(Box::new(Alternation {",
          "        span: Span::default(),",
          "        asts: Vec::new(),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // line 90",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))).unwrap(); // line 91",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))).unwrap(); // line 92",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap(); // line 93",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))).unwrap(); // line 94",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))).unwrap(); // line 95",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))).unwrap(); // line 96",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))).unwrap(); // line 97",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap(); // line 98",
          "    writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Regular, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap(); // line 99",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation { span: Span::default(), asts: Vec::new() }))).unwrap(); // line 100",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat { span: Span::default(), asts: Vec::new() }))).unwrap(); // line 101"
        ],
        "code": [
          "{",
          "    let ast = Ast::Alternation(Box::new(Alternation {",
          "        span: Span::default(),",
          "        asts: Vec::new(),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    writer.visit_post(&Ast::Empty(Box::new(Span::default()))).unwrap(); // line 90",
          "    writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))).unwrap(); // line 91",
          "    writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))).unwrap(); // line 92",
          "    writer.visit_post(&Ast::Dot(Box::new(Span::default()))).unwrap(); // line 93",
          "    writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))).unwrap(); // line 94",
          "    writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))).unwrap(); // line 95",
          "    writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))).unwrap(); // line 96",
          "    writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }))).unwrap(); // line 97",
          "    writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap(); // line 98",
          "    writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Regular, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))).unwrap(); // line 99",
          "    writer.visit_post(&Ast::Alternation(Box::new(Alternation { span: Span::default(), asts: Vec::new() }))).unwrap(); // line 100",
          "    writer.visit_post(&Ast::Concat(Box::new(Concat { span: Span::default(), asts: Vec::new() }))).unwrap(); // line 101",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Concat(Box::new(Concat {",
          "        span: Span::default(),",
          "        asts: Vec::new(),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Dot(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Alternation(Box::new(Alternation { span: Span::default(), asts: Vec::new() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Concat(Box::new(Concat { span: Span::default(), asts: Vec::new() }))), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::Concat(Box::new(Concat {",
          "        span: Span::default(),",
          "        asts: Vec::new(),",
          "    }));",
          "    let mut writer = Writer { wtr: Vec::new() };",
          "    writer.visit_post(&ast).unwrap();",
          "    assert_eq!(writer.visit_post(&Ast::Empty(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Flags(Box::new(SetFlags { span: Span::default(), flags: Flags::default() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Literal(Box::new(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Dot(Box::new(Span::default()))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Assertion(Box::new(Assertion { span: Span::default(), kind: AssertionKind::StartLine }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassPerl(Box::new(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Repetition(Box::new(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Group(Box::new(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Box::new(Span::default()))) }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Alternation(Box::new(Alternation { span: Span::default(), asts: Vec::new() }))), Ok(()));",
          "    assert_eq!(writer.visit_post(&Ast::Concat(Box::new(Concat { span: Span::default(), asts: Vec::new() }))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]