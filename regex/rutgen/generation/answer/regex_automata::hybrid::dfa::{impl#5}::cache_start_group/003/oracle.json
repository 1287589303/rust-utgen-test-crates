[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 5],",
          "        explicit_slot_len: 5,",
          "    };",
          "",
          "    let dfa = DFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(true),",
          "            ..Default::default()",
          "        },",
          "        nfa: NFA::never_match(),",
          "        stride2: 0,",
          "        start_map: StartByteMap::new(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let pattern_id = PatternID(0);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let start = Start::NonWordByte;",
          "",
          "    let result = lazy.cache_start_group(anchored, start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(lazy.dead_id()));"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 5],",
          "        explicit_slot_len: 5,",
          "    };",
          "",
          "    let dfa = DFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(true),",
          "            ..Default::default()",
          "        },",
          "        nfa: NFA::never_match(),",
          "        stride2: 0,",
          "        start_map: StartByteMap::new(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let pattern_id = PatternID(0);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let start = Start::NonWordByte;",
          "",
          "    let result = lazy.cache_start_group(anchored, start);",
          "    assert_eq!(result, Ok(lazy.dead_id()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 5],",
          "        explicit_slot_len: 5,",
          "    };",
          "",
          "    let dfa = DFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(true),",
          "            ..Default::default()",
          "        },",
          "        nfa: NFA::never_match(),",
          "        stride2: 0,",
          "        start_map: StartByteMap::new(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let pattern_id = PatternID(1);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let start = Start::NonWordByte;",
          "",
          "    let result = lazy.cache_start_group(anchored, start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(lazy.dead_id()));"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 5],",
          "        explicit_slot_len: 5,",
          "    };",
          "",
          "    let dfa = DFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(true),",
          "            ..Default::default()",
          "        },",
          "        nfa: NFA::never_match(),",
          "        stride2: 0,",
          "        start_map: StartByteMap::new(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let pattern_id = PatternID(1);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let start = Start::NonWordByte;",
          "",
          "    let result = lazy.cache_start_group(anchored, start);",
          "    assert_eq!(result, Ok(lazy.dead_id()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 10],",
          "        explicit_slot_len: 10,",
          "    };",
          "",
          "    let dfa = DFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(true),",
          "            ..Default::default()",
          "        },",
          "        nfa: NFA::new(\"test\").unwrap(),",
          "        stride2: 0,",
          "        start_map: StartByteMap::new(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let pattern_id = PatternID(2);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let start = Start::WordByte;",
          "",
          "    let result = lazy.cache_start_group(anchored, start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(lazy.dead_id()));",
          "    assert!(dfa.get_config().get_starts_for_each_pattern());",
          "    assert!(dfa.get_nfa().start_pattern(pattern_id).is_none());",
          "    assert_eq!(lazy.cache.starts.len(), 10);",
          "    assert!(lazy.is_valid(lazy.dead_id()));",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap() == lazy.dead_id());",
          "    assert_ne!(result.unwrap(), lazy.unknown_id());"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 10],",
          "        explicit_slot_len: 10,",
          "    };",
          "",
          "    let dfa = DFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(true),",
          "            ..Default::default()",
          "        },",
          "        nfa: NFA::new(\"test\").unwrap(),",
          "        stride2: 0,",
          "        start_map: StartByteMap::new(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let pattern_id = PatternID(2);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let start = Start::WordByte;",
          "",
          "    let result = lazy.cache_start_group(anchored, start);",
          "    assert_eq!(result, Ok(lazy.dead_id()));",
          "    assert!(dfa.get_config().get_starts_for_each_pattern());",
          "    assert!(dfa.get_nfa().start_pattern(pattern_id).is_none());",
          "    assert_eq!(lazy.cache.starts.len(), 10);",
          "    assert!(lazy.is_valid(lazy.dead_id()));",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap() == lazy.dead_id());",
          "    assert_ne!(result.unwrap(), lazy.unknown_id());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]