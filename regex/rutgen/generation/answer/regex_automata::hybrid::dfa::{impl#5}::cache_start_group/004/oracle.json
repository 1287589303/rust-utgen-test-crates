[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestDFA {",
          "        config: Config,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn get_config(&self) -> &Config {",
          "            &self.config",
          "        }",
          "    }",
          "",
          "    let pattern_id = PatternID(1);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![],",
          "        explicit_slot_len: 0,",
          "    };",
          "    ",
          "    let dfa = TestDFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(false),",
          "            ..Config::default()",
          "        },",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "    ",
          "    let result = lazy.cache_start_group(anchored, Start::Text);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(result, Err(StartError::unsupported_anchored(Anchored::Pattern(PatternID(1))))));"
        ],
        "code": [
          "{",
          "    struct TestDFA {",
          "        config: Config,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn get_config(&self) -> &Config {",
          "            &self.config",
          "        }",
          "    }",
          "",
          "    let pattern_id = PatternID(1);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![],",
          "        explicit_slot_len: 0,",
          "    };",
          "    ",
          "    let dfa = TestDFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(false),",
          "            ..Config::default()",
          "        },",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "    ",
          "    let result = lazy.cache_start_group(anchored, Start::Text);",
          "    assert!(matches!(result, Err(StartError::unsupported_anchored(Anchored::Pattern(PatternID(1))))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestDFA {",
          "        config: Config,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn get_config(&self) -> &Config {",
          "            &self.config",
          "        }",
          "    }",
          "",
          "    let pattern_id = PatternID(2);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![],",
          "        explicit_slot_len: 0,",
          "    };",
          "    ",
          "    let dfa = TestDFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(false),",
          "            ..Config::default()",
          "        },",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "    ",
          "    let result = lazy.cache_start_group(anchored, Start::WordByte);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Err(StartError::unsupported_anchored(anchored)));"
        ],
        "code": [
          "{",
          "    struct TestDFA {",
          "        config: Config,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn get_config(&self) -> &Config {",
          "            &self.config",
          "        }",
          "    }",
          "",
          "    let pattern_id = PatternID(2);",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![],",
          "        explicit_slot_len: 0,",
          "    };",
          "    ",
          "    let dfa = TestDFA {",
          "        config: Config {",
          "            starts_for_each_pattern: Some(false),",
          "            ..Config::default()",
          "        },",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "    ",
          "    let result = lazy.cache_start_group(anchored, Start::WordByte);",
          "    assert_eq!(result, Err(StartError::unsupported_anchored(anchored)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]