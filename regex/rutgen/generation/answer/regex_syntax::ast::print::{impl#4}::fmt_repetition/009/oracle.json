[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ast = ast::Repetition {",
          "        span: Span::default(),",
          "        op: ast::RepetitionOp {",
          "            kind: ast::RepetitionKind::ZeroOrOne,",
          "        },",
          "        greedy: true,",
          "        ast: Box::new(ast::Ast::default()),",
          "    };",
          "",
          "    let mut fmt_writer = Writer { wtr: writer };",
          "    fmt_writer.fmt_repetition(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"?\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"??\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrMore,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"*\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrMore,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"*?\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::OneOrMore,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"+\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::OneOrMore,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"+?\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(3)),",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"{{3}}\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(2)),",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"{{2,}}?\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(3, 5)),",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"{{3,5}}\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ast = ast::Repetition {",
          "        span: Span::default(),",
          "        op: ast::RepetitionOp {",
          "            kind: ast::RepetitionKind::ZeroOrOne,",
          "        },",
          "        greedy: true,",
          "        ast: Box::new(ast::Ast::default()),",
          "    };",
          "",
          "    let mut fmt_writer = Writer { wtr: writer };",
          "    fmt_writer.fmt_repetition(&ast).unwrap();",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"?\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"??\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrMore,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"*\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrMore,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"*?\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::OneOrMore,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"+\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::OneOrMore,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"+?\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(3)),",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"{{3}}\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(2)),",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"{{2,}}?\");",
          "    ",
          "    let ast = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(3, 5)),",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    assert_eq!(fmt_writer.wtr.output, \"{{3,5}}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ast = ast::Repetition {",
          "        span: Span::default(),",
          "        op: ast::RepetitionOp {",
          "            kind: ast::RepetitionKind::ZeroOrMore,",
          "        },",
          "        greedy: true,",
          "        ast: Box::new(ast::Ast::default()),",
          "    };",
          "",
          "    let mut fmt_writer = Writer { wtr: writer };",
          "    fmt_writer.fmt_repetition(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, \"*\");",
          "    assert_eq!(ast.greedy, true);",
          "    assert_eq!(ast.op.kind, ast::RepetitionKind::ZeroOrMore);",
          "    assert!(fmt_writer.fmt_repetition(&ast).is_ok());",
          "    ",
          "    let ast_alternate = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_alternate).unwrap();",
          "    assert_eq!(writer.output, \"?\");",
          "    ",
          "    let ast_non_greedy = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_non_greedy).unwrap();",
          "    assert_eq!(writer.output, \"??\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ast = ast::Repetition {",
          "        span: Span::default(),",
          "        op: ast::RepetitionOp {",
          "            kind: ast::RepetitionKind::ZeroOrMore,",
          "        },",
          "        greedy: true,",
          "        ast: Box::new(ast::Ast::default()),",
          "    };",
          "",
          "    let mut fmt_writer = Writer { wtr: writer };",
          "    fmt_writer.fmt_repetition(&ast).unwrap();",
          "    assert_eq!(writer.output, \"*\");",
          "    assert_eq!(ast.greedy, true);",
          "    assert_eq!(ast.op.kind, ast::RepetitionKind::ZeroOrMore);",
          "    assert!(fmt_writer.fmt_repetition(&ast).is_ok());",
          "    ",
          "    let ast_alternate = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_alternate).unwrap();",
          "    assert_eq!(writer.output, \"?\");",
          "    ",
          "    let ast_non_greedy = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_non_greedy).unwrap();",
          "    assert_eq!(writer.output, \"??\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ast = ast::Repetition {",
          "        span: Span::default(),",
          "        op: ast::RepetitionOp {",
          "            kind: ast::RepetitionKind::OneOrMore,",
          "        },",
          "        greedy: true,",
          "        ast: Box::new(ast::Ast::default()),",
          "    };",
          "",
          "    let mut fmt_writer = Writer { wtr: writer };",
          "    fmt_writer.fmt_repetition(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    let expected_output = \"+\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output);",
          "    ",
          "    let ast_greedy_zero_or_one = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_greedy_zero_or_one).unwrap();",
          "    let expected_output_greedy_zero_or_one = \"?\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_greedy_zero_or_one);",
          "    ",
          "    let ast_non_greedy_zero_or_one = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_non_greedy_zero_or_one).unwrap();",
          "    let expected_output_non_greedy_zero_or_one = \"??\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_non_greedy_zero_or_one);",
          "    ",
          "    let ast_greedy_zero_or_more = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrMore,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_greedy_zero_or_more).unwrap();",
          "    let expected_output_greedy_zero_or_more = \"*\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_greedy_zero_or_more);",
          "    ",
          "    let ast_non_greedy_zero_or_more = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrMore,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_non_greedy_zero_or_more).unwrap();",
          "    let expected_output_non_greedy_zero_or_more = \"*?\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_non_greedy_zero_or_more);",
          "    ",
          "    let ast_greedy_repetition_range = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(1, 3)),",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_greedy_repetition_range).unwrap();",
          "    let expected_output_greedy_range = \"{1,3}\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_greedy_range);",
          "    ",
          "    let ast_non_greedy_repetition_range = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(1, 3)),",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_non_greedy_repetition_range).unwrap();",
          "    let expected_output_non_greedy_range = \"{1,3}?\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_non_greedy_range);"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ast = ast::Repetition {",
          "        span: Span::default(),",
          "        op: ast::RepetitionOp {",
          "            kind: ast::RepetitionKind::OneOrMore,",
          "        },",
          "        greedy: true,",
          "        ast: Box::new(ast::Ast::default()),",
          "    };",
          "",
          "    let mut fmt_writer = Writer { wtr: writer };",
          "    fmt_writer.fmt_repetition(&ast).unwrap();",
          "    let expected_output = \"+\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output);",
          "    ",
          "    let ast_greedy_zero_or_one = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_greedy_zero_or_one).unwrap();",
          "    let expected_output_greedy_zero_or_one = \"?\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_greedy_zero_or_one);",
          "    ",
          "    let ast_non_greedy_zero_or_one = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrOne,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_non_greedy_zero_or_one).unwrap();",
          "    let expected_output_non_greedy_zero_or_one = \"??\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_non_greedy_zero_or_one);",
          "    ",
          "    let ast_greedy_zero_or_more = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrMore,",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_greedy_zero_or_more).unwrap();",
          "    let expected_output_greedy_zero_or_more = \"*\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_greedy_zero_or_more);",
          "    ",
          "    let ast_non_greedy_zero_or_more = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::ZeroOrMore,",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_non_greedy_zero_or_more).unwrap();",
          "    let expected_output_non_greedy_zero_or_more = \"*?\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_non_greedy_zero_or_more);",
          "    ",
          "    let ast_greedy_repetition_range = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(1, 3)),",
          "    },",
          "    greedy: true,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_greedy_repetition_range).unwrap();",
          "    let expected_output_greedy_range = \"{1,3}\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_greedy_range);",
          "    ",
          "    let ast_non_greedy_repetition_range = ast::Repetition {",
          "    span: Span::default(),",
          "    op: ast::RepetitionOp {",
          "    kind: ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(1, 3)),",
          "    },",
          "    greedy: false,",
          "    ast: Box::new(ast::Ast::default()),",
          "    };",
          "    fmt_writer.fmt_repetition(&ast_non_greedy_repetition_range).unwrap();",
          "    let expected_output_non_greedy_range = \"{1,3}?\";",
          "    assert_eq!(fmt_writer.wtr.output, expected_output_non_greedy_range);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ast = ast::Repetition {",
          "        span: Span::default(),",
          "        op: ast::RepetitionOp {",
          "            kind: ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(3)),",
          "        },",
          "        greedy: true,",
          "        ast: Box::new(ast::Ast::default()),",
          "    };",
          "",
          "    let mut fmt_writer = Writer { wtr: writer };",
          "    fmt_writer.fmt_repetition(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    fmt_writer.wtr.output == \"?\"",
          "    fmt_writer.wtr.output == \"??\"",
          "    fmt_writer.wtr.output == \"*\"",
          "    fmt_writer.wtr.output == \"*?\"",
          "    fmt_writer.wtr.output == \"+\"",
          "    fmt_writer.wtr.output == \"+?\"",
          "    fmt_writer.wtr.output == \"{{3}}?\""
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ast = ast::Repetition {",
          "        span: Span::default(),",
          "        op: ast::RepetitionOp {",
          "            kind: ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(3)),",
          "        },",
          "        greedy: true,",
          "        ast: Box::new(ast::Ast::default()),",
          "    };",
          "",
          "    let mut fmt_writer = Writer { wtr: writer };",
          "    fmt_writer.fmt_repetition(&ast).unwrap();",
          "    fmt_writer.wtr.output == \"?\"",
          "    fmt_writer.wtr.output == \"??\"",
          "    fmt_writer.wtr.output == \"*\"",
          "    fmt_writer.wtr.output == \"*?\"",
          "    fmt_writer.wtr.output == \"+\"",
          "    fmt_writer.wtr.output == \"+?\"",
          "    fmt_writer.wtr.output == \"{{3}}?\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]