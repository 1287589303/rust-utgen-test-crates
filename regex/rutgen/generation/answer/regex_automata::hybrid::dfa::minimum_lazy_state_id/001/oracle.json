[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Ok(LazyStateID::new(3).unwrap()));",
          "    assert_eq!(_result.is_ok(), true);",
          "    let classes = ByteClasses::singletons();",
          "    let _result_singleton = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result_singleton, Ok(LazyStateID::new(3).unwrap()));",
          "    let classes_empty = ByteClasses::empty();",
          "    let _result_empty = minimum_lazy_state_id(&classes_empty);",
          "    assert_eq!(_result_empty, Ok(LazyStateID::new(3).unwrap()));",
          "    let classes_high_stride = ByteClasses([1; 256]);",
          "    let _result_high_stride = minimum_lazy_state_id(&classes_high_stride);",
          "    assert_eq!(_result_high_stride, Ok(LazyStateID::new(3).unwrap()));"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(3).unwrap()));",
          "    assert_eq!(_result.is_ok(), true);",
          "    let classes = ByteClasses::singletons();",
          "    let _result_singleton = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result_singleton, Ok(LazyStateID::new(3).unwrap()));",
          "    let classes_empty = ByteClasses::empty();",
          "    let _result_empty = minimum_lazy_state_id(&classes_empty);",
          "    assert_eq!(_result_empty, Ok(LazyStateID::new(3).unwrap()));",
          "    let classes_high_stride = ByteClasses([1; 256]);",
          "    let _result_high_stride = minimum_lazy_state_id(&classes_high_stride);",
          "    assert_eq!(_result_high_stride, Ok(LazyStateID::new(3).unwrap()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    for i in 0..256 {",
          "        classes.set(i as u8, 1);",
          "    }",
          "    let _result = minimum_lazy_state_id(&classes);",
          "}"
        ],
        "oracle": [
          "    assert!(_result.is_ok());",
          "    assert_eq!(_result.unwrap().as_usize_untagged(), 14);",
          "    assert!(LazyStateID::is_tagged(&_result.unwrap()));"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    for i in 0..256 {",
          "        classes.set(i as u8, 1);",
          "    }",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    assert_eq!(_result.unwrap().as_usize_untagged(), 14);",
          "    assert!(LazyStateID::is_tagged(&_result.unwrap()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    classes.set(0, 1);",
          "    classes.set(255, 1);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Ok(LazyStateID::new_unchecked(2)));",
          "    assert!(matches!(_result, Ok(_)));",
          "    assert!(matches!(_result, Err(LazyStateIDError { .. })) == false);"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    classes.set(0, 1);",
          "    classes.set(255, 1);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new_unchecked(2)));",
          "    assert!(matches!(_result, Ok(_)));",
          "    assert!(matches!(_result, Err(LazyStateIDError { .. })) == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Ok(LazyStateID::new(1 << classes.stride2() * (MIN_STATES - 1)).unwrap()));",
          "    let classes = ByteClasses::singletons();",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(1 << classes.stride2() * (MIN_STATES - 1)).unwrap()));",
          "    let classes = ByteClasses::empty();",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(0).unwrap()));",
          "    let classes = ByteClasses([1; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result.is_err());",
          "    let classes = ByteClasses([2; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result.is_err());"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(1 << classes.stride2() * (MIN_STATES - 1)).unwrap()));",
          "    let classes = ByteClasses::singletons();",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(1 << classes.stride2() * (MIN_STATES - 1)).unwrap()));",
          "    let classes = ByteClasses::empty();",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(0).unwrap()));",
          "    let classes = ByteClasses([1; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result.is_err());",
          "    let classes = ByteClasses([2; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    if let Ok(lazy_state_id) = _result {",
          "        let id_value = lazy_state_id.as_usize_unchecked();",
          "        assert!(id_value < LazyStateID::MAX);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let mut classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([1; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([255; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([0; 256]);",
          "    classes.set(0, 1);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([128; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    if let Ok(lazy_state_id) = _result {",
          "        let id_value = lazy_state_id.as_usize_unchecked();",
          "        assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([1; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([255; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([0; 256]);",
          "    classes.set(0, 1);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "    let mut classes = ByteClasses([128; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(_result.is_ok());",
          "    if let Ok(lazy_state_id) = _result {",
          "    let id_value = lazy_state_id.as_usize_unchecked();",
          "    assert!(id_value < LazyStateID::MAX);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    classes.set(1, 1);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Ok(LazyStateID(3)));",
          "    assert!(matches!(_result, Ok(_)));",
          "    let mut classes = ByteClasses::empty();",
          "    classes.set(1, 1);",
          "    let stride = 1 << classes.stride2();",
          "    let min_state_index = MIN_STATES.checked_sub(1).unwrap();",
          "    let expected_id = LazyStateID::new(min_state_index * stride).unwrap();",
          "    assert_eq!(_result, Ok(expected_id));"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    classes.set(1, 1);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID(3)));",
          "    assert!(matches!(_result, Ok(_)));",
          "    let mut classes = ByteClasses::empty();",
          "    classes.set(1, 1);",
          "    let stride = 1 << classes.stride2();",
          "    let min_state_index = MIN_STATES.checked_sub(1).unwrap();",
          "    let expected_id = LazyStateID::new(min_state_index * stride).unwrap();",
          "    assert_eq!(_result, Ok(expected_id));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses([0; 256]);",
          "    // Setting condition that leads to LazyStateID above max",
          "    classes.set(255, 255); ",
          "    let _result = minimum_lazy_state_id(&classes);",
          "}"
        ],
        "oracle": [
          "    assert!(minimum_lazy_state_id(&ByteClasses([0; 256])).is_ok());",
          "    assert!(minimum_lazy_state_id(&ByteClasses([1; 256])).is_ok());",
          "    assert!(minimum_lazy_state_id(&ByteClasses([0; 256])).is_ok());",
          "    assert!(minimum_lazy_state_id(&ByteClasses([0; 255] + [1])).is_ok());",
          "    let err = minimum_lazy_state_id(&ByteClasses([0; 256])).err();",
          "    assert_eq!(err.is_some(), true);",
          "    let result = minimum_lazy_state_id(&ByteClasses([255; 256]));",
          "    assert!(result.is_err(), \"Expected error for classes with all bytes set\");",
          "    let classes = ByteClasses([0; 256]);",
          "    classes.set(255, 1);",
          "    assert!(minimum_lazy_state_id(&classes).is_err());",
          "    let classes = ByteClasses([1; 256]);",
          "    assert_eq!(minimum_lazy_state_id(&classes).is_ok(), true);",
          "    let classes = ByteClasses([0; 256]);",
          "    classes.set(0, 255);",
          "    assert_eq!(minimum_lazy_state_id(&classes).is_ok(), true);"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses([0; 256]);",
          "    // Setting condition that leads to LazyStateID above max",
          "    classes.set(255, 255); ",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert!(minimum_lazy_state_id(&ByteClasses([0; 256])).is_ok());",
          "    assert!(minimum_lazy_state_id(&ByteClasses([1; 256])).is_ok());",
          "    assert!(minimum_lazy_state_id(&ByteClasses([0; 256])).is_ok());",
          "    assert!(minimum_lazy_state_id(&ByteClasses([0; 255] + [1])).is_ok());",
          "    let err = minimum_lazy_state_id(&ByteClasses([0; 256])).err();",
          "    assert_eq!(err.is_some(), true);",
          "    let result = minimum_lazy_state_id(&ByteClasses([255; 256]));",
          "    assert!(result.is_err(), \"Expected error for classes with all bytes set\");",
          "    let classes = ByteClasses([0; 256]);",
          "    classes.set(255, 1);",
          "    assert!(minimum_lazy_state_id(&classes).is_err());",
          "    let classes = ByteClasses([1; 256]);",
          "    assert_eq!(minimum_lazy_state_id(&classes).is_ok(), true);",
          "    let classes = ByteClasses([0; 256]);",
          "    classes.set(0, 255);",
          "    assert_eq!(minimum_lazy_state_id(&classes).is_ok(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.is_ok(), true);",
          "    assert_eq!(_result.unwrap().as_usize_untagged(), 0);",
          "    assert_eq!(_result.unwrap().is_tagged(), false);",
          "    ",
          "    let classes_overflow = ByteClasses([1; 256]);",
          "    let _result_overflow = minimum_lazy_state_id(&classes_overflow);",
          "    assert_eq!(_result_overflow.is_err(), true);",
          "    ",
          "    let classes_singleton = ByteClasses::singletons();",
          "    let _result_singleton = minimum_lazy_state_id(&classes_singleton);",
          "    assert_eq!(_result_singleton.is_ok(), true);",
          "    assert_eq!(_result_singleton.unwrap().to_start().is_start(), true);",
          "    ",
          "    let classes_empty = ByteClasses::empty();",
          "    let _result_empty = minimum_lazy_state_id(&classes_empty);",
          "    assert_eq!(_result_empty.is_ok(), true);",
          "    assert_eq!(_result_empty.unwrap().is_unknown(), false);",
          "    ",
          "    let min_state_id_result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(min_state_id_result.unwrap().as_usize_unchecked() >= 0, true);",
          "    assert_eq!(min_state_id_result.unwrap().as_usize_unchecked() <= LazyStateID::MAX, true);"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result.is_ok(), true);",
          "    assert_eq!(_result.unwrap().as_usize_untagged(), 0);",
          "    assert_eq!(_result.unwrap().is_tagged(), false);",
          "    ",
          "    let classes_overflow = ByteClasses([1; 256]);",
          "    let _result_overflow = minimum_lazy_state_id(&classes_overflow);",
          "    assert_eq!(_result_overflow.is_err(), true);",
          "    ",
          "    let classes_singleton = ByteClasses::singletons();",
          "    let _result_singleton = minimum_lazy_state_id(&classes_singleton);",
          "    assert_eq!(_result_singleton.is_ok(), true);",
          "    assert_eq!(_result_singleton.unwrap().to_start().is_start(), true);",
          "    ",
          "    let classes_empty = ByteClasses::empty();",
          "    let _result_empty = minimum_lazy_state_id(&classes_empty);",
          "    assert_eq!(_result_empty.is_ok(), true);",
          "    assert_eq!(_result_empty.unwrap().is_unknown(), false);",
          "    ",
          "    let min_state_id_result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(min_state_id_result.unwrap().as_usize_unchecked() >= 0, true);",
          "    assert_eq!(min_state_id_result.unwrap().as_usize_unchecked() <= LazyStateID::MAX, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses::singletons();",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses::empty();",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses([1; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses([2; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses([255; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    let max_id = LazyStateID::MAX;",
          "    if let Err(LazyStateIDError { attempted }) = LazyStateID::new(max_id + 1) {",
          "    assert_eq!(attempted, (max_id + 1) as u64);",
          "    }"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses::singletons();",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses::empty();",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses([1; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses([2; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses([255; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    assert_eq!(_result, Ok(LazyStateID::new(MIN_STATES - 1).unwrap()));",
          "    let classes = ByteClasses([0; 256]);",
          "    let _result = minimum_lazy_state_id(&classes);",
          "    let max_id = LazyStateID::MAX;",
          "    if let Err(LazyStateIDError { attempted }) = LazyStateID::new(max_id + 1) {",
          "    assert_eq!(attempted, (max_id + 1) as u64);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]