[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"test input string\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input::new(haystack).span(span).anchored(Anchored::No);",
          "    ",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let prefilter = Prefilter {",
          "        pre: Arc::new(MyPrefilter {}),",
          "        is_fast: true,",
          "        max_needle_len: 10,",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), Some(prefilter), &[]).unwrap();",
          "    let strategy = ReverseSuffix { core, pre: prefilter };",
          "",
          "    let result = strategy.search(&mut cache, &input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    assert!(cache.capmatches.is_empty());",
          "    assert!(!strategy.is_accelerated());",
          "    assert_eq!(strategy.memory_usage(), 0);",
          "    assert_eq!(input.get_anchored().is_anchored(), false);",
          "    let fwdinput = input.clone().anchored(Anchored::Pattern(PatternID(0))).span(0..input.end());",
          "    let half_match = strategy.try_search_half_start(&mut cache, &input).unwrap();",
          "    assert!(half_match.is_none());",
          "    let forward_half_match = strategy.try_search_half_fwd(&mut cache, &fwdinput).unwrap();",
          "    assert!(forward_half_match.is_none());"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"test input string\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input::new(haystack).span(span).anchored(Anchored::No);",
          "    ",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let prefilter = Prefilter {",
          "        pre: Arc::new(MyPrefilter {}),",
          "        is_fast: true,",
          "        max_needle_len: 10,",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), Some(prefilter), &[]).unwrap();",
          "    let strategy = ReverseSuffix { core, pre: prefilter };",
          "",
          "    let result = strategy.search(&mut cache, &input);",
          "    assert_eq!(result, None);",
          "    assert!(cache.capmatches.is_empty());",
          "    assert!(!strategy.is_accelerated());",
          "    assert_eq!(strategy.memory_usage(), 0);",
          "    assert_eq!(input.get_anchored().is_anchored(), false);",
          "    let fwdinput = input.clone().anchored(Anchored::Pattern(PatternID(0))).span(0..input.end());",
          "    let half_match = strategy.try_search_half_start(&mut cache, &input).unwrap();",
          "    assert!(half_match.is_none());",
          "    let forward_half_match = strategy.try_search_half_fwd(&mut cache, &fwdinput).unwrap();",
          "    assert!(forward_half_match.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"another test string\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input::new(haystack).span(span).anchored(Anchored::No);",
          "    ",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let prefilter = Prefilter {",
          "        pre: Arc::new(MyPrefilter {}),",
          "        is_fast: true,",
          "        max_needle_len: 10,",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), Some(prefilter), &[]).unwrap();",
          "    let strategy = ReverseSuffix { core, pre: prefilter };",
          "",
          "    let result = strategy.search(&mut cache, &input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_none());",
          "    let empty_haystack: &[u8] = b\"\";",
          "    let empty_input = Input::new(empty_haystack).span(Span::new(0, 0)).anchored(Anchored::No);",
          "    assert_eq!(strategy.search(&mut cache, &empty_input), None);",
          "    let input_with_suffix = Input::new(haystack).span(Span::new(0, 5)).anchored(Anchored::No);",
          "    assert!(strategy.try_search_half_start(&mut cache, &input_with_suffix).unwrap().is_some());",
          "    let input_with_no_match = Input::new(haystack).span(Span::new(10, 15)).anchored(Anchored::No);",
          "    assert!(strategy.try_search_half_start(&mut cache, &input_with_no_match).is_err());",
          "    let fwdinput = input_with_suffix.clone().anchored(Anchored::Pattern(PatternID(0))).span(0..input_with_suffix.end());",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &fwdinput).is_ok());",
          "    let fwdinput_no_match = Input::new(haystack).span(Span::new(0, 2)).anchored(Anchored::Pattern(PatternID(1)));",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &fwdinput_no_match).is_ok());"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"another test string\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input::new(haystack).span(span).anchored(Anchored::No);",
          "    ",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let prefilter = Prefilter {",
          "        pre: Arc::new(MyPrefilter {}),",
          "        is_fast: true,",
          "        max_needle_len: 10,",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), Some(prefilter), &[]).unwrap();",
          "    let strategy = ReverseSuffix { core, pre: prefilter };",
          "",
          "    let result = strategy.search(&mut cache, &input);",
          "    assert!(result.is_none());",
          "    let empty_haystack: &[u8] = b\"\";",
          "    let empty_input = Input::new(empty_haystack).span(Span::new(0, 0)).anchored(Anchored::No);",
          "    assert_eq!(strategy.search(&mut cache, &empty_input), None);",
          "    let input_with_suffix = Input::new(haystack).span(Span::new(0, 5)).anchored(Anchored::No);",
          "    assert!(strategy.try_search_half_start(&mut cache, &input_with_suffix).unwrap().is_some());",
          "    let input_with_no_match = Input::new(haystack).span(Span::new(10, 15)).anchored(Anchored::No);",
          "    assert!(strategy.try_search_half_start(&mut cache, &input_with_no_match).is_err());",
          "    let fwdinput = input_with_suffix.clone().anchored(Anchored::Pattern(PatternID(0))).span(0..input_with_suffix.end());",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &fwdinput).is_ok());",
          "    let fwdinput_no_match = Input::new(haystack).span(Span::new(0, 2)).anchored(Anchored::Pattern(PatternID(1)));",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &fwdinput_no_match).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"failing input case\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input::new(haystack).span(span).anchored(Anchored::No);",
          "    ",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let prefilter = Prefilter {",
          "        pre: Arc::new(MyPrefilter {}),",
          "        is_fast: true,",
          "        max_needle_len: 10,",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), Some(prefilter), &[]).unwrap();",
          "    let strategy = ReverseSuffix { core, pre: prefilter };",
          "",
          "    let result = strategy.search(&mut cache, &input);",
          "}"
        ],
        "oracle": [
          "    assert!(!input.get_anchored().is_anchored());",
          "    assert!(strategy.try_search_half_start(&mut cache, &input).is_ok());",
          "    assert!(strategy.try_search_half_start(&mut cache, &input).unwrap().is_none() || strategy.try_search_half_start(&mut cache, &input).unwrap().is_some());",
          "    assert!(matches!(strategy.try_search_half_start(&mut cache, &input), Err(RetryError::Fail(_)) | Err(RetryError::Quadratic(_))));",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &input).is_ok());",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &input).unwrap().is_none() || strategy.try_search_half_fwd(&mut cache, &input).unwrap().is_some());",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &input).is_ok() && strategy.try_search_half_fwd(&mut cache, &input).unwrap().is_none());"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"failing input case\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input::new(haystack).span(span).anchored(Anchored::No);",
          "    ",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let prefilter = Prefilter {",
          "        pre: Arc::new(MyPrefilter {}),",
          "        is_fast: true,",
          "        max_needle_len: 10,",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), Some(prefilter), &[]).unwrap();",
          "    let strategy = ReverseSuffix { core, pre: prefilter };",
          "",
          "    let result = strategy.search(&mut cache, &input);",
          "    assert!(!input.get_anchored().is_anchored());",
          "    assert!(strategy.try_search_half_start(&mut cache, &input).is_ok());",
          "    assert!(strategy.try_search_half_start(&mut cache, &input).unwrap().is_none() || strategy.try_search_half_start(&mut cache, &input).unwrap().is_some());",
          "    assert!(matches!(strategy.try_search_half_start(&mut cache, &input), Err(RetryError::Fail(_)) | Err(RetryError::Quadratic(_))));",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &input).is_ok());",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &input).unwrap().is_none() || strategy.try_search_half_fwd(&mut cache, &input).unwrap().is_some());",
          "    assert!(strategy.try_search_half_fwd(&mut cache, &input).is_ok() && strategy.try_search_half_fwd(&mut cache, &input).unwrap().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"searchable input\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input::new(haystack).span(span).anchored(Anchored::No);",
          "    ",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let prefilter = Prefilter {",
          "        pre: Arc::new(MyPrefilter {}),",
          "        is_fast: true,",
          "        max_needle_len: 10,",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), Some(prefilter), &[]).unwrap();",
          "    let strategy = ReverseSuffix { core, pre: prefilter };",
          "    ",
          "    let hm_start = HalfMatch::new(PatternID(0), 15);",
          "    let fwdinput = input.clone().anchored(Anchored::Pattern(hm_start.pattern())).span(hm_start.offset()..input.end());",
          "",
          "    let result = strategy.search(&mut cache, &fwdinput);",
          "}"
        ],
        "oracle": [
          "    let input = Input::new(b\"searchable input\").span(Span::new(0, 17)).anchored(Anchored::No);",
          "    let result = strategy.search(&mut cache, &input);",
          "    assert_eq!(result, None);",
          "    ",
          "    let err = RetryError::Fail(RetryFailError { offset: 5 });",
          "    let result = strategy.try_search_half_start(&mut cache, &input);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err(), Some(err));",
          "    ",
          "    let result = strategy.try_search_half_start(&mut cache, &input);",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap().is_none());",
          "    ",
          "    let fwdinput = input.anchored(Anchored::Pattern(hm_start.pattern())).span(hm_start.offset()..input.end());",
          "    let // setup cache for forward search",
          "    let result = strategy.try_search_half_fwd(&mut cache, &fwdinput);",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap().is_none());"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"searchable input\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input::new(haystack).span(span).anchored(Anchored::No);",
          "    ",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let prefilter = Prefilter {",
          "        pre: Arc::new(MyPrefilter {}),",
          "        is_fast: true,",
          "        max_needle_len: 10,",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), Some(prefilter), &[]).unwrap();",
          "    let strategy = ReverseSuffix { core, pre: prefilter };",
          "    ",
          "    let hm_start = HalfMatch::new(PatternID(0), 15);",
          "    let fwdinput = input.clone().anchored(Anchored::Pattern(hm_start.pattern())).span(hm_start.offset()..input.end());",
          "",
          "    let result = strategy.search(&mut cache, &fwdinput);",
          "    let input = Input::new(b\"searchable input\").span(Span::new(0, 17)).anchored(Anchored::No);",
          "    let result = strategy.search(&mut cache, &input);",
          "    assert_eq!(result, None);",
          "    ",
          "    let err = RetryError::Fail(RetryFailError { offset: 5 });",
          "    let result = strategy.try_search_half_start(&mut cache, &input);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err(), Some(err));",
          "    ",
          "    let result = strategy.try_search_half_start(&mut cache, &input);",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap().is_none());",
          "    ",
          "    let fwdinput = input.anchored(Anchored::Pattern(hm_start.pattern())).span(hm_start.offset()..input.end());",
          "    let // setup cache for forward search",
          "    let result = strategy.try_search_half_fwd(&mut cache, &fwdinput);",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]