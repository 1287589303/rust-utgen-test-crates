[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let literal = Literal { span: span.clone(), kind: LiteralKind::Character, c: 'a' };",
          "    let item_literal = ClassSetItem::Literal(literal);",
          "    let item_range = ClassSetItem::Range(ClassSetRange { span: span.clone(), start: literal.clone(), end: literal.clone() });",
          "    ",
          "    let union = ClassSetUnion { span: span.clone(), items: vec![item_literal, item_range] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    ",
          "    let _ = class_set_union.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let item_union = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![] });",
          "    assert_eq!(item_union.span(), &span);",
          "    let item_union_with_literal = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Literal(Literal { span: span.clone(), kind: LiteralKind::Character, c: 'b' })] });",
          "    assert_eq!(item_union_with_literal.span(), &span);",
          "    let item_union_with_range = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Range(ClassSetRange { span: span.clone(), start: Literal { span: span.clone(), kind: LiteralKind::Character, c: 'c' }, end: Literal { span: span.clone(), kind: LiteralKind::Character, c: 'd' } })] });",
          "    assert_eq!(item_union_with_range.span(), &span);",
          "    let item_union_with_ascii = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Ascii(ClassAscii { span: span.clone(), kind: ClassAsciiKind::Alnum, negated: false })] });",
          "    assert_eq!(item_union_with_ascii.span(), &span);",
          "    let item_union_with_unicode = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Unicode(ClassUnicode { span: span.clone(), kind: ClassUnicodeKind::L, negated: false })] });",
          "    assert_eq!(item_union_with_unicode.span(), &span);",
          "    let item_union_with_perl = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Perl(ClassPerl { span: span.clone(), kind: ClassPerlKind::D, negated: false })] });",
          "    assert_eq!(item_union_with_perl.span(), &span);",
          "    let item_union_with_bracketed = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(literal.clone())) }))] });",
          "    assert_eq!(item_union_with_bracketed.span(), &span);"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let literal = Literal { span: span.clone(), kind: LiteralKind::Character, c: 'a' };",
          "    let item_literal = ClassSetItem::Literal(literal);",
          "    let item_range = ClassSetItem::Range(ClassSetRange { span: span.clone(), start: literal.clone(), end: literal.clone() });",
          "    ",
          "    let union = ClassSetUnion { span: span.clone(), items: vec![item_literal, item_range] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    ",
          "    let _ = class_set_union.span();",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let item_union = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![] });",
          "    assert_eq!(item_union.span(), &span);",
          "    let item_union_with_literal = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Literal(Literal { span: span.clone(), kind: LiteralKind::Character, c: 'b' })] });",
          "    assert_eq!(item_union_with_literal.span(), &span);",
          "    let item_union_with_range = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Range(ClassSetRange { span: span.clone(), start: Literal { span: span.clone(), kind: LiteralKind::Character, c: 'c' }, end: Literal { span: span.clone(), kind: LiteralKind::Character, c: 'd' } })] });",
          "    assert_eq!(item_union_with_range.span(), &span);",
          "    let item_union_with_ascii = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Ascii(ClassAscii { span: span.clone(), kind: ClassAsciiKind::Alnum, negated: false })] });",
          "    assert_eq!(item_union_with_ascii.span(), &span);",
          "    let item_union_with_unicode = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Unicode(ClassUnicode { span: span.clone(), kind: ClassUnicodeKind::L, negated: false })] });",
          "    assert_eq!(item_union_with_unicode.span(), &span);",
          "    let item_union_with_perl = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Perl(ClassPerl { span: span.clone(), kind: ClassPerlKind::D, negated: false })] });",
          "    assert_eq!(item_union_with_perl.span(), &span);",
          "    let item_union_with_bracketed = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(literal.clone())) }))] });",
          "    assert_eq!(item_union_with_bracketed.span(), &span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(20) };",
          "    let literal = Literal { span: span.clone(), kind: LiteralKind::Character, c: 'b' };",
          "    let ascii = ClassAscii { span: span.clone(), kind: ClassAsciiKind::Alnum, negated: false };",
          "    let unicode = ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::L };",
          "    let perl = ClassPerl { span: span.clone(), kind: ClassPerlKind::D, negated: false };",
          "    ",
          "    let item_literal = ClassSetItem::Literal(literal);",
          "    let item_ascii = ClassSetItem::Ascii(ascii);",
          "    let item_unicode = ClassSetItem::Unicode(unicode);",
          "    let item_perl = ClassSetItem::Perl(perl);",
          "    ",
          "    let union = ClassSetUnion { span, items: vec![item_literal, item_ascii, item_unicode, item_perl] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    ",
          "    let _ = class_set_union.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(0), end: Position(20) };",
          "    let union = ClassSetUnion { span: span.clone(), items: vec![] };",
          "    let class_set_union_empty = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_empty.span(), &span);",
          "    let literal = Literal { span: span.clone(), kind: LiteralKind::Character, c: 'a' };",
          "    let item_literal = ClassSetItem::Literal(literal);",
          "    let union = ClassSetUnion { span, items: vec![item_literal] };",
          "    let class_set_union_single = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_single.span(), &class_set_union_single.span());",
          "    let span = Span { start: Position(10), end: Position(30) };",
          "    let ascii = ClassAscii { span: span.clone(), kind: ClassAsciiKind::Alnum, negated: false };",
          "    let item_ascii = ClassSetItem::Ascii(ascii);",
          "    let union = ClassSetUnion { span, items: vec![item_ascii] };",
          "    let class_set_union_ascii = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_ascii.span(), &class_set_union_ascii.span());",
          "    let perl = ClassPerl { span: span.clone(), kind: ClassPerlKind::D, negated: false };",
          "    let item_perl = ClassSetItem::Perl(perl);",
          "    let union = ClassSetUnion { span, items: vec![item_perl] };",
          "    let class_set_union_perl = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_perl.span(), &class_set_union_perl.span());",
          "    let unicode = ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::L };",
          "    let item_unicode = ClassSetItem::Unicode(unicode);",
          "    let union = ClassSetUnion { span, items: vec![item_unicode] };",
          "    let class_set_union_unicode = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_unicode.span(), &class_set_union_unicode.span());",
          "    let bracketed = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Item(item_literal) };",
          "    let item_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));",
          "    let union = ClassSetUnion { span, items: vec![item_bracketed] };",
          "    let class_set_union_bracketed = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_bracketed.span(), &class_set_union_bracketed.span());"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(20) };",
          "    let literal = Literal { span: span.clone(), kind: LiteralKind::Character, c: 'b' };",
          "    let ascii = ClassAscii { span: span.clone(), kind: ClassAsciiKind::Alnum, negated: false };",
          "    let unicode = ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::L };",
          "    let perl = ClassPerl { span: span.clone(), kind: ClassPerlKind::D, negated: false };",
          "    ",
          "    let item_literal = ClassSetItem::Literal(literal);",
          "    let item_ascii = ClassSetItem::Ascii(ascii);",
          "    let item_unicode = ClassSetItem::Unicode(unicode);",
          "    let item_perl = ClassSetItem::Perl(perl);",
          "    ",
          "    let union = ClassSetUnion { span, items: vec![item_literal, item_ascii, item_unicode, item_perl] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    ",
          "    let _ = class_set_union.span();",
          "    let span = Span { start: Position(0), end: Position(20) };",
          "    let union = ClassSetUnion { span: span.clone(), items: vec![] };",
          "    let class_set_union_empty = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_empty.span(), &span);",
          "    let literal = Literal { span: span.clone(), kind: LiteralKind::Character, c: 'a' };",
          "    let item_literal = ClassSetItem::Literal(literal);",
          "    let union = ClassSetUnion { span, items: vec![item_literal] };",
          "    let class_set_union_single = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_single.span(), &class_set_union_single.span());",
          "    let span = Span { start: Position(10), end: Position(30) };",
          "    let ascii = ClassAscii { span: span.clone(), kind: ClassAsciiKind::Alnum, negated: false };",
          "    let item_ascii = ClassSetItem::Ascii(ascii);",
          "    let union = ClassSetUnion { span, items: vec![item_ascii] };",
          "    let class_set_union_ascii = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_ascii.span(), &class_set_union_ascii.span());",
          "    let perl = ClassPerl { span: span.clone(), kind: ClassPerlKind::D, negated: false };",
          "    let item_perl = ClassSetItem::Perl(perl);",
          "    let union = ClassSetUnion { span, items: vec![item_perl] };",
          "    let class_set_union_perl = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_perl.span(), &class_set_union_perl.span());",
          "    let unicode = ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::L };",
          "    let item_unicode = ClassSetItem::Unicode(unicode);",
          "    let union = ClassSetUnion { span, items: vec![item_unicode] };",
          "    let class_set_union_unicode = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_unicode.span(), &class_set_union_unicode.span());",
          "    let bracketed = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Item(item_literal) };",
          "    let item_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));",
          "    let union = ClassSetUnion { span, items: vec![item_bracketed] };",
          "    let class_set_union_bracketed = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union_bracketed.span(), &class_set_union_bracketed.span());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(5) };",
          "    let empty_item = ClassSetItem::Empty(span.clone());",
          "    ",
          "    let union = ClassSetUnion { span: span.clone(), items: vec![empty_item] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    ",
          "    let _ = class_set_union.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(0), end: Position(5) };",
          "    let empty_item = ClassSetItem::Empty(span.clone());",
          "    let union = ClassSetUnion { span: span.clone(), items: vec![empty_item] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union.span(), &span);"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(5) };",
          "    let empty_item = ClassSetItem::Empty(span.clone());",
          "    ",
          "    let union = ClassSetUnion { span: span.clone(), items: vec![empty_item] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    ",
          "    let _ = class_set_union.span();",
          "    let span = Span { start: Position(0), end: Position(5) };",
          "    let empty_item = ClassSetItem::Empty(span.clone());",
          "    let union = ClassSetUnion { span: span.clone(), items: vec![empty_item] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    assert_eq!(class_set_union.span(), &span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(15) };",
          "    let bracketed = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal { span: span.clone(), kind: LiteralKind::Character, c: 'c' })) };",
          "    ",
          "    let item_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));",
          "    ",
          "    let union = ClassSetUnion { span, items: vec![item_bracketed] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    ",
          "    let _ = class_set_union.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(0), end: Position(15) };",
          "    let item_empty = ClassSetItem::Empty(span.clone());",
          "    let item_literal = ClassSetItem::Literal(Literal { span: span.clone(), kind: LiteralKind::Character, c: 'c' });",
          "    let item_range = ClassSetItem::Range(ClassSetRange { span: span.clone(), start: item_literal.clone(), end: item_literal.clone() });",
          "    let item_ascii = ClassSetItem::Ascii(ClassAscii { span: span.clone(), kind: ClassAsciiKind::Alnum, negated: false });",
          "    let item_perl = ClassSetItem::Perl(ClassPerl { span: span.clone(), kind: ClassPerlKind::Digit, negated: false });",
          "    let item_unicode = ClassSetItem::Unicode(ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::Letter });",
          "    let item_bracketed = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Item(item_literal) }));",
          "    let item_union = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![item_bracketed] });",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(ClassSetUnion { span, items: vec![item_empty, item_literal, item_range, item_ascii, item_perl, item_unicode, item_bracketed] }));",
          "    let result_span = class_set_union.span();",
          "    assert_eq!(result_span, &span);"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(15) };",
          "    let bracketed = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal { span: span.clone(), kind: LiteralKind::Character, c: 'c' })) };",
          "    ",
          "    let item_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));",
          "    ",
          "    let union = ClassSetUnion { span, items: vec![item_bracketed] };",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(union));",
          "    ",
          "    let _ = class_set_union.span();",
          "    let span = Span { start: Position(0), end: Position(15) };",
          "    let item_empty = ClassSetItem::Empty(span.clone());",
          "    let item_literal = ClassSetItem::Literal(Literal { span: span.clone(), kind: LiteralKind::Character, c: 'c' });",
          "    let item_range = ClassSetItem::Range(ClassSetRange { span: span.clone(), start: item_literal.clone(), end: item_literal.clone() });",
          "    let item_ascii = ClassSetItem::Ascii(ClassAscii { span: span.clone(), kind: ClassAsciiKind::Alnum, negated: false });",
          "    let item_perl = ClassSetItem::Perl(ClassPerl { span: span.clone(), kind: ClassPerlKind::Digit, negated: false });",
          "    let item_unicode = ClassSetItem::Unicode(ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::Letter });",
          "    let item_bracketed = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Item(item_literal) }));",
          "    let item_union = ClassSetItem::Union(ClassSetUnion { span: span.clone(), items: vec![item_bracketed] });",
          "    let class_set_union = ClassSet::Item(ClassSetItem::Union(ClassSetUnion { span, items: vec![item_empty, item_literal, item_range, item_ascii, item_perl, item_unicode, item_bracketed] }));",
          "    let result_span = class_set_union.span();",
          "    assert_eq!(result_span, &span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]