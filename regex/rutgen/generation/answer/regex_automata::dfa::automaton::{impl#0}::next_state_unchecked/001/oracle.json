[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton;",
          "    ",
          "    unsafe impl Automaton for TestAutomaton {",
          "        fn next_state(&self, _: StateID, _: u8) -> StateID { StateID(SmallIndex::new(0)) }",
          "    }",
          "    ",
          "    let automaton = TestAutomaton;",
          "    let current = StateID(SmallIndex::new(0)); // valid StateID",
          "    let input = 0; // minimum byte value",
          "    unsafe {",
          "        let _ = automaton.next_state_unchecked(current, input);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(automaton.next_state_unchecked(current, input), StateID(SmallIndex::new(0)));",
          "    assert!(matches!(automaton.next_state_unchecked(StateID(SmallIndex::new(1)), 1), StateID(SmallIndex::new(0)));",
          "    assert!(matches!(automaton.next_state_unchecked(StateID(SmallIndex::new(2)), 255), StateID(SmallIndex::new(0)));",
          "    assert_eq!(automaton.next_state_unchecked(current, 0), StateID(SmallIndex::new(0)));",
          "    assert_eq!(automaton.next_state_unchecked(current, 127), StateID(SmallIndex::new(0)));",
          "    assert_eq!(automaton.next_state_unchecked(current, 255), StateID(SmallIndex::new(0)));",
          "    assert!(std::panic::catch_unwind(|| { unsafe { automaton.next_state_unchecked(current, input); }}).is_ok());",
          "    assert!(std::panic::catch_unwind(|| { unsafe { automaton.next_state_unchecked(current, 256); }}).is_err());"
        ],
        "code": [
          "{",
          "    struct TestAutomaton;",
          "    ",
          "    unsafe impl Automaton for TestAutomaton {",
          "        fn next_state(&self, _: StateID, _: u8) -> StateID { StateID(SmallIndex::new(0)) }",
          "    }",
          "    ",
          "    let automaton = TestAutomaton;",
          "    let current = StateID(SmallIndex::new(0)); // valid StateID",
          "    let input = 0; // minimum byte value",
          "    unsafe {",
          "        let _ = automaton.next_state_unchecked(current, input);",
          "    }",
          "    assert!(matches!(automaton.next_state_unchecked(current, input), StateID(SmallIndex::new(0)));",
          "    assert!(matches!(automaton.next_state_unchecked(StateID(SmallIndex::new(1)), 1), StateID(SmallIndex::new(0)));",
          "    assert!(matches!(automaton.next_state_unchecked(StateID(SmallIndex::new(2)), 255), StateID(SmallIndex::new(0)));",
          "    assert_eq!(automaton.next_state_unchecked(current, 0), StateID(SmallIndex::new(0)));",
          "    assert_eq!(automaton.next_state_unchecked(current, 127), StateID(SmallIndex::new(0)));",
          "    assert_eq!(automaton.next_state_unchecked(current, 255), StateID(SmallIndex::new(0)));",
          "    assert!(std::panic::catch_unwind(|| { unsafe { automaton.next_state_unchecked(current, input); }}).is_ok());",
          "    assert!(std::panic::catch_unwind(|| { unsafe { automaton.next_state_unchecked(current, 256); }}).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton;",
          "    ",
          "    unsafe impl Automaton for TestAutomaton {",
          "        fn next_state(&self, _: StateID, _: u8) -> StateID { StateID(SmallIndex::new(1)) }",
          "    }",
          "    ",
          "    let automaton = TestAutomaton;",
          "    let current = StateID(SmallIndex::new(1)); // valid StateID",
          "    let input = 255; // maximum byte value",
          "    unsafe {",
          "        let _ = automaton.next_state_unchecked(current, input);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(automaton.next_state_unchecked(current, input) == StateID(SmallIndex::new(1)));",
          "    assert!(automaton.next_state_unchecked(StateID(SmallIndex::new(0)), 0) == StateID(SmallIndex::new(1)));",
          "    assert!(automaton.next_state_unchecked(StateID(SmallIndex::new(1)), 1) == StateID(SmallIndex::new(1)));",
          "    assert!(automaton.next_state_unchecked(StateID(SmallIndex::new(2)), 255) == StateID(SmallIndex::new(1)));",
          "    assert!(automaton.next_state_unchecked(StateID(SmallIndex::new(3)), 128) == StateID(SmallIndex::new(1)));"
        ],
        "code": [
          "{",
          "    struct TestAutomaton;",
          "    ",
          "    unsafe impl Automaton for TestAutomaton {",
          "        fn next_state(&self, _: StateID, _: u8) -> StateID { StateID(SmallIndex::new(1)) }",
          "    }",
          "    ",
          "    let automaton = TestAutomaton;",
          "    let current = StateID(SmallIndex::new(1)); // valid StateID",
          "    let input = 255; // maximum byte value",
          "    unsafe {",
          "        let _ = automaton.next_state_unchecked(current, input);",
          "    }",
          "    assert!(automaton.next_state_unchecked(current, input) == StateID(SmallIndex::new(1)));",
          "    assert!(automaton.next_state_unchecked(StateID(SmallIndex::new(0)), 0) == StateID(SmallIndex::new(1)));",
          "    assert!(automaton.next_state_unchecked(StateID(SmallIndex::new(1)), 1) == StateID(SmallIndex::new(1)));",
          "    assert!(automaton.next_state_unchecked(StateID(SmallIndex::new(2)), 255) == StateID(SmallIndex::new(1)));",
          "    assert!(automaton.next_state_unchecked(StateID(SmallIndex::new(3)), 128) == StateID(SmallIndex::new(1)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton;",
          "    ",
          "    unsafe impl Automaton for TestAutomaton {",
          "        fn next_state(&self, _: StateID, _: u8) -> StateID { StateID(SmallIndex::new(2)) }",
          "    }",
          "    ",
          "    let automaton = TestAutomaton;",
          "    let current = StateID(SmallIndex::new(2)); // valid StateID",
          "    let input = 128; // middle byte value",
          "    unsafe {",
          "        let _ = automaton.next_state_unchecked(current, input);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let automaton = TestAutomaton;",
          "    let current = StateID(SmallIndex::new(2));",
          "    let input = 128;",
          "    let result = unsafe { automaton.next_state_unchecked(current, input) };",
          "    assert_eq!(result, StateID(SmallIndex::new(2)));",
          "    let invalid_input = 256;",
          "    let panic_result = std::panic::catch_unwind(|| { unsafe { automaton.next_state_unchecked(current, invalid_input) } });",
          "    assert!(panic_result.is_err());"
        ],
        "code": [
          "{",
          "    struct TestAutomaton;",
          "    ",
          "    unsafe impl Automaton for TestAutomaton {",
          "        fn next_state(&self, _: StateID, _: u8) -> StateID { StateID(SmallIndex::new(2)) }",
          "    }",
          "    ",
          "    let automaton = TestAutomaton;",
          "    let current = StateID(SmallIndex::new(2)); // valid StateID",
          "    let input = 128; // middle byte value",
          "    unsafe {",
          "        let _ = automaton.next_state_unchecked(current, input);",
          "    }",
          "    let automaton = TestAutomaton;",
          "    let current = StateID(SmallIndex::new(2));",
          "    let input = 128;",
          "    let result = unsafe { automaton.next_state_unchecked(current, input) };",
          "    assert_eq!(result, StateID(SmallIndex::new(2)));",
          "    let invalid_input = 256;",
          "    let panic_result = std::panic::catch_unwind(|| { unsafe { automaton.next_state_unchecked(current, invalid_input) } });",
          "    assert!(panic_result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]