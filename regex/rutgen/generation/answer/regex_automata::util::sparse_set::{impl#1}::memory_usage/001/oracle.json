[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse_set = SparseSet::new(0);",
          "    let usage = sparse_set.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(usage, 0);",
          "    let sparse_set = SparseSet::new(5);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.insert(StateID(1));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE);",
          "    sparse_set.insert(StateID(2));",
          "    assert_eq!(sparse_set.memory_usage(), 2 * StateID::SIZE);",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.resize(10);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.insert(StateID(3));",
          "    sparse_set.insert(StateID(4));",
          "    assert_eq!(sparse_set.memory_usage(), 2 * StateID::SIZE);"
        ],
        "code": [
          "{",
          "    let sparse_set = SparseSet::new(0);",
          "    let usage = sparse_set.memory_usage();",
          "    assert_eq!(usage, 0);",
          "    let sparse_set = SparseSet::new(5);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.insert(StateID(1));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE);",
          "    sparse_set.insert(StateID(2));",
          "    assert_eq!(sparse_set.memory_usage(), 2 * StateID::SIZE);",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.resize(10);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.insert(StateID(3));",
          "    sparse_set.insert(StateID(4));",
          "    assert_eq!(sparse_set.memory_usage(), 2 * StateID::SIZE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(1);",
          "    let state_id = StateID(0);",
          "    sparse_set.insert(state_id);",
          "    let usage = sparse_set.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let mut sparse_set = SparseSet::new(1);",
          "    let state_id = StateID(0);",
          "    sparse_set.insert(state_id);",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 1);",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 0);",
          "    sparse_set.resize(5);",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 0);",
          "    sparse_set.insert(StateID(1));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 1);",
          "    sparse_set.insert(StateID(2));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 2);",
          "    sparse_set.insert(StateID(3));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 3);",
          "    sparse_set.insert(StateID(4));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 4);"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(1);",
          "    let state_id = StateID(0);",
          "    sparse_set.insert(state_id);",
          "    let usage = sparse_set.memory_usage();",
          "    let mut sparse_set = SparseSet::new(1);",
          "    let state_id = StateID(0);",
          "    sparse_set.insert(state_id);",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 1);",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 0);",
          "    sparse_set.resize(5);",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 0);",
          "    sparse_set.insert(StateID(1));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 1);",
          "    sparse_set.insert(StateID(2));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 2);",
          "    sparse_set.insert(StateID(3));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 3);",
          "    sparse_set.insert(StateID(4));",
          "    assert_eq!(sparse_set.memory_usage(), StateID::SIZE * 4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    let state_ids = [StateID(0), StateID(1), StateID(2)];",
          "    for &id in &state_ids {",
          "        sparse_set.insert(id);",
          "    }",
          "    let usage = sparse_set.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.memory_usage(), (3 * StateID::SIZE) + (5 * StateID::SIZE));",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.resize(10);",
          "    assert_eq!(sparse_set.memory_usage(), (3 * StateID::SIZE) + (10 * StateID::SIZE));",
          "    sparse_set.insert(StateID(3));",
          "    assert_eq!(sparse_set.memory_usage(), (4 * StateID::SIZE) + (10 * StateID::SIZE));",
          "    sparse_set.resize(0);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    assert_eq!(sparse_set.memory_usage(), (0 * StateID::SIZE) + (0 * StateID::SIZE));",
          "    sparse_set.resize(3);",
          "    assert_eq!(sparse_set.memory_usage(), (0 * StateID::SIZE) + (3 * StateID::SIZE));"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    let state_ids = [StateID(0), StateID(1), StateID(2)];",
          "    for &id in &state_ids {",
          "        sparse_set.insert(id);",
          "    }",
          "    let usage = sparse_set.memory_usage();",
          "    assert_eq!(sparse_set.memory_usage(), (3 * StateID::SIZE) + (5 * StateID::SIZE));",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.resize(10);",
          "    assert_eq!(sparse_set.memory_usage(), (3 * StateID::SIZE) + (10 * StateID::SIZE));",
          "    sparse_set.insert(StateID(3));",
          "    assert_eq!(sparse_set.memory_usage(), (4 * StateID::SIZE) + (10 * StateID::SIZE));",
          "    sparse_set.resize(0);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    assert_eq!(sparse_set.memory_usage(), (0 * StateID::SIZE) + (0 * StateID::SIZE));",
          "    sparse_set.resize(3);",
          "    assert_eq!(sparse_set.memory_usage(), (0 * StateID::SIZE) + (3 * StateID::SIZE));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let max_capacity = std::u32::MAX as usize; // Assuming StateID can support up to u32::MAX",
          "    let mut sparse_set = SparseSet::new(max_capacity);",
          "    for i in 0..max_capacity {",
          "        sparse_set.insert(StateID(i as u32));",
          "    }",
          "    let usage = sparse_set.memory_usage();",
          "}"
        ],
        "oracle": [
          "    sparse_set.memory_usage() == (max_capacity * StateID::SIZE) * 2",
          "    sparse_set.memory_usage() == (sparse_set.dense.len() * StateID::SIZE) + (sparse_set.sparse.len() * StateID::SIZE)",
          "    sparse_set.memory_usage() >= 0",
          "    sparse_set.memory_usage() <= (max_capacity * StateID::SIZE) * 2",
          "    sparse_set.len() == max_capacity",
          "    sparse_set.is_empty() == false",
          "    sparse_set.capacity() == max_capacity",
          "    sparse_set.insert(StateID(0)) == true",
          "    sparse_set.contains(StateID(0)) == true",
          "    sparse_set.clear()",
          "    sparse_set.is_empty() == true"
        ],
        "code": [
          "{",
          "    let max_capacity = std::u32::MAX as usize; // Assuming StateID can support up to u32::MAX",
          "    let mut sparse_set = SparseSet::new(max_capacity);",
          "    for i in 0..max_capacity {",
          "        sparse_set.insert(StateID(i as u32));",
          "    }",
          "    let usage = sparse_set.memory_usage();",
          "    sparse_set.memory_usage() == (max_capacity * StateID::SIZE) * 2",
          "    sparse_set.memory_usage() == (sparse_set.dense.len() * StateID::SIZE) + (sparse_set.sparse.len() * StateID::SIZE)",
          "    sparse_set.memory_usage() >= 0",
          "    sparse_set.memory_usage() <= (max_capacity * StateID::SIZE) * 2",
          "    sparse_set.len() == max_capacity",
          "    sparse_set.is_empty() == false",
          "    sparse_set.capacity() == max_capacity",
          "    sparse_set.insert(StateID(0)) == true",
          "    sparse_set.contains(StateID(0)) == true",
          "    sparse_set.clear()",
          "    sparse_set.is_empty() == true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(3);",
          "    let state_ids = [StateID(0), StateID(1), StateID(2)];",
          "    for &id in &state_ids {",
          "        sparse_set.insert(id);",
          "    }",
          "    sparse_set.resize(5);",
          "    let usage = sparse_set.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.memory_usage(), 5 * StateID::SIZE);"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(3);",
          "    let state_ids = [StateID(0), StateID(1), StateID(2)];",
          "    for &id in &state_ids {",
          "        sparse_set.insert(id);",
          "    }",
          "    sparse_set.resize(5);",
          "    let usage = sparse_set.memory_usage();",
          "    assert_eq!(sparse_set.memory_usage(), 5 * StateID::SIZE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(3);",
          "    let state_ids = [StateID(0), StateID(1), StateID(2)];",
          "    for &id in &state_ids {",
          "        sparse_set.insert(id);",
          "    }",
          "    sparse_set.clear();",
          "    let usage = sparse_set.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.resize(5);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    for &id in &state_ids {",
          "    sparse_set.insert(id);",
          "    }",
          "    assert_eq!(sparse_set.memory_usage(), 3 * StateID::SIZE);",
          "    sparse_set.insert(StateID(3));",
          "    assert_eq!(sparse_set.memory_usage(), 4 * StateID::SIZE);",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.resize(10);",
          "    assert_eq!(sparse_set.memory_usage(), 0);"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(3);",
          "    let state_ids = [StateID(0), StateID(1), StateID(2)];",
          "    for &id in &state_ids {",
          "        sparse_set.insert(id);",
          "    }",
          "    sparse_set.clear();",
          "    let usage = sparse_set.memory_usage();",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.resize(5);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    for &id in &state_ids {",
          "    sparse_set.insert(id);",
          "    }",
          "    assert_eq!(sparse_set.memory_usage(), 3 * StateID::SIZE);",
          "    sparse_set.insert(StateID(3));",
          "    assert_eq!(sparse_set.memory_usage(), 4 * StateID::SIZE);",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "    sparse_set.resize(10);",
          "    assert_eq!(sparse_set.memory_usage(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]