[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestPikeVM;",
          "    let pikevm = TestPikeVM;",
          "",
          "    let haystack: &[u8] = b\"test string\";",
          "    let cache = CachePoolGuard::default(); ",
          "    let at = 0;",
          "    let slots = vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap()))];",
          "    let last_match_end = Some(10);",
          "    ",
          "    let find_matches = FindMatches {",
          "        pikevm: &pikevm,",
          "        cache,",
          "        haystack,",
          "        at,",
          "        slots,",
          "        last_match_end,",
          "    };",
          "    ",
          "    let mut captures_matches = CapturesMatches { it: find_matches };",
          "    ",
          "    let result = captures_matches.next();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap()))]);"
        ],
        "code": [
          "{",
          "    struct TestPikeVM;",
          "    let pikevm = TestPikeVM;",
          "",
          "    let haystack: &[u8] = b\"test string\";",
          "    let cache = CachePoolGuard::default(); ",
          "    let at = 0;",
          "    let slots = vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap()))];",
          "    let last_match_end = Some(10);",
          "    ",
          "    let find_matches = FindMatches {",
          "        pikevm: &pikevm,",
          "        cache,",
          "        haystack,",
          "        at,",
          "        slots,",
          "        last_match_end,",
          "    };",
          "    ",
          "    let mut captures_matches = CapturesMatches { it: find_matches };",
          "    ",
          "    let result = captures_matches.next();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap()))]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestPikeVM;",
          "    let pikevm = TestPikeVM;",
          "",
          "    let haystack: &[u8] = b\"another test string\";",
          "    let cache = CachePoolGuard::default();",
          "    let at = 5;",
          "    let slots = vec![Some(NonMaxUsize(NonZeroUsize::new(2).unwrap())), None, Some(NonMaxUsize(NonZeroUsize::new(3).unwrap()))];",
          "    let last_match_end = Some(15);",
          "",
          "    let find_matches = FindMatches {",
          "        pikevm: &pikevm,",
          "        cache,",
          "        haystack,",
          "        at,",
          "        slots,",
          "        last_match_end,",
          "    };",
          "",
          "    let mut captures_matches = CapturesMatches { it: find_matches };",
          "    ",
          "    let result = captures_matches.next();",
          "}"
        ],
        "oracle": [
          "    result.is_some();",
          "    result.unwrap() == Some(captures_matches.it.slots.clone());"
        ],
        "code": [
          "{",
          "    struct TestPikeVM;",
          "    let pikevm = TestPikeVM;",
          "",
          "    let haystack: &[u8] = b\"another test string\";",
          "    let cache = CachePoolGuard::default();",
          "    let at = 5;",
          "    let slots = vec![Some(NonMaxUsize(NonZeroUsize::new(2).unwrap())), None, Some(NonMaxUsize(NonZeroUsize::new(3).unwrap()))];",
          "    let last_match_end = Some(15);",
          "",
          "    let find_matches = FindMatches {",
          "        pikevm: &pikevm,",
          "        cache,",
          "        haystack,",
          "        at,",
          "        slots,",
          "        last_match_end,",
          "    };",
          "",
          "    let mut captures_matches = CapturesMatches { it: find_matches };",
          "    ",
          "    let result = captures_matches.next();",
          "    result.is_some();",
          "    result.unwrap() == Some(captures_matches.it.slots.clone());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestPikeVM;",
          "    let pikevm = TestPikeVM;",
          "",
          "    let haystack: &[u8] = b\"fully filled string\";",
          "    let cache = CachePoolGuard::default();",
          "    let at = 10;",
          "    let slots = vec![Some(NonMaxUsize(NonZeroUsize::new(4).unwrap())), Some(NonMaxUsize(NonZeroUsize::new(5).unwrap()))];",
          "    let last_match_end = Some(20);",
          "",
          "    let find_matches = FindMatches {",
          "        pikevm: &pikevm,",
          "        cache,",
          "        haystack,",
          "        at,",
          "        slots,",
          "        last_match_end,",
          "    };",
          "",
          "    let mut captures_matches = CapturesMatches { it: find_matches };",
          "    ",
          "    let result = captures_matches.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(slots.clone()));",
          "    assert!(result.is_some());",
          "    assert!(result.as_ref().unwrap().len() > 0);",
          "    assert!(result.unwrap() == slots);",
          "    assert_eq!(captures_matches.it.slots, slots);",
          "    assert!(captures_matches.it.last_match_end.is_some());",
          "    assert_eq!(captures_matches.it.at, at);",
          "    assert_eq!(captures_matches.it.haystack, haystack);"
        ],
        "code": [
          "{",
          "    struct TestPikeVM;",
          "    let pikevm = TestPikeVM;",
          "",
          "    let haystack: &[u8] = b\"fully filled string\";",
          "    let cache = CachePoolGuard::default();",
          "    let at = 10;",
          "    let slots = vec![Some(NonMaxUsize(NonZeroUsize::new(4).unwrap())), Some(NonMaxUsize(NonZeroUsize::new(5).unwrap()))];",
          "    let last_match_end = Some(20);",
          "",
          "    let find_matches = FindMatches {",
          "        pikevm: &pikevm,",
          "        cache,",
          "        haystack,",
          "        at,",
          "        slots,",
          "        last_match_end,",
          "    };",
          "",
          "    let mut captures_matches = CapturesMatches { it: find_matches };",
          "    ",
          "    let result = captures_matches.next();",
          "    assert_eq!(result, Some(slots.clone()));",
          "    assert!(result.is_some());",
          "    assert!(result.as_ref().unwrap().len() > 0);",
          "    assert!(result.unwrap() == slots);",
          "    assert_eq!(captures_matches.it.slots, slots);",
          "    assert!(captures_matches.it.last_match_end.is_some());",
          "    assert_eq!(captures_matches.it.at, at);",
          "    assert_eq!(captures_matches.it.haystack, haystack);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestPikeVM;",
          "    let pikevm = TestPikeVM;",
          "",
          "    let haystack: &[u8] = b\"empty slots string\";",
          "    let cache = CachePoolGuard::default();",
          "    let at = 0;",
          "    let slots: Vec<Option<NonMaxUsize>> = vec![None; 5];",
          "    let last_match_end = Some(12);",
          "",
          "    let find_matches = FindMatches {",
          "        pikevm: &pikevm,",
          "        cache,",
          "        haystack,",
          "        at,",
          "        slots,",
          "        last_match_end,",
          "    };",
          "",
          "    let mut captures_matches = CapturesMatches { it: find_matches };",
          "    ",
          "    let result = captures_matches.next();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), vec![None, None, None, None, None]);"
        ],
        "code": [
          "{",
          "    struct TestPikeVM;",
          "    let pikevm = TestPikeVM;",
          "",
          "    let haystack: &[u8] = b\"empty slots string\";",
          "    let cache = CachePoolGuard::default();",
          "    let at = 0;",
          "    let slots: Vec<Option<NonMaxUsize>> = vec![None; 5];",
          "    let last_match_end = Some(12);",
          "",
          "    let find_matches = FindMatches {",
          "        pikevm: &pikevm,",
          "        cache,",
          "        haystack,",
          "        at,",
          "        slots,",
          "        last_match_end,",
          "    };",
          "",
          "    let mut captures_matches = CapturesMatches { it: find_matches };",
          "    ",
          "    let result = captures_matches.next();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), vec![None, None, None, None, None]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]