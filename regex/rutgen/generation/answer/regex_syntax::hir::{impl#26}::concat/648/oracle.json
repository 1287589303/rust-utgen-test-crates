[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHir {",
          "        props: Properties,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn properties(&self) -> &Properties {",
          "            &self.props",
          "        }",
          "    }",
          "",
          "    let empty_look_set = LookSet::empty();",
          "    let prop_none = Properties(Box::new(PropertiesI {",
          "        minimum_len: None,",
          "        maximum_len: None,",
          "        look_set: empty_look_set,",
          "        look_set_prefix: empty_look_set,",
          "        look_set_suffix: empty_look_set,",
          "        look_set_prefix_any: empty_look_set,",
          "        look_set_suffix_any: empty_look_set,",
          "        utf8: false,",
          "        explicit_captures_len: 0,",
          "        static_explicit_captures_len: Some(0),",
          "        literal: false,",
          "        alternation_literal: false,",
          "    }));",
          "",
          "    let hir1 = TestHir { props: prop_none.clone() };",
          "    let hir2 = TestHir { props: prop_none.clone() };",
          "    let concatenated_props = Properties::concat(&[hir1, hir2]);",
          "",
          "    let _ = concatenated_props; // This is just to satisfy the function call.",
          "}"
        ],
        "oracle": [
          "    assert_eq!(concatenated_props.minimum_len, None);",
          "    assert_eq!(concatenated_props.maximum_len, None);",
          "    assert!(!concatenated_props.utf8);",
          "    assert!(!concatenated_props.literal);",
          "    assert!(!concatenated_props.alternation_literal);",
          "    assert_eq!(concatenated_props.explicit_captures_len, 0);",
          "    assert_eq!(concatenated_props.static_explicit_captures_len, Some(0));",
          "    assert!(concatenated_props.look_set.is_empty());",
          "    assert!(concatenated_props.look_set_prefix.is_empty());",
          "    assert!(concatenated_props.look_set_suffix.is_empty());",
          "    assert!(concatenated_props.look_set_prefix_any.is_empty());",
          "    assert!(concatenated_props.look_set_suffix_any.is_empty());"
        ],
        "code": [
          "{",
          "    struct TestHir {",
          "        props: Properties,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn properties(&self) -> &Properties {",
          "            &self.props",
          "        }",
          "    }",
          "",
          "    let empty_look_set = LookSet::empty();",
          "    let prop_none = Properties(Box::new(PropertiesI {",
          "        minimum_len: None,",
          "        maximum_len: None,",
          "        look_set: empty_look_set,",
          "        look_set_prefix: empty_look_set,",
          "        look_set_suffix: empty_look_set,",
          "        look_set_prefix_any: empty_look_set,",
          "        look_set_suffix_any: empty_look_set,",
          "        utf8: false,",
          "        explicit_captures_len: 0,",
          "        static_explicit_captures_len: Some(0),",
          "        literal: false,",
          "        alternation_literal: false,",
          "    }));",
          "",
          "    let hir1 = TestHir { props: prop_none.clone() };",
          "    let hir2 = TestHir { props: prop_none.clone() };",
          "    let concatenated_props = Properties::concat(&[hir1, hir2]);",
          "",
          "    let _ = concatenated_props; // This is just to satisfy the function call.",
          "    assert_eq!(concatenated_props.minimum_len, None);",
          "    assert_eq!(concatenated_props.maximum_len, None);",
          "    assert!(!concatenated_props.utf8);",
          "    assert!(!concatenated_props.literal);",
          "    assert!(!concatenated_props.alternation_literal);",
          "    assert_eq!(concatenated_props.explicit_captures_len, 0);",
          "    assert_eq!(concatenated_props.static_explicit_captures_len, Some(0));",
          "    assert!(concatenated_props.look_set.is_empty());",
          "    assert!(concatenated_props.look_set_prefix.is_empty());",
          "    assert!(concatenated_props.look_set_suffix.is_empty());",
          "    assert!(concatenated_props.look_set_prefix_any.is_empty());",
          "    assert!(concatenated_props.look_set_suffix_any.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHir {",
          "        props: Properties,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn properties(&self) -> &Properties {",
          "            &self.props",
          "        }",
          "    }",
          "",
          "    let empty_look_set = LookSet::empty();",
          "    let prop_zero = Properties(Box::new(PropertiesI {",
          "        minimum_len: Some(0),",
          "        maximum_len: Some(0),",
          "        look_set: empty_look_set,",
          "        look_set_prefix: empty_look_set,",
          "        look_set_suffix: empty_look_set,",
          "        look_set_prefix_any: empty_look_set,",
          "        look_set_suffix_any: empty_look_set,",
          "        utf8: false,",
          "        explicit_captures_len: 0,",
          "        static_explicit_captures_len: Some(0),",
          "        literal: false,",
          "        alternation_literal: false,",
          "    }));",
          "",
          "    let hir1 = TestHir { props: prop_zero.clone() };",
          "    let hir2 = TestHir { props: prop_zero.clone() };",
          "    let concatenated_props = Properties::concat(&[hir1, hir2]);",
          "",
          "    let _ = concatenated_props; // This is just to satisfy the function call.",
          "}"
        ],
        "oracle": [
          "    assert_eq!(concatenated_props.minimum_len, None);",
          "    assert_eq!(concatenated_props.maximum_len, None);",
          "    assert!(!concatenated_props.utf8);",
          "    assert!(!concatenated_props.literal);",
          "    assert!(!concatenated_props.alternation_literal);",
          "    assert_eq!(concatenated_props.explicit_captures_len, 0);",
          "    assert_eq!(concatenated_props.static_explicit_captures_len, Some(0));",
          "    assert_eq!(concatenated_props.look_set.len(), 0);",
          "    assert_eq!(concatenated_props.look_set_prefix.len(), 0);",
          "    assert_eq!(concatenated_props.look_set_suffix.len(), 0);",
          "    assert_eq!(concatenated_props.look_set_prefix_any.len(), 0);",
          "    assert_eq!(concatenated_props.look_set_suffix_any.len(), 0);"
        ],
        "code": [
          "{",
          "    struct TestHir {",
          "        props: Properties,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn properties(&self) -> &Properties {",
          "            &self.props",
          "        }",
          "    }",
          "",
          "    let empty_look_set = LookSet::empty();",
          "    let prop_zero = Properties(Box::new(PropertiesI {",
          "        minimum_len: Some(0),",
          "        maximum_len: Some(0),",
          "        look_set: empty_look_set,",
          "        look_set_prefix: empty_look_set,",
          "        look_set_suffix: empty_look_set,",
          "        look_set_prefix_any: empty_look_set,",
          "        look_set_suffix_any: empty_look_set,",
          "        utf8: false,",
          "        explicit_captures_len: 0,",
          "        static_explicit_captures_len: Some(0),",
          "        literal: false,",
          "        alternation_literal: false,",
          "    }));",
          "",
          "    let hir1 = TestHir { props: prop_zero.clone() };",
          "    let hir2 = TestHir { props: prop_zero.clone() };",
          "    let concatenated_props = Properties::concat(&[hir1, hir2]);",
          "",
          "    let _ = concatenated_props; // This is just to satisfy the function call.",
          "    assert_eq!(concatenated_props.minimum_len, None);",
          "    assert_eq!(concatenated_props.maximum_len, None);",
          "    assert!(!concatenated_props.utf8);",
          "    assert!(!concatenated_props.literal);",
          "    assert!(!concatenated_props.alternation_literal);",
          "    assert_eq!(concatenated_props.explicit_captures_len, 0);",
          "    assert_eq!(concatenated_props.static_explicit_captures_len, Some(0));",
          "    assert_eq!(concatenated_props.look_set.len(), 0);",
          "    assert_eq!(concatenated_props.look_set_prefix.len(), 0);",
          "    assert_eq!(concatenated_props.look_set_suffix.len(), 0);",
          "    assert_eq!(concatenated_props.look_set_prefix_any.len(), 0);",
          "    assert_eq!(concatenated_props.look_set_suffix_any.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]