[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "}"
        ],
        "oracle": [
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "    config,",
          "    nfa: thompson::NFA::default(),",
          "    stride2: 0,",
          "    start_map: StartByteMap { map: [Default::default(); 256] },",
          "    classes,",
          "    quitset: byte_set,",
          "    cache_capacity: 0,",
          "    };",
          "    assert_eq!(dfa.byte_classes(), &dfa.classes);"
        ],
        "code": [
          "{",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "    config,",
          "    nfa: thompson::NFA::default(),",
          "    stride2: 0,",
          "    start_map: StartByteMap { map: [Default::default(); 256] },",
          "    classes,",
          "    quitset: byte_set,",
          "    cache_capacity: 0,",
          "    };",
          "    assert_eq!(dfa.byte_classes(), &dfa.classes);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([1; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "}"
        ],
        "oracle": [
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([1; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA { config, nfa: thompson::NFA::default(), stride2: 0, start_map: StartByteMap { map: [Default::default(); 256] }, classes, quitset: byte_set, cache_capacity: 0 };",
          "    assert_eq!(dfa.byte_classes(), &dfa.classes);",
          "    assert_eq!(dfa.byte_classes().0, [1; 256]);",
          "    assert!(dfa.config.byte_classes.is_some());",
          "    assert!(dfa.classes.0.iter().all(|&x| x == 1));"
        ],
        "code": [
          "{",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([1; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([1; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA { config, nfa: thompson::NFA::default(), stride2: 0, start_map: StartByteMap { map: [Default::default(); 256] }, classes, quitset: byte_set, cache_capacity: 0 };",
          "    assert_eq!(dfa.byte_classes(), &dfa.classes);",
          "    assert_eq!(dfa.byte_classes().0, [1; 256]);",
          "    assert!(dfa.config.byte_classes.is_some());",
          "    assert!(dfa.classes.0.iter().all(|&x| x == 1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "}"
        ],
        "oracle": [
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "    config,",
          "    nfa: thompson::NFA::default(),",
          "    stride2: 0,",
          "    start_map: StartByteMap { map: [Default::default(); 256] },",
          "    classes,",
          "    quitset: byte_set,",
          "    cache_capacity: 0,",
          "    };",
          "    assert_eq!(dfa.byte_classes(), &classes);"
        ],
        "code": [
          "{",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "    config,",
          "    nfa: thompson::NFA::default(),",
          "    stride2: 0,",
          "    start_map: StartByteMap { map: [Default::default(); 256] },",
          "    classes,",
          "    quitset: byte_set,",
          "    cache_capacity: 0,",
          "    };",
          "    assert_eq!(dfa.byte_classes(), &classes);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(false), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dfa.byte_classes(), &dfa.classes);",
          "    assert!(dfa.byte_classes().0.iter().all(|&x| x == 0));",
          "    assert_eq!(dfa.config.byte_classes, Some(false));",
          "    assert_eq!(dfa.memory_usage(), size_of::<DFA>());",
          "    assert_eq!(dfa.pattern_len(), 256);",
          "    assert!(dfa.always_match().is_ok());",
          "    assert!(dfa.never_match().is_ok());"
        ],
        "code": [
          "{",
          "    let byte_set = ByteSet([true; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(false), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "    assert_eq!(dfa.byte_classes(), &dfa.classes);",
          "    assert!(dfa.byte_classes().0.iter().all(|&x| x == 0));",
          "    assert_eq!(dfa.config.byte_classes, Some(false));",
          "    assert_eq!(dfa.memory_usage(), size_of::<DFA>());",
          "    assert_eq!(dfa.pattern_len(), 256);",
          "    assert!(dfa.always_match().is_ok());",
          "    assert!(dfa.never_match().is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_set = ByteSet([false; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "}"
        ],
        "oracle": [
          "    let byte_set = ByteSet([false; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "    config,",
          "    nfa: thompson::NFA::default(),",
          "    stride2: 0,",
          "    start_map: StartByteMap { map: [Default::default(); 256] },",
          "    classes,",
          "    quitset: byte_set,",
          "    cache_capacity: 0,",
          "    };",
          "    assert_eq!(dfa.byte_classes(), &classes);"
        ],
        "code": [
          "{",
          "    let byte_set = ByteSet([false; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "        config,",
          "        nfa: thompson::NFA::default(),",
          "        stride2: 0,",
          "        start_map: StartByteMap { map: [Default::default(); 256] },",
          "        classes,",
          "        quitset: byte_set,",
          "        cache_capacity: 0,",
          "    };",
          "    let _result = dfa.byte_classes();",
          "    let byte_set = ByteSet([false; 256]);",
          "    let classes = ByteClasses([0; 256]);",
          "    let config = Config { byte_classes: Some(true), ..Default::default() };",
          "    let dfa = DFA {",
          "    config,",
          "    nfa: thompson::NFA::default(),",
          "    stride2: 0,",
          "    start_map: StartByteMap { map: [Default::default(); 256] },",
          "    classes,",
          "    quitset: byte_set,",
          "    cache_capacity: 0,",
          "    };",
          "    assert_eq!(dfa.byte_classes(), &classes);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]