[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = vec![];",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    ",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "}"
        ],
        "oracle": [
          "    let table: Vec<u32> = vec![];",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    let transition_table = TransitionTable { table, classes, stride2 };",
          "    assert_eq!(transition_table.table(), &[]);",
          "    assert_eq!(transition_table.table().len(), 0);",
          "    assert!(transition_table.table().is_empty());"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = vec![];",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    ",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "    let table: Vec<u32> = vec![];",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    let transition_table = TransitionTable { table, classes, stride2 };",
          "    assert_eq!(transition_table.table(), &[]);",
          "    assert_eq!(transition_table.table().len(), 0);",
          "    assert!(transition_table.table().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = vec![1];",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    ",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, wire::u32s_to_state_ids(transition_table.table.as_ref()));",
          "    assert!(!_result.is_empty());",
          "    assert_eq!(_result.len(), 1);",
          "    assert_eq!(_result[0], StateID(1));"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = vec![1];",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    ",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "    assert_eq!(_result, wire::u32s_to_state_ids(transition_table.table.as_ref()));",
          "    assert!(!_result.is_empty());",
          "    assert_eq!(_result.len(), 1);",
          "    assert_eq!(_result[0], StateID(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = (0..256).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 8;",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "}"
        ],
        "oracle": [
          "    let expected: &[StateID] = wire::u32s_to_state_ids(&(0..256).collect::<Vec<u32>>().as_ref());",
          "    assert_eq!(transition_table.table(), expected);"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = (0..256).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 8;",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "    let expected: &[StateID] = wire::u32s_to_state_ids(&(0..256).collect::<Vec<u32>>().as_ref());",
          "    assert_eq!(transition_table.table(), expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = vec![0; 257];",
          "    let classes = ByteClasses([1; 256]);",
          "    let stride2 = 9;",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.len(), 257);",
          "    assert!(_result.iter().all(|&id| id.0 < 257));",
          "    assert_eq!(_result[0], StateID(0));",
          "    assert_eq!(_result[256], StateID(0));",
          "    assert_eq!(transition_table.stride(), 512);",
          "    assert_eq!(transition_table.alphabet_len(), 257);",
          "    assert!(transition_table.is_valid(StateID(0)));",
          "    assert!(!transition_table.is_valid(StateID(258)));",
          "    assert_eq!(transition_table.memory_usage(), size_of::<StateID>() * 257);",
          "    assert_eq!(transition_table.len(), 257);"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = vec![0; 257];",
          "    let classes = ByteClasses([1; 256]);",
          "    let stride2 = 9;",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "    assert_eq!(_result.len(), 257);",
          "    assert!(_result.iter().all(|&id| id.0 < 257));",
          "    assert_eq!(_result[0], StateID(0));",
          "    assert_eq!(_result[256], StateID(0));",
          "    assert_eq!(transition_table.stride(), 512);",
          "    assert_eq!(transition_table.alphabet_len(), 257);",
          "    assert!(transition_table.is_valid(StateID(0)));",
          "    assert!(!transition_table.is_valid(StateID(258)));",
          "    assert_eq!(transition_table.memory_usage(), size_of::<StateID>() * 257);",
          "    assert_eq!(transition_table.len(), 257);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = vec![255; 257];",
          "    let classes = ByteClasses([1; 256]);",
          "    let stride2 = 9;",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "}"
        ],
        "oracle": [
          "    let expected_length = 257;",
          "    let expected_classes = ByteClasses([1; 256]);",
          "    let expected_stride2 = 9;",
          "    let result = transition_table.table();",
          "    assert_eq!(result.len(), expected_length);",
          "    assert_eq!(transition_table.classes, expected_classes);",
          "    assert_eq!(transition_table.stride2, expected_stride2);",
          "    assert!(result.iter().all(|&state_id| state_id.0 < expected_length as u32));",
          "    assert_eq!(result[0], StateID(SmallIndex::from(0)));",
          "    assert_eq!(result[result.len() - 1], StateID(SmallIndex::from(expected_length - 1)));"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = vec![255; 257];",
          "    let classes = ByteClasses([1; 256]);",
          "    let stride2 = 9;",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "    let expected_length = 257;",
          "    let expected_classes = ByteClasses([1; 256]);",
          "    let expected_stride2 = 9;",
          "    let result = transition_table.table();",
          "    assert_eq!(result.len(), expected_length);",
          "    assert_eq!(transition_table.classes, expected_classes);",
          "    assert_eq!(transition_table.stride2, expected_stride2);",
          "    assert!(result.iter().all(|&state_id| state_id.0 < expected_length as u32));",
          "    assert_eq!(result[0], StateID(SmallIndex::from(0)));",
          "    assert_eq!(result[result.len() - 1], StateID(SmallIndex::from(expected_length - 1)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = vec![0; 128];",
          "    let classes = ByteClasses([1; 256]);",
          "    let stride2 = 8;",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "}"
        ],
        "oracle": [
          "    let table: Vec<u32> = vec![0; 128];",
          "    let classes = ByteClasses([1; 256]);",
          "    let stride2 = 8;",
          "    let transition_table = TransitionTable { table, classes, stride2 };",
          "    let result = transition_table.table();",
          "    assert_eq!(result.len(), 128);",
          "    assert_eq!(result[0], StateID(SmallIndex(0)));",
          "    assert_eq!(result[1], StateID(SmallIndex(0)));",
          "    assert_eq!(result[2], StateID(SmallIndex(0)));",
          "    assert_eq!(result[127], StateID(SmallIndex(0)));",
          "    assert!(result.iter().all(|&state_id| transition_table.is_valid(state_id)));"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = vec![0; 128];",
          "    let classes = ByteClasses([1; 256]);",
          "    let stride2 = 8;",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let _result = transition_table.table();",
          "    let table: Vec<u32> = vec![0; 128];",
          "    let classes = ByteClasses([1; 256]);",
          "    let stride2 = 8;",
          "    let transition_table = TransitionTable { table, classes, stride2 };",
          "    let result = transition_table.table();",
          "    assert_eq!(result.len(), 128);",
          "    assert_eq!(result[0], StateID(SmallIndex(0)));",
          "    assert_eq!(result[1], StateID(SmallIndex(0)));",
          "    assert_eq!(result[2], StateID(SmallIndex(0)));",
          "    assert_eq!(result[127], StateID(SmallIndex(0)));",
          "    assert!(result.iter().all(|&state_id| transition_table.is_valid(state_id)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]