[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut lit1 = Literal::exact(vec![1, 2, 3]);",
          "    let lit2 = Literal::exact(vec![4, 5, 6]);",
          "    lit1.extend(&lit2);",
          "}"
        ],
        "oracle": [
          "    let lit1 = Literal::exact(vec![1, 2, 3]);",
          "    let lit2 = Literal::exact(vec![4, 5, 6]);",
          "    assert_eq!(lit1.bytes, vec![1, 2, 3, 4, 5, 6]);",
          "    assert!(lit1.is_exact());",
          "    assert_eq!(lit1.len(), 6);",
          "    assert!(!lit1.is_empty());"
        ],
        "code": [
          "{",
          "    let mut lit1 = Literal::exact(vec![1, 2, 3]);",
          "    let lit2 = Literal::exact(vec![4, 5, 6]);",
          "    lit1.extend(&lit2);",
          "    let lit1 = Literal::exact(vec![1, 2, 3]);",
          "    let lit2 = Literal::exact(vec![4, 5, 6]);",
          "    assert_eq!(lit1.bytes, vec![1, 2, 3, 4, 5, 6]);",
          "    assert!(lit1.is_exact());",
          "    assert_eq!(lit1.len(), 6);",
          "    assert!(!lit1.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut lit1 = Literal::exact(vec![1, 2]);",
          "    let lit2 = Literal::exact(vec![3, 4, 5, 6]);",
          "    lit1.extend(&lit2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lit1.as_bytes(), &[1, 2, 3, 4, 5, 6]);",
          "    assert_eq!(lit1.len(), 6);",
          "    assert!(!lit1.is_empty());",
          "    assert!(lit1.is_exact());"
        ],
        "code": [
          "{",
          "    let mut lit1 = Literal::exact(vec![1, 2]);",
          "    let lit2 = Literal::exact(vec![3, 4, 5, 6]);",
          "    lit1.extend(&lit2);",
          "    assert_eq!(lit1.as_bytes(), &[1, 2, 3, 4, 5, 6]);",
          "    assert_eq!(lit1.len(), 6);",
          "    assert!(!lit1.is_empty());",
          "    assert!(lit1.is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut lit1 = Literal::exact(vec![10, 20, 30]);",
          "    let lit2 = Literal::exact(vec![40, 50, 60, 70, 80]);",
          "    lit1.extend(&lit2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lit1.as_bytes(), &[10, 20, 30, 40, 50, 60, 70, 80]);",
          "    assert_eq!(lit1.len(), 8);",
          "    assert!(!lit1.is_empty());",
          "    assert!(lit1.is_exact());"
        ],
        "code": [
          "{",
          "    let mut lit1 = Literal::exact(vec![10, 20, 30]);",
          "    let lit2 = Literal::exact(vec![40, 50, 60, 70, 80]);",
          "    lit1.extend(&lit2);",
          "    assert_eq!(lit1.as_bytes(), &[10, 20, 30, 40, 50, 60, 70, 80]);",
          "    assert_eq!(lit1.len(), 8);",
          "    assert!(!lit1.is_empty());",
          "    assert!(lit1.is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut lit1 = Literal::exact(vec![100, 200, 300, 400]);",
          "    let lit2 = Literal::exact(vec![500, 600]);",
          "    lit1.extend(&lit2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lit1.as_bytes(), vec![100, 200, 300, 400, 500, 600].as_slice());",
          "    assert_eq!(lit1.len(), 6);",
          "    assert!(!lit1.is_empty());",
          "    assert!(lit1.is_exact());"
        ],
        "code": [
          "{",
          "    let mut lit1 = Literal::exact(vec![100, 200, 300, 400]);",
          "    let lit2 = Literal::exact(vec![500, 600]);",
          "    lit1.extend(&lit2);",
          "    assert_eq!(lit1.as_bytes(), vec![100, 200, 300, 400, 500, 600].as_slice());",
          "    assert_eq!(lit1.len(), 6);",
          "    assert!(!lit1.is_empty());",
          "    assert!(lit1.is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut lit1 = Literal::exact(vec![7, 8, 9]);",
          "    let lit2 = Literal::exact(vec![7, 8, 9]);",
          "    lit1.extend(&lit2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lit1.as_bytes(), vec![7, 8, 9, 7, 8, 9].as_slice());",
          "    assert_eq!(lit1.len(), 6);",
          "    assert!(!lit1.is_empty());",
          "    assert!(lit1.is_exact());"
        ],
        "code": [
          "{",
          "    let mut lit1 = Literal::exact(vec![7, 8, 9]);",
          "    let lit2 = Literal::exact(vec![7, 8, 9]);",
          "    lit1.extend(&lit2);",
          "    assert_eq!(lit1.as_bytes(), vec![7, 8, 9, 7, 8, 9].as_slice());",
          "    assert_eq!(lit1.len(), 6);",
          "    assert!(!lit1.is_empty());",
          "    assert!(lit1.is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]