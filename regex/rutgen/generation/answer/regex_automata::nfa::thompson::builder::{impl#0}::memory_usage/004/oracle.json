[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Union { alternates: Vec::new() };",
          "    let _ = state.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let state = State::Union { alternates: Vec::new() };",
          "    assert_eq!(state.memory_usage(), 0);",
          "    ",
          "    let state = State::Union { alternates: vec![StateID(SmallIndex(1)), StateID(SmallIndex(2))] };",
          "    assert_eq!(state.memory_usage(), 2 * mem::size_of::<StateID>());",
          "    ",
          "    let state = State::Union { alternates: vec![StateID(SmallIndex(3)), StateID(SmallIndex(4)), StateID(SmallIndex(5))] };",
          "    assert_eq!(state.memory_usage(), 3 * mem::size_of::<StateID>());"
        ],
        "code": [
          "{",
          "    let state = State::Union { alternates: Vec::new() };",
          "    let _ = state.memory_usage();",
          "    let state = State::Union { alternates: Vec::new() };",
          "    assert_eq!(state.memory_usage(), 0);",
          "    ",
          "    let state = State::Union { alternates: vec![StateID(SmallIndex(1)), StateID(SmallIndex(2))] };",
          "    assert_eq!(state.memory_usage(), 2 * mem::size_of::<StateID>());",
          "    ",
          "    let state = State::Union { alternates: vec![StateID(SmallIndex(3)), StateID(SmallIndex(4)), StateID(SmallIndex(5))] };",
          "    assert_eq!(state.memory_usage(), 3 * mem::size_of::<StateID>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id = StateID(SmallIndex(1));",
          "    let state = State::Union { alternates: vec![state_id] };",
          "    let _ = state.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(state.memory_usage(), 1 * mem::size_of::<StateID>());"
        ],
        "code": [
          "{",
          "    let state_id = StateID(SmallIndex(1));",
          "    let state = State::Union { alternates: vec![state_id] };",
          "    let _ = state.memory_usage();",
          "    assert_eq!(state.memory_usage(), 1 * mem::size_of::<StateID>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let state_id_3 = StateID(SmallIndex(3));",
          "    let state = State::Union { alternates: vec![state_id_1, state_id_2, state_id_3] };",
          "    let _ = state.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(state.memory_usage(), 3 * mem::size_of::<StateID>());"
        ],
        "code": [
          "{",
          "    let state_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let state_id_3 = StateID(SmallIndex(3));",
          "    let state = State::Union { alternates: vec![state_id_1, state_id_2, state_id_3] };",
          "    let _ = state.memory_usage();",
          "    assert_eq!(state.memory_usage(), 3 * mem::size_of::<StateID>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut alternates = Vec::with_capacity(1000);",
          "    for i in 0..1000 {",
          "        alternates.push(StateID(SmallIndex(i)));",
          "    }",
          "    let state = State::Union { alternates };",
          "    let _ = state.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let mut alternates = Vec::with_capacity(1000);",
          "    assert_eq!(alternates.len(), 1000);",
          "    let state = State::Union { alternates };",
          "    let expected_memory_usage = 1000 * mem::size_of::<StateID>();",
          "    assert_eq!(state.memory_usage(), expected_memory_usage);"
        ],
        "code": [
          "{",
          "    let mut alternates = Vec::with_capacity(1000);",
          "    for i in 0..1000 {",
          "        alternates.push(StateID(SmallIndex(i)));",
          "    }",
          "    let state = State::Union { alternates };",
          "    let _ = state.memory_usage();",
          "    let mut alternates = Vec::with_capacity(1000);",
          "    assert_eq!(alternates.len(), 1000);",
          "    let state = State::Union { alternates };",
          "    let expected_memory_usage = 1000 * mem::size_of::<StateID>();",
          "    assert_eq!(state.memory_usage(), expected_memory_usage);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]