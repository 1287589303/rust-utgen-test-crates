[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .size_limit(Some(10));",
          "    let o_config = Config::default()",
          "        .match_kind(MatchKind::All);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.match_kind, Some(MatchKind::All));",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);",
          "    assert_eq!(result.size_limit, Some(10));"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .size_limit(Some(10));",
          "    let o_config = Config::default()",
          "        .match_kind(MatchKind::All);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, Some(MatchKind::All));",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);",
          "    assert_eq!(result.size_limit, Some(10));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .byte_classes(true);",
          "    let o_config = Config::default()",
          "        .match_kind(MatchKind::LeftmostFirst);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    let expected_match_kind = MatchKind::LeftmostFirst;",
          "    let expected_starts_for_each_pattern = false;",
          "    let expected_byte_classes = true;",
          "    let expected_size_limit = None;",
          "    assert_eq!(result.get_match_kind(), expected_match_kind);",
          "    assert_eq!(result.get_starts_for_each_pattern(), expected_starts_for_each_pattern);",
          "    assert_eq!(result.get_byte_classes(), expected_byte_classes);",
          "    assert_eq!(result.get_size_limit(), expected_size_limit);"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .byte_classes(true);",
          "    let o_config = Config::default()",
          "        .match_kind(MatchKind::LeftmostFirst);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    let expected_match_kind = MatchKind::LeftmostFirst;",
          "    let expected_starts_for_each_pattern = false;",
          "    let expected_byte_classes = true;",
          "    let expected_size_limit = None;",
          "    assert_eq!(result.get_match_kind(), expected_match_kind);",
          "    assert_eq!(result.get_starts_for_each_pattern(), expected_starts_for_each_pattern);",
          "    assert_eq!(result.get_byte_classes(), expected_byte_classes);",
          "    assert_eq!(result.get_size_limit(), expected_size_limit);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .match_kind(MatchKind::All);",
          "    let o_config = Config::default()",
          "        .starts_for_each_pattern(true);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.match_kind, Some(MatchKind::All));",
          "    assert_eq!(result.starts_for_each_pattern, Some(true));",
          "    assert_eq!(result.byte_classes, None);",
          "    assert_eq!(result.size_limit, None);",
          "    ",
          "    let self_config = Config::default()",
          "    .byte_classes(true);",
          "    let o_config = Config::default()",
          "    .match_kind(MatchKind::LeftmostFirst);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, Some(MatchKind::LeftmostFirst));",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, Some(true));",
          "    assert_eq!(result.size_limit, None);",
          "    ",
          "    let self_config = Config::default()",
          "    .size_limit(Some(10));",
          "    let o_config = Config::default()",
          "    .size_limit(None);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);",
          "    assert_eq!(result.size_limit, Some(10));",
          "    ",
          "    let self_config = Config::default();",
          "    let o_config = Config::default();",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);",
          "    assert_eq!(result.size_limit, None);"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .match_kind(MatchKind::All);",
          "    let o_config = Config::default()",
          "        .starts_for_each_pattern(true);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, Some(MatchKind::All));",
          "    assert_eq!(result.starts_for_each_pattern, Some(true));",
          "    assert_eq!(result.byte_classes, None);",
          "    assert_eq!(result.size_limit, None);",
          "    ",
          "    let self_config = Config::default()",
          "    .byte_classes(true);",
          "    let o_config = Config::default()",
          "    .match_kind(MatchKind::LeftmostFirst);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, Some(MatchKind::LeftmostFirst));",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, Some(true));",
          "    assert_eq!(result.size_limit, None);",
          "    ",
          "    let self_config = Config::default()",
          "    .size_limit(Some(10));",
          "    let o_config = Config::default()",
          "    .size_limit(None);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);",
          "    assert_eq!(result.size_limit, Some(10));",
          "    ",
          "    let self_config = Config::default();",
          "    let o_config = Config::default();",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);",
          "    assert_eq!(result.size_limit, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .starts_for_each_pattern(Some(true));",
          "    let o_config = Config::default()",
          "        .starts_for_each_pattern(false);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    result.get_match_kind() == MatchKind::All",
          "    result.get_starts_for_each_pattern() == false",
          "    result.get_byte_classes() == false",
          "    result.get_size_limit() == None"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .starts_for_each_pattern(Some(true));",
          "    let o_config = Config::default()",
          "        .starts_for_each_pattern(false);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    result.get_match_kind() == MatchKind::All",
          "    result.get_starts_for_each_pattern() == false",
          "    result.get_byte_classes() == false",
          "    result.get_size_limit() == None",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .byte_classes(false);",
          "    let o_config = Config::default()",
          "        .byte_classes(true);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.get_match_kind(), MatchKind::All);",
          "    assert_eq!(result.get_starts_for_each_pattern(), false);",
          "    assert_eq!(result.get_byte_classes(), true);",
          "    assert_eq!(result.get_size_limit(), None);"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .byte_classes(false);",
          "    let o_config = Config::default()",
          "        .byte_classes(true);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.get_match_kind(), MatchKind::All);",
          "    assert_eq!(result.get_starts_for_each_pattern(), false);",
          "    assert_eq!(result.get_byte_classes(), true);",
          "    assert_eq!(result.get_size_limit(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .byte_classes(Some(true));",
          "    let o_config = Config::default()",
          "        .byte_classes(false);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, Some(false));",
          "    assert_eq!(result.size_limit, None);",
          "    ",
          "    let self_config2 = Config::default()",
          "    .match_kind(MatchKind::All)",
          "    .starts_for_each_pattern(true);",
          "    let o_config2 = Config::default()",
          "    .match_kind(MatchKind::LeftmostFirst)",
          "    .size_limit(Some(10));",
          "    ",
          "    let result2 = self_config2.overwrite(o_config2);",
          "    assert_eq!(result2.match_kind, Some(MatchKind::LeftmostFirst));",
          "    assert_eq!(result2.starts_for_each_pattern, Some(true));",
          "    assert_eq!(result2.byte_classes, None);",
          "    assert_eq!(result2.size_limit, Some(10));",
          "    ",
          "    let self_config3 = Config::default()",
          "    .byte_classes(Some(true))",
          "    .size_limit(Some(5));",
          "    let o_config3 = Config::default();",
          "    ",
          "    let result3 = self_config3.overwrite(o_config3);",
          "    assert_eq!(result3.match_kind, None);",
          "    assert_eq!(result3.starts_for_each_pattern, None);",
          "    assert_eq!(result3.byte_classes, Some(true));",
          "    assert_eq!(result3.size_limit, Some(5));",
          "    ",
          "    let self_config4 = Config::default();",
          "    let o_config4 = Config::default()",
          "    .byte_classes(Some(false))",
          "    .size_limit(None);",
          "    ",
          "    let result4 = self_config4.overwrite(o_config4);",
          "    assert_eq!(result4.match_kind, None);",
          "    assert_eq!(result4.starts_for_each_pattern, None);",
          "    assert_eq!(result4.byte_classes, Some(false));",
          "    assert_eq!(result4.size_limit, None);"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .byte_classes(Some(true));",
          "    let o_config = Config::default()",
          "        .byte_classes(false);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, Some(false));",
          "    assert_eq!(result.size_limit, None);",
          "    ",
          "    let self_config2 = Config::default()",
          "    .match_kind(MatchKind::All)",
          "    .starts_for_each_pattern(true);",
          "    let o_config2 = Config::default()",
          "    .match_kind(MatchKind::LeftmostFirst)",
          "    .size_limit(Some(10));",
          "    ",
          "    let result2 = self_config2.overwrite(o_config2);",
          "    assert_eq!(result2.match_kind, Some(MatchKind::LeftmostFirst));",
          "    assert_eq!(result2.starts_for_each_pattern, Some(true));",
          "    assert_eq!(result2.byte_classes, None);",
          "    assert_eq!(result2.size_limit, Some(10));",
          "    ",
          "    let self_config3 = Config::default()",
          "    .byte_classes(Some(true))",
          "    .size_limit(Some(5));",
          "    let o_config3 = Config::default();",
          "    ",
          "    let result3 = self_config3.overwrite(o_config3);",
          "    assert_eq!(result3.match_kind, None);",
          "    assert_eq!(result3.starts_for_each_pattern, None);",
          "    assert_eq!(result3.byte_classes, Some(true));",
          "    assert_eq!(result3.size_limit, Some(5));",
          "    ",
          "    let self_config4 = Config::default();",
          "    let o_config4 = Config::default()",
          "    .byte_classes(Some(false))",
          "    .size_limit(None);",
          "    ",
          "    let result4 = self_config4.overwrite(o_config4);",
          "    assert_eq!(result4.match_kind, None);",
          "    assert_eq!(result4.starts_for_each_pattern, None);",
          "    assert_eq!(result4.byte_classes, Some(false));",
          "    assert_eq!(result4.size_limit, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .size_limit(Some(15));",
          "    let o_config = Config::default()",
          "        .size_limit(None);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.size_limit, Some(15));",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .size_limit(Some(15));",
          "    let o_config = Config::default()",
          "        .size_limit(None);",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.size_limit, Some(15));",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .size_limit(Some(5));",
          "    let o_config = Config::default()",
          "        .size_limit(Some(0));",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    let expected_match_kind = None;",
          "    let expected_starts_for_each_pattern = false;",
          "    let expected_byte_classes = false;",
          "    let expected_size_limit = Some(5);",
          "    assert_eq!(result.match_kind, expected_match_kind);",
          "    assert_eq!(result.starts_for_each_pattern, expected_starts_for_each_pattern);",
          "    assert_eq!(result.byte_classes, expected_byte_classes);",
          "    assert_eq!(result.size_limit, expected_size_limit);"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .size_limit(Some(5));",
          "    let o_config = Config::default()",
          "        .size_limit(Some(0));",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    let expected_match_kind = None;",
          "    let expected_starts_for_each_pattern = false;",
          "    let expected_byte_classes = false;",
          "    let expected_size_limit = Some(5);",
          "    assert_eq!(result.match_kind, expected_match_kind);",
          "    assert_eq!(result.starts_for_each_pattern, expected_starts_for_each_pattern);",
          "    assert_eq!(result.byte_classes, expected_byte_classes);",
          "    assert_eq!(result.size_limit, expected_size_limit);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let self_config = Config::default()",
          "        .size_limit(Some(100));",
          "    let o_config = Config::default()",
          "        .size_limit(Some(u32::MAX));",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.size_limit, Some(u32::MAX));",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);"
        ],
        "code": [
          "{",
          "    let self_config = Config::default()",
          "        .size_limit(Some(100));",
          "    let o_config = Config::default()",
          "        .size_limit(Some(u32::MAX));",
          "    ",
          "    let result = self_config.overwrite(o_config);",
          "    assert_eq!(result.size_limit, Some(u32::MAX));",
          "    assert_eq!(result.match_kind, None);",
          "    assert_eq!(result.starts_for_each_pattern, None);",
          "    assert_eq!(result.byte_classes, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]