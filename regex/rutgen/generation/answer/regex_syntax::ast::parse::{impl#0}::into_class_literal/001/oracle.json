[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestParser;",
          "",
          "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
          "    let span = Span { start: 0, end: 1 };",
          "    ",
          "    let primitive = Primitive::Assertion(Assertion { span, kind: AssertionKind::WordBoundary });",
          "",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Err(parser_instance.error(span, ast::ErrorKind::ClassRangeLiteral)));"
        ],
        "code": [
          "{",
          "    struct TestParser;",
          "",
          "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
          "    let span = Span { start: 0, end: 1 };",
          "    ",
          "    let primitive = Primitive::Assertion(Assertion { span, kind: AssertionKind::WordBoundary });",
          "",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "    assert_eq!(result, Err(parser_instance.error(span, ast::ErrorKind::ClassRangeLiteral)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestParser;",
          "",
          "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
          "    let span = Span { start: 1, end: 2 };",
          "",
          "    let primitive = Primitive::Dot(span);",
          "",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(result, Err(err) if err.kind == ast::ErrorKind::ClassRangeLiteral));"
        ],
        "code": [
          "{",
          "    struct TestParser;",
          "",
          "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
          "    let span = Span { start: 1, end: 2 };",
          "",
          "    let primitive = Primitive::Dot(span);",
          "",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "    assert!(matches!(result, Err(err) if err.kind == ast::ErrorKind::ClassRangeLiteral));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestParser;",
          "",
          "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
          "    let span = Span { start: 2, end: 3 };",
          "",
          "    let primitive = Primitive::Perl(ClassPerl { span, kind: ClassPerlKind::Word, negated: false });",
          "",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "}"
        ],
        "oracle": [
          "    let primitive = Primitive::Perl(ClassPerl { span, kind: ClassPerlKind::Word, negated: false });",
          "    let expected_error_kind = ast::ErrorKind::ClassRangeLiteral;",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "    assert!(result.is_err());",
          "    if let Err(ref error) = result {",
          "    assert_eq!(error.kind, expected_error_kind);",
          "    assert_eq!(error.span, span);",
          "    }"
        ],
        "code": [
          "{",
          "    struct TestParser;",
          "",
          "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
          "    let span = Span { start: 2, end: 3 };",
          "",
          "    let primitive = Primitive::Perl(ClassPerl { span, kind: ClassPerlKind::Word, negated: false });",
          "",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "    let primitive = Primitive::Perl(ClassPerl { span, kind: ClassPerlKind::Word, negated: false });",
          "    let expected_error_kind = ast::ErrorKind::ClassRangeLiteral;",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "    assert!(result.is_err());",
          "    if let Err(ref error) = result {",
          "    assert_eq!(error.kind, expected_error_kind);",
          "    assert_eq!(error.span, span);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestParser;",
          "",
          "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
          "    let span = Span { start: 3, end: 4 };",
          "",
          "    let primitive = Primitive::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Letter });",
          "",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "}"
        ],
        "oracle": [
          "    let expected_error = Error { kind: ErrorKind::ClassRangeLiteral, pattern: \"test pattern\".to_string(), span };",
          "    assert_eq!(result, Err(expected_error));"
        ],
        "code": [
          "{",
          "    struct TestParser;",
          "",
          "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
          "    let span = Span { start: 3, end: 4 };",
          "",
          "    let primitive = Primitive::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Letter });",
          "",
          "    let result = primitive.into_class_literal(&parser_instance);",
          "    let expected_error = Error { kind: ErrorKind::ClassRangeLiteral, pattern: \"test pattern\".to_string(), span };",
          "    assert_eq!(result, Err(expected_error));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]