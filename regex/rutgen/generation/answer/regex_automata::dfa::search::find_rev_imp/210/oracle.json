[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton {",
          "        special_state: StateID,",
          "        start_state: StateID,",
          "        accel_state: StateID,",
          "    }",
          "",
          "    impl Automaton for TestAutomaton {",
          "        // Implement required methods for Automaton trait...",
          "    }",
          "",
          "    let haystack: &[u8] = b\"example\";",
          "    let input = Input::new(haystack)",
          "        .span(Span::new(1, haystack.len()))",
          "        .anchored(Anchored::None)",
          "        .earliest(false);",
          "    ",
          "    let mut dfa = TestAutomaton {",
          "        special_state: StateID(1),",
          "        start_state: StateID(0),",
          "        accel_state: StateID(2),",
          "    };",
          "",
          "    let result = find_rev_imp(&dfa, &input, false);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let mat = result.unwrap();",
          "    assert!(mat.is_some());",
          "    let half_match = mat.unwrap();",
          "    assert_eq!(half_match.pattern(), PatternID(2));",
          "    assert_eq!(half_match.offset(), 6);",
          "    assert!(!dfa.is_dead_state(sid));",
          "    assert!(dfa.is_accel_state(sid));"
        ],
        "code": [
          "{",
          "    struct TestAutomaton {",
          "        special_state: StateID,",
          "        start_state: StateID,",
          "        accel_state: StateID,",
          "    }",
          "",
          "    impl Automaton for TestAutomaton {",
          "        // Implement required methods for Automaton trait...",
          "    }",
          "",
          "    let haystack: &[u8] = b\"example\";",
          "    let input = Input::new(haystack)",
          "        .span(Span::new(1, haystack.len()))",
          "        .anchored(Anchored::None)",
          "        .earliest(false);",
          "    ",
          "    let mut dfa = TestAutomaton {",
          "        special_state: StateID(1),",
          "        start_state: StateID(0),",
          "        accel_state: StateID(2),",
          "    };",
          "",
          "    let result = find_rev_imp(&dfa, &input, false);",
          "    assert!(result.is_ok());",
          "    let mat = result.unwrap();",
          "    assert!(mat.is_some());",
          "    let half_match = mat.unwrap();",
          "    assert_eq!(half_match.pattern(), PatternID(2));",
          "    assert_eq!(half_match.offset(), 6);",
          "    assert!(!dfa.is_dead_state(sid));",
          "    assert!(dfa.is_accel_state(sid));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton {",
          "        special_state: StateID,",
          "        start_state: StateID,",
          "        accel_state: StateID,",
          "    }",
          "",
          "    impl Automaton for TestAutomaton {",
          "        // Implement required methods for Automaton trait...",
          "    }",
          "",
          "    let haystack: &[u8] = b\"boundary\";",
          "    let input = Input::new(haystack)",
          "        .span(Span::new(1, haystack.len()))",
          "        .anchored(Anchored::None)",
          "        .earliest(false);",
          "    ",
          "    let mut dfa = TestAutomaton {",
          "        special_state: StateID(1),",
          "        start_state: StateID(0),",
          "        accel_state: StateID(2),",
          "    };",
          "",
          "    let result = find_rev_imp(&dfa, &input, false);",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = b\"boundary\";",
          "    let input = Input::new(haystack)",
          "    .span(Span::new(1, haystack.len()))",
          "    .anchored(Anchored::None)",
          "    .earliest(false);",
          "    let mut dfa = TestAutomaton {",
          "    special_state: StateID(1),",
          "    start_state: StateID(0),",
          "    accel_state: StateID(2),",
          "    };",
          "    let sid = init_rev(&dfa, &input).expect(\"Failed to initialize state\");",
          "    assert!(input.start() != input.end());",
          "    let mut at = input.end() - 1;",
          "    assert!(at >= input.start());",
          "    assert!(dfa.is_special_state(sid));",
          "    assert!(dfa.is_start_state(sid));",
          "    assert!(dfa.is_accel_state(sid));",
          "    at = input.start();",
          "    let eoi_result = eoi_rev(&dfa, &input, &mut sid, &mut mat);",
          "    assert!(eoi_result.is_ok());",
          "    assert_eq!(result.unwrap(), mat);"
        ],
        "code": [
          "{",
          "    struct TestAutomaton {",
          "        special_state: StateID,",
          "        start_state: StateID,",
          "        accel_state: StateID,",
          "    }",
          "",
          "    impl Automaton for TestAutomaton {",
          "        // Implement required methods for Automaton trait...",
          "    }",
          "",
          "    let haystack: &[u8] = b\"boundary\";",
          "    let input = Input::new(haystack)",
          "        .span(Span::new(1, haystack.len()))",
          "        .anchored(Anchored::None)",
          "        .earliest(false);",
          "    ",
          "    let mut dfa = TestAutomaton {",
          "        special_state: StateID(1),",
          "        start_state: StateID(0),",
          "        accel_state: StateID(2),",
          "    };",
          "",
          "    let result = find_rev_imp(&dfa, &input, false);",
          "    let haystack: &[u8] = b\"boundary\";",
          "    let input = Input::new(haystack)",
          "    .span(Span::new(1, haystack.len()))",
          "    .anchored(Anchored::None)",
          "    .earliest(false);",
          "    let mut dfa = TestAutomaton {",
          "    special_state: StateID(1),",
          "    start_state: StateID(0),",
          "    accel_state: StateID(2),",
          "    };",
          "    let sid = init_rev(&dfa, &input).expect(\"Failed to initialize state\");",
          "    assert!(input.start() != input.end());",
          "    let mut at = input.end() - 1;",
          "    assert!(at >= input.start());",
          "    assert!(dfa.is_special_state(sid));",
          "    assert!(dfa.is_start_state(sid));",
          "    assert!(dfa.is_accel_state(sid));",
          "    at = input.start();",
          "    let eoi_result = eoi_rev(&dfa, &input, &mut sid, &mut mat);",
          "    assert!(eoi_result.is_ok());",
          "    assert_eq!(result.unwrap(), mat);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]