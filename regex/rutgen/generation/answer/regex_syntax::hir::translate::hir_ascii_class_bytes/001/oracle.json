[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 3);",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'0', b'9')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'A', b'Z')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'a', b'z')));"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 3);",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'0', b'9')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'A', b'Z')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'a', b'z')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'a', b'z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'a', b'z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'\\x00', b'\\x7F')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Blank;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'\\t', b'\\t'), hir::ClassBytesRange::new(b' ', b' ')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Cntrl;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'\\x00', b'\\x1F'), hir::ClassBytesRange::new(b'\\x7F', b'\\x7F')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'0', b'9')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'!', b'~')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'a', b'z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b' ', b'~')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'!', b'/'), hir::ClassBytesRange::new(b':', b'@'), hir::ClassBytesRange::new(b'[', b'`'), hir::ClassBytesRange::new(b'{', b'~')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'\\t', b'\\t'), hir::ClassBytesRange::new(b'\\n', b'\\n'), hir::ClassBytesRange::new(b'\\x0B', b'\\x0B'), hir::ClassBytesRange::new(b'\\x0C', b'\\x0C'), hir::ClassBytesRange::new(b'\\r', b'\\r'), hir::ClassBytesRange::new(b' ', b' ')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'A', b'Z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Word;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'_', b'_'), hir::ClassBytesRange::new(b'a', b'z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'F'), hir::ClassBytesRange::new(b'a', b'f')]));"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'a', b'z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'a', b'z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'\\x00', b'\\x7F')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Blank;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'\\t', b'\\t'), hir::ClassBytesRange::new(b' ', b' ')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Cntrl;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'\\x00', b'\\x1F'), hir::ClassBytesRange::new(b'\\x7F', b'\\x7F')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'0', b'9')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'!', b'~')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'a', b'z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b' ', b'~')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'!', b'/'), hir::ClassBytesRange::new(b':', b'@'), hir::ClassBytesRange::new(b'[', b'`'), hir::ClassBytesRange::new(b'{', b'~')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'\\t', b'\\t'), hir::ClassBytesRange::new(b'\\n', b'\\n'), hir::ClassBytesRange::new(b'\\x0B', b'\\x0B'), hir::ClassBytesRange::new(b'\\x0C', b'\\x0C'), hir::ClassBytesRange::new(b'\\r', b'\\r'), hir::ClassBytesRange::new(b' ', b' ')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'A', b'Z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Word;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'_', b'_'), hir::ClassBytesRange::new(b'a', b'z')]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'F'), hir::ClassBytesRange::new(b'a', b'f')]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&(0x00, 0x7F)), true);",
          "    assert_eq!(result.set.get(0).unwrap().start, 0x00);",
          "    assert_eq!(result.set.get(0).unwrap().end, 0x7F);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 3);",
          "    assert_eq!(result.set.contains(&(0x30, 0x39)), true);",
          "    assert_eq!(result.set.contains(&(0x41, 0x5A)), true);",
          "    assert_eq!(result.set.contains(&(0x61, 0x7A)), true);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 2);",
          "    assert_eq!(result.set.contains(&(0x41, 0x5A)), true);",
          "    assert_eq!(result.set.contains(&(0x61, 0x7A)), true);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&(0x30, 0x39)), true);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&(0x61, 0x7A)), true);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&(0x41, 0x5A)), true);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&(0x00, 0x7F)), true);",
          "    assert_eq!(result.set.get(0).unwrap().start, 0x00);",
          "    assert_eq!(result.set.get(0).unwrap().end, 0x7F);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 3);",
          "    assert_eq!(result.set.contains(&(0x30, 0x39)), true);",
          "    assert_eq!(result.set.contains(&(0x41, 0x5A)), true);",
          "    assert_eq!(result.set.contains(&(0x61, 0x7A)), true);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 2);",
          "    assert_eq!(result.set.contains(&(0x41, 0x5A)), true);",
          "    assert_eq!(result.set.contains(&(0x61, 0x7A)), true);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&(0x30, 0x39)), true);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&(0x61, 0x7A)), true);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&(0x41, 0x5A)), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Blank;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 2);",
          "    assert!(result.set.contains(&(b' ', b' ')));",
          "    assert!(result.set.contains(&(b'\\t', b'\\t')));"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Blank;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 2);",
          "    assert!(result.set.contains(&(b' ', b' ')));",
          "    assert!(result.set.contains(&(b'\\t', b'\\t')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Cntrl;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(0, 31), hir::ClassBytesRange::new(127, 127)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(48, 57), hir::ClassBytesRange::new(65, 90), hir::ClassBytesRange::new(97, 122)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(65, 90), hir::ClassBytesRange::new(97, 122)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(0, 127)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(48, 57)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(97, 122)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(65, 90)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(9, 9), hir::ClassBytesRange::new(10, 10), hir::ClassBytesRange::new(11, 11), hir::ClassBytesRange::new(12, 12), hir::ClassBytesRange::new(13, 13), hir::ClassBytesRange::new(32, 32)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(33, 126)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(33, 47), hir::ClassBytesRange::new(58, 64), hir::ClassBytesRange::new(91, 96), hir::ClassBytesRange::new(123, 126)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(48, 57), hir::ClassBytesRange::new(65, 70), hir::ClassBytesRange::new(97, 102)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(32, 126)]));"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Cntrl;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(0, 31), hir::ClassBytesRange::new(127, 127)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(48, 57), hir::ClassBytesRange::new(65, 90), hir::ClassBytesRange::new(97, 122)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(65, 90), hir::ClassBytesRange::new(97, 122)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(0, 127)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(48, 57)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(97, 122)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(65, 90)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(9, 9), hir::ClassBytesRange::new(10, 10), hir::ClassBytesRange::new(11, 11), hir::ClassBytesRange::new(12, 12), hir::ClassBytesRange::new(13, 13), hir::ClassBytesRange::new(32, 32)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(33, 126)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(33, 47), hir::ClassBytesRange::new(58, 64), hir::ClassBytesRange::new(91, 96), hir::ClassBytesRange::new(123, 126)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(48, 57), hir::ClassBytesRange::new(65, 70), hir::ClassBytesRange::new(97, 102)]));",
          "    ",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(32, 126)]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'0', b'9')), true);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'A', b'Z')), false);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'a', b'z')), false);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'0', b'9')), true);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'A', b'Z')), false);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'a', b'z')), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 1);",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'!', b'~')));"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'!', b'~')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.range(0).start, b'a');",
          "    assert_eq!(result.set.range(0).end, b'z');"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.range(0).start, b'a');",
          "    assert_eq!(result.set.range(0).end, b'z');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b' ', b'~')), true);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'A', b'Z')), false);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'a', b'c')), false);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'!', b'/')), false);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 1);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b' ', b'~')), true);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'A', b'Z')), false);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'a', b'c')), false);",
          "    assert_eq!(result.set.contains(&hir::ClassBytesRange::new(b'!', b'/')), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'!', b'/'), hir::ClassBytesRange::new(b\":\", b'@'), hir::ClassBytesRange::new(b'[', b'`'), hir::ClassBytesRange::new(b'{', b'~')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'a', b'z')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'a', b'z')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'\\t', b'\\t'), hir::ClassBytesRange::new(b'\\n', b'\\n'), hir::ClassBytesRange::new(b'\\x0B', b'\\x0B'), hir::ClassBytesRange::new(b'\\x0C', b'\\x0C'), hir::ClassBytesRange::new(b'\\r', b'\\r'), hir::ClassBytesRange::new(b' ', b' ')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'0', b'9')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b' ', b'~')];",
          "    assert_eq!(result.set, expected_ranges);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'!', b'/'), hir::ClassBytesRange::new(b\":\", b'@'), hir::ClassBytesRange::new(b'[', b'`'), hir::ClassBytesRange::new(b'{', b'~')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'a', b'z')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'A', b'Z'), hir::ClassBytesRange::new(b'a', b'z')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'\\t', b'\\t'), hir::ClassBytesRange::new(b'\\n', b'\\n'), hir::ClassBytesRange::new(b'\\x0B', b'\\x0B'), hir::ClassBytesRange::new(b'\\x0C', b'\\x0C'), hir::ClassBytesRange::new(b'\\r', b'\\r'), hir::ClassBytesRange::new(b' ', b' ')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'0', b'9')];",
          "    assert_eq!(result.set, expected_ranges);",
          "    ",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b' ', b'~')];",
          "    assert_eq!(result.set, expected_ranges);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 6);",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\t', b'\\t')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\n', b'\\n')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\x0B', b'\\x0B')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\x0C', b'\\x0C')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\r', b'\\r')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b' ', b' ')));"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 6);",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\t', b'\\t')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\n', b'\\n')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\x0B', b'\\x0B')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\x0C', b'\\x0C')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'\\r', b'\\r')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b' ', b' ')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'A', b'Z')];",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let expected_ranges = vec![hir::ClassBytesRange::new(b'A', b'Z')];",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Word;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 4);",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'0', b'9')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'A', b'Z')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'a', b'z')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'_', b'_')));"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Word;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 4);",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'0', b'9')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'A', b'Z')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'a', b'z')));",
          "    assert!(result.set.contains(&hir::ClassBytesRange::new(b'_', b'_')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.set.len(), 3);",
          "    assert!(result.set.contains(hir::ClassBytesRange::new(b'0', b'9')));",
          "    assert!(result.set.contains(hir::ClassBytesRange::new(b'A', b'F')));",
          "    assert!(result.set.contains(hir::ClassBytesRange::new(b'a', b'f')));"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    let result = hir_ascii_class_bytes(&kind);",
          "    assert_eq!(result.set.len(), 3);",
          "    assert!(result.set.contains(hir::ClassBytesRange::new(b'0', b'9')));",
          "    assert!(result.set.contains(hir::ClassBytesRange::new(b'A', b'F')));",
          "    assert!(result.set.contains(hir::ClassBytesRange::new(b'a', b'f')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]