[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let range = ClassBytesRange { start: 1, end: 2 };",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = class_bytes.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes.ranges().len(), 1);",
          "    assert_eq!(class_bytes.ranges()[0].start, 1);",
          "    assert_eq!(class_bytes.ranges()[0].end, 2);",
          "    assert!(formatter.is_empty());",
          "    assert!(matches!(class_bytes, Class::Bytes(_)));",
          "    assert!(class_bytes.is_ascii());",
          "    assert!(class_bytes.minimum_len().is_none());",
          "    assert!(class_bytes.maximum_len().is_none());",
          "    let literal_result = class_bytes.literal();",
          "    assert!(literal_result.is_none());",
          "    let unicode_class = class_bytes.to_unicode_class();",
          "    assert!(unicode_class.is_none());"
        ],
        "code": [
          "{",
          "    let range = ClassBytesRange { start: 1, end: 2 };",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = class_bytes.fmt(&mut formatter);",
          "    assert_eq!(class_bytes.ranges().len(), 1);",
          "    assert_eq!(class_bytes.ranges()[0].start, 1);",
          "    assert_eq!(class_bytes.ranges()[0].end, 2);",
          "    assert!(formatter.is_empty());",
          "    assert!(matches!(class_bytes, Class::Bytes(_)));",
          "    assert!(class_bytes.is_ascii());",
          "    assert!(class_bytes.minimum_len().is_none());",
          "    assert!(class_bytes.maximum_len().is_none());",
          "    let literal_result = class_bytes.literal();",
          "    assert!(literal_result.is_none());",
          "    let unicode_class = class_bytes.to_unicode_class();",
          "    assert!(unicode_class.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassBytesRange { start: 1, end: 3 },",
          "        ClassBytesRange { start: 5, end: 7 },",
          "    ];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = class_bytes.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(formatter.content(), \"{Byte(1)..=Byte(3), Byte(5)..=Byte(7)}\");",
          "    assert!(class_bytes.is_ascii());",
          "    assert_eq!(class_bytes.minimum_len(), Some(1));",
          "    assert_eq!(class_bytes.maximum_len(), Some(2));",
          "    assert!(class_bytes.literal().is_none());"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassBytesRange { start: 1, end: 3 },",
          "        ClassBytesRange { start: 5, end: 7 },",
          "    ];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = class_bytes.fmt(&mut formatter);",
          "    assert_eq!(formatter.content(), \"{Byte(1)..=Byte(3), Byte(5)..=Byte(7)}\");",
          "    assert!(class_bytes.is_ascii());",
          "    assert_eq!(class_bytes.minimum_len(), Some(1));",
          "    assert_eq!(class_bytes.maximum_len(), Some(2));",
          "    assert!(class_bytes.literal().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_bytes = ClassBytes::empty();",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = class_bytes.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0x20, end: 0x7E }]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    assert_eq!(class_bytes.fmt(&mut formatter), Ok(()));",
          "    assert!(formatter.to_string().contains(\"20..7E\"));",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    assert_eq!(class_bytes.fmt(&mut formatter), Ok(()));",
          "    assert!(formatter.to_string().contains(\"30..39\"));",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0x00 }]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    assert_eq!(class_bytes.fmt(&mut formatter), Ok(()));",
          "    assert!(formatter.to_string().is_empty());",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    assert_eq!(class_bytes.fmt(&mut formatter), Ok(()));",
          "    assert!(formatter.to_string().is_empty());"
        ],
        "code": [
          "{",
          "    let class_bytes = ClassBytes::empty();",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = class_bytes.fmt(&mut formatter);",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0x20, end: 0x7E }]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    assert_eq!(class_bytes.fmt(&mut formatter), Ok(()));",
          "    assert!(formatter.to_string().contains(\"20..7E\"));",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    assert_eq!(class_bytes.fmt(&mut formatter), Ok(()));",
          "    assert!(formatter.to_string().contains(\"30..39\"));",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0x00 }]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    assert_eq!(class_bytes.fmt(&mut formatter), Ok(()));",
          "    assert!(formatter.to_string().is_empty());",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![]);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    assert_eq!(class_bytes.fmt(&mut formatter), Ok(()));",
          "    assert!(formatter.to_string().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassBytesRange { start: 1, end: 5 },",
          "        ClassBytesRange { start: 3, end: 7 },",
          "    ];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = class_bytes.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    let ranges = vec![ClassBytesRange { start: 1, end: 5 }, ClassBytesRange { start: 3, end: 7 }];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let result = class_bytes.fmt(&mut formatter);",
          "    assert_eq!(result, core::fmt::Result::Ok);",
          "    assert!(matches!(class_bytes, Class::Bytes(_)));",
          "    assert!(!class_bytes.ranges().is_empty());",
          "    for range in class_bytes.ranges() {",
          "    assert!(range.start <= range.end);",
          "    }"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassBytesRange { start: 1, end: 5 },",
          "        ClassBytesRange { start: 3, end: 7 },",
          "    ];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = class_bytes.fmt(&mut formatter);",
          "    let ranges = vec![ClassBytesRange { start: 1, end: 5 }, ClassBytesRange { start: 3, end: 7 }];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let result = class_bytes.fmt(&mut formatter);",
          "    assert_eq!(result, core::fmt::Result::Ok);",
          "    assert!(matches!(class_bytes, Class::Bytes(_)));",
          "    assert!(!class_bytes.ranges().is_empty());",
          "    for range in class_bytes.ranges() {",
          "    assert!(range.start <= range.end);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]