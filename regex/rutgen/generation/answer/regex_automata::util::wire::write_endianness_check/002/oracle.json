[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(val: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&val.to_le_bytes());",
          "        }",
          "    }",
          "",
          "    let mut buffer = [0u8; 4];",
          "    let result = write_endianness_check::<LittleEndian>(&mut buffer);",
          "    let expected = Ok(4);",
          "    // The assertion is omitted as per guidelines, but this will check",
          "    // that buffer contains the bytes representing 0xFEFF in little-endian.",
          "}"
        ],
        "oracle": [
          "    let buffer = [0u8; 4];",
          "    let result = write_endianness_check::<LittleEndian>(&mut buffer);",
          "    let expected = Ok(4);",
          "    assert_eq!(result, expected);",
          "    assert_eq!(buffer, [0xFF, 0xFE, 0x00, 0x00]);"
        ],
        "code": [
          "{",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(val: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&val.to_le_bytes());",
          "        }",
          "    }",
          "",
          "    let mut buffer = [0u8; 4];",
          "    let result = write_endianness_check::<LittleEndian>(&mut buffer);",
          "    let expected = Ok(4);",
          "    // The assertion is omitted as per guidelines, but this will check",
          "    // that buffer contains the bytes representing 0xFEFF in little-endian.",
          "    let buffer = [0u8; 4];",
          "    let result = write_endianness_check::<LittleEndian>(&mut buffer);",
          "    let expected = Ok(4);",
          "    assert_eq!(result, expected);",
          "    assert_eq!(buffer, [0xFF, 0xFE, 0x00, 0x00]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct BigEndian;",
          "    impl Endian for BigEndian {",
          "        fn write_u32(val: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&val.to_be_bytes());",
          "        }",
          "    }",
          "",
          "    let mut buffer = [0u8; 4];",
          "    let result = write_endianness_check::<BigEndian>(&mut buffer);",
          "    let expected = Ok(4);",
          "    // The assertion is omitted as per guidelines, but this will check",
          "    // that buffer contains the bytes representing 0xFEFF in big-endian.",
          "}"
        ],
        "oracle": [
          "    let result = write_endianness_check::<BigEndian>(&mut buffer);",
          "    let expected = Ok(4);",
          "    assert_eq!(result, expected);",
          "    assert_eq!(buffer, [0xFE, 0xFF, 0x00, 0x00]);"
        ],
        "code": [
          "{",
          "    struct BigEndian;",
          "    impl Endian for BigEndian {",
          "        fn write_u32(val: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&val.to_be_bytes());",
          "        }",
          "    }",
          "",
          "    let mut buffer = [0u8; 4];",
          "    let result = write_endianness_check::<BigEndian>(&mut buffer);",
          "    let expected = Ok(4);",
          "    // The assertion is omitted as per guidelines, but this will check",
          "    // that buffer contains the bytes representing 0xFEFF in big-endian.",
          "    let result = write_endianness_check::<BigEndian>(&mut buffer);",
          "    let expected = Ok(4);",
          "    assert_eq!(result, expected);",
          "    assert_eq!(buffer, [0xFE, 0xFF, 0x00, 0x00]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]