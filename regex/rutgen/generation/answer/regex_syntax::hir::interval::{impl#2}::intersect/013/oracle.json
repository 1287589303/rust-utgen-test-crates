[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]",
          "    struct Bound(u32);",
          "    ",
          "    impl Bound {",
          "        fn decrement(&self) -> Self {",
          "            Bound(self.0 - 1)",
          "        }",
          "        fn increment(&self) -> Self {",
          "            Bound(self.0 + 1)",
          "        }",
          "    }",
          "    ",
          "    #[derive(Clone, Debug, Default, PartialEq, PartialOrd)]",
          "    struct TestInterval {",
          "        lower: Bound,",
          "        upper: Bound,",
          "    }",
          "    ",
          "    impl Interval for TestInterval {",
          "        type Bound = Bound;",
          "        ",
          "        fn lower(&self) -> Self::Bound {",
          "            self.lower",
          "        }",
          "        fn upper(&self) -> Self::Bound {",
          "            self.upper",
          "        }",
          "        fn set_lower(&mut self, bound: Self::Bound) {",
          "            self.lower = bound;",
          "        }",
          "        fn set_upper(&mut self, bound: Self::Bound) {",
          "            self.upper = bound;",
          "        }",
          "        fn case_fold_simple(&self, _: &mut Vec<Self>) -> Result<(), unicode::CaseFoldError> {",
          "            Ok(())",
          "        }",
          "        fn is_contiguous(&self, other: &Self) -> bool {",
          "            self.upper >= other.lower",
          "        }",
          "        fn is_intersection_empty(&self, other: &Self) -> bool {",
          "            self.lower > other.upper || self.upper < other.lower",
          "        }",
          "        fn is_subset(&self, other: &Self) -> bool {",
          "            self.lower >= other.lower && self.upper <= other.upper",
          "        }",
          "    }",
          "",
          "    let mut set_a = IntervalSet::new(vec![",
          "        TestInterval { lower: Bound(1), upper: Bound(5) },",
          "        TestInterval { lower: Bound(6), upper: Bound(10) },",
          "    ]);",
          "    ",
          "    let set_b = IntervalSet::new(vec![",
          "        TestInterval { lower: Bound(3), upper: Bound(7) },",
          "        TestInterval { lower: Bound(8), upper: Bound(12) },",
          "    ]);",
          "    ",
          "    set_a.folded = true;",
          "",
          "    set_a.intersect(&set_b);",
          "}"
        ],
        "oracle": [
          "    assert!(!set_a.ranges.is_empty());",
          "    assert!(!set_b.ranges.is_empty());",
          "    assert_eq!(set_a.ranges.len(), 2);",
          "    assert!(set_a.ranges[0].intersect(&set_b.ranges[0]).is_some());",
          "    assert!(set_a.ranges[1].intersect(&set_b.ranges[1]).is_some());",
          "    assert!(set_a.ranges[0].upper() < set_b.ranges[1].upper());",
          "    assert!(set_a.ranges[1].upper() < set_b.ranges[1].upper());",
          "    assert_eq!(set_a.folded, true);"
        ],
        "code": [
          "{",
          "    #[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]",
          "    struct Bound(u32);",
          "    ",
          "    impl Bound {",
          "        fn decrement(&self) -> Self {",
          "            Bound(self.0 - 1)",
          "        }",
          "        fn increment(&self) -> Self {",
          "            Bound(self.0 + 1)",
          "        }",
          "    }",
          "    ",
          "    #[derive(Clone, Debug, Default, PartialEq, PartialOrd)]",
          "    struct TestInterval {",
          "        lower: Bound,",
          "        upper: Bound,",
          "    }",
          "    ",
          "    impl Interval for TestInterval {",
          "        type Bound = Bound;",
          "        ",
          "        fn lower(&self) -> Self::Bound {",
          "            self.lower",
          "        }",
          "        fn upper(&self) -> Self::Bound {",
          "            self.upper",
          "        }",
          "        fn set_lower(&mut self, bound: Self::Bound) {",
          "            self.lower = bound;",
          "        }",
          "        fn set_upper(&mut self, bound: Self::Bound) {",
          "            self.upper = bound;",
          "        }",
          "        fn case_fold_simple(&self, _: &mut Vec<Self>) -> Result<(), unicode::CaseFoldError> {",
          "            Ok(())",
          "        }",
          "        fn is_contiguous(&self, other: &Self) -> bool {",
          "            self.upper >= other.lower",
          "        }",
          "        fn is_intersection_empty(&self, other: &Self) -> bool {",
          "            self.lower > other.upper || self.upper < other.lower",
          "        }",
          "        fn is_subset(&self, other: &Self) -> bool {",
          "            self.lower >= other.lower && self.upper <= other.upper",
          "        }",
          "    }",
          "",
          "    let mut set_a = IntervalSet::new(vec![",
          "        TestInterval { lower: Bound(1), upper: Bound(5) },",
          "        TestInterval { lower: Bound(6), upper: Bound(10) },",
          "    ]);",
          "    ",
          "    let set_b = IntervalSet::new(vec![",
          "        TestInterval { lower: Bound(3), upper: Bound(7) },",
          "        TestInterval { lower: Bound(8), upper: Bound(12) },",
          "    ]);",
          "    ",
          "    set_a.folded = true;",
          "",
          "    set_a.intersect(&set_b);",
          "    assert!(!set_a.ranges.is_empty());",
          "    assert!(!set_b.ranges.is_empty());",
          "    assert_eq!(set_a.ranges.len(), 2);",
          "    assert!(set_a.ranges[0].intersect(&set_b.ranges[0]).is_some());",
          "    assert!(set_a.ranges[1].intersect(&set_b.ranges[1]).is_some());",
          "    assert!(set_a.ranges[0].upper() < set_b.ranges[1].upper());",
          "    assert!(set_a.ranges[1].upper() < set_b.ranges[1].upper());",
          "    assert_eq!(set_a.folded, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]",
          "    struct Bound(u32);",
          "    ",
          "    impl Bound {",
          "        fn decrement(&self) -> Self {",
          "            Bound(self.0 - 1)",
          "        }",
          "        fn increment(&self) -> Self {",
          "            Bound(self.0 + 1)",
          "        }",
          "    }",
          "    ",
          "    #[derive(Clone, Debug, Default, PartialEq, PartialOrd)]",
          "    struct TestInterval {",
          "        lower: Bound,",
          "        upper: Bound,",
          "    }",
          "    ",
          "    impl Interval for TestInterval {",
          "        type Bound = Bound;",
          "        ",
          "        fn lower(&self) -> Self::Bound {",
          "            self.lower",
          "        }",
          "        fn upper(&self) -> Self::Bound {",
          "            self.upper",
          "        }",
          "        fn set_lower(&mut self, bound: Self::Bound) {",
          "            self.lower = bound;",
          "        }",
          "        fn set_upper(&mut self, bound: Self::Bound) {",
          "            self.upper = bound;",
          "        }",
          "        fn case_fold_simple(&self, _: &mut Vec<Self>) -> Result<(), unicode::CaseFoldError> {",
          "            Ok(())",
          "        }",
          "        fn is_contiguous(&self, other: &Self) -> bool {",
          "            self.upper >= other.lower",
          "        }",
          "        fn is_intersection_empty(&self, other: &Self) -> bool {",
          "            self.lower > other.upper || self.upper < other.lower",
          "        }",
          "        fn is_subset(&self, other: &Self) -> bool {",
          "            self.lower >= other.lower && self.upper <= other.upper",
          "        }",
          "    }",
          "",
          "    let mut set_a = IntervalSet::new(vec![",
          "        TestInterval { lower: Bound(2), upper: Bound(6) },",
          "        TestInterval { lower: Bound(7), upper: Bound(12) },",
          "    ]);",
          "    ",
          "    let set_b = IntervalSet::new(vec![",
          "        TestInterval { lower: Bound(4), upper: Bound(8) },",
          "        TestInterval { lower: Bound(9), upper: Bound(15) },",
          "    ]);",
          "    ",
          "    set_a.folded = true;",
          "",
          "    set_a.intersect(&set_b);",
          "}"
        ],
        "oracle": [
          "    assert!(!set_a.ranges.is_empty());",
          "    assert!(!set_b.ranges.is_empty());",
          "    assert_eq!(set_a.ranges.len(), 3);",
          "    assert_eq!(set_a.ranges[0].lower(), Bound(4));",
          "    assert_eq!(set_a.ranges[0].upper(), Bound(6));",
          "    assert_eq!(set_a.ranges[1].lower(), Bound(7));",
          "    assert_eq!(set_a.ranges[1].upper(), Bound(8));",
          "    assert_eq!(set_a.ranges[2].lower(), Bound(9));",
          "    assert_eq!(set_a.ranges[2].upper(), Bound(12));",
          "    assert!(set_a.folded);"
        ],
        "code": [
          "{",
          "    #[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]",
          "    struct Bound(u32);",
          "    ",
          "    impl Bound {",
          "        fn decrement(&self) -> Self {",
          "            Bound(self.0 - 1)",
          "        }",
          "        fn increment(&self) -> Self {",
          "            Bound(self.0 + 1)",
          "        }",
          "    }",
          "    ",
          "    #[derive(Clone, Debug, Default, PartialEq, PartialOrd)]",
          "    struct TestInterval {",
          "        lower: Bound,",
          "        upper: Bound,",
          "    }",
          "    ",
          "    impl Interval for TestInterval {",
          "        type Bound = Bound;",
          "        ",
          "        fn lower(&self) -> Self::Bound {",
          "            self.lower",
          "        }",
          "        fn upper(&self) -> Self::Bound {",
          "            self.upper",
          "        }",
          "        fn set_lower(&mut self, bound: Self::Bound) {",
          "            self.lower = bound;",
          "        }",
          "        fn set_upper(&mut self, bound: Self::Bound) {",
          "            self.upper = bound;",
          "        }",
          "        fn case_fold_simple(&self, _: &mut Vec<Self>) -> Result<(), unicode::CaseFoldError> {",
          "            Ok(())",
          "        }",
          "        fn is_contiguous(&self, other: &Self) -> bool {",
          "            self.upper >= other.lower",
          "        }",
          "        fn is_intersection_empty(&self, other: &Self) -> bool {",
          "            self.lower > other.upper || self.upper < other.lower",
          "        }",
          "        fn is_subset(&self, other: &Self) -> bool {",
          "            self.lower >= other.lower && self.upper <= other.upper",
          "        }",
          "    }",
          "",
          "    let mut set_a = IntervalSet::new(vec![",
          "        TestInterval { lower: Bound(2), upper: Bound(6) },",
          "        TestInterval { lower: Bound(7), upper: Bound(12) },",
          "    ]);",
          "    ",
          "    let set_b = IntervalSet::new(vec![",
          "        TestInterval { lower: Bound(4), upper: Bound(8) },",
          "        TestInterval { lower: Bound(9), upper: Bound(15) },",
          "    ]);",
          "    ",
          "    set_a.folded = true;",
          "",
          "    set_a.intersect(&set_b);",
          "    assert!(!set_a.ranges.is_empty());",
          "    assert!(!set_b.ranges.is_empty());",
          "    assert_eq!(set_a.ranges.len(), 3);",
          "    assert_eq!(set_a.ranges[0].lower(), Bound(4));",
          "    assert_eq!(set_a.ranges[0].upper(), Bound(6));",
          "    assert_eq!(set_a.ranges[1].lower(), Bound(7));",
          "    assert_eq!(set_a.ranges[1].upper(), Bound(8));",
          "    assert_eq!(set_a.ranges[2].lower(), Bound(9));",
          "    assert_eq!(set_a.ranges[2].upper(), Bound(12));",
          "    assert!(set_a.folded);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]