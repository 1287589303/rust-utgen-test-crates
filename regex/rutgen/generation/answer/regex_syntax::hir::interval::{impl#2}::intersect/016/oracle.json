[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
      "struct TestBound(u32);",
      "",
      "impl TestBound {",
      "    fn increment(&self) -> Self {",
      "        TestBound(self.0 + 1)",
      "    }",
      "    fn decrement(&self) -> Self {",
      "        TestBound(self.0 - 1)",
      "    }",
      "}",
      "",
      "#[derive(Clone, Debug, Default, PartialEq, Eq)]",
      "struct TestInterval {",
      "    lower: TestBound,",
      "    upper: TestBound,",
      "}",
      "",
      "impl Interval for TestInterval {",
      "    type Bound = TestBound;",
      "",
      "    fn lower(&self) -> Self::Bound {",
      "        self.lower",
      "    }",
      "",
      "    fn upper(&self) -> Self::Bound {",
      "        self.upper",
      "    }",
      "",
      "    fn set_lower(&mut self, bound: Self::Bound) {",
      "        self.lower = bound;",
      "    }",
      "",
      "    fn set_upper(&mut self, bound: Self::Bound) {",
      "        self.upper = bound;",
      "    }",
      "",
      "    fn case_fold_simple(",
      "        &self,",
      "        intervals: &mut Vec<Self>,",
      "    ) -> Result<(), unicode::CaseFoldError> {",
      "        Ok(())",
      "    }",
      "",
      "    fn is_contiguous(&self, other: &Self) -> bool {",
      "        self.upper < other.lower || self.lower > other.upper",
      "    }",
      "",
      "    fn is_intersection_empty(&self, other: &Self) -> bool {",
      "        self.upper < other.lower || self.lower > other.upper",
      "    }",
      "",
      "    fn is_subset(&self, other: &Self) -> bool {",
      "        self.lower >= other.lower && self.upper <= other.upper",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(1),",
          "            upper: TestBound(5),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(6),",
          "            upper: TestBound(10),",
          "        },",
          "    ];",
          "    ",
          "    let other_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(4),",
          "            upper: TestBound(10),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(11),",
          "            upper: TestBound(15),",
          "        },",
          "    ];",
          "",
          "    let mut self_set = IntervalSet::new(self_intervals);",
          "    let other_set = IntervalSet::new(other_intervals);",
          "",
          "    self_set.intersect(&other_set);",
          "}"
        ],
        "oracle": [
          "    self_set.ranges.is_empty() == false",
          "    other_set.ranges.is_empty() == false",
          "    let Some(ab) = self_set.ranges[0].intersect(&other_set.ranges[0]) == true",
          "    self_set.ranges[0].upper() == other_set.ranges[0].upper()",
          "    it.next() == Some(1)",
          "    it.next() == Some(2)",
          "    let Some(ab) = self_set.ranges[0].intersect(&other_set.ranges[0]) == true",
          "    self_set.ranges[0].upper() < other_set.ranges[1].upper() == true",
          "    it.next() == None",
          "    self_set.folded == false"
        ],
        "code": [
          "{",
          "    let mut self_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(1),",
          "            upper: TestBound(5),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(6),",
          "            upper: TestBound(10),",
          "        },",
          "    ];",
          "    ",
          "    let other_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(4),",
          "            upper: TestBound(10),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(11),",
          "            upper: TestBound(15),",
          "        },",
          "    ];",
          "",
          "    let mut self_set = IntervalSet::new(self_intervals);",
          "    let other_set = IntervalSet::new(other_intervals);",
          "",
          "    self_set.intersect(&other_set);",
          "    self_set.ranges.is_empty() == false",
          "    other_set.ranges.is_empty() == false",
          "    let Some(ab) = self_set.ranges[0].intersect(&other_set.ranges[0]) == true",
          "    self_set.ranges[0].upper() == other_set.ranges[0].upper()",
          "    it.next() == Some(1)",
          "    it.next() == Some(2)",
          "    let Some(ab) = self_set.ranges[0].intersect(&other_set.ranges[0]) == true",
          "    self_set.ranges[0].upper() < other_set.ranges[1].upper() == true",
          "    it.next() == None",
          "    self_set.folded == false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(1),",
          "            upper: TestBound(5),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(6),",
          "            upper: TestBound(5),",
          "        },",
          "    ];",
          "",
          "    let other_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(4),",
          "            upper: TestBound(5),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(5),",
          "            upper: TestBound(10),",
          "        },",
          "    ];",
          "",
          "    let mut self_set = IntervalSet::new(self_intervals);",
          "    let other_set = IntervalSet::new(other_intervals);",
          "",
          "    self_set.intersect(&other_set);",
          "}"
        ],
        "oracle": [
          "    self_set.ranges.is_empty() == false",
          "    other_set.ranges.is_empty() == false",
          "    self_set.ranges[0].intersect(&other_set.ranges[0]).is_some() == true",
          "    self_set.ranges[0].upper() == other_set.ranges[0].upper()",
          "    it.next().is_some() == true",
          "    it.next().is_some() == true",
          "    self_set.ranges[0].intersect(&other_set.ranges[0]).is_some() == true",
          "    self_set.ranges[0].upper() < other_set.ranges[1].upper() == true",
          "    it.next().is_some() == false",
          "    self_set.folded == false"
        ],
        "code": [
          "{",
          "    let mut self_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(1),",
          "            upper: TestBound(5),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(6),",
          "            upper: TestBound(5),",
          "        },",
          "    ];",
          "",
          "    let other_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(4),",
          "            upper: TestBound(5),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(5),",
          "            upper: TestBound(10),",
          "        },",
          "    ];",
          "",
          "    let mut self_set = IntervalSet::new(self_intervals);",
          "    let other_set = IntervalSet::new(other_intervals);",
          "",
          "    self_set.intersect(&other_set);",
          "    self_set.ranges.is_empty() == false",
          "    other_set.ranges.is_empty() == false",
          "    self_set.ranges[0].intersect(&other_set.ranges[0]).is_some() == true",
          "    self_set.ranges[0].upper() == other_set.ranges[0].upper()",
          "    it.next().is_some() == true",
          "    it.next().is_some() == true",
          "    self_set.ranges[0].intersect(&other_set.ranges[0]).is_some() == true",
          "    self_set.ranges[0].upper() < other_set.ranges[1].upper() == true",
          "    it.next().is_some() == false",
          "    self_set.folded == false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(2),",
          "            upper: TestBound(5),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(5),",
          "            upper: TestBound(7),",
          "        },",
          "    ];",
          "",
          "    let other_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(5),",
          "            upper: TestBound(8),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(6),",
          "            upper: TestBound(10),",
          "        },",
          "    ];",
          "",
          "    let mut self_set = IntervalSet::new(self_intervals);",
          "    let other_set = IntervalSet::new(other_intervals);",
          "    self_set.folded = false;",
          "",
          "    self_set.intersect(&other_set);",
          "}"
        ],
        "oracle": [
          "    let mut self_intervals = vec![",
          "    TestInterval { lower: TestBound(2), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(5), upper: TestBound(7) },",
          "    ];",
          "    let other_intervals = vec![",
          "    TestInterval { lower: TestBound(5), upper: TestBound(8) },",
          "    TestInterval { lower: TestBound(6), upper: TestBound(10) },",
          "    ];",
          "    assert!(!self_intervals.is_empty());",
          "    assert!(!other_intervals.is_empty());",
          "    let mut self_set = IntervalSet::new(self_intervals);",
          "    let other_set = IntervalSet::new(other_intervals);",
          "    assert!(self_set.ranges.len() > 0);",
          "    assert!(other_set.ranges.len() > 0);",
          "    self_set.intersect(&other_set);",
          "    assert_eq!(self_set.folded, false);",
          "    assert!(self_set.ranges.iter().all(|x| x.intersect(&other_set.ranges[0]).is_some()));",
          "    assert!(self_set.ranges.iter().any(|x| x.upper() == other_set.ranges[0].upper()));",
          "    assert!(self_set.ranges.iter().any(|x| x.upper() < other_set.ranges[0].upper()));",
          "    assert!(self_set.ranges.iter().all(|x| x.intersect(&other_set.ranges[1]).is_some()));",
          "    assert!(self_set.ranges.last().unwrap().upper() == other_set.ranges[1].upper());",
          "    assert!(self_set.ranges.last().unwrap().upper() < other_set.ranges[1].upper());",
          "    assert!(self_set.ranges.len() > 0);",
          "    assert!(self_set.ranges.len() > 0);"
        ],
        "code": [
          "{",
          "    let mut self_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(2),",
          "            upper: TestBound(5),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(5),",
          "            upper: TestBound(7),",
          "        },",
          "    ];",
          "",
          "    let other_intervals = vec![",
          "        TestInterval {",
          "            lower: TestBound(5),",
          "            upper: TestBound(8),",
          "        },",
          "        TestInterval {",
          "            lower: TestBound(6),",
          "            upper: TestBound(10),",
          "        },",
          "    ];",
          "",
          "    let mut self_set = IntervalSet::new(self_intervals);",
          "    let other_set = IntervalSet::new(other_intervals);",
          "    self_set.folded = false;",
          "",
          "    self_set.intersect(&other_set);",
          "    let mut self_intervals = vec![",
          "    TestInterval { lower: TestBound(2), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(5), upper: TestBound(7) },",
          "    ];",
          "    let other_intervals = vec![",
          "    TestInterval { lower: TestBound(5), upper: TestBound(8) },",
          "    TestInterval { lower: TestBound(6), upper: TestBound(10) },",
          "    ];",
          "    assert!(!self_intervals.is_empty());",
          "    assert!(!other_intervals.is_empty());",
          "    let mut self_set = IntervalSet::new(self_intervals);",
          "    let other_set = IntervalSet::new(other_intervals);",
          "    assert!(self_set.ranges.len() > 0);",
          "    assert!(other_set.ranges.len() > 0);",
          "    self_set.intersect(&other_set);",
          "    assert_eq!(self_set.folded, false);",
          "    assert!(self_set.ranges.iter().all(|x| x.intersect(&other_set.ranges[0]).is_some()));",
          "    assert!(self_set.ranges.iter().any(|x| x.upper() == other_set.ranges[0].upper()));",
          "    assert!(self_set.ranges.iter().any(|x| x.upper() < other_set.ranges[0].upper()));",
          "    assert!(self_set.ranges.iter().all(|x| x.intersect(&other_set.ranges[1]).is_some()));",
          "    assert!(self_set.ranges.last().unwrap().upper() == other_set.ranges[1].upper());",
          "    assert!(self_set.ranges.last().unwrap().upper() < other_set.ranges[1].upper());",
          "    assert!(self_set.ranges.len() > 0);",
          "    assert!(self_set.ranges.len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]