[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = Vec::new();",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 0;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _result = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    let expected_table: &[u32] = &[];",
          "    let expected_kind = StartKind::Both;",
          "    let expected_start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let expected_stride = 0;",
          "    let expected_pattern_len = None;",
          "    let expected_universal_start_unanchored: Option<StateID> = None;",
          "    let expected_universal_start_anchored: Option<StateID> = None;",
          "    assert_eq!(_result.table, expected_table);",
          "    assert_eq!(_result.kind, expected_kind);",
          "    assert_eq!(_result.start_map, expected_start_map);",
          "    assert_eq!(_result.stride, expected_stride);",
          "    assert_eq!(_result.pattern_len, expected_pattern_len);",
          "    assert_eq!(_result.universal_start_unanchored, expected_universal_start_unanchored);",
          "    assert_eq!(_result.universal_start_anchored, expected_universal_start_anchored);"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = Vec::new();",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 0;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _result = start_table.as_ref();",
          "    let expected_table: &[u32] = &[];",
          "    let expected_kind = StartKind::Both;",
          "    let expected_start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let expected_stride = 0;",
          "    let expected_pattern_len = None;",
          "    let expected_universal_start_unanchored: Option<StateID> = None;",
          "    let expected_universal_start_anchored: Option<StateID> = None;",
          "    assert_eq!(_result.table, expected_table);",
          "    assert_eq!(_result.kind, expected_kind);",
          "    assert_eq!(_result.start_map, expected_start_map);",
          "    assert_eq!(_result.stride, expected_stride);",
          "    assert_eq!(_result.pattern_len, expected_pattern_len);",
          "    assert_eq!(_result.universal_start_unanchored, expected_universal_start_unanchored);",
          "    assert_eq!(_result.universal_start_anchored, expected_universal_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = vec![1];",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 1;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored: Option<StateID> = Some(StateID(0));",
          "    let universal_start_anchored: Option<StateID> = None;",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _result = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.table, start_table.table.as_ref());",
          "    assert_eq!(_result.kind, start_table.kind);",
          "    assert_eq!(_result.start_map, start_table.start_map.clone());",
          "    assert_eq!(_result.stride, start_table.stride);",
          "    assert_eq!(_result.pattern_len, start_table.pattern_len);",
          "    assert_eq!(_result.universal_start_unanchored, start_table.universal_start_unanchored);",
          "    assert_eq!(_result.universal_start_anchored, start_table.universal_start_anchored);"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = vec![1];",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 1;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored: Option<StateID> = Some(StateID(0));",
          "    let universal_start_anchored: Option<StateID> = None;",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _result = start_table.as_ref();",
          "    assert_eq!(_result.table, start_table.table.as_ref());",
          "    assert_eq!(_result.kind, start_table.kind);",
          "    assert_eq!(_result.start_map, start_table.start_map.clone());",
          "    assert_eq!(_result.stride, start_table.stride);",
          "    assert_eq!(_result.pattern_len, start_table.pattern_len);",
          "    assert_eq!(_result.universal_start_unanchored, start_table.universal_start_unanchored);",
          "    assert_eq!(_result.universal_start_anchored, start_table.universal_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = (0..256).collect();",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 4;",
          "    let pattern_len = Some(5);",
          "    let universal_start_unanchored: Option<StateID> = Some(StateID(1));",
          "    let universal_start_anchored: Option<StateID> = Some(StateID(2));",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _result = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    let expected_table: &[u32] = (0..256).collect::<Vec<u32>>().as_slice();",
          "    let expected_start_table = StartTable {",
          "    table: expected_table,",
          "    kind: StartKind::Anchored,",
          "    start_map: StartByteMap { map: [Start::default(); 256] },",
          "    stride: 4,",
          "    pattern_len: Some(5),",
          "    universal_start_unanchored: Some(StateID(1)),",
          "    universal_start_anchored: Some(StateID(2)),",
          "    };",
          "    assert_eq!(_result.table, expected_start_table.table);",
          "    assert_eq!(_result.kind, expected_start_table.kind);",
          "    assert_eq!(_result.start_map, expected_start_table.start_map);",
          "    assert_eq!(_result.stride, expected_start_table.stride);",
          "    assert_eq!(_result.pattern_len, expected_start_table.pattern_len);",
          "    assert_eq!(_result.universal_start_unanchored, expected_start_table.universal_start_unanchored);",
          "    assert_eq!(_result.universal_start_anchored, expected_start_table.universal_start_anchored);"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = (0..256).collect();",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 4;",
          "    let pattern_len = Some(5);",
          "    let universal_start_unanchored: Option<StateID> = Some(StateID(1));",
          "    let universal_start_anchored: Option<StateID> = Some(StateID(2));",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _result = start_table.as_ref();",
          "    let expected_table: &[u32] = (0..256).collect::<Vec<u32>>().as_slice();",
          "    let expected_start_table = StartTable {",
          "    table: expected_table,",
          "    kind: StartKind::Anchored,",
          "    start_map: StartByteMap { map: [Start::default(); 256] },",
          "    stride: 4,",
          "    pattern_len: Some(5),",
          "    universal_start_unanchored: Some(StateID(1)),",
          "    universal_start_anchored: Some(StateID(2)),",
          "    };",
          "    assert_eq!(_result.table, expected_start_table.table);",
          "    assert_eq!(_result.kind, expected_start_table.kind);",
          "    assert_eq!(_result.start_map, expected_start_table.start_map);",
          "    assert_eq!(_result.stride, expected_start_table.stride);",
          "    assert_eq!(_result.pattern_len, expected_start_table.pattern_len);",
          "    assert_eq!(_result.universal_start_unanchored, expected_start_table.universal_start_unanchored);",
          "    assert_eq!(_result.universal_start_anchored, expected_start_table.universal_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = (0..256).collect();",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 8;",
          "    let pattern_len = Some(10);",
          "    let universal_start_unanchored: Option<StateID> = Some(StateID(3));",
          "    let universal_start_anchored: Option<StateID> = Some(StateID(4));",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _result = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    let expected_table: &[u32] = (0..256).collect::<Vec<u32>>().as_ref();",
          "    let expected_kind = StartKind::Both;",
          "    let expected_start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let expected_stride = 8;",
          "    let expected_pattern_len = Some(10);",
          "    let expected_universal_start_unanchored: Option<StateID> = Some(StateID(3));",
          "    let expected_universal_start_anchored: Option<StateID> = Some(StateID(4));",
          "    let expected_result = StartTable {",
          "    table: expected_table,",
          "    kind: expected_kind,",
          "    start_map: expected_start_map.clone(),",
          "    stride: expected_stride,",
          "    pattern_len: expected_pattern_len,",
          "    universal_start_unanchored: expected_universal_start_unanchored,",
          "    universal_start_anchored: expected_universal_start_anchored,",
          "    };",
          "    assert_eq!(_result.table, expected_result.table);",
          "    assert_eq!(_result.kind, expected_result.kind);",
          "    assert_eq!(_result.start_map, expected_result.start_map);",
          "    assert_eq!(_result.stride, expected_result.stride);",
          "    assert_eq!(_result.pattern_len, expected_result.pattern_len);",
          "    assert_eq!(_result.universal_start_unanchored, expected_result.universal_start_unanchored);",
          "    assert_eq!(_result.universal_start_anchored, expected_result.universal_start_anchored);"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = (0..256).collect();",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 8;",
          "    let pattern_len = Some(10);",
          "    let universal_start_unanchored: Option<StateID> = Some(StateID(3));",
          "    let universal_start_anchored: Option<StateID> = Some(StateID(4));",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _result = start_table.as_ref();",
          "    let expected_table: &[u32] = (0..256).collect::<Vec<u32>>().as_ref();",
          "    let expected_kind = StartKind::Both;",
          "    let expected_start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let expected_stride = 8;",
          "    let expected_pattern_len = Some(10);",
          "    let expected_universal_start_unanchored: Option<StateID> = Some(StateID(3));",
          "    let expected_universal_start_anchored: Option<StateID> = Some(StateID(4));",
          "    let expected_result = StartTable {",
          "    table: expected_table,",
          "    kind: expected_kind,",
          "    start_map: expected_start_map.clone(),",
          "    stride: expected_stride,",
          "    pattern_len: expected_pattern_len,",
          "    universal_start_unanchored: expected_universal_start_unanchored,",
          "    universal_start_anchored: expected_universal_start_anchored,",
          "    };",
          "    assert_eq!(_result.table, expected_result.table);",
          "    assert_eq!(_result.kind, expected_result.kind);",
          "    assert_eq!(_result.start_map, expected_result.start_map);",
          "    assert_eq!(_result.stride, expected_result.stride);",
          "    assert_eq!(_result.pattern_len, expected_result.pattern_len);",
          "    assert_eq!(_result.universal_start_unanchored, expected_result.universal_start_unanchored);",
          "    assert_eq!(_result.universal_start_anchored, expected_result.universal_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]