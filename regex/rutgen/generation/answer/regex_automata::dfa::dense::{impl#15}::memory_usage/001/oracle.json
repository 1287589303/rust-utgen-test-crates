[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = Vec::new();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let table: Vec<u32> = vec![0; 10];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table: table.clone(), classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), table.len() * StateID::SIZE);",
          "    ",
          "    let table: Vec<u32> = vec![1, 2, 3, 4, 5];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), transition_table.table().len() * StateID::SIZE);",
          "    ",
          "    let table: Vec<u32> = vec![0; 256];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), table.len() * StateID::SIZE);",
          "    ",
          "    let table: Vec<u32> = vec![10];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), table.len() * StateID::SIZE);",
          "    ",
          "    let table: Vec<u32> = vec![0; 0];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), table.len() * StateID::SIZE);"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = Vec::new();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "    let table: Vec<u32> = vec![0; 10];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table: table.clone(), classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), table.len() * StateID::SIZE);",
          "    ",
          "    let table: Vec<u32> = vec![1, 2, 3, 4, 5];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), transition_table.table().len() * StateID::SIZE);",
          "    ",
          "    let table: Vec<u32> = vec![0; 256];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), table.len() * StateID::SIZE);",
          "    ",
          "    let table: Vec<u32> = vec![10];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), table.len() * StateID::SIZE);",
          "    ",
          "    let table: Vec<u32> = vec![0; 0];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), table.len() * StateID::SIZE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table = vec![0u32];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transition_table.memory_usage(), 1 * StateID::SIZE);"
        ],
        "code": [
          "{",
          "    let table = vec![0u32];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "    assert_eq!(transition_table.memory_usage(), 1 * StateID::SIZE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table = vec![0u32, 1];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transition_table.memory_usage(), 2 * StateID::SIZE);"
        ],
        "code": [
          "{",
          "    let table = vec![0u32, 1];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "    assert_eq!(transition_table.memory_usage(), 2 * StateID::SIZE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = (0..257).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let table: Vec<u32> = (0..257).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 257 * StateID::SIZE);",
          "    let table: Vec<u32> = vec![1, 2, 3, 4, 5];",
          "    let classes = ByteClasses([1; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 5 * StateID::SIZE);",
          "    let table: Vec<u32> = vec![];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 0 * StateID::SIZE);",
          "    let table: Vec<u32> = (0..1).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 1 * StateID::SIZE);",
          "    let table: Vec<u32> = (0..256).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 256 * StateID::SIZE);",
          "    let table: Vec<u32> = (0..257).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([255; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 8 };",
          "    assert_eq!(transition_table.memory_usage(), 257 * StateID::SIZE);"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = (0..257).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "    let table: Vec<u32> = (0..257).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 257 * StateID::SIZE);",
          "    let table: Vec<u32> = vec![1, 2, 3, 4, 5];",
          "    let classes = ByteClasses([1; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 5 * StateID::SIZE);",
          "    let table: Vec<u32> = vec![];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 0 * StateID::SIZE);",
          "    let table: Vec<u32> = (0..1).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 1 * StateID::SIZE);",
          "    let table: Vec<u32> = (0..256).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 1 };",
          "    assert_eq!(transition_table.memory_usage(), 256 * StateID::SIZE);",
          "    let table: Vec<u32> = (0..257).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([255; 256]);",
          "    let transition_table = TransitionTable { table, classes, stride2: 8 };",
          "    assert_eq!(transition_table.memory_usage(), 257 * StateID::SIZE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: Vec<u32> = (0..256).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transition_table.memory_usage(), 256 * StateID::SIZE);",
          "    assert!(transition_table.memory_usage() > 0);",
          "    assert_eq!(transition_table.stride(), 1);",
          "    assert_eq!(transition_table.table().len(), 256);",
          "    assert!(transition_table.is_valid(StateID(0)));",
          "    assert!(transition_table.is_valid(StateID(255)));",
          "    assert!(!transition_table.is_valid(StateID(256)));"
        ],
        "code": [
          "{",
          "    let table: Vec<u32> = (0..256).map(|i| i as u32).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let _ = transition_table.memory_usage();",
          "    assert_eq!(transition_table.memory_usage(), 256 * StateID::SIZE);",
          "    assert!(transition_table.memory_usage() > 0);",
          "    assert_eq!(transition_table.stride(), 1);",
          "    assert_eq!(transition_table.table().len(), 256);",
          "    assert!(transition_table.is_valid(StateID(0)));",
          "    assert!(transition_table.is_valid(StateID(255)));",
          "    assert!(!transition_table.is_valid(StateID(256)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]