[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let patterns = &[\"foo\", \"bar\"];",
          "    let dfa = DFA::builder().build_many(patterns).unwrap();",
          "    let input = Input::new(&b\"\"[..]);",
          "    let mut patset = PatternSet::new(dfa.pattern_len());",
          "    let state = OverlappingState::start();",
          "    dfa.try_which_overlapping_matches(&input, &mut patset).unwrap();",
          "}"
        ],
        "oracle": [
          "    let patterns = &[\"foo\", \"bar\"];",
          "    let dfa = DFA::builder().build_many(patterns).unwrap();",
          "    let input = Input::new(&b\"\"[..]);",
          "    let mut patset = PatternSet::new(dfa.pattern_len());",
          "    let state = OverlappingState::start();",
          "    ",
          "    // Verify that try_search_overlapping_fwd returns Err/None",
          "    assert!(dfa.try_search_overlapping_matches(&input, &mut patset).is_ok());",
          "    assert!(patset.is_empty());"
        ],
        "code": [
          "{",
          "    let patterns = &[\"foo\", \"bar\"];",
          "    let dfa = DFA::builder().build_many(patterns).unwrap();",
          "    let input = Input::new(&b\"\"[..]);",
          "    let mut patset = PatternSet::new(dfa.pattern_len());",
          "    let state = OverlappingState::start();",
          "    dfa.try_which_overlapping_matches(&input, &mut patset).unwrap();",
          "    let patterns = &[\"foo\", \"bar\"];",
          "    let dfa = DFA::builder().build_many(patterns).unwrap();",
          "    let input = Input::new(&b\"\"[..]);",
          "    let mut patset = PatternSet::new(dfa.pattern_len());",
          "    let state = OverlappingState::start();",
          "    ",
          "    // Verify that try_search_overlapping_fwd returns Err/None",
          "    assert!(dfa.try_search_overlapping_matches(&input, &mut patset).is_ok());",
          "    assert!(patset.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let patterns = &[\"foo\", \"bar\"];",
          "    let dfa = DFA::builder().build_many(patterns).unwrap();",
          "    let input = Input::new(&b\"\\xFF\\xFF\"[..]);",
          "    let mut patset = PatternSet::new(dfa.pattern_len());",
          "    let state = OverlappingState::start();",
          "    dfa.try_which_overlapping_matches(&input, &mut patset).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(dfa.try_search_overlapping_fwd(&input, &mut state), Err(_)));",
          "    assert!(patset.is_empty());",
          "    assert_eq!(patset.len(), 0);",
          "    assert!(patset.capacity() > 0);",
          "    assert!(dfa.is_dead_state(state.id.unwrap()));"
        ],
        "code": [
          "{",
          "    let patterns = &[\"foo\", \"bar\"];",
          "    let dfa = DFA::builder().build_many(patterns).unwrap();",
          "    let input = Input::new(&b\"\\xFF\\xFF\"[..]);",
          "    let mut patset = PatternSet::new(dfa.pattern_len());",
          "    let state = OverlappingState::start();",
          "    dfa.try_which_overlapping_matches(&input, &mut patset).unwrap();",
          "    assert!(matches!(dfa.try_search_overlapping_fwd(&input, &mut state), Err(_)));",
          "    assert!(patset.is_empty());",
          "    assert_eq!(patset.len(), 0);",
          "    assert!(patset.capacity() > 0);",
          "    assert!(dfa.is_dead_state(state.id.unwrap()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let patterns = &[\"foo\", \"bar\"];",
          "    let dfa = DFA::builder().build_many(patterns).unwrap();",
          "    let input = Input::new(&b\"foobar\"[..]);",
          "    let mut patset = PatternSet::new(dfa.pattern_len());",
          "    patset.insert(PatternID(0)).unwrap();",
          "    patset.insert(PatternID(1)).unwrap();",
          "    let state = OverlappingState::start();",
          "    dfa.try_which_overlapping_matches(&input, &mut patset).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(patset.len(), 2);",
          "    assert!(patset.contains(PatternID(0)));",
          "    assert!(patset.contains(PatternID(1)));",
          "    assert!(!patset.is_full());",
          "    assert!(!patset.is_empty());",
          "    assert!(patset.insert(PatternID(2)).is_err());",
          "    assert_eq!(state.mat, None);",
          "    assert_eq!(state.id, None);"
        ],
        "code": [
          "{",
          "    let patterns = &[\"foo\", \"bar\"];",
          "    let dfa = DFA::builder().build_many(patterns).unwrap();",
          "    let input = Input::new(&b\"foobar\"[..]);",
          "    let mut patset = PatternSet::new(dfa.pattern_len());",
          "    patset.insert(PatternID(0)).unwrap();",
          "    patset.insert(PatternID(1)).unwrap();",
          "    let state = OverlappingState::start();",
          "    dfa.try_which_overlapping_matches(&input, &mut patset).unwrap();",
          "    assert_eq!(patset.len(), 2);",
          "    assert!(patset.contains(PatternID(0)));",
          "    assert!(patset.contains(PatternID(1)));",
          "    assert!(!patset.is_full());",
          "    assert!(!patset.is_empty());",
          "    assert!(patset.insert(PatternID(2)).is_err());",
          "    assert_eq!(state.mat, None);",
          "    assert_eq!(state.id, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]