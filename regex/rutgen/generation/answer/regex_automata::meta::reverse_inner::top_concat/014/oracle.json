[
  {
    "uses": [
      "use regex_syntax::hir::Class;",
      "use regex_syntax::hir::Alternation;",
      "use regex_syntax::hir::Hir;",
      "use regex_syntax::hir::Look;",
      "use regex_syntax::hir::literal;",
      "use regex_syntax::hir::HirKind;",
      "use regex_syntax::hir::Repetition;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind};",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::class(vec![], false); // HirKind::Class",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::literal('a'); // HirKind::Literal",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::repetition(Box::new(Hir::literal('b')), regex_syntax::hir::Repetition::zero_or_more()); // HirKind::Repetition",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::look(regex_syntax::hir::Look::ZeroWidthLookBehind(Box::new(Hir::literal('c')))); // HirKind::Look",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::literal('d'), Hir::literal('e')]); // HirKind::Alternation",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::empty(); // HirKind::Empty",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind};",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    let hir = Hir::class(vec![], false); // HirKind::Class",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::literal('a'); // HirKind::Literal",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::repetition(Box::new(Hir::literal('b')), regex_syntax::hir::Repetition::zero_or_more()); // HirKind::Repetition",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::look(regex_syntax::hir::Look::ZeroWidthLookBehind(Box::new(Hir::literal('c')))); // HirKind::Look",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::literal('d'), Hir::literal('e')]); // HirKind::Alternation",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::empty(); // HirKind::Empty",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, literal};",
          "    let hir = Hir::literal(literal::Literal::new(\"test\".into()));",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, literal};",
          "    let hir = Hir::literal(literal::Literal::new(\"test\".into()));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Class};",
          "    let class = Class::new(vec![], true);",
          "    let hir = Hir::class(class);",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Class};",
          "    let class = Class::new(vec![], true);",
          "    let hir = Hir::class(class);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Repetition};",
          "    let hir = Hir::repetition(Box::new(Hir::literal(literal::Literal::new(\"test\".into()))), Repetition::one());",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Repetition};",
          "    let hir = Hir::repetition(Box::new(Hir::literal(literal::Literal::new(\"test\".into()))), Repetition::one());",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Look};",
          "    let hir = Hir::look(Box::new(Hir::literal(literal::Literal::new(\"test\".into()))));",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    let hir = Hir::class(...);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let hir = Hir::repetition(...);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let hir = Hir::alternation(...);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Look};",
          "    let hir = Hir::look(Box::new(Hir::literal(literal::Literal::new(\"test\".into()))));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let hir = Hir::class(...);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let hir = Hir::repetition(...);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let hir = Hir::alternation(...);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Alternation};",
          "    let hir = Hir::alternation(vec![Hir::literal(literal::Literal::new(\"a\".into())), Hir::literal(literal::Literal::new(\"b\".into()))]);",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    assert!(matches!(hir.kind(), HirKind::Alternation(_)));",
          "    assert!(matches!(hir.kind(), HirKind::Class(_) | HirKind::Empty | HirKind::Repetition(_) | HirKind::Literal(_) | HirKind::Look(_)));",
          "    assert!(hir.kind() == HirKind::Alternation(vec![Hir::literal(literal::Literal::new(\"a\".into())), Hir::literal(literal::Literal::new(\"b\".into()))]));"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Alternation};",
          "    let hir = Hir::alternation(vec![Hir::literal(literal::Literal::new(\"a\".into())), Hir::literal(literal::Literal::new(\"b\".into()))]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    assert!(matches!(hir.kind(), HirKind::Alternation(_)));",
          "    assert!(matches!(hir.kind(), HirKind::Class(_) | HirKind::Empty | HirKind::Repetition(_) | HirKind::Literal(_) | HirKind::Look(_)));",
          "    assert!(hir.kind() == HirKind::Alternation(vec![Hir::literal(literal::Literal::new(\"a\".into())), Hir::literal(literal::Literal::new(\"b\".into()))]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]