[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::literal('a');",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::class(vec!['a', 'b', 'c']);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::look(hir::Look::Any);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::repetition(Box::new(Hir::literal('a')), 1..=2);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::literal('a'), Hir::literal('b')]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::literal('a');",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::class(vec!['a', 'b', 'c']);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::look(hir::Look::Any);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::repetition(Box::new(Hir::literal('a')), 1..=2);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::literal('a'), Hir::literal('b')]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::literal('a');",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir_capture = Hir::capture(hir::Capture { sub: Hir::literal('a') });",
          "    assert_eq!(top_concat(&hir_capture), None);",
          "    let hir_alternation = Hir::alternation(vec![Hir::literal('a'), Hir::literal('b')]);",
          "    assert_eq!(top_concat(&hir_alternation), None);",
          "    let hir_empty = Hir::empty();",
          "    assert_eq!(top_concat(&hir_empty), None);",
          "    let hir_repetition = Hir::repetition(Box::new(Hir::literal('a')), None);",
          "    assert_eq!(top_concat(&hir_repetition), None);",
          "    let hir_class = Hir::class(vec!['a', 'b', 'c'], false);",
          "    assert_eq!(top_concat(&hir_class), None);",
          "    let hir_look = Hir::look(hir::Look::assert(Hir::literal('a')));",
          "    assert_eq!(top_concat(&hir_look), None);"
        ],
        "code": [
          "{",
          "    let hir = Hir::literal('a');",
          "    let result = top_concat(&hir);",
          "    let hir_capture = Hir::capture(hir::Capture { sub: Hir::literal('a') });",
          "    assert_eq!(top_concat(&hir_capture), None);",
          "    let hir_alternation = Hir::alternation(vec![Hir::literal('a'), Hir::literal('b')]);",
          "    assert_eq!(top_concat(&hir_alternation), None);",
          "    let hir_empty = Hir::empty();",
          "    assert_eq!(top_concat(&hir_empty), None);",
          "    let hir_repetition = Hir::repetition(Box::new(Hir::literal('a')), None);",
          "    assert_eq!(top_concat(&hir_repetition), None);",
          "    let hir_class = Hir::class(vec!['a', 'b', 'c'], false);",
          "    assert_eq!(top_concat(&hir_class), None);",
          "    let hir_look = Hir::look(hir::Look::assert(Hir::literal('a')));",
          "    assert_eq!(top_concat(&hir_look), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::class(vec![b'a', b'b']); ",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::capture(hir::Capture { sub: Hir::class(vec![b'a', b'b']), ..Default::default() });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::literal(b'a');",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::repetition(hir::Repetition::new(Hir::class(vec![b'a']), hir::Quantifier::ZeroOrMore));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::look(hir::Look::zero_width_assert(hir::LookKind::LookAhead, Hir::class(vec![b'a'])));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::class(vec![b'a']), Hir::class(vec![b'b'])]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::capture(hir::Capture { sub: Hir::alternation(vec![Hir::class(vec![b'a']), Hir::class(vec![b'b'])]), ..Default::default() });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let hir = Hir::class(vec![b'a', b'b']); ",
          "    let result = top_concat(&hir);",
          "    let hir = Hir::capture(hir::Capture { sub: Hir::class(vec![b'a', b'b']), ..Default::default() });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::literal(b'a');",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::repetition(hir::Repetition::new(Hir::class(vec![b'a']), hir::Quantifier::ZeroOrMore));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::look(hir::Look::zero_width_assert(hir::LookKind::LookAhead, Hir::class(vec![b'a'])));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::class(vec![b'a']), Hir::class(vec![b'b'])]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::capture(hir::Capture { sub: Hir::alternation(vec![Hir::class(vec![b'a']), Hir::class(vec![b'b'])]), ..Default::default() });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::look(hir::Look::assert(true, Hir::literal('b')));",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::capture(hir::Capture { sub: Hir::empty() }); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::capture(hir::Capture { sub: Hir::literal('a') }); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::alternation(vec![Hir::literal('x'), Hir::literal('y')]); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::repetition(Hir::literal('c')); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::look(hir::Look::assert(false, Hir::literal('d'))); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::class(vec!['e', 'f'], false); assert_eq!(top_concat(&hir), None);"
        ],
        "code": [
          "{",
          "    let hir = Hir::look(hir::Look::assert(true, Hir::literal('b')));",
          "    let result = top_concat(&hir);",
          "    let hir = Hir::capture(hir::Capture { sub: Hir::empty() }); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::capture(hir::Capture { sub: Hir::literal('a') }); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::alternation(vec![Hir::literal('x'), Hir::literal('y')]); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::repetition(Hir::literal('c')); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::look(hir::Look::assert(false, Hir::literal('d'))); assert_eq!(top_concat(&hir), None);",
          "    let hir = Hir::class(vec!['e', 'f'], false); assert_eq!(top_concat(&hir), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::repetition(Hir::literal('c'), None, None);",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::repetition(Hir::literal('c'), None, None);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::capture(hir::Capture { sub: Hir::literal('a'), .. });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result.is_none(), true);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::literal('x'), Hir::literal('y')]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let hir = Hir::repetition(Hir::literal('c'), None, None);",
          "    let result = top_concat(&hir);",
          "    let hir = Hir::repetition(Hir::literal('c'), None, None);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::capture(hir::Capture { sub: Hir::literal('a'), .. });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result.is_none(), true);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::literal('x'), Hir::literal('y')]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir::empty();",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    ",
          "    let sub_hir = Hir::literal(\"a\".into());",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let alternation_hir = Hir::alternation(vec![Hir::literal(\"a\".into()), Hir::literal(\"b\".into())]);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(alternation_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let empty_hir = Hir::empty();",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(empty_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let repetition_hir = Hir::repetition(Hir::literal(\"c\".into()), Some(1), None);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(repetition_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let look_hir = Hir::look(Hir::literal(\"d\".into()));",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(look_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let class_hir = Hir::class(vec!['e', 'f']);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(class_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir::empty();",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let sub_hir = Hir::literal(\"a\".into());",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let alternation_hir = Hir::alternation(vec![Hir::literal(\"a\".into()), Hir::literal(\"b\".into())]);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(alternation_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let empty_hir = Hir::empty();",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(empty_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let repetition_hir = Hir::repetition(Hir::literal(\"c\".into()), Some(1), None);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(repetition_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let look_hir = Hir::look(Hir::literal(\"d\".into()));",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(look_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let class_hir = Hir::class(vec!['e', 'f']);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(class_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir::literal('d');",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir::literal('d');",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir::class(vec![b'e', b'f']); ",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    assert!(matches!(hir.kind(), HirKind::Capture(_)));",
          "    assert!(matches!(hir.kind(), HirKind::Alternation(_) | HirKind::Empty | HirKind::Repetition(_) | HirKind::Literal(_) | HirKind::Look(_) | HirKind::Class(_)));"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir::class(vec![b'e', b'f']); ",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    assert!(matches!(hir.kind(), HirKind::Capture(_)));",
          "    assert!(matches!(hir.kind(), HirKind::Alternation(_) | HirKind::Empty | HirKind::Repetition(_) | HirKind::Literal(_) | HirKind::Look(_) | HirKind::Class(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir::repetition(Hir::literal('g'), None, None);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::literal('g');",
          "    let hir = Hir::alternation(vec![sub_hir]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::empty();",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::class(vec![]);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::lookaround(true, Hir::literal('g'));",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::repetition(Hir::literal('g'), None, None);",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir::repetition(Hir::literal('g'), None, None);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::literal('g');",
          "    let hir = Hir::alternation(vec![sub_hir]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::empty();",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::class(vec![]);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::lookaround(true, Hir::literal('g'));",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    let sub_hir = Hir::repetition(Hir::literal('g'), None, None);",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir::look(hir::Look::assert(true, Hir::literal('h')));",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    let sub_hir = Hir::look(hir::Look::assert(true, Hir::literal('h')));",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::concat(vec![Hir::literal('a'), Hir::literal('b')]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::look(hir::Look::assert(true, Hir::literal('x')));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::repetition(hir::Repetition::zero_or_more(Hir::literal('c')));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::literal('d'), Hir::literal('e')]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir::look(hir::Look::assert(true, Hir::literal('h')));",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    let sub_hir = Hir::look(hir::Look::assert(true, Hir::literal('h')));",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::concat(vec![Hir::literal('a'), Hir::literal('b')]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::look(hir::Look::assert(true, Hir::literal('x')));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::repetition(hir::Repetition::zero_or_more(Hir::literal('c')));",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::alternation(vec![Hir::literal('d'), Hir::literal('e')]);",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hir = Hir::empty();",
          "    let result = top_concat(&hir);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir::alternation(vec![Hir::literal('i'), Hir::literal('j')]);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "}"
        ],
        "oracle": [
          "    result.is_none();",
          "    let sub_hir = Hir::alternation(vec![Hir::literal('i'), Hir::literal('j')]);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    assert_eq!(top_concat(&hir), None);",
          "    let empty_hir = Hir::empty();",
          "    assert_eq!(top_concat(&empty_hir), None);",
          "    let repetition_hir = Hir::repetition(hir::Repetition::zero_or_more(Hir::literal('x')));",
          "    assert_eq!(top_concat(&repetition_hir), None);",
          "    let literal_hir = Hir::literal('k');",
          "    assert_eq!(top_concat(&literal_hir), None);",
          "    let look_hir = Hir::look(hir::Look::assert(Hir::literal('m')));",
          "    assert_eq!(top_concat(&look_hir), None);",
          "    let class_hir = Hir::class(hir::Class::new(vec!['a', 'b', 'c']));",
          "    assert_eq!(top_concat(&class_hir), None);"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir::alternation(vec![Hir::literal('i'), Hir::literal('j')]);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    let result = top_concat(&hir);",
          "    result.is_none();",
          "    let sub_hir = Hir::alternation(vec![Hir::literal('i'), Hir::literal('j')]);",
          "    let hir = Hir::capture(hir::Capture { sub: Box::new(sub_hir) });",
          "    assert_eq!(top_concat(&hir), None);",
          "    let empty_hir = Hir::empty();",
          "    assert_eq!(top_concat(&empty_hir), None);",
          "    let repetition_hir = Hir::repetition(hir::Repetition::zero_or_more(Hir::literal('x')));",
          "    assert_eq!(top_concat(&repetition_hir), None);",
          "    let literal_hir = Hir::literal('k');",
          "    assert_eq!(top_concat(&literal_hir), None);",
          "    let look_hir = Hir::look(hir::Look::assert(Hir::literal('m')));",
          "    assert_eq!(top_concat(&look_hir), None);",
          "    let class_hir = Hir::class(hir::Class::new(vec!['a', 'b', 'c']));",
          "    assert_eq!(top_concat(&class_hir), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]