[
  {
    "uses": [
      "use regex_syntax::hir::Capture;",
      "use regex_syntax::hir::HirKind;",
      "use regex_syntax::hir::Hir;",
      "use regex_syntax::hir::Literal;",
      "use regex_syntax::hir::Class;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Capture};",
          "    use regex_syntax::hir::Class;",
          "    use regex_syntax::hir::Literal;",
          "",
          "    let inner_capture = Hir::concat(vec![",
          "        Hir::literal(\"a\".into()),",
          "        Hir::class(vec![Class::new_char_range('b', 'b')])",
          "    ]);",
          "",
          "    let top_concat = Hir::concat(vec![",
          "        Hir::capture(Capture { sub: Box::new(inner_capture), span: Default::default() }),",
          "        Hir::literal(\"c\".into())",
          "    ]);",
          "",
          "    let result = top_concat(&top_concat);",
          "}"
        ],
        "oracle": [
          "    let inner_capture = Hir::concat(vec![Hir::literal(\"a\".into()), Hir::class(vec![Class::new_char_range('b', 'b')])]);",
          "    let top_concat = Hir::concat(vec![Hir::capture(Capture { sub: Box::new(inner_capture), span: Default::default() }), Hir::literal(\"c\".into())]);",
          "    let result = top_concat(&top_concat);",
          "    assert_eq!(result, Some(vec![Hir::literal(\"a\".into()), Hir::class(vec![Class::new_char_range('b', 'b')]), Hir::literal(\"c\".into())]));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(_)));"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Capture};",
          "    use regex_syntax::hir::Class;",
          "    use regex_syntax::hir::Literal;",
          "",
          "    let inner_capture = Hir::concat(vec![",
          "        Hir::literal(\"a\".into()),",
          "        Hir::class(vec![Class::new_char_range('b', 'b')])",
          "    ]);",
          "",
          "    let top_concat = Hir::concat(vec![",
          "        Hir::capture(Capture { sub: Box::new(inner_capture), span: Default::default() }),",
          "        Hir::literal(\"c\".into())",
          "    ]);",
          "",
          "    let result = top_concat(&top_concat);",
          "    let inner_capture = Hir::concat(vec![Hir::literal(\"a\".into()), Hir::class(vec![Class::new_char_range('b', 'b')])]);",
          "    let top_concat = Hir::concat(vec![Hir::capture(Capture { sub: Box::new(inner_capture), span: Default::default() }), Hir::literal(\"c\".into())]);",
          "    let result = top_concat(&top_concat);",
          "    assert_eq!(result, Some(vec![Hir::literal(\"a\".into()), Hir::class(vec![Class::new_char_range('b', 'b')]), Hir::literal(\"c\".into())]));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Capture};",
          "    use regex_syntax::hir::Literal;",
          "",
          "    let nested_capture = Hir::concat(vec![",
          "        Hir::literal(\"x\".into()),",
          "        Hir::literal(\"y\".into())",
          "    ]);",
          "",
          "    let top_concat = Hir::concat(vec![",
          "        Hir::capture(Capture { sub: Box::new(nested_capture), span: Default::default() }),",
          "        Hir::literal(\"z\".into())",
          "    ]);",
          "",
          "    let result = top_concat(&top_concat);",
          "}"
        ],
        "oracle": [
          "    let nested_capture = Hir::concat(vec![Hir::literal(\"x\".into()), Hir::literal(\"y\".into())]);",
          "    let top_concat = Hir::concat(vec![Hir::capture(Capture { sub: Box::new(nested_capture), span: Default::default() }), Hir::literal(\"z\".into())]);",
          "    let result = top_concat(&top_concat);",
          "    assert_eq!(result, Some(vec![Hir::literal(\"x\".into()), Hir::literal(\"y\".into()), Hir::literal(\"z\".into())]));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(xs) if xs.len() == 3));",
          "    assert!(matches!(result, Some(xs) if xs[0] == Hir::literal(\"x\".into())));",
          "    assert!(matches!(result, Some(xs) if xs[1] == Hir::literal(\"y\".into())));",
          "    assert!(matches!(result, Some(xs) if xs[2] == Hir::literal(\"z\".into())));"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Capture};",
          "    use regex_syntax::hir::Literal;",
          "",
          "    let nested_capture = Hir::concat(vec![",
          "        Hir::literal(\"x\".into()),",
          "        Hir::literal(\"y\".into())",
          "    ]);",
          "",
          "    let top_concat = Hir::concat(vec![",
          "        Hir::capture(Capture { sub: Box::new(nested_capture), span: Default::default() }),",
          "        Hir::literal(\"z\".into())",
          "    ]);",
          "",
          "    let result = top_concat(&top_concat);",
          "    let nested_capture = Hir::concat(vec![Hir::literal(\"x\".into()), Hir::literal(\"y\".into())]);",
          "    let top_concat = Hir::concat(vec![Hir::capture(Capture { sub: Box::new(nested_capture), span: Default::default() }), Hir::literal(\"z\".into())]);",
          "    let result = top_concat(&top_concat);",
          "    assert_eq!(result, Some(vec![Hir::literal(\"x\".into()), Hir::literal(\"y\".into()), Hir::literal(\"z\".into())]));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(xs) if xs.len() == 3));",
          "    assert!(matches!(result, Some(xs) if xs[0] == Hir::literal(\"x\".into())));",
          "    assert!(matches!(result, Some(xs) if xs[1] == Hir::literal(\"y\".into())));",
          "    assert!(matches!(result, Some(xs) if xs[2] == Hir::literal(\"z\".into())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Capture};",
          "    use regex_syntax::hir::Literal;",
          "",
          "    let first_capture = Hir::literal(\"1\".into());",
          "    let second_capture = Hir::literal(\"2\".into());",
          "",
          "    let top_concat = Hir::concat(vec![",
          "        Hir::capture(Capture { sub: Box::new(first_capture), span: Default::default() }),",
          "        Hir::capture(Capture { sub: Box::new(second_capture), span: Default::default() }),",
          "    ]);",
          "",
          "    let result = top_concat(&top_concat);",
          "}"
        ],
        "oracle": [
          "    let expected_result = Some(vec![first_capture, second_capture]);",
          "    assert_eq!(result, expected_result);",
          "    let top_concat_empty = Hir::concat(vec![]);",
          "    let result_empty = top_concat(&top_concat_empty);",
          "    assert_eq!(result_empty, None);",
          "    let top_concat_single_capture = Hir::capture(Capture { sub: Box::new(first_capture), span: Default::default() });",
          "    let result_single_capture = top_concat(&top_concat_single_capture);",
          "    assert_eq!(result_single_capture, Some(vec![first_capture]));",
          "    let top_concat_nested_capture = Hir::capture(Capture { sub: Box::new(top_concat), span: Default::default() });",
          "    let result_nested_capture = top_concat(&top_concat_nested_capture);",
          "    assert_eq!(result_nested_capture, Some(vec![first_capture, second_capture]));",
          "    let top_concat_alternation = Hir::alternation(vec![top_concat, Hir::literal(\"3\".into())]);",
          "    let result_alternation = top_concat(&top_concat_alternation);",
          "    assert_eq!(result_alternation, None);",
          "    let top_concat_repetition = Hir::repetition(top_concat, 1..=2);",
          "    let result_repetition = top_concat(&top_concat_repetition);",
          "    assert_eq!(result_repetition, None);"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Capture};",
          "    use regex_syntax::hir::Literal;",
          "",
          "    let first_capture = Hir::literal(\"1\".into());",
          "    let second_capture = Hir::literal(\"2\".into());",
          "",
          "    let top_concat = Hir::concat(vec![",
          "        Hir::capture(Capture { sub: Box::new(first_capture), span: Default::default() }),",
          "        Hir::capture(Capture { sub: Box::new(second_capture), span: Default::default() }),",
          "    ]);",
          "",
          "    let result = top_concat(&top_concat);",
          "    let expected_result = Some(vec![first_capture, second_capture]);",
          "    assert_eq!(result, expected_result);",
          "    let top_concat_empty = Hir::concat(vec![]);",
          "    let result_empty = top_concat(&top_concat_empty);",
          "    assert_eq!(result_empty, None);",
          "    let top_concat_single_capture = Hir::capture(Capture { sub: Box::new(first_capture), span: Default::default() });",
          "    let result_single_capture = top_concat(&top_concat_single_capture);",
          "    assert_eq!(result_single_capture, Some(vec![first_capture]));",
          "    let top_concat_nested_capture = Hir::capture(Capture { sub: Box::new(top_concat), span: Default::default() });",
          "    let result_nested_capture = top_concat(&top_concat_nested_capture);",
          "    assert_eq!(result_nested_capture, Some(vec![first_capture, second_capture]));",
          "    let top_concat_alternation = Hir::alternation(vec![top_concat, Hir::literal(\"3\".into())]);",
          "    let result_alternation = top_concat(&top_concat_alternation);",
          "    assert_eq!(result_alternation, None);",
          "    let top_concat_repetition = Hir::repetition(top_concat, 1..=2);",
          "    let result_repetition = top_concat(&top_concat_repetition);",
          "    assert_eq!(result_repetition, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]