[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
          "    sparse_sets.set2 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
          "    sparse_sets.swap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_sets.set1.len, 0);",
          "    assert_eq!(sparse_sets.set2.len, 0);",
          "    assert!(sparse_sets.set1.dense.is_empty());",
          "    assert!(sparse_sets.set2.dense.is_empty());",
          "    assert!(sparse_sets.set1.sparse.is_empty());",
          "    assert!(sparse_sets.set2.sparse.is_empty());",
          "    let set1_ptr = &sparse_sets.set1 as *const SparseSet;",
          "    let set2_ptr = &sparse_sets.set2 as *const SparseSet;",
          "    sparse_sets.swap();",
          "    assert_eq!(set1_ptr, &sparse_sets.set2 as *const SparseSet);",
          "    assert_eq!(set2_ptr, &sparse_sets.set1 as *const SparseSet);"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
          "    sparse_sets.set2 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
          "    sparse_sets.swap();",
          "    assert_eq!(sparse_sets.set1.len, 0);",
          "    assert_eq!(sparse_sets.set2.len, 0);",
          "    assert!(sparse_sets.set1.dense.is_empty());",
          "    assert!(sparse_sets.set2.dense.is_empty());",
          "    assert!(sparse_sets.set1.sparse.is_empty());",
          "    assert!(sparse_sets.set2.sparse.is_empty());",
          "    let set1_ptr = &sparse_sets.set1 as *const SparseSet;",
          "    let set2_ptr = &sparse_sets.set2 as *const SparseSet;",
          "    sparse_sets.swap();",
          "    assert_eq!(set1_ptr, &sparse_sets.set2 as *const SparseSet);",
          "    assert_eq!(set2_ptr, &sparse_sets.set1 as *const SparseSet);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 1, dense: vec![1], sparse: vec![0] };",
          "    sparse_sets.set2 = SparseSet { len: 1, dense: vec![2], sparse: vec![0] };",
          "    sparse_sets.swap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_sets.set1.len, 1);",
          "    assert_eq!(sparse_sets.set1.dense, vec![2]);",
          "    assert_eq!(sparse_sets.set1.sparse, vec![0]);",
          "    assert_eq!(sparse_sets.set2.len, 1);",
          "    assert_eq!(sparse_sets.set2.dense, vec![1]);",
          "    assert_eq!(sparse_sets.set2.sparse, vec![0]);"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 1, dense: vec![1], sparse: vec![0] };",
          "    sparse_sets.set2 = SparseSet { len: 1, dense: vec![2], sparse: vec![0] };",
          "    sparse_sets.swap();",
          "    assert_eq!(sparse_sets.set1.len, 1);",
          "    assert_eq!(sparse_sets.set1.dense, vec![2]);",
          "    assert_eq!(sparse_sets.set1.sparse, vec![0]);",
          "    assert_eq!(sparse_sets.set2.len, 1);",
          "    assert_eq!(sparse_sets.set2.dense, vec![1]);",
          "    assert_eq!(sparse_sets.set2.sparse, vec![0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 10, dense: (0..10).map(|x| x as StateID).collect(), sparse: (0..10).map(|x| x as StateID).collect() };",
          "    sparse_sets.set2 = SparseSet { len: 10, dense: (10..20).map(|x| x as StateID).collect(), sparse: (0..10).map(|x| (x + 10) as StateID).collect() };",
          "    sparse_sets.swap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_sets.set1.len, 10);",
          "    assert_eq!(sparse_sets.set1.dense, (10..20).map(|x| x as StateID).collect::<Vec<StateID>>());",
          "    assert_eq!(sparse_sets.set1.sparse, (0..10).map(|x| (x + 10) as StateID).collect::<Vec<StateID>>());",
          "    assert_eq!(sparse_sets.set2.len, 10);",
          "    assert_eq!(sparse_sets.set2.dense, (0..10).map(|x| x as StateID).collect::<Vec<StateID>>());",
          "    assert_eq!(sparse_sets.set2.sparse, (0..10).map(|x| x as StateID).collect::<Vec<StateID>>());"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 10, dense: (0..10).map(|x| x as StateID).collect(), sparse: (0..10).map(|x| x as StateID).collect() };",
          "    sparse_sets.set2 = SparseSet { len: 10, dense: (10..20).map(|x| x as StateID).collect(), sparse: (0..10).map(|x| (x + 10) as StateID).collect() };",
          "    sparse_sets.swap();",
          "    assert_eq!(sparse_sets.set1.len, 10);",
          "    assert_eq!(sparse_sets.set1.dense, (10..20).map(|x| x as StateID).collect::<Vec<StateID>>());",
          "    assert_eq!(sparse_sets.set1.sparse, (0..10).map(|x| (x + 10) as StateID).collect::<Vec<StateID>>());",
          "    assert_eq!(sparse_sets.set2.len, 10);",
          "    assert_eq!(sparse_sets.set2.dense, (0..10).map(|x| x as StateID).collect::<Vec<StateID>>());",
          "    assert_eq!(sparse_sets.set2.sparse, (0..10).map(|x| x as StateID).collect::<Vec<StateID>>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 5, dense: vec![0, 1, 2, 3, 4], sparse: vec![0, 1, 2, 3, 4] };",
          "    sparse_sets.set2 = SparseSet { len: 3, dense: vec![5, 6, 7], sparse: vec![0, 1, 2] };",
          "    sparse_sets.swap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_sets.set1.len, 3);",
          "    assert_eq!(sparse_sets.set1.dense, vec![5, 6, 7]);",
          "    assert_eq!(sparse_sets.set1.sparse, vec![0, 1, 2]);",
          "    assert_eq!(sparse_sets.set2.len, 5);",
          "    assert_eq!(sparse_sets.set2.dense, vec![0, 1, 2, 3, 4]);",
          "    assert_eq!(sparse_sets.set2.sparse, vec![0, 1, 2, 3, 4]);"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 5, dense: vec![0, 1, 2, 3, 4], sparse: vec![0, 1, 2, 3, 4] };",
          "    sparse_sets.set2 = SparseSet { len: 3, dense: vec![5, 6, 7], sparse: vec![0, 1, 2] };",
          "    sparse_sets.swap();",
          "    assert_eq!(sparse_sets.set1.len, 3);",
          "    assert_eq!(sparse_sets.set1.dense, vec![5, 6, 7]);",
          "    assert_eq!(sparse_sets.set1.sparse, vec![0, 1, 2]);",
          "    assert_eq!(sparse_sets.set2.len, 5);",
          "    assert_eq!(sparse_sets.set2.dense, vec![0, 1, 2, 3, 4]);",
          "    assert_eq!(sparse_sets.set2.sparse, vec![0, 1, 2, 3, 4]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
          "    sparse_sets.set2 = SparseSet { len: 6, dense: vec![0, 1, 2, 3, 4, 5], sparse: vec![0, 1, 2, 3, 4, 5] };",
          "    sparse_sets.swap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_sets.set1.len, 0);",
          "    assert_eq!(sparse_sets.set2.len, 6);",
          "    assert_eq!(sparse_sets.set1.dense, vec![]);",
          "    assert_eq!(sparse_sets.set2.dense, vec![0, 1, 2, 3, 4, 5]);",
          "    assert_eq!(sparse_sets.set1.sparse, vec![]);",
          "    assert_eq!(sparse_sets.set2.sparse, vec![0, 1, 2, 3, 4, 5]);"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    sparse_sets.set1 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
          "    sparse_sets.set2 = SparseSet { len: 6, dense: vec![0, 1, 2, 3, 4, 5], sparse: vec![0, 1, 2, 3, 4, 5] };",
          "    sparse_sets.swap();",
          "    assert_eq!(sparse_sets.set1.len, 0);",
          "    assert_eq!(sparse_sets.set2.len, 6);",
          "    assert_eq!(sparse_sets.set1.dense, vec![]);",
          "    assert_eq!(sparse_sets.set2.dense, vec![0, 1, 2, 3, 4, 5]);",
          "    assert_eq!(sparse_sets.set1.sparse, vec![]);",
          "    assert_eq!(sparse_sets.set2.sparse, vec![0, 1, 2, 3, 4, 5]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]