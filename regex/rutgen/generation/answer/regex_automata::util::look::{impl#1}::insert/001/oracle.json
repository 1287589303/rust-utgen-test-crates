[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lookset = LookSet::empty();",
          "    let result = lookset.insert(Look::Start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.bits, LookSet::empty().bits | Look::Start.as_repr());",
          "    assert_eq!(result.bits, LookSet::empty().bits | 1);",
          "    assert!(result.contains(Look::Start));",
          "    assert!(!lookset.contains(Look::Start));",
          "    assert_eq!(result.len(), 1);",
          "    assert!(!result.is_empty());",
          "    assert_eq!(result.bits & Look::End.as_repr(), 0);"
        ],
        "code": [
          "{",
          "    let lookset = LookSet::empty();",
          "    let result = lookset.insert(Look::Start);",
          "    assert_eq!(result.bits, LookSet::empty().bits | Look::Start.as_repr());",
          "    assert_eq!(result.bits, LookSet::empty().bits | 1);",
          "    assert!(result.contains(Look::Start));",
          "    assert!(!lookset.contains(Look::Start));",
          "    assert_eq!(result.len(), 1);",
          "    assert!(!result.is_empty());",
          "    assert_eq!(result.bits & Look::End.as_repr(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lookset = LookSet::empty();",
          "    let result = lookset.insert(Look::End);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.bits, LookSet::empty().bits | Look::End.as_repr());"
        ],
        "code": [
          "{",
          "    let lookset = LookSet::empty();",
          "    let result = lookset.insert(Look::End);",
          "    assert_eq!(result.bits, LookSet::empty().bits | Look::End.as_repr());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lookset = LookSet::empty();",
          "    let combined_assertion = Look::Start as u32 | Look::End as u32;",
          "    let result = lookset.insert(Look::from_repr(combined_assertion).unwrap());",
          "}"
        ],
        "oracle": [
          "    LookSet::empty().insert(Look::Start) == LookSet { bits: Look::Start.as_repr() }",
          "    LookSet::empty().insert(Look::End) == LookSet { bits: Look::End.as_repr() }",
          "    LookSet::empty().insert(Look::Start).insert(Look::End) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "    LookSet::full().insert(Look::Start) == LookSet { bits: Look::full().bits }",
          "    LookSet::singleton(Look::Start).insert(Look::Start) == LookSet { bits: Look::Start.as_repr() }",
          "    LookSet::singleton(Look::Start).insert(Look::End) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "    LookSet::singleton(Look::End).insert(Look::Start) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "    LookSet::full().insert(Look::Start) == LookSet::full()",
          "    LookSet::singleton(Look::Start).insert(Look::End) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "    LookSet::singleton(Look::End).insert(Look::Start) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }"
        ],
        "code": [
          "{",
          "    let lookset = LookSet::empty();",
          "    let combined_assertion = Look::Start as u32 | Look::End as u32;",
          "    let result = lookset.insert(Look::from_repr(combined_assertion).unwrap());",
          "    LookSet::empty().insert(Look::Start) == LookSet { bits: Look::Start.as_repr() }",
          "    LookSet::empty().insert(Look::End) == LookSet { bits: Look::End.as_repr() }",
          "    LookSet::empty().insert(Look::Start).insert(Look::End) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "    LookSet::full().insert(Look::Start) == LookSet { bits: Look::full().bits }",
          "    LookSet::singleton(Look::Start).insert(Look::Start) == LookSet { bits: Look::Start.as_repr() }",
          "    LookSet::singleton(Look::Start).insert(Look::End) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "    LookSet::singleton(Look::End).insert(Look::Start) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "    LookSet::full().insert(Look::Start) == LookSet::full()",
          "    LookSet::singleton(Look::Start).insert(Look::End) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "    LookSet::singleton(Look::End).insert(Look::Start) == LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lookset = LookSet::singleton(Look::Start);",
          "    let result = lookset.insert(Look::Start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.bits, lookset.bits);",
          "    assert_eq!(result.bits, LookSet::singleton(Look::Start).bits);",
          "    assert_ne!(result.bits, LookSet::empty().bits);",
          "    assert!(result.contains(Look::Start));",
          "    assert!(!result.is_empty());"
        ],
        "code": [
          "{",
          "    let lookset = LookSet::singleton(Look::Start);",
          "    let result = lookset.insert(Look::Start);",
          "    assert_eq!(result.bits, lookset.bits);",
          "    assert_eq!(result.bits, LookSet::singleton(Look::Start).bits);",
          "    assert_ne!(result.bits, LookSet::empty().bits);",
          "    assert!(result.contains(Look::Start));",
          "    assert!(!result.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lookset = LookSet::singleton(Look::Start);",
          "    let result = lookset.insert(Look::End);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.bits, lookset.bits | Look::End.as_repr());"
        ],
        "code": [
          "{",
          "    let lookset = LookSet::singleton(Look::Start);",
          "    let result = lookset.insert(Look::End);",
          "    assert_eq!(result.bits, lookset.bits | Look::End.as_repr());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut lookset = LookSet::empty();",
          "    for i in 0..18 {",
          "        lookset = lookset.insert(Look::from_repr(1 << i).unwrap());",
          "    }",
          "    let result = lookset.insert(Look::WordEndHalfUnicode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.bits, LookSet::empty().insert(Look::WordStartHalfUnicode).bits | Look::WordEndHalfUnicode.as_repr());",
          "    assert_eq!(result.len(), 18);",
          "    assert!(result.contains(Look::WordEndHalfUnicode));",
          "    assert!(!result.is_empty());",
          "    assert!(result.contains_anchor());"
        ],
        "code": [
          "{",
          "    let mut lookset = LookSet::empty();",
          "    for i in 0..18 {",
          "        lookset = lookset.insert(Look::from_repr(1 << i).unwrap());",
          "    }",
          "    let result = lookset.insert(Look::WordEndHalfUnicode);",
          "    assert_eq!(result.bits, LookSet::empty().insert(Look::WordStartHalfUnicode).bits | Look::WordEndHalfUnicode.as_repr());",
          "    assert_eq!(result.len(), 18);",
          "    assert!(result.contains(Look::WordEndHalfUnicode));",
          "    assert!(!result.is_empty());",
          "    assert!(result.contains_anchor());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]