[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[];",
          "    let what: &'static str = \"empty slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "}"
        ],
        "oracle": [
          "    let slice: &[u8] = &[];",
          "    let what: &'static str = \"empty slice\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Err(DeserializeError::invalid_length(\"empty slice\"));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[0, 1];",
          "    let what: &'static str = \"valid input\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Ok((1, 2));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[0, 255];",
          "    let what: &'static str = \"u16 max\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Ok((255, 2));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[255, 255];",
          "    let what: &'static str = \"u16 overflow\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Err(DeserializeError::invalid_usize(\"u16 overflow\"));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[1];",
          "    let what: &'static str = \"slice with one byte\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Err(DeserializeError::invalid_length(\"slice with one byte\"));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[0, 0, 0, 0];",
          "    let what: &'static str = \"slice with extra bytes\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Ok((0, 2));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[];",
          "    let what: &'static str = \"empty slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    let slice: &[u8] = &[];",
          "    let what: &'static str = \"empty slice\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Err(DeserializeError::invalid_length(\"empty slice\"));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[0, 1];",
          "    let what: &'static str = \"valid input\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Ok((1, 2));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[0, 255];",
          "    let what: &'static str = \"u16 max\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Ok((255, 2));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[255, 255];",
          "    let what: &'static str = \"u16 overflow\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Err(DeserializeError::invalid_usize(\"u16 overflow\"));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[1];",
          "    let what: &'static str = \"slice with one byte\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Err(DeserializeError::invalid_length(\"slice with one byte\"));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "    ",
          "    let slice: &[u8] = &[0, 0, 0, 0];",
          "    let what: &'static str = \"slice with extra bytes\";",
          "    let expected: Result<(usize, usize), DeserializeError> = Ok((0, 2));",
          "    assert_eq!(try_read_u16_as_usize(slice, what), expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[0x01];",
          "    let what: &'static str = \"one byte slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().0, DeserializeErrorKind::InvalidLength);",
          "    assert_eq!(result.unwrap_err().what, what);",
          "    ",
          "    let slice: &[u8] = &[0x01, 0x00];",
          "    let what: &'static str = \"two byte slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (1, 2));",
          "    ",
          "    let slice: &[u8] = &[0xFF, 0xFF];",
          "    let what: &'static str = \"maximum u16 value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (65535, 2));",
          "    ",
          "    let slice: &[u8] = &[0x00, 0x00];",
          "    let what: &'static str = \"minimum u16 value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (0, 2));",
          "    ",
          "    let slice: &[u8] = &[0x80, 0x00];",
          "    let what: &'static str = \"half-range u16 value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (32768, 2));",
          "    ",
          "    let slice: &[u8] = &[0x00];",
          "    let what: &'static str = \"single byte (too short)\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().0, DeserializeErrorKind::InvalidLength);",
          "    assert_eq!(result.unwrap_err().what, what);",
          "    ",
          "    let slice: &[u8] = &[0x01, 0x00, 0x00];",
          "    let what: &'static str = \"extra byte (valid slice)\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (1, 2));"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[0x01];",
          "    let what: &'static str = \"one byte slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().0, DeserializeErrorKind::InvalidLength);",
          "    assert_eq!(result.unwrap_err().what, what);",
          "    ",
          "    let slice: &[u8] = &[0x01, 0x00];",
          "    let what: &'static str = \"two byte slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (1, 2));",
          "    ",
          "    let slice: &[u8] = &[0xFF, 0xFF];",
          "    let what: &'static str = \"maximum u16 value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (65535, 2));",
          "    ",
          "    let slice: &[u8] = &[0x00, 0x00];",
          "    let what: &'static str = \"minimum u16 value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (0, 2));",
          "    ",
          "    let slice: &[u8] = &[0x80, 0x00];",
          "    let what: &'static str = \"half-range u16 value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (32768, 2));",
          "    ",
          "    let slice: &[u8] = &[0x00];",
          "    let what: &'static str = \"single byte (too short)\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().0, DeserializeErrorKind::InvalidLength);",
          "    assert_eq!(result.unwrap_err().what, what);",
          "    ",
          "    let slice: &[u8] = &[0x01, 0x00, 0x00];",
          "    let what: &'static str = \"extra byte (valid slice)\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), (1, 2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[0x00, 0x00];",
          "    let what: &'static str = \"two byte slice min value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((0, 2)));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().1, 2);",
          "    assert!(matches!(result, Ok(_)));",
          "    assert_err!(try_read_u16_as_usize(&[], what));",
          "    assert_err!(try_read_u16_as_usize(&[0x00], what));",
          "    assert_err!(try_read_u16_as_usize(&[0xFF, 0xFF], what));",
          "    assert_err!(try_read_u16_as_usize(&[0x80, 0x00], what));",
          "    assert_err!(try_read_u16_as_usize(&[0x01, 0x00], \"invalid descriptor\"));",
          "    assert_eq!(try_read_u16_as_usize(&[0x01, 0x00], what), Ok((1, 2)));",
          "    assert_eq!(try_read_u16_as_usize(&[0x02, 0x00], what), Ok((2, 2)));",
          "    assert_eq!(try_read_u16_as_usize(&[0xFF, 0x7F], what), Ok((32767, 2)));",
          "    assert_eq!(try_read_u16_as_usize(&[0x00, 0xFF], what), Ok((255, 2)));",
          "    assert_eq!(try_read_u16_as_usize(&[0x00, 0x00], what), Ok((0, 2)));"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[0x00, 0x00];",
          "    let what: &'static str = \"two byte slice min value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((0, 2)));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().1, 2);",
          "    assert!(matches!(result, Ok(_)));",
          "    assert_err!(try_read_u16_as_usize(&[], what));",
          "    assert_err!(try_read_u16_as_usize(&[0x00], what));",
          "    assert_err!(try_read_u16_as_usize(&[0xFF, 0xFF], what));",
          "    assert_err!(try_read_u16_as_usize(&[0x80, 0x00], what));",
          "    assert_err!(try_read_u16_as_usize(&[0x01, 0x00], \"invalid descriptor\"));",
          "    assert_eq!(try_read_u16_as_usize(&[0x01, 0x00], what), Ok((1, 2)));",
          "    assert_eq!(try_read_u16_as_usize(&[0x02, 0x00], what), Ok((2, 2)));",
          "    assert_eq!(try_read_u16_as_usize(&[0xFF, 0x7F], what), Ok((32767, 2)));",
          "    assert_eq!(try_read_u16_as_usize(&[0x00, 0xFF], what), Ok((255, 2)));",
          "    assert_eq!(try_read_u16_as_usize(&[0x00, 0x00], what), Ok((0, 2)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[0x7F, 0xFF];",
          "    let what: &'static str = \"two byte slice mid value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((32767, 2)));",
          "    assert_eq!(result.unwrap().1, 2);",
          "    assert!(result.is_ok());",
          "    assert!(matches!(result, Ok(_)));",
          "    assert!(result.unwrap().0 <= usize::MAX as u16);"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[0x7F, 0xFF];",
          "    let what: &'static str = \"two byte slice mid value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((32767, 2)));",
          "    assert_eq!(result.unwrap().1, 2);",
          "    assert!(result.is_ok());",
          "    assert!(matches!(result, Ok(_)));",
          "    assert!(result.unwrap().0 <= usize::MAX as u16);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[0xFF, 0xFF];",
          "    let what: &'static str = \"two byte slice max value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((65535, 2)));",
          "    let slice: &[u8] = &[0x00, 0x01];",
          "    let what: &'static str = \"two byte slice min value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((1, 2)));",
          "    let slice: &[u8] = &[0x00];",
          "    let what: &'static str = \"single byte slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert!(result.is_err());",
          "    let slice: &[u8] = &[];",
          "    let what: &'static str = \"empty slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert!(result.is_err());",
          "    let slice: &[u8] = &[0xFF, 0xFF];",
          "    let what: &'static str = \"two byte slice max value for usize\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((65535, 2)));",
          "    let slice: &[u8] = &[0x7F, 0xFF];",
          "    let what: &'static str = \"random two byte slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((32767, 2)));"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[0xFF, 0xFF];",
          "    let what: &'static str = \"two byte slice max value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((65535, 2)));",
          "    let slice: &[u8] = &[0x00, 0x01];",
          "    let what: &'static str = \"two byte slice min value\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((1, 2)));",
          "    let slice: &[u8] = &[0x00];",
          "    let what: &'static str = \"single byte slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert!(result.is_err());",
          "    let slice: &[u8] = &[];",
          "    let what: &'static str = \"empty slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert!(result.is_err());",
          "    let slice: &[u8] = &[0xFF, 0xFF];",
          "    let what: &'static str = \"two byte slice max value for usize\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((65535, 2)));",
          "    let slice: &[u8] = &[0x7F, 0xFF];",
          "    let what: &'static str = \"random two byte slice\";",
          "    let result = try_read_u16_as_usize(slice, what);",
          "    assert_eq!(result, Ok((32767, 2)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]