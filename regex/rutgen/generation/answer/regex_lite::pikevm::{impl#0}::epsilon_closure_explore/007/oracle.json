[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(1).unwrap())];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let haystack: &[u8] = b\"example haystack\";",
          "    let at: usize = 5;",
          "    let sid: StateID = StateID(0);",
          "",
          "    let nfa = NFA {",
          "       //... initialize with appropriate pattern, states, etc.",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    ",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "}"
        ],
        "oracle": [
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(1).unwrap())];",
          "    let mut next = ActiveStates { set: SparseSet::new(10), slot_table: SlotTable::new(), };",
          "    let haystack: &[u8] = b\"example haystack\";",
          "    let at: usize = 5;",
          "    let sid: StateID = StateID(0);",
          "    let nfa = NFA { /* ... initialize with appropriate pattern, states, etc. */ };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    ",
          "    next.set.insert(sid);",
          "    let state = pike_vm.nfa.state(sid);",
          "    if let State::Goto { target, look: None } = *state {",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    }",
          "    if let State::Goto { target, look: Some(look) } = *state {",
          "    assert!(look.is_match(haystack, at));",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    }",
          "    if let State::Char { .. } = *state {",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    }",
          "    if !next.set.insert(sid) {",
          "    return;",
          "    }"
        ],
        "code": [
          "{",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(1).unwrap())];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let haystack: &[u8] = b\"example haystack\";",
          "    let at: usize = 5;",
          "    let sid: StateID = StateID(0);",
          "",
          "    let nfa = NFA {",
          "       //... initialize with appropriate pattern, states, etc.",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    ",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(1).unwrap())];",
          "    let mut next = ActiveStates { set: SparseSet::new(10), slot_table: SlotTable::new(), };",
          "    let haystack: &[u8] = b\"example haystack\";",
          "    let at: usize = 5;",
          "    let sid: StateID = StateID(0);",
          "    let nfa = NFA { /* ... initialize with appropriate pattern, states, etc. */ };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    ",
          "    next.set.insert(sid);",
          "    let state = pike_vm.nfa.state(sid);",
          "    if let State::Goto { target, look: None } = *state {",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    }",
          "    if let State::Goto { target, look: Some(look) } = *state {",
          "    assert!(look.is_match(haystack, at));",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    }",
          "    if let State::Char { .. } = *state {",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    }",
          "    if !next.set.insert(sid) {",
          "    return;",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(2).unwrap())];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let haystack: &[u8] = b\"another example\";",
          "    let at: usize = 8;",
          "    let sid: StateID = StateID(1);",
          "",
          "    let nfa = NFA {",
          "        //... initialize with appropriate pattern, states, etc.",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "}"
        ],
        "oracle": [
          "    next.set.insert(sid) = true;  // precondition satisfied",
          "    self.nfa.state(sid) = State::Goto { target: StateID(2), look: None };  // precondition satisfied",
          "    self.nfa.state(sid) = State::Char { target: StateID(3), ch: 'a' };  // precondition satisfied",
          "    self.nfa.state(sid) = State::Goto { target: StateID(1), look: None };  // precondition satisfied",
          "    next.set.insert(sid) = false;  // precondition satisfied"
        ],
        "code": [
          "{",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(2).unwrap())];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let haystack: &[u8] = b\"another example\";",
          "    let at: usize = 8;",
          "    let sid: StateID = StateID(1);",
          "",
          "    let nfa = NFA {",
          "        //... initialize with appropriate pattern, states, etc.",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    next.set.insert(sid) = true;  // precondition satisfied",
          "    self.nfa.state(sid) = State::Goto { target: StateID(2), look: None };  // precondition satisfied",
          "    self.nfa.state(sid) = State::Char { target: StateID(3), ch: 'a' };  // precondition satisfied",
          "    self.nfa.state(sid) = State::Goto { target: StateID(1), look: None };  // precondition satisfied",
          "    next.set.insert(sid) = false;  // precondition satisfied",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(3).unwrap())];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let haystack: &[u8] = b\"test haystack\";",
          "    let at: usize = 6;",
          "    let sid: StateID = StateID(2);",
          "",
          "    let nfa = NFA {",
          "        //... initialize with appropriate pattern, states, etc.",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "}"
        ],
        "oracle": [
          "    next.set.insert(sid).assert_eq(true);",
          "    self.nfa.state(sid).is_a(State::Goto { target, look: Some(look) }).assert_eq(true);",
          "    self.nfa.state(sid).is_a(State::Goto { target, look: None }).assert_eq(true);",
          "    self.nfa.state(sid).is_a(State::Char { .. }).assert_eq(true);",
          "    next.set.insert(sid).assert_eq(false);"
        ],
        "code": [
          "{",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(3).unwrap())];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let haystack: &[u8] = b\"test haystack\";",
          "    let at: usize = 6;",
          "    let sid: StateID = StateID(2);",
          "",
          "    let nfa = NFA {",
          "        //... initialize with appropriate pattern, states, etc.",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    next.set.insert(sid).assert_eq(true);",
          "    self.nfa.state(sid).is_a(State::Goto { target, look: Some(look) }).assert_eq(true);",
          "    self.nfa.state(sid).is_a(State::Goto { target, look: None }).assert_eq(true);",
          "    self.nfa.state(sid).is_a(State::Char { .. }).assert_eq(true);",
          "    next.set.insert(sid).assert_eq(false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(4).unwrap())];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let haystack: &[u8] = b\"final test\";",
          "    let at: usize = 3;",
          "    let sid: StateID = StateID(3);",
          "",
          "    let nfa = NFA {",
          "        //... initialize with appropriate pattern, states, etc.",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "}"
        ],
        "oracle": [
          "    stack.expect().to.eq(Vec::new());",
          "    curr_slots.expect().to.eq(vec![Some(NonMaxUsize::new(4).unwrap())]);",
          "    next.set.len().expect().to.eq(0);",
          "    next.slot_table.table.len().expect().to.eq(0);",
          "    haystack.len().expect().to.eq(10);",
          "    at.expect().to.eq(3);",
          "    sid.expect().to.eq(StateID(3));",
          "    nfa.pattern().expect().to.eq(\"expected_pattern\");",
          "    pike_vm.nfa().states.len().expect().to.eq(expected_states_count);",
          "    pike_vm.nfa().start().expect().to.eq(expected_start_state_id);"
        ],
        "code": [
          "{",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let mut curr_slots: Vec<Option<NonMaxUsize>> = vec![Some(NonMaxUsize::new(4).unwrap())];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let haystack: &[u8] = b\"final test\";",
          "    let at: usize = 3;",
          "    let sid: StateID = StateID(3);",
          "",
          "    let nfa = NFA {",
          "        //... initialize with appropriate pattern, states, etc.",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    stack.expect().to.eq(Vec::new());",
          "    curr_slots.expect().to.eq(vec![Some(NonMaxUsize::new(4).unwrap())]);",
          "    next.set.len().expect().to.eq(0);",
          "    next.slot_table.table.len().expect().to.eq(0);",
          "    haystack.len().expect().to.eq(10);",
          "    at.expect().to.eq(3);",
          "    sid.expect().to.eq(StateID(3));",
          "    nfa.pattern().expect().to.eq(\"expected_pattern\");",
          "    pike_vm.nfa().states.len().expect().to.eq(expected_states_count);",
          "    pike_vm.nfa().start().expect().to.eq(expected_start_state_id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]