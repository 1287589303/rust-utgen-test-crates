[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"testhaystack\";",
          "    let at = 5;",
          "    let sid = StateID(0); // Assuming this is valid and points to a state with no targets in reverse.",
          "    ",
          "    let nfa = NFA {",
          "        pattern: String::from(\"test\"),",
          "        states: vec![",
          "            State::Splits { targets: vec![], reverse: true },",
          "            State::Fail,",
          "            State::Match,",
          "        ],",
          "        start: sid,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let mut stack = Vec::new();",
          "    let mut curr_slots = vec![None; 1]; // Assuming this is valid and has length > 0",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable {",
          "            table: vec![None; 10],",
          "            slots_per_state: 2,",
          "            slots_for_captures: 1,",
          "        },",
          "    };",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = b\"testhaystack\";",
          "    let at = 5;",
          "    let sid = StateID(0);",
          "    let nfa = NFA {",
          "    states: vec![",
          "    State::Splits { targets: vec![], reverse: true },",
          "    ],",
          "    };",
          "    let mut next = ActiveStates {",
          "    set: SparseSet::new(10),",
          "    slot_table: SlotTable {",
          "    table: vec![None; 10],",
          "    slots_per_state: 2,",
          "    slots_for_captures: 1,",
          "    },",
          "    };",
          "    let result = next.set.insert(sid);",
          "    assert!(result);  // next.set.insert(sid) is true",
          "    ",
          "    let match_state = *nfa.state(sid);",
          "    match match_state {",
          "    State::Splits { ref targets, reverse: true } => {",
          "    assert!(targets.is_empty()); // targets last() is None",
          "    assert!(next.set.len() == 1); // Verify next set has updated",
          "    }",
          "    _ => panic!(\"Expected State::Splits { reverse: true }\")",
          "    }",
          "    ",
          "    let curr_slots: &mut [Option<NonMaxUsize>] = &mut vec![None; 1];",
          "    let mut stack = Vec::new();",
          "    let original_len = stack.len();",
          "    ",
          "    pike_vm.epsilon_closure_explore(&mut stack, curr_slots, &mut next, haystack, at, sid);",
          "    assert_eq!(stack.len(), original_len);  // Ensure stack remains unchanged",
          "    assert_eq!(curr_slots, &[None]);  // Ensure slots are unchanged in capture"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"testhaystack\";",
          "    let at = 5;",
          "    let sid = StateID(0); // Assuming this is valid and points to a state with no targets in reverse.",
          "    ",
          "    let nfa = NFA {",
          "        pattern: String::from(\"test\"),",
          "        states: vec![",
          "            State::Splits { targets: vec![], reverse: true },",
          "            State::Fail,",
          "            State::Match,",
          "        ],",
          "        start: sid,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let mut stack = Vec::new();",
          "    let mut curr_slots = vec![None; 1]; // Assuming this is valid and has length > 0",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable {",
          "            table: vec![None; 10],",
          "            slots_per_state: 2,",
          "            slots_for_captures: 1,",
          "        },",
          "    };",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    let haystack: &[u8] = b\"testhaystack\";",
          "    let at = 5;",
          "    let sid = StateID(0);",
          "    let nfa = NFA {",
          "    states: vec![",
          "    State::Splits { targets: vec![], reverse: true },",
          "    ],",
          "    };",
          "    let mut next = ActiveStates {",
          "    set: SparseSet::new(10),",
          "    slot_table: SlotTable {",
          "    table: vec![None; 10],",
          "    slots_per_state: 2,",
          "    slots_for_captures: 1,",
          "    },",
          "    };",
          "    let result = next.set.insert(sid);",
          "    assert!(result);  // next.set.insert(sid) is true",
          "    ",
          "    let match_state = *nfa.state(sid);",
          "    match match_state {",
          "    State::Splits { ref targets, reverse: true } => {",
          "    assert!(targets.is_empty()); // targets last() is None",
          "    assert!(next.set.len() == 1); // Verify next set has updated",
          "    }",
          "    _ => panic!(\"Expected State::Splits { reverse: true }\")",
          "    }",
          "    ",
          "    let curr_slots: &mut [Option<NonMaxUsize>] = &mut vec![None; 1];",
          "    let mut stack = Vec::new();",
          "    let original_len = stack.len();",
          "    ",
          "    pike_vm.epsilon_closure_explore(&mut stack, curr_slots, &mut next, haystack, at, sid);",
          "    assert_eq!(stack.len(), original_len);  // Ensure stack remains unchanged",
          "    assert_eq!(curr_slots, &[None]);  // Ensure slots are unchanged in capture",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"examplehaystack\";",
          "    let at = 4;",
          "    let sid = StateID(1); // Assuming this is valid and points to a state that has reverse splits.",
          "",
          "    let nfa = NFA {",
          "        pattern: String::from(\"example\"),",
          "        states: vec![",
          "            State::Splits { targets: vec![StateID(2), StateID(3)], reverse: true },",
          "            State::Match,",
          "            State::Fail,",
          "        ],",
          "        start: sid,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let mut stack = Vec::new();",
          "    let mut curr_slots = vec![None; 5]; // Assuming valid length > 0",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable {",
          "            table: vec![None; 20],",
          "            slots_per_state: 2,",
          "            slots_for_captures: 5,",
          "        },",
          "    };",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "}"
        ],
        "oracle": [
          "    next.set.insert(sid); // Precondition: should return true",
          "    ",
          "    let state = pike_vm.nfa.state(sid); // Fetch state for sid",
          "    assert!(matches!(state, State::Splits { ref targets, reverse: true })); // Precondition: must match State::Splits { reverse: true }",
          "    ",
          "    let targets = if let State::Splits { ref targets, .. } = state { targets } else { unreachable!() }; // Retrieve targets",
          "    ",
          "    assert!(targets.last().is_none()); // Precondition: targets.last() must be None",
          "    ",
          "    // Validate that other preconditions hold true by checking state type",
          "    assert!(!matches!(state, State::Ranges { .. })); // Precondition: must NOT match State::Ranges { .. }",
          "    assert!(!matches!(state, State::Goto { target, look: Some(_) })); // Precondition: must NOT match State::Goto with Some(look)",
          "    assert!(!matches!(state, State::Match { .. })); // Precondition: must NOT match State::Match { .. }",
          "    assert!(!matches!(state, State::Char { .. })); // Precondition: must NOT match State::Char { .. }",
          "    assert!(!matches!(state, State::Fail)); // Precondition: must NOT match State::Fail",
          "    assert!(!matches!(state, State::Goto { target, look: None })); // Precondition: must NOT match State::Goto with None",
          "    assert!(!matches!(state, State::Capture { target, slot })); // Precondition: must NOT match State::Capture { .. }"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"examplehaystack\";",
          "    let at = 4;",
          "    let sid = StateID(1); // Assuming this is valid and points to a state that has reverse splits.",
          "",
          "    let nfa = NFA {",
          "        pattern: String::from(\"example\"),",
          "        states: vec![",
          "            State::Splits { targets: vec![StateID(2), StateID(3)], reverse: true },",
          "            State::Match,",
          "            State::Fail,",
          "        ],",
          "        start: sid,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let mut stack = Vec::new();",
          "    let mut curr_slots = vec![None; 5]; // Assuming valid length > 0",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable {",
          "            table: vec![None; 20],",
          "            slots_per_state: 2,",
          "            slots_for_captures: 5,",
          "        },",
          "    };",
          "",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
          "    next.set.insert(sid); // Precondition: should return true",
          "    ",
          "    let state = pike_vm.nfa.state(sid); // Fetch state for sid",
          "    assert!(matches!(state, State::Splits { ref targets, reverse: true })); // Precondition: must match State::Splits { reverse: true }",
          "    ",
          "    let targets = if let State::Splits { ref targets, .. } = state { targets } else { unreachable!() }; // Retrieve targets",
          "    ",
          "    assert!(targets.last().is_none()); // Precondition: targets.last() must be None",
          "    ",
          "    // Validate that other preconditions hold true by checking state type",
          "    assert!(!matches!(state, State::Ranges { .. })); // Precondition: must NOT match State::Ranges { .. }",
          "    assert!(!matches!(state, State::Goto { target, look: Some(_) })); // Precondition: must NOT match State::Goto with Some(look)",
          "    assert!(!matches!(state, State::Match { .. })); // Precondition: must NOT match State::Match { .. }",
          "    assert!(!matches!(state, State::Char { .. })); // Precondition: must NOT match State::Char { .. }",
          "    assert!(!matches!(state, State::Fail)); // Precondition: must NOT match State::Fail",
          "    assert!(!matches!(state, State::Goto { target, look: None })); // Precondition: must NOT match State::Goto with None",
          "    assert!(!matches!(state, State::Capture { target, slot })); // Precondition: must NOT match State::Capture { .. }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]