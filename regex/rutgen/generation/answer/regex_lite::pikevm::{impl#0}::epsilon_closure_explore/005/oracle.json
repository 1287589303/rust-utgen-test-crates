[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: Vec<u8> = vec![b'a'];",
          "    let mut stack = vec![];",
          "    let mut curr_slots = vec![None; 2];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let nfa = NFA {",
          "        states: vec![",
          "            State::Goto { target: StateID(1), look: None },",
          "            State::Match,",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pike_vm = PikeVM { nfa };",
          "",
          "    let sid = StateID(0);",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, &haystack, 0, sid);",
          "}"
        ],
        "oracle": [
          "    next.set.insert(sid); // Precondition that insert is true",
          "    ",
          "    let sid = StateID(0);",
          "    let state = pike_vm.nfa.state(sid);",
          "    assert!(matches!(state, State::Goto { target: StateID(1), look: None })); // *self.nfa.state(sid) matches State::Goto { target, look: None }",
          "    ",
          "    let state = pike_vm.nfa.state(StateID(1));",
          "    assert!(matches!(state, State::Match)); // Validate that state transitions to a match",
          "    ",
          "    let state_with_look = State::Goto { target: StateID(1), look: Some(Look::Start) };",
          "    let look_match_result = look_with_look.is_match(&haystack, 0);",
          "    assert!(look_match_result); // Precondition look.is_match(haystack, at) is true",
          "    ",
          "    next.set.insert(sid); // Precondition that insert is false"
        ],
        "code": [
          "{",
          "    let haystack: Vec<u8> = vec![b'a'];",
          "    let mut stack = vec![];",
          "    let mut curr_slots = vec![None; 2];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let nfa = NFA {",
          "        states: vec![",
          "            State::Goto { target: StateID(1), look: None },",
          "            State::Match,",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pike_vm = PikeVM { nfa };",
          "",
          "    let sid = StateID(0);",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, &haystack, 0, sid);",
          "    next.set.insert(sid); // Precondition that insert is true",
          "    ",
          "    let sid = StateID(0);",
          "    let state = pike_vm.nfa.state(sid);",
          "    assert!(matches!(state, State::Goto { target: StateID(1), look: None })); // *self.nfa.state(sid) matches State::Goto { target, look: None }",
          "    ",
          "    let state = pike_vm.nfa.state(StateID(1));",
          "    assert!(matches!(state, State::Match)); // Validate that state transitions to a match",
          "    ",
          "    let state_with_look = State::Goto { target: StateID(1), look: Some(Look::Start) };",
          "    let look_match_result = look_with_look.is_match(&haystack, 0);",
          "    assert!(look_match_result); // Precondition look.is_match(haystack, at) is true",
          "    ",
          "    next.set.insert(sid); // Precondition that insert is false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: Vec<u8> = vec![b'a'];",
          "    let mut stack = vec![];",
          "    let mut curr_slots = vec![None; 2];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let nfa = NFA {",
          "        states: vec![",
          "            State::Goto { target: StateID(1), look: Some(Look::Start) },",
          "            State::Match,",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pike_vm = PikeVM { nfa };",
          "",
          "    let sid = StateID(0);",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, &haystack, 0, sid);",
          "}"
        ],
        "oracle": [
          "    next.set.insert(sid) = true;",
          "    self.nfa.state(sid) = State::Goto { target: StateID(1), look: Some(Look::Start) };",
          "    haystack = &[b'a'];",
          "    at = 0;",
          "    sid = StateID(0);",
          "    curr_slots[slot.as_usize()] = Some(NonMaxUsize::new(at).unwrap());",
          "    next.slot_table.for_state(sid).copy_from_slice(curr_slots);",
          "    next.set.insert(sid) = false;",
          "    self.nfa.state(sid) = State::Goto { target: StateID(1), look: None };",
          "    self.nfa.state(sid) = State::Ranges { target: StateID(1), ranges: vec![(b'a' as char, b'a' as char)] };",
          "    look.is_match(haystack, at) = true;"
        ],
        "code": [
          "{",
          "    let haystack: Vec<u8> = vec![b'a'];",
          "    let mut stack = vec![];",
          "    let mut curr_slots = vec![None; 2];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let nfa = NFA {",
          "        states: vec![",
          "            State::Goto { target: StateID(1), look: Some(Look::Start) },",
          "            State::Match,",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pike_vm = PikeVM { nfa };",
          "",
          "    let sid = StateID(0);",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, &haystack, 0, sid);",
          "    next.set.insert(sid) = true;",
          "    self.nfa.state(sid) = State::Goto { target: StateID(1), look: Some(Look::Start) };",
          "    haystack = &[b'a'];",
          "    at = 0;",
          "    sid = StateID(0);",
          "    curr_slots[slot.as_usize()] = Some(NonMaxUsize::new(at).unwrap());",
          "    next.slot_table.for_state(sid).copy_from_slice(curr_slots);",
          "    next.set.insert(sid) = false;",
          "    self.nfa.state(sid) = State::Goto { target: StateID(1), look: None };",
          "    self.nfa.state(sid) = State::Ranges { target: StateID(1), ranges: vec![(b'a' as char, b'a' as char)] };",
          "    look.is_match(haystack, at) = true;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: Vec<u8> = vec![b'a'];",
          "    let mut stack = vec![];",
          "    let mut curr_slots = vec![None; 2];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let nfa = NFA {",
          "        states: vec![",
          "            State::Ranges { target: StateID(1), ranges: vec![('a', 'z')] },",
          "            State::Match,",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pike_vm = PikeVM { nfa };",
          "",
          "    let sid = StateID(0);",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, &haystack, 0, sid);",
          "}"
        ],
        "oracle": [
          "    next.set.insert(sid);",
          "    * self.nfa.state(sid) matches State::Goto { target, look: None };",
          "    * self.nfa.state(sid) matches State::Goto { target, look: Some(look) };",
          "    * self.nfa.state(sid) matches State::Ranges { .. };",
          "    * self.nfa.state(sid) matches State::Goto { target, look: Some(look) };",
          "    look.is_match(haystack, at);",
          "    next.set.insert(sid) is false;"
        ],
        "code": [
          "{",
          "    let haystack: Vec<u8> = vec![b'a'];",
          "    let mut stack = vec![];",
          "    let mut curr_slots = vec![None; 2];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let nfa = NFA {",
          "        states: vec![",
          "            State::Ranges { target: StateID(1), ranges: vec![('a', 'z')] },",
          "            State::Match,",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pike_vm = PikeVM { nfa };",
          "",
          "    let sid = StateID(0);",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, &haystack, 0, sid);",
          "    next.set.insert(sid);",
          "    * self.nfa.state(sid) matches State::Goto { target, look: None };",
          "    * self.nfa.state(sid) matches State::Goto { target, look: Some(look) };",
          "    * self.nfa.state(sid) matches State::Ranges { .. };",
          "    * self.nfa.state(sid) matches State::Goto { target, look: Some(look) };",
          "    look.is_match(haystack, at);",
          "    next.set.insert(sid) is false;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: Vec<u8> = vec![b'a'];",
          "    let mut stack = vec![];",
          "    let mut curr_slots = vec![None; 2];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let nfa = NFA {",
          "        states: vec![",
          "            State::Goto { target: StateID(1), look: Some(Look::Word) },",
          "            State::Goto { target: StateID(0), look: None },",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pike_vm = PikeVM { nfa };",
          "",
          "    let sid = StateID(0);",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, &haystack, 0, sid);",
          "}"
        ],
        "oracle": [
          "    next.set.insert(sid); // Ensure precondition is true before method invocation",
          "    self.nfa.state(sid) == State::Goto { target: StateID(1), look: Some(Look::Word) }; // Precondition for exploring Goto",
          "    self.nfa.state(sid) == State::Goto { target: StateID(0), look: None }; // Precondition for exploring Goto",
          "    self.nfa.state(sid) == State::Ranges { .. }; // Precondition for state Ranges",
          "    self.nfa.state(sid) == State::Goto { target, look: Some(look) }; // Precondition for state Goto with look",
          "    look.is_match(&haystack, 0); // Precondition for look match",
          "    !next.set.insert(sid); // Precondition for insertion failure"
        ],
        "code": [
          "{",
          "    let haystack: Vec<u8> = vec![b'a'];",
          "    let mut stack = vec![];",
          "    let mut curr_slots = vec![None; 2];",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(10),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "    let nfa = NFA {",
          "        states: vec![",
          "            State::Goto { target: StateID(1), look: Some(Look::Word) },",
          "            State::Goto { target: StateID(0), look: None },",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pike_vm = PikeVM { nfa };",
          "",
          "    let sid = StateID(0);",
          "    pike_vm.epsilon_closure_explore(&mut stack, &mut curr_slots, &mut next, &haystack, 0, sid);",
          "    next.set.insert(sid); // Ensure precondition is true before method invocation",
          "    self.nfa.state(sid) == State::Goto { target: StateID(1), look: Some(Look::Word) }; // Precondition for exploring Goto",
          "    self.nfa.state(sid) == State::Goto { target: StateID(0), look: None }; // Precondition for exploring Goto",
          "    self.nfa.state(sid) == State::Ranges { .. }; // Precondition for state Ranges",
          "    self.nfa.state(sid) == State::Goto { target, look: Some(look) }; // Precondition for state Goto with look",
          "    look.is_match(&haystack, 0); // Precondition for look match",
          "    !next.set.insert(sid); // Precondition for insertion failure",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]