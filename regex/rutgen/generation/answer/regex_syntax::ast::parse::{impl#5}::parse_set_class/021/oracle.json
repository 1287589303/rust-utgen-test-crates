[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = {",
          "        let mut pos = Cell::new(Position::new());",
          "        let comments = RefCell::new(vec![]);",
          "        let stack_class = RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { span: Span { start: pos.get(), end: pos.get() }, items: vec![] }, set: ast::ClassBracketed { span: Span { start: pos.get(), end: pos.get() }, negated: false, kind: ClassSet::Normal } }]);",
          "        let parser = Parser {",
          "            pos,",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments,",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class,",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "        parser",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: \"[[a-z]]\",",
          "    };",
          "",
          "    let result = parser_i.parse_set_class();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_err(), true);",
          "    assert!(result.err().unwrap() == some_expected_error);",
          "    assert!(parser_i.parser.stack_class.borrow().len() == 1);",
          "    assert!(parser_i.parser.stack_class.borrow().last().unwrap().is_open());",
          "    assert!(parser_i.scratch.borrow().is_empty());",
          "    assert!(parser_i.ignore_whitespace.get() == false);",
          "    assert!(parser_i.capture_names.borrow().is_empty());",
          "    assert!(parser_i.pos.get() == parser_i.pattern.len());",
          "    assert!(parser_i.parser.comments.borrow().is_empty());",
          "    assert!(parser_i.parser.capture_index.get() == 0);"
        ],
        "code": [
          "{",
          "    let parser = {",
          "        let mut pos = Cell::new(Position::new());",
          "        let comments = RefCell::new(vec![]);",
          "        let stack_class = RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { span: Span { start: pos.get(), end: pos.get() }, items: vec![] }, set: ast::ClassBracketed { span: Span { start: pos.get(), end: pos.get() }, negated: false, kind: ClassSet::Normal } }]);",
          "        let parser = Parser {",
          "            pos,",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments,",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class,",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "        parser",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: \"[[a-z]]\",",
          "    };",
          "",
          "    let result = parser_i.parse_set_class();",
          "    assert_eq!(result.is_err(), true);",
          "    assert!(result.err().unwrap() == some_expected_error);",
          "    assert!(parser_i.parser.stack_class.borrow().len() == 1);",
          "    assert!(parser_i.parser.stack_class.borrow().last().unwrap().is_open());",
          "    assert!(parser_i.scratch.borrow().is_empty());",
          "    assert!(parser_i.ignore_whitespace.get() == false);",
          "    assert!(parser_i.capture_names.borrow().is_empty());",
          "    assert!(parser_i.pos.get() == parser_i.pattern.len());",
          "    assert!(parser_i.parser.comments.borrow().is_empty());",
          "    assert!(parser_i.parser.capture_index.get() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = {",
          "        let mut pos = Cell::new(Position::new());",
          "        let comments = RefCell::new(vec![]);",
          "        let stack_class = RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { span: Span { start: pos.get(), end: pos.get() }, items: vec![] }, set: ast::ClassBracketed { span: Span { start: pos.get(), end: pos.get() }, negated: false, kind: ClassSet::Normal } }]);",
          "        let parser = Parser {",
          "            pos,",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments,",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class,",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "        parser",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: \"[[:alpha:]]&[[::digit:]]\",",
          "    };",
          "",
          "    let result = parser_i.parse_set_class();",
          "}"
        ],
        "oracle": [
          "    let parser = { let parser = Parser { stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { items: vec![] }, set: ast::ClassBracketed { negated: false, kind: ClassSet::Normal } }]), ..Default::default() }; parser };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"[[:alpha:]]&[[::digit:]]\" };",
          "    let result = parser_i.parse_set_class();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::ClassRangeInvalid);"
        ],
        "code": [
          "{",
          "    let parser = {",
          "        let mut pos = Cell::new(Position::new());",
          "        let comments = RefCell::new(vec![]);",
          "        let stack_class = RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { span: Span { start: pos.get(), end: pos.get() }, items: vec![] }, set: ast::ClassBracketed { span: Span { start: pos.get(), end: pos.get() }, negated: false, kind: ClassSet::Normal } }]);",
          "        let parser = Parser {",
          "            pos,",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments,",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class,",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "        parser",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: \"[[:alpha:]]&[[::digit:]]\",",
          "    };",
          "",
          "    let result = parser_i.parse_set_class();",
          "    let parser = { let parser = Parser { stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { items: vec![] }, set: ast::ClassBracketed { negated: false, kind: ClassSet::Normal } }]), ..Default::default() }; parser };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"[[:alpha:]]&[[::digit:]]\" };",
          "    let result = parser_i.parse_set_class();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::ClassRangeInvalid);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = {",
          "        let mut pos = Cell::new(Position::new());",
          "        let comments = RefCell::new(vec![]);",
          "        let stack_class = RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { span: Span { start: pos.get(), end: pos.get() }, items: vec![] }, set: ast::ClassBracketed { span: Span { start: pos.get(), end: pos.get() }, negated: false, kind: ClassSet::Normal } }]);",
          "        let parser = Parser {",
          "            pos,",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments,",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class,",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "        parser",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: \"[a--b]\",",
          "    };",
          "",
          "    let result = parser_i.parse_set_class();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::ClassRangeInvalid);",
          "    assert_eq!(parser_i.parser.stack_class.borrow().len(), 1);",
          "    assert_eq!(parser_i.parser.comments.borrow().len(), 0);",
          "    assert_eq!(parser_i.parser.capture_names.borrow().len(), 0);",
          "    assert_eq!(parser_i.parser.scratch.borrow().len(), 0);",
          "    assert_eq!(parser_i.parser.stack_group.borrow().is_empty(), true);"
        ],
        "code": [
          "{",
          "    let parser = {",
          "        let mut pos = Cell::new(Position::new());",
          "        let comments = RefCell::new(vec![]);",
          "        let stack_class = RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { span: Span { start: pos.get(), end: pos.get() }, items: vec![] }, set: ast::ClassBracketed { span: Span { start: pos.get(), end: pos.get() }, negated: false, kind: ClassSet::Normal } }]);",
          "        let parser = Parser {",
          "            pos,",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments,",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class,",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "        parser",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: \"[a--b]\",",
          "    };",
          "",
          "    let result = parser_i.parse_set_class();",
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::ClassRangeInvalid);",
          "    assert_eq!(parser_i.parser.stack_class.borrow().len(), 1);",
          "    assert_eq!(parser_i.parser.comments.borrow().len(), 0);",
          "    assert_eq!(parser_i.parser.capture_names.borrow().len(), 0);",
          "    assert_eq!(parser_i.parser.scratch.borrow().len(), 0);",
          "    assert_eq!(parser_i.parser.stack_group.borrow().is_empty(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = {",
          "        let mut pos = Cell::new(Position::new());",
          "        let comments = RefCell::new(vec![]);",
          "        let stack_class = RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { span: Span { start: pos.get(), end: pos.get() }, items: vec![] }, set: ast::ClassBracketed { span: Span { start: pos.get(), end: pos.get() }, negated: false, kind: ClassSet::Normal } }]);",
          "        let parser = Parser {",
          "            pos,",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments,",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class,",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "        parser",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: \"[a-z&&[a]]\",",
          "    };",
          "",
          "    let result = parser_i.parse_set_class();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.char(), '[');",
          "    assert!(!self.is_eof());",
          "    assert_eq!(self.char(), '[');",
          "    assert!(!self.parser().stack_class.borrow().is_empty());",
          "    assert!(self.maybe_parse_ascii_class().is_some());",
          "    assert!(self.push_class_open(union).is_err());",
          "    let union = ast::ClassSetUnion { span: self.span(), items: vec![] };",
          "    let class_set_item = self.parse_set_class_range().unwrap();",
          "    union.push(class_set_item);",
          "    assert!(union.items.len() > 0);",
          "    assert_eq!(self.char(), ']');"
        ],
        "code": [
          "{",
          "    let parser = {",
          "        let mut pos = Cell::new(Position::new());",
          "        let comments = RefCell::new(vec![]);",
          "        let stack_class = RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion { span: Span { start: pos.get(), end: pos.get() }, items: vec![] }, set: ast::ClassBracketed { span: Span { start: pos.get(), end: pos.get() }, negated: false, kind: ClassSet::Normal } }]);",
          "        let parser = Parser {",
          "            pos,",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments,",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class,",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "        parser",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: \"[a-z&&[a]]\",",
          "    };",
          "",
          "    let result = parser_i.parse_set_class();",
          "    assert_eq!(self.char(), '[');",
          "    assert!(!self.is_eof());",
          "    assert_eq!(self.char(), '[');",
          "    assert!(!self.parser().stack_class.borrow().is_empty());",
          "    assert!(self.maybe_parse_ascii_class().is_some());",
          "    assert!(self.push_class_open(union).is_err());",
          "    let union = ast::ClassSetUnion { span: self.span(), items: vec![] };",
          "    let class_set_item = self.parse_set_class_range().unwrap();",
          "    union.push(class_set_item);",
          "    assert!(union.items.len() > 0);",
          "    assert_eq!(self.char(), ']');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]