[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_info = GroupInfo::empty();",
          "    let captures = Captures::empty(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures_debug_map.caps.group_info().pattern_names(captures_debug_map.pid).enumerate().next(), None);",
          "    assert!(captures_debug_map.caps.get_group(0).is_none());",
          "    assert!(captures_debug_map.caps.group_info().pattern_len() == 0);",
          "    assert!(captures_debug_map.caps.slots.is_empty());",
          "    assert!(captures_debug_map.caps.pattern().is_none());",
          "    assert!(captures_debug_map.caps.group_len() == 0);",
          "    assert!(captures_debug_map.caps.is_match() == false);"
        ],
        "code": [
          "{",
          "    let group_info = GroupInfo::empty();",
          "    let captures = Captures::empty(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "    assert_eq!(captures_debug_map.caps.group_info().pattern_names(captures_debug_map.pid).enumerate().next(), None);",
          "    assert!(captures_debug_map.caps.get_group(0).is_none());",
          "    assert!(captures_debug_map.caps.group_info().pattern_len() == 0);",
          "    assert!(captures_debug_map.caps.slots.is_empty());",
          "    assert!(captures_debug_map.caps.pattern().is_none());",
          "    assert!(captures_debug_map.caps.group_len() == 0);",
          "    assert!(captures_debug_map.caps.is_match() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_info = GroupInfo::new(vec![None]).unwrap();",
          "    let captures = Captures::all(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "}"
        ],
        "oracle": [
          "    assert!(captures_debug_map.caps.group_info().pattern_names(captures_debug_map.pid).count() == 0);",
          "    assert!(captures_debug_map.caps.get_group(0).is_none());"
        ],
        "code": [
          "{",
          "    let group_info = GroupInfo::new(vec![None]).unwrap();",
          "    let captures = Captures::all(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "    assert!(captures_debug_map.caps.group_info().pattern_names(captures_debug_map.pid).count() == 0);",
          "    assert!(captures_debug_map.caps.get_group(0).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut names = vec![None];",
          "    let group_info = GroupInfo::new(vec![Some(names.pop())]).unwrap();",
          "    let captures = Captures::all(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "}"
        ],
        "oracle": [
          "    let mut names = vec![None];",
          "    let group_info = GroupInfo::new(vec![Some(names.pop())]).unwrap();",
          "    let captures = Captures::all(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());"
        ],
        "code": [
          "{",
          "    let mut names = vec![None];",
          "    let group_info = GroupInfo::new(vec![Some(names.pop())]).unwrap();",
          "    let captures = Captures::all(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "    let mut names = vec![None];",
          "    let group_info = GroupInfo::new(vec![Some(names.pop())]).unwrap();",
          "    let captures = Captures::all(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let groups = vec![None, None, None];",
          "    let group_info = GroupInfo::new(vec![Some(group); groups.len()]).unwrap();",
          "    let captures = Captures::all(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures_debug_map.caps.group_info().pattern_names(pid).count(), 0);",
          "    assert!(captures_debug_map.caps.get_group(0).is_none());",
          "    assert!(captures_debug_map.caps.get_group(1).is_none());",
          "    assert!(captures_debug_map.caps.get_group(2).is_none());",
          "    assert!(captures_debug_map.caps.group_info().slots(pid, 0).is_none());",
          "    assert!(captures_debug_map.caps.group_info().to_name(pid, 0).is_none());"
        ],
        "code": [
          "{",
          "    let groups = vec![None, None, None];",
          "    let group_info = GroupInfo::new(vec![Some(group); groups.len()]).unwrap();",
          "    let captures = Captures::all(group_info);",
          "    let pid = PatternID::default();",
          "    let captures_debug_map = CapturesDebugMap { pid, caps: &captures };",
          "",
          "    let _result = core::fmt::Debug::fmt(&captures_debug_map, &mut core::fmt::Formatter::default());",
          "    assert_eq!(captures_debug_map.caps.group_info().pattern_names(pid).count(), 0);",
          "    assert!(captures_debug_map.caps.get_group(0).is_none());",
          "    assert!(captures_debug_map.caps.get_group(1).is_none());",
          "    assert!(captures_debug_map.caps.get_group(2).is_none());",
          "    assert!(captures_debug_map.caps.group_info().slots(pid, 0).is_none());",
          "    assert!(captures_debug_map.caps.group_info().to_name(pid, 0).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]