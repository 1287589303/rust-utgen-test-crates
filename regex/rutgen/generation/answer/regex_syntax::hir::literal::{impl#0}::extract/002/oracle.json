[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    ",
          "    let literal1 = Literal::exact(vec![b'a']);",
          "    let literal2 = Literal::exact(vec![b'b']);",
          "    let hir1 = Hir { kind: HirKind::Literal(literal1.clone()), props: Properties::default() };",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "    ",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "    ",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len(), Some(2));",
          "    assert_eq!(result.literals().unwrap()[0], Literal::exact(vec![b'b']));",
          "    assert_eq!(result.literals().unwrap()[1], Literal::exact(vec![b'a']));",
          "    assert!(result.is_exact());",
          "    assert!(!result.is_inexact());"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    ",
          "    let literal1 = Literal::exact(vec![b'a']);",
          "    let literal2 = Literal::exact(vec![b'b']);",
          "    let hir1 = Hir { kind: HirKind::Literal(literal1.clone()), props: Properties::default() };",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "    ",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "    ",
          "    let result = extractor.extract(&hir);",
          "    assert_eq!(result.len(), Some(2));",
          "    assert_eq!(result.literals().unwrap()[0], Literal::exact(vec![b'b']));",
          "    assert_eq!(result.literals().unwrap()[1], Literal::exact(vec![b'a']));",
          "    assert!(result.is_exact());",
          "    assert!(!result.is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    ",
          "    let literal1 = Literal::exact(vec![b'c']);",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(literal1.clone()), props: Properties::default() }) };",
          "    let hir1 = Hir { kind: HirKind::Repetition(repetition), props: Properties::default() };",
          "    ",
          "    let literal2 = Literal::exact(vec![b'd']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "    ",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "    ",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    let literal1 = Literal::exact(vec![b'c']);",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(literal1.clone()), props: Properties::default() }) };",
          "    let hir1 = Hir { kind: HirKind::Repetition(repetition), props: Properties::default() };",
          "    let literal2 = Literal::exact(vec![b'd']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "    let result = extractor.extract(&hir);",
          "    assert_eq!(result.len(), Some(4));",
          "    assert!(result.is_exact());",
          "    assert!(result.literals().unwrap().contains(&literal2));",
          "    assert!(result.literals().unwrap().iter().any(|lit| lit.bytes == vec![b'c', b'c', b'c']));",
          "    assert!(result.literals().unwrap().iter().any(|lit| lit.bytes == vec![b'c', b'c', b'd']));"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    ",
          "    let literal1 = Literal::exact(vec![b'c']);",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(literal1.clone()), props: Properties::default() }) };",
          "    let hir1 = Hir { kind: HirKind::Repetition(repetition), props: Properties::default() };",
          "    ",
          "    let literal2 = Literal::exact(vec![b'd']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "    ",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "    ",
          "    let result = extractor.extract(&hir);",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    let literal1 = Literal::exact(vec![b'c']);",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(literal1.clone()), props: Properties::default() }) };",
          "    let hir1 = Hir { kind: HirKind::Repetition(repetition), props: Properties::default() };",
          "    let literal2 = Literal::exact(vec![b'd']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "    let result = extractor.extract(&hir);",
          "    assert_eq!(result.len(), Some(4));",
          "    assert!(result.is_exact());",
          "    assert!(result.literals().unwrap().contains(&literal2));",
          "    assert!(result.literals().unwrap().iter().any(|lit| lit.bytes == vec![b'c', b'c', b'c']));",
          "    assert!(result.literals().unwrap().iter().any(|lit| lit.bytes == vec![b'c', b'c', b'd']));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    ",
          "    let class_bytes = ClassBytes { set: IntervalSet::default() }; // Assuming appropriate default construction",
          "    let hir1 = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), props: Properties::default() };",
          "",
          "    let literal2 = Literal::exact(vec![b'e']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    let class_bytes = ClassBytes { set: IntervalSet::default() };",
          "    let hir1 = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), props: Properties::default() };",
          "    let literal2 = Literal::exact(vec![b'e']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "    let result = extractor.extract(&hir);",
          "    assert_eq!(result.literals().unwrap().len(), expected_length);",
          "    assert!(result.is_inexact());",
          "    assert_eq!(result.max_literal_len(), Some(expected_max_len));",
          "    assert_eq!(result.min_literal_len(), Some(expected_min_len));",
          "    assert!(result.literals().unwrap().contains(&literal2));"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    ",
          "    let class_bytes = ClassBytes { set: IntervalSet::default() }; // Assuming appropriate default construction",
          "    let hir1 = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), props: Properties::default() };",
          "",
          "    let literal2 = Literal::exact(vec![b'e']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "",
          "    let result = extractor.extract(&hir);",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    let class_bytes = ClassBytes { set: IntervalSet::default() };",
          "    let hir1 = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), props: Properties::default() };",
          "    let literal2 = Literal::exact(vec![b'e']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "    let hirs = vec![hir1, hir2];",
          "    let hir = Hir { kind: HirKind::Concat(hirs), props: Properties::default() };",
          "    let result = extractor.extract(&hir);",
          "    assert_eq!(result.literals().unwrap().len(), expected_length);",
          "    assert!(result.is_inexact());",
          "    assert_eq!(result.max_literal_len(), Some(expected_max_len));",
          "    assert_eq!(result.min_literal_len(), Some(expected_min_len));",
          "    assert!(result.literals().unwrap().contains(&literal2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "",
          "    let literal1 = Literal::exact(vec![b'f']);",
          "    let hir1 = Hir { kind: HirKind::Literal(literal1.clone()), props: Properties::default() };",
          "    ",
          "    let literal2 = Literal::exact(vec![b'g']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "",
          "    let hirs_alt = vec![hir1, hir2];",
          "    let alt_hir = Hir { kind: HirKind::Alternation(hirs_alt), props: Properties::default() };",
          "",
          "    let hirs_concat = vec![alt_hir, alt_hir]; // At least two sub-expressions",
          "    let hir = Hir { kind: HirKind::Concat(hirs_concat), props: Properties::default() };",
          "    ",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.literals().unwrap().len(), 2);",
          "    assert!(result.literals().unwrap()[0].is_exact());",
          "    assert!(result.literals().unwrap()[1].is_exact());",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'g']);",
          "    assert_eq!(result.literals().unwrap()[1].bytes, vec![b'g']);",
          "    assert!(result.is_inexact());",
          "    assert!(!result.is_empty());",
          "    assert!(result.len().is_some());",
          "    assert!(result.len().unwrap() > 0);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "",
          "    let literal1 = Literal::exact(vec![b'f']);",
          "    let hir1 = Hir { kind: HirKind::Literal(literal1.clone()), props: Properties::default() };",
          "    ",
          "    let literal2 = Literal::exact(vec![b'g']);",
          "    let hir2 = Hir { kind: HirKind::Literal(literal2.clone()), props: Properties::default() };",
          "",
          "    let hirs_alt = vec![hir1, hir2];",
          "    let alt_hir = Hir { kind: HirKind::Alternation(hirs_alt), props: Properties::default() };",
          "",
          "    let hirs_concat = vec![alt_hir, alt_hir]; // At least two sub-expressions",
          "    let hir = Hir { kind: HirKind::Concat(hirs_concat), props: Properties::default() };",
          "    ",
          "    let result = extractor.extract(&hir);",
          "    assert_eq!(result.literals().unwrap().len(), 2);",
          "    assert!(result.literals().unwrap()[0].is_exact());",
          "    assert!(result.literals().unwrap()[1].is_exact());",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'g']);",
          "    assert_eq!(result.literals().unwrap()[1].bytes, vec![b'g']);",
          "    assert!(result.is_inexact());",
          "    assert!(!result.is_empty());",
          "    assert!(result.len().is_some());",
          "    assert!(result.len().unwrap() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]