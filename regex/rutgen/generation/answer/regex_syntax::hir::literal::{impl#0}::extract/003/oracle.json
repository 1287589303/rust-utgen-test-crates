[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(10)",
          "        .limit_repeat(5)",
          "        .limit_literal_len(15)",
          "        .limit_total(100);",
          "",
          "    let hir1 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"abc\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hir2 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"def\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir_concat = Hir {",
          "        kind: HirKind::Concat(vec![hir1.clone(), hir2.clone()]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let _seq = extractor.extract(&hir_concat);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_seq.len(), Some(6));",
          "    assert!(_seq.is_exact());",
          "    assert!(!_seq.is_inexact());",
          "    assert!(!_seq.is_empty());",
          "    assert_eq!(&_seq.literals().unwrap()[0].bytes, b\"abc\");",
          "    assert_eq!(&_seq.literals().unwrap()[1].bytes, b\"def\");",
          "    assert_eq!(&_seq.literals().unwrap()[2].bytes, b\"defabc\");",
          "    assert_eq!(&_seq.literals().unwrap()[3].bytes, b\"abcdef\");",
          "    assert_eq!(&_seq.literals().unwrap()[4].bytes, b\"defabc\");",
          "    assert_eq!(&_seq.literals().unwrap()[5].bytes, b\"abc\");"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(10)",
          "        .limit_repeat(5)",
          "        .limit_literal_len(15)",
          "        .limit_total(100);",
          "",
          "    let hir1 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"abc\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hir2 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"def\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir_concat = Hir {",
          "        kind: HirKind::Concat(vec![hir1.clone(), hir2.clone()]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let _seq = extractor.extract(&hir_concat);",
          "    assert_eq!(_seq.len(), Some(6));",
          "    assert!(_seq.is_exact());",
          "    assert!(!_seq.is_inexact());",
          "    assert!(!_seq.is_empty());",
          "    assert_eq!(&_seq.literals().unwrap()[0].bytes, b\"abc\");",
          "    assert_eq!(&_seq.literals().unwrap()[1].bytes, b\"def\");",
          "    assert_eq!(&_seq.literals().unwrap()[2].bytes, b\"defabc\");",
          "    assert_eq!(&_seq.literals().unwrap()[3].bytes, b\"abcdef\");",
          "    assert_eq!(&_seq.literals().unwrap()[4].bytes, b\"defabc\");",
          "    assert_eq!(&_seq.literals().unwrap()[5].bytes, b\"abc\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(10)",
          "        .limit_repeat(3)",
          "        .limit_literal_len(5)",
          "        .limit_total(50);",
          "",
          "    let hir1 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir2 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"ghi\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir_concat = Hir {",
          "        kind: HirKind::Concat(vec![hir1.clone(), hir2.clone()]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let _seq = extractor.extract(&hir_concat);",
          "}"
        ],
        "oracle": [
          "    _seq.len().unwrap() == 3",
          "    _seq.literals().unwrap()[0].bytes == b\"\"",
          "    _seq.literals().unwrap()[1].bytes == b\"ghi\"",
          "    _seq.literals().unwrap()[2].bytes == b\"\"",
          "    _seq.is_exact() == false",
          "    _seq.is_inexact() == true",
          "    _seq.min_literal_len().unwrap() == 0",
          "    _seq.max_literal_len().unwrap() == 3",
          "    _seq.is_finite() == true",
          "    _seq.dedup().len() == 2"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(10)",
          "        .limit_repeat(3)",
          "        .limit_literal_len(5)",
          "        .limit_total(50);",
          "",
          "    let hir1 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir2 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"ghi\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir_concat = Hir {",
          "        kind: HirKind::Concat(vec![hir1.clone(), hir2.clone()]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let _seq = extractor.extract(&hir_concat);",
          "    _seq.len().unwrap() == 3",
          "    _seq.literals().unwrap()[0].bytes == b\"\"",
          "    _seq.literals().unwrap()[1].bytes == b\"ghi\"",
          "    _seq.literals().unwrap()[2].bytes == b\"\"",
          "    _seq.is_exact() == false",
          "    _seq.is_inexact() == true",
          "    _seq.min_literal_len().unwrap() == 0",
          "    _seq.max_literal_len().unwrap() == 3",
          "    _seq.is_finite() == true",
          "    _seq.dedup().len() == 2",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(20)",
          "        .limit_repeat(8)",
          "        .limit_literal_len(12)",
          "        .limit_total(200);",
          "",
          "    let hir1 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"xyz\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir2 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"uvw\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir3 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"rst\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir_concat = Hir {",
          "        kind: HirKind::Concat(vec![hir1.clone(), hir2.clone(), hir3.clone()]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let _seq = extractor.extract(&hir_concat);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_seq.len(), Some(3));",
          "    assert!(!_seq.is_empty());",
          "    assert!(_seq.is_finite());",
          "    assert!(_seq.is_exact());",
          "    assert_eq!(_seq.min_literal_len(), Some(3));",
          "    assert_eq!(_seq.max_literal_len(), Some(3));",
          "    assert_eq!(_seq.literals().unwrap()[0].bytes, b\"xyz\");",
          "    assert_eq!(_seq.literals().unwrap()[1].bytes, b\"uvw\");",
          "    assert_eq!(_seq.literals().unwrap()[2].bytes, b\"rst\");"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(20)",
          "        .limit_repeat(8)",
          "        .limit_literal_len(12)",
          "        .limit_total(200);",
          "",
          "    let hir1 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"xyz\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir2 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"uvw\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir3 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: b\"rst\".to_vec(),",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hir_concat = Hir {",
          "        kind: HirKind::Concat(vec![hir1.clone(), hir2.clone(), hir3.clone()]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let _seq = extractor.extract(&hir_concat);",
          "    assert_eq!(_seq.len(), Some(3));",
          "    assert!(!_seq.is_empty());",
          "    assert!(_seq.is_finite());",
          "    assert!(_seq.is_exact());",
          "    assert_eq!(_seq.min_literal_len(), Some(3));",
          "    assert_eq!(_seq.max_literal_len(), Some(3));",
          "    assert_eq!(_seq.literals().unwrap()[0].bytes, b\"xyz\");",
          "    assert_eq!(_seq.literals().unwrap()[1].bytes, b\"uvw\");",
          "    assert_eq!(_seq.literals().unwrap()[2].bytes, b\"rst\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]