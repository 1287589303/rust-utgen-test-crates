[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new();",
          "",
          "    let bytes = vec![65, 66, 67]; // Represents the string \"ABC\"",
          "    let hir = Hir { ",
          "        kind: HirKind::Literal(hir::Literal(bytes.clone())), ",
          "        props: Properties::default() ",
          "    };",
          "",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.literals().unwrap().len(), 1);",
          "    assert_eq!(result.literals().unwrap()[0].bytes, bytes);",
          "    assert!(result.is_exact());",
          "    assert_eq!(result.len(), Some(1));",
          "    ",
          "    let class_bytes = hir::ClassBytes::new(vec![0x41..=0x43]); // A, B, C",
          "    let hir_class_bytes = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(class_bytes)),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    let result_class_bytes = extractor.extract(&hir_class_bytes);",
          "    assert!(!result_class_bytes.is_empty());",
          "    assert!(result_class_bytes.literals().is_some());",
          "    ",
          "    let class_unicode = hir::ClassUnicode::new(vec![0x0041..=0x0043]); // A, B, C",
          "    let hir_class_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(class_unicode)),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    let result_class_unicode = extractor.extract(&hir_class_unicode);",
          "    assert!(!result_class_unicode.is_empty());",
          "    assert!(result_class_unicode.literals().is_some());"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new();",
          "",
          "    let bytes = vec![65, 66, 67]; // Represents the string \"ABC\"",
          "    let hir = Hir { ",
          "        kind: HirKind::Literal(hir::Literal(bytes.clone())), ",
          "        props: Properties::default() ",
          "    };",
          "",
          "    let result = extractor.extract(&hir);",
          "    assert_eq!(result.literals().unwrap().len(), 1);",
          "    assert_eq!(result.literals().unwrap()[0].bytes, bytes);",
          "    assert!(result.is_exact());",
          "    assert_eq!(result.len(), Some(1));",
          "    ",
          "    let class_bytes = hir::ClassBytes::new(vec![0x41..=0x43]); // A, B, C",
          "    let hir_class_bytes = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(class_bytes)),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    let result_class_bytes = extractor.extract(&hir_class_bytes);",
          "    assert!(!result_class_bytes.is_empty());",
          "    assert!(result_class_bytes.literals().is_some());",
          "    ",
          "    let class_unicode = hir::ClassUnicode::new(vec![0x0041..=0x0043]); // A, B, C",
          "    let hir_class_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(class_unicode)),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    let result_class_unicode = extractor.extract(&hir_class_unicode);",
          "    assert!(!result_class_unicode.is_empty());",
          "    assert!(result_class_unicode.literals().is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new();",
          "",
          "    let cls = hir::Class::Bytes(ClassBytes { ",
          "        set: IntervalSet::new(vec![ClassBytesRange::new(65, 90)]) // Represents \"A-Z\"",
          "    });",
          "    let hir = Hir {",
          "        kind: HirKind::Class(cls),",
          "        props: Properties::default()",
          "    };",
          "",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    seq = extractor.extract(&hir);",
          "    assert!(result.is_exact());",
          "    assert_eq!(result.len(), Some(26));",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![65]); // First literal corresponds to 'A'",
          "    assert_eq!(result.literals().unwrap()[25].bytes, vec![90]); // Last literal corresponds to 'Z'",
          "    ",
          "    let literal_hir = hir::Literal(vec![97, 98, 99]); // Represents \"abc\"",
          "    let hir_literal = Hir {",
          "    kind: HirKind::Literal(literal_hir),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    let result_literal = extractor.extract(&hir_literal);",
          "    assert!(result_literal.is_exact());",
          "    assert_eq!(result_literal.len(), Some(3));",
          "    assert_eq!(result_literal.literals().unwrap()[0].bytes, vec![97]); // First literal corresponds to 'a'",
          "    assert_eq!(result_literal.literals().unwrap()[1].bytes, vec![98]); // Second literal corresponds to 'b'",
          "    assert_eq!(result_literal.literals().unwrap()[2].bytes, vec![99]); // Third literal corresponds to 'c'",
          "    ",
          "    let cls_unicode = hir::Class::Unicode(ClassUnicode {",
          "    set: IntervalSet::new(vec![ClassUnicodeRange::new(UnicodeScalar::new(65), UnicodeScalar::new(90))]) // Represents \"A-Z\"",
          "    });",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(cls_unicode),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    let result_unicode = extractor.extract(&hir_unicode);",
          "    assert!(result_unicode.is_exact());",
          "    assert_eq!(result_unicode.len(), Some(26));",
          "    assert_eq!(result_unicode.literals().unwrap()[0].bytes, vec![65]); // First literal corresponds to 'A'",
          "    assert_eq!(result_unicode.literals().unwrap()[25].bytes, vec![90]); // Last literal corresponds to 'Z'"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new();",
          "",
          "    let cls = hir::Class::Bytes(ClassBytes { ",
          "        set: IntervalSet::new(vec![ClassBytesRange::new(65, 90)]) // Represents \"A-Z\"",
          "    });",
          "    let hir = Hir {",
          "        kind: HirKind::Class(cls),",
          "        props: Properties::default()",
          "    };",
          "",
          "    let result = extractor.extract(&hir);",
          "    seq = extractor.extract(&hir);",
          "    assert!(result.is_exact());",
          "    assert_eq!(result.len(), Some(26));",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![65]); // First literal corresponds to 'A'",
          "    assert_eq!(result.literals().unwrap()[25].bytes, vec![90]); // Last literal corresponds to 'Z'",
          "    ",
          "    let literal_hir = hir::Literal(vec![97, 98, 99]); // Represents \"abc\"",
          "    let hir_literal = Hir {",
          "    kind: HirKind::Literal(literal_hir),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    let result_literal = extractor.extract(&hir_literal);",
          "    assert!(result_literal.is_exact());",
          "    assert_eq!(result_literal.len(), Some(3));",
          "    assert_eq!(result_literal.literals().unwrap()[0].bytes, vec![97]); // First literal corresponds to 'a'",
          "    assert_eq!(result_literal.literals().unwrap()[1].bytes, vec![98]); // Second literal corresponds to 'b'",
          "    assert_eq!(result_literal.literals().unwrap()[2].bytes, vec![99]); // Third literal corresponds to 'c'",
          "    ",
          "    let cls_unicode = hir::Class::Unicode(ClassUnicode {",
          "    set: IntervalSet::new(vec![ClassUnicodeRange::new(UnicodeScalar::new(65), UnicodeScalar::new(90))]) // Represents \"A-Z\"",
          "    });",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(cls_unicode),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    let result_unicode = extractor.extract(&hir_unicode);",
          "    assert!(result_unicode.is_exact());",
          "    assert_eq!(result_unicode.len(), Some(26));",
          "    assert_eq!(result_unicode.literals().unwrap()[0].bytes, vec![65]); // First literal corresponds to 'A'",
          "    assert_eq!(result_unicode.literals().unwrap()[25].bytes, vec![90]); // Last literal corresponds to 'Z'",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new();",
          "",
          "    let cls = hir::Class::Unicode(ClassUnicode {",
          "        set: IntervalSet::new(vec![ClassUnicodeRange::new(192, 255)]) // Represents valid Unicode range",
          "    });",
          "    let hir = Hir {",
          "        kind: HirKind::Class(cls),",
          "        props: Properties::default()",
          "    };",
          "",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.literals().unwrap().len(), 64);",
          "    assert!(result.is_finite());",
          "    assert!(result.is_exact());",
          "    assert_eq!(result.min_literal_len(), Some(1));",
          "    assert_eq!(result.max_literal_len(), Some(64));",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![192]);",
          "    assert_eq!(result.literals().unwrap()[63].bytes, vec![255]);"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new();",
          "",
          "    let cls = hir::Class::Unicode(ClassUnicode {",
          "        set: IntervalSet::new(vec![ClassUnicodeRange::new(192, 255)]) // Represents valid Unicode range",
          "    });",
          "    let hir = Hir {",
          "        kind: HirKind::Class(cls),",
          "        props: Properties::default()",
          "    };",
          "",
          "    let result = extractor.extract(&hir);",
          "    assert_eq!(result.literals().unwrap().len(), 64);",
          "    assert!(result.is_finite());",
          "    assert!(result.is_exact());",
          "    assert_eq!(result.min_literal_len(), Some(1));",
          "    assert_eq!(result.max_literal_len(), Some(64));",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![192]);",
          "    assert_eq!(result.literals().unwrap()[63].bytes, vec![255]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]