[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new()",
          "        .kind(ExtractKind::Suffix)",
          "        .limit_class(10)",
          "        .limit_repeat(5)",
          "        .limit_literal_len(3)",
          "        .limit_total(20);",
          "    ",
          "    let literals = vec![",
          "        Literal::exact(vec![b'a']),",
          "        Literal::exact(vec![b'b', b'c']),",
          "    ];",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![",
          "            Hir { kind: HirKind::Literal(literals[0].clone()), props: Properties::default() },",
          "            Hir { kind: HirKind::Literal(literals[1].clone()), props: Properties::default() },",
          "        ]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
          "    assert_eq!(extractor.limit_class, 10);",
          "    assert_eq!(extractor.limit_repeat, 5);",
          "    assert_eq!(extractor.limit_literal_len, 3);",
          "    assert_eq!(extractor.limit_total, 20);",
          "    let result_seq = extractor.extract(&hir);",
          "    assert!(result_seq.is_finite());",
          "    assert!(result_seq.len().is_some());",
          "    assert_eq!(result_seq.literals().map(|lits| lits.len()), Some(2));",
          "    assert!(result_seq.literals().unwrap().contains(&literals[0]));",
          "    assert!(result_seq.literals().unwrap().contains(&literals[1]));",
          "    assert!(result_seq.min_literal_len().is_none() || result_seq.min_literal_len().unwrap() <= 3);",
          "    assert!(result_seq.max_literal_len().is_none() || result_seq.max_literal_len().unwrap() <= 3);"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new()",
          "        .kind(ExtractKind::Suffix)",
          "        .limit_class(10)",
          "        .limit_repeat(5)",
          "        .limit_literal_len(3)",
          "        .limit_total(20);",
          "    ",
          "    let literals = vec![",
          "        Literal::exact(vec![b'a']),",
          "        Literal::exact(vec![b'b', b'c']),",
          "    ];",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![",
          "            Hir { kind: HirKind::Literal(literals[0].clone()), props: Properties::default() },",
          "            Hir { kind: HirKind::Literal(literals[1].clone()), props: Properties::default() },",
          "        ]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    extractor.extract(&hir);",
          "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
          "    assert_eq!(extractor.limit_class, 10);",
          "    assert_eq!(extractor.limit_repeat, 5);",
          "    assert_eq!(extractor.limit_literal_len, 3);",
          "    assert_eq!(extractor.limit_total, 20);",
          "    let result_seq = extractor.extract(&hir);",
          "    assert!(result_seq.is_finite());",
          "    assert!(result_seq.len().is_some());",
          "    assert_eq!(result_seq.literals().map(|lits| lits.len()), Some(2));",
          "    assert!(result_seq.literals().unwrap().contains(&literals[0]));",
          "    assert!(result_seq.literals().unwrap().contains(&literals[1]));",
          "    assert!(result_seq.min_literal_len().is_none() || result_seq.min_literal_len().unwrap() <= 3);",
          "    assert!(result_seq.max_literal_len().is_none() || result_seq.max_literal_len().unwrap() <= 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(15)",
          "        .limit_repeat(10)",
          "        .limit_literal_len(5)",
          "        .limit_total(30);",
          "    ",
          "    let class_unicode = ClassUnicode {",
          "        set: IntervalSet::new(vec![ClassUnicodeRange::new(0x61, 0x7A)]),",
          "    };",
          "    ",
          "    let class_bytes = ClassBytes {",
          "        set: IntervalSet::new(vec![ClassBytesRange::new(0x61, 0x62)]),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![",
          "            Hir { kind: HirKind::Class(class_unicode.clone()), props: Properties::default() },",
          "            Hir { kind: HirKind::Class(class_bytes.clone()), props: Properties::default() },",
          "        ]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.extract(&hir).literals().unwrap().len(), 2);",
          "    assert!(extractor.extract(&hir).is_finite());",
          "    assert!(!extractor.extract(&hir).is_empty());",
          "    assert_eq!(extractor.extract(&hir).max_literal_len(), Some(5));",
          "    assert_eq!(extractor.extract(&hir).min_literal_len(), Some(1));",
          "    assert_eq!(extractor.extract(&hir).max_union_len(&extractor.extract(&hir)), Some(5));",
          "    assert_eq!(extractor.extract(&hir).longest_common_prefix(), None);",
          "    assert_eq!(extractor.extract(&hir).longest_common_suffix(), None);",
          "    assert!(extractor.extract(&hir).is_exact());",
          "    assert!(extractor.extract(&hir).literals().unwrap()[0].bytes == vec![0x61]);",
          "    assert!(extractor.extract(&hir).literals().unwrap()[1].bytes == vec![0x61, 0x62]);"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(15)",
          "        .limit_repeat(10)",
          "        .limit_literal_len(5)",
          "        .limit_total(30);",
          "    ",
          "    let class_unicode = ClassUnicode {",
          "        set: IntervalSet::new(vec![ClassUnicodeRange::new(0x61, 0x7A)]),",
          "    };",
          "    ",
          "    let class_bytes = ClassBytes {",
          "        set: IntervalSet::new(vec![ClassBytesRange::new(0x61, 0x62)]),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![",
          "            Hir { kind: HirKind::Class(class_unicode.clone()), props: Properties::default() },",
          "            Hir { kind: HirKind::Class(class_bytes.clone()), props: Properties::default() },",
          "        ]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    extractor.extract(&hir);",
          "    assert_eq!(extractor.extract(&hir).literals().unwrap().len(), 2);",
          "    assert!(extractor.extract(&hir).is_finite());",
          "    assert!(!extractor.extract(&hir).is_empty());",
          "    assert_eq!(extractor.extract(&hir).max_literal_len(), Some(5));",
          "    assert_eq!(extractor.extract(&hir).min_literal_len(), Some(1));",
          "    assert_eq!(extractor.extract(&hir).max_union_len(&extractor.extract(&hir)), Some(5));",
          "    assert_eq!(extractor.extract(&hir).longest_common_prefix(), None);",
          "    assert_eq!(extractor.extract(&hir).longest_common_suffix(), None);",
          "    assert!(extractor.extract(&hir).is_exact());",
          "    assert!(extractor.extract(&hir).literals().unwrap()[0].bytes == vec![0x61]);",
          "    assert!(extractor.extract(&hir).literals().unwrap()[1].bytes == vec![0x61, 0x62]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(10)",
          "        .limit_repeat(5)",
          "        .limit_literal_len(3)",
          "        .limit_total(20);",
          "    ",
          "    let literals = vec![",
          "        Literal::exact(vec![b'x']),",
          "        Literal::exact(vec![b'y', b'z']),",
          "    ];",
          "    ",
          "    let class_unicode = ClassUnicode {",
          "        set: IntervalSet::new(vec![ClassUnicodeRange::new(0x41, 0x5A)]),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![",
          "            Hir { kind: HirKind::Literal(literals[0].clone()), props: Properties::default() },",
          "            Hir { kind: HirKind::Class(class_unicode.clone()), props: Properties::default() },",
          "            Hir { kind: HirKind::Literal(literals[1].clone()), props: Properties::default() },",
          "        ]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    Seq::singleton(self::Literal::exact(vec![])); // Test for Empty or Look variant",
          "    ",
          "    let literals = vec![Literal::exact(vec![b'x'])];",
          "    let mut seq = Seq::singleton(self::Literal::exact(literals[0].clone().bytes.clone()));",
          "    self.enforce_literal_len(&mut seq); // Ensure limit on literal length",
          "    ",
          "    let class_unicode = ClassUnicode { set: IntervalSet::new(vec![ClassUnicodeRange::new(0x41, 0x5A)]) };",
          "    self.extract_class_unicode(&class_unicode); // Test for Class variant with ClassUnicode",
          "    ",
          "    self.extract_repetition(&hir::Repetition { min: 1, max: None, greedy: true, sub: Box::new(hir) }); // Test extraction from Repetition",
          "    ",
          "    self.extract(&Hir { kind: HirKind::Capture { sub: Box::new(hir.clone()), .. } }); // Test extraction from Capture",
          "    ",
          "    self.extract_concat(hirs.iter()); // Test extraction from Concat",
          "    ",
          "    self.extract_alternation(hirs.iter()); // Validate extraction logic from Alternation variant",
          "    ",
          "    assert_eq!(self.kind, ExtractKind::Prefix); // Validate extractor configured for Prefix",
          "    ",
          "    assert!(seq.is_empty()); // Check sequence validity after extraction",
          "    ",
          "    assert_eq!(self.limit_total, 20); // Validate limit total after extraction"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(10)",
          "        .limit_repeat(5)",
          "        .limit_literal_len(3)",
          "        .limit_total(20);",
          "    ",
          "    let literals = vec![",
          "        Literal::exact(vec![b'x']),",
          "        Literal::exact(vec![b'y', b'z']),",
          "    ];",
          "    ",
          "    let class_unicode = ClassUnicode {",
          "        set: IntervalSet::new(vec![ClassUnicodeRange::new(0x41, 0x5A)]),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![",
          "            Hir { kind: HirKind::Literal(literals[0].clone()), props: Properties::default() },",
          "            Hir { kind: HirKind::Class(class_unicode.clone()), props: Properties::default() },",
          "            Hir { kind: HirKind::Literal(literals[1].clone()), props: Properties::default() },",
          "        ]),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    extractor.extract(&hir);",
          "    Seq::singleton(self::Literal::exact(vec![])); // Test for Empty or Look variant",
          "    ",
          "    let literals = vec![Literal::exact(vec![b'x'])];",
          "    let mut seq = Seq::singleton(self::Literal::exact(literals[0].clone().bytes.clone()));",
          "    self.enforce_literal_len(&mut seq); // Ensure limit on literal length",
          "    ",
          "    let class_unicode = ClassUnicode { set: IntervalSet::new(vec![ClassUnicodeRange::new(0x41, 0x5A)]) };",
          "    self.extract_class_unicode(&class_unicode); // Test for Class variant with ClassUnicode",
          "    ",
          "    self.extract_repetition(&hir::Repetition { min: 1, max: None, greedy: true, sub: Box::new(hir) }); // Test extraction from Repetition",
          "    ",
          "    self.extract(&Hir { kind: HirKind::Capture { sub: Box::new(hir.clone()), .. } }); // Test extraction from Capture",
          "    ",
          "    self.extract_concat(hirs.iter()); // Test extraction from Concat",
          "    ",
          "    self.extract_alternation(hirs.iter()); // Validate extraction logic from Alternation variant",
          "    ",
          "    assert_eq!(self.kind, ExtractKind::Prefix); // Validate extractor configured for Prefix",
          "    ",
          "    assert!(seq.is_empty()); // Check sequence validity after extraction",
          "    ",
          "    assert_eq!(self.limit_total, 20); // Validate limit total after extraction",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]