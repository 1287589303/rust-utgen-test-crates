[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new();",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        props: Properties::default(),",
          "    };",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    Seq::singleton(Literal::exact(vec![]));",
          "    assert_eq!(result, Seq::singleton(Literal::exact(vec![])));",
          "    ",
          "    let cls_bytes = hir::ClassBytes { set: IntervalSet::new() };",
          "    let hir_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(cls_bytes)), props: Properties::default() };",
          "    let result_bytes = extractor.extract(&hir_bytes);",
          "    assert_eq!(result_bytes.literals(), None);",
          "    ",
          "    let cls_unicode = hir::ClassUnicode { set: IntervalSet::new() };",
          "    let hir_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(cls_unicode)), props: Properties::default() };",
          "    let result_unicode = extractor.extract(&hir_unicode);",
          "    assert_eq!(result_unicode.literals(), None);"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new();",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        props: Properties::default(),",
          "    };",
          "    let result = extractor.extract(&hir);",
          "    Seq::singleton(Literal::exact(vec![]));",
          "    assert_eq!(result, Seq::singleton(Literal::exact(vec![])));",
          "    ",
          "    let cls_bytes = hir::ClassBytes { set: IntervalSet::new() };",
          "    let hir_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(cls_bytes)), props: Properties::default() };",
          "    let result_bytes = extractor.extract(&hir_bytes);",
          "    assert_eq!(result_bytes.literals(), None);",
          "    ",
          "    let cls_unicode = hir::ClassUnicode { set: IntervalSet::new() };",
          "    let hir_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(cls_unicode)), props: Properties::default() };",
          "    let result_unicode = extractor.extract(&hir_unicode);",
          "    assert_eq!(result_unicode.literals(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new();",
          "    let bytes_range = IntervalSet::new(vec![ClassBytesRange::new(0u8..=255u8)]);",
          "    let cls = ClassBytes { set: bytes_range };",
          "    let hir = Hir {",
          "        kind: HirKind::Class(hir::Class::Bytes(cls)),",
          "        props: Properties::default(),",
          "    };",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    let extractor = Extractor::new();",
          "    let bytes_range = IntervalSet::new(vec![ClassBytesRange::new(0u8..=255u8)]);",
          "    let cls = ClassBytes { set: bytes_range };",
          "    let hir = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(cls)),",
          "    props: Properties::default(),",
          "    };",
          "    let result = extractor.extract(&hir);",
          "    assert!(!result.is_empty());",
          "    assert!(result.is_finite());",
          "    assert_eq!(result.len(), Some(256));",
          "    assert!(result.literals().unwrap().iter().all(|lit| lit.bytes == (0u8..=255u8).collect::<Vec<_>>()));",
          "    ",
          "    let unicode_range = IntervalSet::new(vec![ClassUnicodeRange::new(0u32..=127u32)]);",
          "    let cls_unicode = ClassUnicode { set: unicode_range };",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(cls_unicode)),",
          "    props: Properties::default(),",
          "    };",
          "    let result_unicode = extractor.extract(&hir_unicode);",
          "    assert!(!result_unicode.is_empty());",
          "    assert!(result_unicode.is_finite());",
          "    assert_eq!(result_unicode.len(), Some(128));",
          "    assert!(result_unicode.literals().unwrap().iter().all(|lit| lit.bytes == (0u32..=127u32).map(|x| x as u8).collect::<Vec<_>>()));",
          "    ",
          "    let empty_hir = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties::default(),",
          "    };",
          "    let result_empty = extractor.extract(&empty_hir);",
          "    assert!(result_empty.is_exact());",
          "    assert_eq!(result_empty.len(), Some(0));",
          "    assert!(result_empty.literals().unwrap().is_empty());"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new();",
          "    let bytes_range = IntervalSet::new(vec![ClassBytesRange::new(0u8..=255u8)]);",
          "    let cls = ClassBytes { set: bytes_range };",
          "    let hir = Hir {",
          "        kind: HirKind::Class(hir::Class::Bytes(cls)),",
          "        props: Properties::default(),",
          "    };",
          "    let result = extractor.extract(&hir);",
          "    let extractor = Extractor::new();",
          "    let bytes_range = IntervalSet::new(vec![ClassBytesRange::new(0u8..=255u8)]);",
          "    let cls = ClassBytes { set: bytes_range };",
          "    let hir = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(cls)),",
          "    props: Properties::default(),",
          "    };",
          "    let result = extractor.extract(&hir);",
          "    assert!(!result.is_empty());",
          "    assert!(result.is_finite());",
          "    assert_eq!(result.len(), Some(256));",
          "    assert!(result.literals().unwrap().iter().all(|lit| lit.bytes == (0u8..=255u8).collect::<Vec<_>>()));",
          "    ",
          "    let unicode_range = IntervalSet::new(vec![ClassUnicodeRange::new(0u32..=127u32)]);",
          "    let cls_unicode = ClassUnicode { set: unicode_range };",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(cls_unicode)),",
          "    props: Properties::default(),",
          "    };",
          "    let result_unicode = extractor.extract(&hir_unicode);",
          "    assert!(!result_unicode.is_empty());",
          "    assert!(result_unicode.is_finite());",
          "    assert_eq!(result_unicode.len(), Some(128));",
          "    assert!(result_unicode.literals().unwrap().iter().all(|lit| lit.bytes == (0u32..=127u32).map(|x| x as u8).collect::<Vec<_>>()));",
          "    ",
          "    let empty_hir = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties::default(),",
          "    };",
          "    let result_empty = extractor.extract(&empty_hir);",
          "    assert!(result_empty.is_exact());",
          "    assert_eq!(result_empty.len(), Some(0));",
          "    assert!(result_empty.literals().unwrap().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new();",
          "    let unicode_range = IntervalSet::new(vec![ClassUnicodeRange::new('a'..='z')]);",
          "    let cls = ClassUnicode { set: unicode_range };",
          "    let hir = Hir {",
          "        kind: HirKind::Class(hir::Class::Unicode(cls)),",
          "        props: Properties::default(),",
          "    };",
          "    let result = extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_finite());",
          "    assert_eq!(result.len(), Some(26));",
          "    assert!(result.literals().unwrap().iter().all(|lit| lit.is_exact()));",
          "    assert!(result.literals().unwrap().iter().map(|lit| lit.bytes.clone()).collect::<Vec<_>>() == (b'a'..=b'z').map(|b| Literal::from(b)).collect::<Vec<_>>());",
          "    assert!(result.is_exact());",
          "    ",
          "    let bytes_sequence = result.literals().unwrap().iter().map(|lit| lit.bytes.clone()).collect::<Vec<_>>();",
          "    assert!(bytes_sequence.iter().all(|bytes| bytes.len() == 1));"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new();",
          "    let unicode_range = IntervalSet::new(vec![ClassUnicodeRange::new('a'..='z')]);",
          "    let cls = ClassUnicode { set: unicode_range };",
          "    let hir = Hir {",
          "        kind: HirKind::Class(hir::Class::Unicode(cls)),",
          "        props: Properties::default(),",
          "    };",
          "    let result = extractor.extract(&hir);",
          "    assert!(result.is_finite());",
          "    assert_eq!(result.len(), Some(26));",
          "    assert!(result.literals().unwrap().iter().all(|lit| lit.is_exact()));",
          "    assert!(result.literals().unwrap().iter().map(|lit| lit.bytes.clone()).collect::<Vec<_>>() == (b'a'..=b'z').map(|b| Literal::from(b)).collect::<Vec<_>>());",
          "    assert!(result.is_exact());",
          "    ",
          "    let bytes_sequence = result.literals().unwrap().iter().map(|lit| lit.bytes.clone()).collect::<Vec<_>>();",
          "    assert!(bytes_sequence.iter().all(|bytes| bytes.len() == 1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]