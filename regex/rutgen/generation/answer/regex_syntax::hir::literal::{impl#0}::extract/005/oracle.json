[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().limit_repeat(5);",
          "    let rep = Repetition {",
          "        min: 3,",
          "        max: Some(1),",
          "        greedy: true,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties {} }),",
          "    };",
          "    let hir = Hir { kind: HirKind::Repetition(rep), props: Properties {} };",
          "    extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.extract(&hir).len().unwrap(), 1);",
          "    assert!(extractor.extract(&hir).is_inexact());",
          "    assert_eq!(extractor.extract(&hir).min_literal_len(), Some(3));",
          "    assert_eq!(extractor.extract(&hir).max_literal_len(), None);",
          "    assert!(extractor.extract(&hir).is_finite());",
          "    assert!(extractor.extract(&hir).is_exact());",
          "    assert!(extractor.extract(&hir).longest_common_prefix().is_none());",
          "    assert!(extractor.extract(&hir).longest_common_suffix().is_none());"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().limit_repeat(5);",
          "    let rep = Repetition {",
          "        min: 3,",
          "        max: Some(1),",
          "        greedy: true,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties {} }),",
          "    };",
          "    let hir = Hir { kind: HirKind::Repetition(rep), props: Properties {} };",
          "    extractor.extract(&hir);",
          "    assert_eq!(extractor.extract(&hir).len().unwrap(), 1);",
          "    assert!(extractor.extract(&hir).is_inexact());",
          "    assert_eq!(extractor.extract(&hir).min_literal_len(), Some(3));",
          "    assert_eq!(extractor.extract(&hir).max_literal_len(), None);",
          "    assert!(extractor.extract(&hir).is_finite());",
          "    assert!(extractor.extract(&hir).is_exact());",
          "    assert!(extractor.extract(&hir).longest_common_prefix().is_none());",
          "    assert!(extractor.extract(&hir).longest_common_suffix().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().limit_repeat(5);",
          "    let rep = Repetition {",
          "        min: 2,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties {} }),",
          "    };",
          "    let hir = Hir { kind: HirKind::Repetition(rep), props: Properties {} };",
          "    extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.limit_repeat, 5);",
          "    assert_eq!(rep.min, 2);",
          "    assert_eq!(rep.max, Some(1));",
          "    assert_eq!(rep.greedy, false);",
          "    assert_eq!(rep.sub.kind(), &HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }));",
          "    assert_eq!(hir.kind(), &HirKind::Repetition(rep));"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().limit_repeat(5);",
          "    let rep = Repetition {",
          "        min: 2,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties {} }),",
          "    };",
          "    let hir = Hir { kind: HirKind::Repetition(rep), props: Properties {} };",
          "    extractor.extract(&hir);",
          "    assert_eq!(extractor.limit_repeat, 5);",
          "    assert_eq!(rep.min, 2);",
          "    assert_eq!(rep.max, Some(1));",
          "    assert_eq!(rep.greedy, false);",
          "    assert_eq!(rep.sub.kind(), &HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }));",
          "    assert_eq!(hir.kind(), &HirKind::Repetition(rep));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().limit_repeat(5);",
          "    let rep = Repetition {",
          "        min: 1,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties {} }),",
          "    };",
          "    let hir = Hir { kind: HirKind::Repetition(rep), props: Properties {} };",
          "    extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    Seq::singleton(Literal::exact(vec![])) == extractor.extract(&hir)",
          "    extractor.limit_repeat(5);",
          "    let mut subseq = extractor.extract(&rep.sub);",
          "    subseq.make_inexact();",
          "    assert!(subseq.is_inexact());",
          "    ",
          "    let expected_min_length = 1;",
          "    let actual_length = extractor.extract(&hir).len();",
          "    assert!(actual_length.is_some());",
          "    assert_eq!(actual_length.unwrap(), expected_min_length);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().limit_repeat(5);",
          "    let rep = Repetition {",
          "        min: 1,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties {} }),",
          "    };",
          "    let hir = Hir { kind: HirKind::Repetition(rep), props: Properties {} };",
          "    extractor.extract(&hir);",
          "    Seq::singleton(Literal::exact(vec![])) == extractor.extract(&hir)",
          "    extractor.limit_repeat(5);",
          "    let mut subseq = extractor.extract(&rep.sub);",
          "    subseq.make_inexact();",
          "    assert!(subseq.is_inexact());",
          "    ",
          "    let expected_min_length = 1;",
          "    let actual_length = extractor.extract(&hir).len();",
          "    assert!(actual_length.is_some());",
          "    assert_eq!(actual_length.unwrap(), expected_min_length);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().limit_repeat(5);",
          "    let rep = Repetition {",
          "        min: 4,",
          "        max: None,",
          "        greedy: false,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties {} }),",
          "    };",
          "    let hir = Hir { kind: HirKind::Repetition(rep), props: Properties {} };",
          "    extractor.extract(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.limit_repeat, 5);",
          "    assert_eq!(rep.min, 4);",
          "    assert!(rep.max.is_none());",
          "    assert!(!rep.greedy);",
          "    assert_eq!(rep.sub.kind(), &HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }));",
          "    assert_eq!(hir.kind(), &HirKind::Repetition(rep));",
          "    assert!(extractor.extract(&hir).is_inexact());"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().limit_repeat(5);",
          "    let rep = Repetition {",
          "        min: 4,",
          "        max: None,",
          "        greedy: false,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties {} }),",
          "    };",
          "    let hir = Hir { kind: HirKind::Repetition(rep), props: Properties {} };",
          "    extractor.extract(&hir);",
          "    assert_eq!(extractor.limit_repeat, 5);",
          "    assert_eq!(rep.min, 4);",
          "    assert!(rep.max.is_none());",
          "    assert!(!rep.greedy);",
          "    assert_eq!(rep.sub.kind(), &HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }));",
          "    assert_eq!(hir.kind(), &HirKind::Repetition(rep));",
          "    assert!(extractor.extract(&hir).is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]