[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(0);",
          "    let input = 0u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "}"
        ],
        "oracle": [
          "    let test_automaton = TestAutomaton;",
          "    let test_state_id = StateID(0);",
          "    let test_input = 0u8;",
          "    let expected_next_state = test_automaton.next_state(test_state_id, test_input);",
          "    assert_eq!(expected_next_state, test_automaton.next_state(test_state_id, test_input));",
          "    assert!(test_automaton.is_start_state(test_state_id));",
          "    assert!(!test_automaton.is_dead_state(test_state_id));",
          "    assert!(!test_automaton.is_match_state(test_state_id));",
          "    assert!(!test_automaton.is_quit_state(test_state_id));",
          "    assert!(!test_automaton.has_empty());",
          "    assert!(test_automaton.is_utf8());",
          "    assert_eq!(test_automaton.pattern_len(), 0);"
        ],
        "code": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(0);",
          "    let input = 0u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "    let test_automaton = TestAutomaton;",
          "    let test_state_id = StateID(0);",
          "    let test_input = 0u8;",
          "    let expected_next_state = test_automaton.next_state(test_state_id, test_input);",
          "    assert_eq!(expected_next_state, test_automaton.next_state(test_state_id, test_input));",
          "    assert!(test_automaton.is_start_state(test_state_id));",
          "    assert!(!test_automaton.is_dead_state(test_state_id));",
          "    assert!(!test_automaton.is_match_state(test_state_id));",
          "    assert!(!test_automaton.is_quit_state(test_state_id));",
          "    assert!(!test_automaton.has_empty());",
          "    assert!(test_automaton.is_utf8());",
          "    assert_eq!(test_automaton.pattern_len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(0);",
          "    let input = 255u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(automaton.next_state(state_id, input), expected_state_id);"
        ],
        "code": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(0);",
          "    let input = 255u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "    assert_eq!(automaton.next_state(state_id, input), expected_state_id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(128);",
          "    let input = 128u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "}"
        ],
        "oracle": [
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(128);",
          "    let input = 128u8;",
          "    let result = automaton.next_state(state_id, input);",
          "    assert_eq!(result, expected_state_id);"
        ],
        "code": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(128);",
          "    let input = 128u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(128);",
          "    let input = 128u8;",
          "    let result = automaton.next_state(state_id, input);",
          "    assert_eq!(result, expected_state_id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(255);",
          "    let input = 0u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(automaton.next_state(state_id, input), expected_state_id);",
          "    assert!(automaton.is_special_state(state_id));",
          "    assert!(!automaton.is_dead_state(state_id));",
          "    assert!(!automaton.is_quit_state(state_id));",
          "    assert!(!automaton.is_match_state(state_id));",
          "    assert!(automaton.is_start_state(state_id));",
          "    assert!(!automaton.is_accel_state(state_id));",
          "    assert_eq!(automaton.pattern_len(), expected_pattern_length);",
          "    assert_eq!(automaton.match_len(state_id), expected_match_length);",
          "    assert_eq!(automaton.match_pattern(state_id, expected_index), expected_pattern_id);",
          "    assert!(automaton.has_empty());",
          "    assert!(automaton.is_utf8());",
          "    assert!(!automaton.is_always_start_anchored());",
          "    assert_eq!(automaton.accelerator(state_id), expected_accelerator_slice);",
          "    assert_eq!(automaton.get_prefilter(), expected_prefilter);",
          "    assert_eq!(automaton.try_search_fwd(&input), expected_half_match_result);",
          "    assert_eq!(automaton.try_search_rev(&input), expected_half_match_result);",
          "    assert_eq!(automaton.try_search_overlapping_fwd(&input, &mut state), Ok(()));",
          "    assert_eq!(automaton.try_search_overlapping_rev(&input, &mut state), Ok(()));",
          "    assert_eq!(automaton.try_which_overlapping_matches(&input, &mut patset), Ok(()));"
        ],
        "code": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(255);",
          "    let input = 0u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "    assert_eq!(automaton.next_state(state_id, input), expected_state_id);",
          "    assert!(automaton.is_special_state(state_id));",
          "    assert!(!automaton.is_dead_state(state_id));",
          "    assert!(!automaton.is_quit_state(state_id));",
          "    assert!(!automaton.is_match_state(state_id));",
          "    assert!(automaton.is_start_state(state_id));",
          "    assert!(!automaton.is_accel_state(state_id));",
          "    assert_eq!(automaton.pattern_len(), expected_pattern_length);",
          "    assert_eq!(automaton.match_len(state_id), expected_match_length);",
          "    assert_eq!(automaton.match_pattern(state_id, expected_index), expected_pattern_id);",
          "    assert!(automaton.has_empty());",
          "    assert!(automaton.is_utf8());",
          "    assert!(!automaton.is_always_start_anchored());",
          "    assert_eq!(automaton.accelerator(state_id), expected_accelerator_slice);",
          "    assert_eq!(automaton.get_prefilter(), expected_prefilter);",
          "    assert_eq!(automaton.try_search_fwd(&input), expected_half_match_result);",
          "    assert_eq!(automaton.try_search_rev(&input), expected_half_match_result);",
          "    assert_eq!(automaton.try_search_overlapping_fwd(&input, &mut state), Ok(()));",
          "    assert_eq!(automaton.try_search_overlapping_rev(&input, &mut state), Ok(()));",
          "    assert_eq!(automaton.try_which_overlapping_matches(&input, &mut patset), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(255);",
          "    let input = 255u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(automaton.next_state(state_id, input), expected_state_id);",
          "    assert!(automaton.is_start_state(state_id));",
          "    assert!(!automaton.is_dead_state(state_id));",
          "    assert!(!automaton.is_match_state(state_id));",
          "    assert_eq!(automaton.match_len(state_id), expected_match_length);",
          "    assert!(automaton.pattern_len() > 0);",
          "    assert!(automaton.is_accel_state(state_id) == false);"
        ],
        "code": [
          "{",
          "    struct TestAutomaton;",
          "    let automaton = TestAutomaton;",
          "    let state_id = StateID(255);",
          "    let input = 255u8;",
          "    let _ = automaton.next_state(state_id, input);",
          "    assert_eq!(automaton.next_state(state_id, input), expected_state_id);",
          "    assert!(automaton.is_start_state(state_id));",
          "    assert!(!automaton.is_dead_state(state_id));",
          "    assert!(!automaton.is_match_state(state_id));",
          "    assert_eq!(automaton.match_len(state_id), expected_match_length);",
          "    assert!(automaton.pattern_len() > 0);",
          "    assert!(automaton.is_accel_state(state_id) == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]