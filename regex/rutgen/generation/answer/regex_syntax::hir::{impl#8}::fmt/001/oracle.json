[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer, \"\");",
          "    assert!(buffer.is_empty());",
          "    let hir_empty = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI {})) };",
          "    let hir_display_empty = format!(\"{}\", hir_empty);",
          "    assert_eq!(hir_display_empty, \"\");",
          "    buffer.clear();",
          "    let hir_literal = Hir { kind: HirKind::Literal(Literal::new(\"test\")), props: Properties(Box::new(PropertiesI {})) };",
          "    write!(buffer, \"{}\", hir_literal).unwrap();",
          "    assert_eq!(buffer, \"test\");",
          "    buffer.clear();",
          "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_literal.clone()]), props: Properties(Box::new(PropertiesI {})) };",
          "    write!(buffer, \"{}\", hir_concat).unwrap();",
          "    assert_eq!(buffer, \"test\");",
          "    buffer.clear();",
          "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_literal.clone(), hir_empty.clone()]), props: Properties(Box::new(PropertiesI {})) };",
          "    write!(buffer, \"{}\", hir_alternation).unwrap();",
          "    assert_eq!(buffer, \"test\");",
          "    buffer.clear();",
          "    let hir_capture = Hir { kind: HirKind::Capture(Capture::new(hir_literal.clone())), props: Properties(Box::new(PropertiesI {})) };",
          "    write!(buffer, \"{}\", hir_capture).unwrap();",
          "    assert_eq!(buffer, \"test\");",
          "    buffer.clear();"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "    assert_eq!(buffer, \"\");",
          "    assert!(buffer.is_empty());",
          "    let hir_empty = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI {})) };",
          "    let hir_display_empty = format!(\"{}\", hir_empty);",
          "    assert_eq!(hir_display_empty, \"\");",
          "    buffer.clear();",
          "    let hir_literal = Hir { kind: HirKind::Literal(Literal::new(\"test\")), props: Properties(Box::new(PropertiesI {})) };",
          "    write!(buffer, \"{}\", hir_literal).unwrap();",
          "    assert_eq!(buffer, \"test\");",
          "    buffer.clear();",
          "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_literal.clone()]), props: Properties(Box::new(PropertiesI {})) };",
          "    write!(buffer, \"{}\", hir_concat).unwrap();",
          "    assert_eq!(buffer, \"test\");",
          "    buffer.clear();",
          "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_literal.clone(), hir_empty.clone()]), props: Properties(Box::new(PropertiesI {})) };",
          "    write!(buffer, \"{}\", hir_alternation).unwrap();",
          "    assert_eq!(buffer, \"test\");",
          "    buffer.clear();",
          "    let hir_capture = Hir { kind: HirKind::Capture(Capture::new(hir_literal.clone())), props: Properties(Box::new(PropertiesI {})) };",
          "    write!(buffer, \"{}\", hir_capture).unwrap();",
          "    assert_eq!(buffer, \"test\");",
          "    buffer.clear();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Literal(Literal::new(\"test\")),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "}"
        ],
        "oracle": [
          "    assert!(buffer.eq(\"test\"));",
          "    assert_eq!(hir.kind, HirKind::Literal(Literal::new(\"test\")));",
          "    assert!(hir.props == Properties(Box::new(PropertiesI {})));"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Literal(Literal::new(\"test\")),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "    assert!(buffer.eq(\"test\"));",
          "    assert_eq!(hir.kind, HirKind::Literal(Literal::new(\"test\")));",
          "    assert!(hir.props == Properties(Box::new(PropertiesI {})));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer, \"expected_output_based_on_hir_class\");",
          "    assert!(buffer.contains(\"class: [a, b, c]\"));",
          "    assert!(buffer.len() > 0);",
          "    assert!(format!(\"{}\", hir).is_ok());",
          "    assert!(buffer.is_ascii());"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "    assert_eq!(buffer, \"expected_output_based_on_hir_class\");",
          "    assert!(buffer.contains(\"class: [a, b, c]\"));",
          "    assert!(buffer.len() > 0);",
          "    assert!(format!(\"{}\", hir).is_ok());",
          "    assert!(buffer.is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Look(Look::new()),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"\");",
          "    let hir = Hir { kind: HirKind::Literal(Literal::new(\"test\")), props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"test\");",
          "    let hir = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), props: Properties(Box::new(PropertiesI {})) }; assert!(buffer.contains('a') || buffer.contains('b') || buffer.contains('c'));",
          "    let hir = Hir { kind: HirKind::Repetition(Repetition::new(Hir::new(Literal::new(\"x\")), 2)), props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"xx\");",
          "    let hir = Hir { kind: HirKind::Capture(Capture::new(Hir::new(Literal::new(\"capture\")))), props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"(capture)\");",
          "    let hir = Hir { kind: HirKind::Concat(vec![Hir::new(Literal::new(\"hello\")), Hir::new(Literal::new(\"world\"))]), props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"helloworld\");",
          "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::new(Literal::new(\"foo\")), Hir::new(Literal::new(\"bar\"))]), props: Properties(Box::new(PropertiesI {})) }; assert!(buffer == \"foo\" || buffer == \"bar\");"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Look(Look::new()),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "    let hir = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"\");",
          "    let hir = Hir { kind: HirKind::Literal(Literal::new(\"test\")), props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"test\");",
          "    let hir = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), props: Properties(Box::new(PropertiesI {})) }; assert!(buffer.contains('a') || buffer.contains('b') || buffer.contains('c'));",
          "    let hir = Hir { kind: HirKind::Repetition(Repetition::new(Hir::new(Literal::new(\"x\")), 2)), props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"xx\");",
          "    let hir = Hir { kind: HirKind::Capture(Capture::new(Hir::new(Literal::new(\"capture\")))), props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"(capture)\");",
          "    let hir = Hir { kind: HirKind::Concat(vec![Hir::new(Literal::new(\"hello\")), Hir::new(Literal::new(\"world\"))]), props: Properties(Box::new(PropertiesI {})) }; assert_eq!(buffer, \"helloworld\");",
          "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::new(Literal::new(\"foo\")), Hir::new(Literal::new(\"bar\"))]), props: Properties(Box::new(PropertiesI {})) }; assert!(buffer == \"foo\" || buffer == \"bar\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(Repetition::new(Box::new(Hir {",
          "            kind: HirKind::Literal(Literal::new(\"inner\")),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        }))),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer, \"inner*\");",
          "    assert!(matches!(hir.kind, HirKind::Repetition(_)));",
          "    assert!(hir.props == Properties(Box::new(PropertiesI {})));",
          "    assert!(buffer.len() > 0);",
          "    assert!(buffer.contains(\"inner\"));",
          "    assert!(buffer.ends_with(\"*\"));"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(Repetition::new(Box::new(Hir {",
          "            kind: HirKind::Literal(Literal::new(\"inner\")),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        }))),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "    assert_eq!(buffer, \"inner*\");",
          "    assert!(matches!(hir.kind, HirKind::Repetition(_)));",
          "    assert!(hir.props == Properties(Box::new(PropertiesI {})));",
          "    assert!(buffer.len() > 0);",
          "    assert!(buffer.contains(\"inner\"));",
          "    assert!(buffer.ends_with(\"*\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Capture(Capture::new(Box::new(Hir {",
          "            kind: HirKind::Literal(Literal::new(\"group\")),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        }))),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer, \"group\");",
          "    assert!(buffer.len() > 0);",
          "    assert!(buffer.contains(\"group\"));",
          "    assert!(buffer.starts_with(\"g\"));",
          "    assert!(buffer.ends_with(\"p\"));",
          "    assert!(buffer.chars().all(|c| c.is_alphanumeric() || c == ' '));"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Capture(Capture::new(Box::new(Hir {",
          "            kind: HirKind::Literal(Literal::new(\"group\")),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        }))),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "    assert_eq!(buffer, \"group\");",
          "    assert!(buffer.len() > 0);",
          "    assert!(buffer.contains(\"group\"));",
          "    assert!(buffer.starts_with(\"g\"));",
          "    assert!(buffer.ends_with(\"p\"));",
          "    assert!(buffer.chars().all(|c| c.is_alphanumeric() || c == ' '));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Concat(vec![",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::new(\"part1\")),",
          "                props: Properties(Box::new(PropertiesI {})),",
          "            },",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::new(\"part2\")),",
          "                props: Properties(Box::new(PropertiesI {})),",
          "            },",
          "        ]),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer, \"part1part2\");",
          "    assert!(buffer.contains(\"part1\"));",
          "    assert!(buffer.contains(\"part2\"));",
          "    assert!(!buffer.contains(\"part3\"));",
          "    assert!(buffer.len() == 10);",
          "    assert!(buffer.starts_with(\"part1\"));",
          "    assert!(buffer.ends_with(\"part2\"));"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Concat(vec![",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::new(\"part1\")),",
          "                props: Properties(Box::new(PropertiesI {})),",
          "            },",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::new(\"part2\")),",
          "                props: Properties(Box::new(PropertiesI {})),",
          "            },",
          "        ]),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "    assert_eq!(buffer, \"part1part2\");",
          "    assert!(buffer.contains(\"part1\"));",
          "    assert!(buffer.contains(\"part2\"));",
          "    assert!(!buffer.contains(\"part3\"));",
          "    assert!(buffer.len() == 10);",
          "    assert!(buffer.starts_with(\"part1\"));",
          "    assert!(buffer.ends_with(\"part2\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::new(\"option1\")),",
          "                props: Properties(Box::new(PropertiesI {})),",
          "            },",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::new(\"option2\")),",
          "                props: Properties(Box::new(PropertiesI {})),",
          "            },",
          "        ]),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "}"
        ],
        "oracle": [
          "    let hir_alternation = Hir {",
          "    kind: HirKind::Alternation(vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal::new(\"option1\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal::new(\"option2\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    },",
          "    ]),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_alternation), \"option1|option2\");",
          "    ",
          "    let hir_empty = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_empty), \"\");",
          "    ",
          "    let hir_class = Hir {",
          "    kind: HirKind::Class(Class::new(vec![char::from('a'), char::from('b')])),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_class), \"[ab]\");",
          "    ",
          "    let hir_literal = Hir {",
          "    kind: HirKind::Literal(Literal::new(\"test\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_literal), \"test\");",
          "    ",
          "    let hir_concatenation = Hir {",
          "    kind: HirKind::Concat(vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal::new(\"hello\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal::new(\"world\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    },",
          "    ]),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_concatenation), \"helloworld\");"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::new(\"option1\")),",
          "                props: Properties(Box::new(PropertiesI {})),",
          "            },",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::new(\"option2\")),",
          "                props: Properties(Box::new(PropertiesI {})),",
          "            },",
          "        ]),",
          "        props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    let mut buffer = String::new();",
          "    let _ = write!(buffer, \"{}\", hir);",
          "    let hir_alternation = Hir {",
          "    kind: HirKind::Alternation(vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal::new(\"option1\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal::new(\"option2\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    },",
          "    ]),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_alternation), \"option1|option2\");",
          "    ",
          "    let hir_empty = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_empty), \"\");",
          "    ",
          "    let hir_class = Hir {",
          "    kind: HirKind::Class(Class::new(vec![char::from('a'), char::from('b')])),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_class), \"[ab]\");",
          "    ",
          "    let hir_literal = Hir {",
          "    kind: HirKind::Literal(Literal::new(\"test\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_literal), \"test\");",
          "    ",
          "    let hir_concatenation = Hir {",
          "    kind: HirKind::Concat(vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal::new(\"hello\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal::new(\"world\")),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    },",
          "    ]),",
          "    props: Properties(Box::new(PropertiesI {})),",
          "    };",
          "    assert_eq!(format!(\"{}\", hir_concatenation), \"helloworld\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]