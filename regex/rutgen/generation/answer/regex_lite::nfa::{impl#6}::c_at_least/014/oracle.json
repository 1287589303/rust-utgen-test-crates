[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"a+\";",
          "    let hir = Hir::parse(config.clone(), pattern).expect(\"Failed to parse Hir\");",
          "    let compiler = Compiler::new(config, pattern.to_string());",
          "",
          "    let greedy = true;",
          "    let n = 1;",
          "",
          "    let splits_result = compiler.add(State::Splits { targets: vec![1, 2], reverse: !greedy });",
          "    if let Ok(splits) = splits_result {",
          "        let compiled_result = compiler.c(&hir);",
          "        if let Ok(compiled) = compiled_result {",
          "            let patch_result_start = compiler.patch(splits, compiled.start);",
          "            if patch_result_start.is_ok() {",
          "                let patch_result_end = compiler.patch(compiled.end, splits);",
          "                // We expect this patch to fail",
          "                assert!(patch_result_end.is_err());",
          "            }",
          "        }",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(n > 0);",
          "    assert!(!hir.is_match_empty());",
          "    let splits_result = compiler.add(State::Splits { targets: vec![1, 2], reverse: !greedy });",
          "    assert!(splits_result.is_ok());",
          "    let compiled_result = compiler.c(&hir);",
          "    assert!(compiled_result.is_ok());",
          "    let compiled = compiled_result.unwrap();",
          "    let patch_result_start = compiler.patch(splits, compiled.start);",
          "    assert!(patch_result_start.is_ok());",
          "    let patch_result_end = compiler.patch(compiled.end, splits);",
          "    assert!(patch_result_end.is_err());"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"a+\";",
          "    let hir = Hir::parse(config.clone(), pattern).expect(\"Failed to parse Hir\");",
          "    let compiler = Compiler::new(config, pattern.to_string());",
          "",
          "    let greedy = true;",
          "    let n = 1;",
          "",
          "    let splits_result = compiler.add(State::Splits { targets: vec![1, 2], reverse: !greedy });",
          "    if let Ok(splits) = splits_result {",
          "        let compiled_result = compiler.c(&hir);",
          "        if let Ok(compiled) = compiled_result {",
          "            let patch_result_start = compiler.patch(splits, compiled.start);",
          "            if patch_result_start.is_ok() {",
          "                let patch_result_end = compiler.patch(compiled.end, splits);",
          "                // We expect this patch to fail",
          "                assert!(patch_result_end.is_err());",
          "            }",
          "        }",
          "    }",
          "    assert!(n > 0);",
          "    assert!(!hir.is_match_empty());",
          "    let splits_result = compiler.add(State::Splits { targets: vec![1, 2], reverse: !greedy });",
          "    assert!(splits_result.is_ok());",
          "    let compiled_result = compiler.c(&hir);",
          "    assert!(compiled_result.is_ok());",
          "    let compiled = compiled_result.unwrap();",
          "    let patch_result_start = compiler.patch(splits, compiled.start);",
          "    assert!(patch_result_start.is_ok());",
          "    let patch_result_end = compiler.patch(compiled.end, splits);",
          "    assert!(patch_result_end.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"b*\";",
          "    let hir = Hir::parse(config.clone(), pattern).expect(\"Failed to parse Hir\");",
          "    let compiler = Compiler::new(config, pattern.to_string());",
          "",
          "    let greedy = false;",
          "    let n = 2;",
          "",
          "    let splits_result = compiler.add(State::Splits { targets: vec![3, 4], reverse: !greedy });",
          "    if let Ok(splits) = splits_result {",
          "        let compiled_result = compiler.c(&hir);",
          "        if let Ok(compiled) = compiled_result {",
          "            let patch_result_start = compiler.patch(splits, compiled.start);",
          "            if patch_result_start.is_ok() {",
          "                let patch_result_end = compiler.patch(compiled.end, splits);",
          "                // We expect this patch to be Ok",
          "                assert!(patch_result_end.is_ok());",
          "            }",
          "        }",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(compiler.c(&hir).is_ok());",
          "    assert!(compiler.add(State::Splits { targets: vec![3, 4], reverse: !greedy }).is_ok());",
          "    assert!(compiler.patch(splits, compiled.start).is_ok());",
          "    assert!(compiler.patch(compiled.end, splits).is_err());"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"b*\";",
          "    let hir = Hir::parse(config.clone(), pattern).expect(\"Failed to parse Hir\");",
          "    let compiler = Compiler::new(config, pattern.to_string());",
          "",
          "    let greedy = false;",
          "    let n = 2;",
          "",
          "    let splits_result = compiler.add(State::Splits { targets: vec![3, 4], reverse: !greedy });",
          "    if let Ok(splits) = splits_result {",
          "        let compiled_result = compiler.c(&hir);",
          "        if let Ok(compiled) = compiled_result {",
          "            let patch_result_start = compiler.patch(splits, compiled.start);",
          "            if patch_result_start.is_ok() {",
          "                let patch_result_end = compiler.patch(compiled.end, splits);",
          "                // We expect this patch to be Ok",
          "                assert!(patch_result_end.is_ok());",
          "            }",
          "        }",
          "    }",
          "    assert!(compiler.c(&hir).is_ok());",
          "    assert!(compiler.add(State::Splits { targets: vec![3, 4], reverse: !greedy }).is_ok());",
          "    assert!(compiler.patch(splits, compiled.start).is_ok());",
          "    assert!(compiler.patch(compiled.end, splits).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]