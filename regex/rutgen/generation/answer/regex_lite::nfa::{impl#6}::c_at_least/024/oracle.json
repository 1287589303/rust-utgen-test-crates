[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::empty();",
          "    let result = compiler.c_at_least(&hir, true, 0);",
          "}"
        ],
        "oracle": [
          "    result.unwrap().start; // should not be an error for n == 0",
          "    result.unwrap().end; // should not be an error for n == 0",
          "    let result_one = compiler.c_at_least(&hir, true, 1); // should succeed for n == 1",
          "    result_one.unwrap().start; // should not be an error for n == 1",
          "    result_one.unwrap().end; // should not be an error for n == 1",
          "    let result_multiple = compiler.c_exactly(&hir, 1).unwrap(); // should succeed and be Ok for n-1",
          "    let result_last = compiler.c(&hir).unwrap(); // should succeed and be Ok for n",
          "    let result_splits = compiler.add(State::Splits { targets: vec![], reverse: true }).unwrap(); // should succeed and be Ok",
          "    assert!(compiler.patch(result_multiple.end, result_last.start).is_err()); // should return an error in patch for this case"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::empty();",
          "    let result = compiler.c_at_least(&hir, true, 0);",
          "    result.unwrap().start; // should not be an error for n == 0",
          "    result.unwrap().end; // should not be an error for n == 0",
          "    let result_one = compiler.c_at_least(&hir, true, 1); // should succeed for n == 1",
          "    result_one.unwrap().start; // should not be an error for n == 1",
          "    result_one.unwrap().end; // should not be an error for n == 1",
          "    let result_multiple = compiler.c_exactly(&hir, 1).unwrap(); // should succeed and be Ok for n-1",
          "    let result_last = compiler.c(&hir).unwrap(); // should succeed and be Ok for n",
          "    let result_splits = compiler.add(State::Splits { targets: vec![], reverse: true }).unwrap(); // should succeed and be Ok",
          "    assert!(compiler.patch(result_multiple.end, result_last.start).is_err()); // should return an error in patch for this case",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::char('a');",
          "    let result = compiler.c_at_least(&hir, true, 1);",
          "}"
        ],
        "oracle": [
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::char('a');",
          "    let result = compiler.c_at_least(&hir, true, 0);",
          "    assert!(result.is_ok());",
          "    let result = compiler.c_at_least(&hir, false, 1);",
          "    assert!(result.is_ok());",
          "    let result = compiler.c_at_least(&hir, true, 1);",
          "    assert!(result.is_ok());",
          "    let result = compiler.c_at_least(&hir, false, 2);",
          "    assert!(result.is_ok());",
          "    let result = compiler.c_at_least(&hir, true, 2);",
          "    assert!(result.is_ok());",
          "    assert!(compiler.c_exactly(&hir, 1).is_ok());",
          "    assert!(compiler.c(&hir).is_ok());",
          "    assert!(compiler.add(State::Splits { targets: vec![], reverse: true }).is_ok());",
          "    assert!(compiler.patch(0, 0).is_err());"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::char('a');",
          "    let result = compiler.c_at_least(&hir, true, 1);",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::char('a');",
          "    let result = compiler.c_at_least(&hir, true, 0);",
          "    assert!(result.is_ok());",
          "    let result = compiler.c_at_least(&hir, false, 1);",
          "    assert!(result.is_ok());",
          "    let result = compiler.c_at_least(&hir, true, 1);",
          "    assert!(result.is_ok());",
          "    let result = compiler.c_at_least(&hir, false, 2);",
          "    assert!(result.is_ok());",
          "    let result = compiler.c_at_least(&hir, true, 2);",
          "    assert!(result.is_ok());",
          "    assert!(compiler.c_exactly(&hir, 1).is_ok());",
          "    assert!(compiler.c(&hir).is_ok());",
          "    assert!(compiler.add(State::Splits { targets: vec![], reverse: true }).is_ok());",
          "    assert!(compiler.patch(0, 0).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::char('b');",
          "    let result = compiler.c_exactly(&hir, 1).unwrap();",
          "    let result2 = compiler.c_at_least(&hir, true, 2);",
          "    if let Err(_) = compiler.patch(result.end, result2.start) {",
          "        // expected failure",
          "    }",
          "}"
        ],
        "oracle": [
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::char('b');",
          "    let result = compiler.c_exactly(&hir, 1).unwrap();",
          "    let result2 = compiler.c_at_least(&hir, true, 0);",
          "    assert_eq!(result2.is_ok(), true);",
          "    let result3 = compiler.c_at_least(&hir, true, 1);",
          "    assert_eq!(result3.is_ok(), true);",
          "    let result4 = compiler.c_at_least(&hir, true, 2);",
          "    assert_eq!(result4.is_err(), true);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::char('b');",
          "    let result = compiler.c_exactly(&hir, 1).unwrap();",
          "    let result2 = compiler.c_at_least(&hir, true, 2);",
          "    if let Err(_) = compiler.patch(result.end, result2.start) {",
          "        // expected failure",
          "    }",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let compiler = Compiler::new(config, String::from(\"\"));",
          "    let hir = Hir::char('b');",
          "    let result = compiler.c_exactly(&hir, 1).unwrap();",
          "    let result2 = compiler.c_at_least(&hir, true, 0);",
          "    assert_eq!(result2.is_ok(), true);",
          "    let result3 = compiler.c_at_least(&hir, true, 1);",
          "    assert_eq!(result3.is_ok(), true);",
          "    let result4 = compiler.c_at_least(&hir, true, 2);",
          "    assert_eq!(result4.is_err(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]