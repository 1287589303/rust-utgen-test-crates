[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"(a|b)*#simple comment\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    assert!(self.is_eof());",
          "    let concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    assert!(self.pop_group_end(concat).is_ok());",
          "    let ast = self.pop_group_end(concat).unwrap();",
          "    assert!(NestLimiter::new(self).check(&ast).is_ok());",
          "    let result = parser_i.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    if let Ok(with_comments) = result {",
          "    assert_eq!(with_comments.comments.len(), 1);",
          "    assert_eq!(with_comments.comments[0].comment, \"simple comment\");",
          "    }"
        ],
        "code": [
          "{",
          "    let pattern = \"(a|b)*#simple comment\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    assert!(self.is_eof());",
          "    let concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    assert!(self.pop_group_end(concat).is_ok());",
          "    let ast = self.pop_group_end(concat).unwrap();",
          "    assert!(NestLimiter::new(self).check(&ast).is_ok());",
          "    let result = parser_i.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    if let Ok(with_comments) = result {",
          "    assert_eq!(with_comments.comments.len(), 1);",
          "    assert_eq!(with_comments.comments[0].comment, \"simple comment\");",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"((a|b)+(c|d)?)*#nested groups\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert!(parser.pos.get() == Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser_i.offset(), 0);",
          "    assert!(parser_i.is_eof());",
          "    assert!(parser_i.parser().comments.borrow().is_empty());",
          "    assert!(parser_i.pop_group_end(concat).is_ok());",
          "    assert!(NestLimiter::new(&parser_i).check(&ast).is_ok());",
          "    let result = parser_i.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    let with_comments = result.unwrap();",
          "    assert_eq!(with_comments.comments, vec![]);",
          "    assert!(with_comments.ast.is_some());"
        ],
        "code": [
          "{",
          "    let pattern = \"((a|b)+(c|d)?)*#nested groups\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "    assert!(parser.pos.get() == Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser_i.offset(), 0);",
          "    assert!(parser_i.is_eof());",
          "    assert!(parser_i.parser().comments.borrow().is_empty());",
          "    assert!(parser_i.pop_group_end(concat).is_ok());",
          "    assert!(NestLimiter::new(&parser_i).check(&ast).is_ok());",
          "    let result = parser_i.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    let with_comments = result.unwrap();",
          "    assert_eq!(with_comments.comments, vec![]);",
          "    assert!(with_comments.ast.is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[a-zA-Z]*#character set\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    assert!(self.bump_space().is_ok());",
          "    assert!(self.is_eof());",
          "    let concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    let class = self.parse_set_class().unwrap();",
          "    assert!(class.negated == false);",
          "    let ast = self.pop_group_end(concat).unwrap();",
          "    let result = NestLimiter::new(self).check(&ast);",
          "    assert!(result.is_ok());",
          "    let comments = mem::replace(&mut *self.parser().comments.borrow_mut(), vec![]);",
          "    assert!(!comments.is_empty());",
          "    assert!(matches!(self.parse_with_comments(), Ok(ast::WithComments { ast, comments: _ })));"
        ],
        "code": [
          "{",
          "    let pattern = \"[a-zA-Z]*#character set\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    assert!(self.bump_space().is_ok());",
          "    assert!(self.is_eof());",
          "    let concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    let class = self.parse_set_class().unwrap();",
          "    assert!(class.negated == false);",
          "    let ast = self.pop_group_end(concat).unwrap();",
          "    let result = NestLimiter::new(self).check(&ast);",
          "    assert!(result.is_ok());",
          "    let comments = mem::replace(&mut *self.parser().comments.borrow_mut(), vec![]);",
          "    assert!(!comments.is_empty());",
          "    assert!(matches!(self.parse_with_comments(), Ok(ast::WithComments { ast, comments: _ })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"a{1,3}#repetition\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(*left_val, *right_val);",
          "    assert!(self.is_eof());",
          "    let concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    let ast = self.pop_group_end(concat).is_ok();",
          "    let check_result = NestLimiter::new(self).check(&ast).is_ok();",
          "    let result = parser_i.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    if let Ok(with_comments) = result {",
          "    assert!(!with_comments.comments.is_empty());",
          "    }"
        ],
        "code": [
          "{",
          "    let pattern = \"a{1,3}#repetition\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "    assert_eq!(*left_val, *right_val);",
          "    assert!(self.is_eof());",
          "    let concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    let ast = self.pop_group_end(concat).is_ok();",
          "    let check_result = NestLimiter::new(self).check(&ast).is_ok();",
          "    let result = parser_i.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    if let Ok(with_comments) = result {",
          "    assert!(!with_comments.comments.is_empty());",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\(abc\\\\)\\\\d+#escaped characters\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    self.bump_space();",
          "    assert!(self.is_eof());",
          "    let concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    let class = self.parse_set_class().expect(\"Failed to parse set class\");",
          "    concat.asts.push(Ast::class_bracketed(class));",
          "    let ast = self.pop_group_end(concat).expect(\"Failed to pop group end\");",
          "    NestLimiter::new(self).check(&ast).expect(\"Failed to check nest limit\");",
          "    let result = Ok(ast::WithComments { ast, comments: mem::replace(&mut *self.parser().comments.borrow_mut(), vec![])});",
          "    assert!(result.is_ok());",
          "    assert!(matches!(result, Ok(_)));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\(abc\\\\)\\\\d+#escaped characters\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    self.bump_space();",
          "    assert!(self.is_eof());",
          "    let concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    let class = self.parse_set_class().expect(\"Failed to parse set class\");",
          "    concat.asts.push(Ast::class_bracketed(class));",
          "    let ast = self.pop_group_end(concat).expect(\"Failed to pop group end\");",
          "    NestLimiter::new(self).check(&ast).expect(\"Failed to check nest limit\");",
          "    let result = Ok(ast::WithComments { ast, comments: mem::replace(&mut *self.parser().comments.borrow_mut(), vec![])});",
          "    assert!(result.is_ok());",
          "    assert!(matches!(result, Ok(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"#empty pattern\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    assert!(self.is_eof());",
          "    let mut concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    assert!(self.pop_group_end(concat).is_ok());",
          "    let ast = self.pop_group_end(concat).expect(\"Should not fail\");",
          "    assert!(NestLimiter::new(self).check(&ast).is_ok());",
          "    let result = parser_i.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    let with_comments = result.unwrap();",
          "    assert_eq!(with_comments.comments, vec![]);"
        ],
        "code": [
          "{",
          "    let pattern = \"#empty pattern\\n\";",
          "    let parser = Parser::new();",
          "    let parser_i = ParserI { parser: &parser, pattern };",
          "    let _ = parser_i.parse_with_comments();",
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    assert!(self.is_eof());",
          "    let mut concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    assert!(self.pop_group_end(concat).is_ok());",
          "    let ast = self.pop_group_end(concat).expect(\"Should not fail\");",
          "    assert!(NestLimiter::new(self).check(&ast).is_ok());",
          "    let result = parser_i.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    let with_comments = result.unwrap();",
          "    assert_eq!(with_comments.comments, vec![]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]