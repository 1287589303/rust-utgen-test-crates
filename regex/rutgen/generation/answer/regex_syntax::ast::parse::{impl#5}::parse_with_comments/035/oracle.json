[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(abc)* # a comment\";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    let with_comments = result.unwrap();",
          "    assert!(matches!(with_comments.ast, Ast::Concat { .. }));",
          "    assert_eq!(with_comments.comments.len(), 1);",
          "    assert_eq!(with_comments.comments[0].comment, \" a comment\");",
          "    assert_eq!(with_comments.comments[0].span.start, expected_span_start);",
          "    assert_eq!(with_comments.comments[0].span.end, expected_span_end);"
        ],
        "code": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(abc)* # a comment\";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "    assert_eq!(result.is_ok(), true);",
          "    let with_comments = result.unwrap();",
          "    assert!(matches!(with_comments.ast, Ast::Concat { .. }));",
          "    assert_eq!(with_comments.comments.len(), 1);",
          "    assert_eq!(with_comments.comments[0].comment, \" a comment\");",
          "    assert_eq!(with_comments.comments[0].span.start, expected_span_start);",
          "    assert_eq!(with_comments.comments[0].span.end, expected_span_end);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(a|b(c|d)) # nested comment\";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    let with_comments = result.unwrap();",
          "    assert!(with_comments.comments.len() > 0);",
          "    assert_eq!(with_comments.ast.is_valid(), true);",
          "    assert_eq!(with_comments.ast.is_empty(), false);",
          "    assert_eq!(with_comments.ast.has_subexprs(), true);",
          "    assert!(parser_instance.parser.borrow().pos.get().offset > 0);",
          "    assert!(parser_instance.parser.borrow().comments.borrow().is_empty());"
        ],
        "code": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(a|b(c|d)) # nested comment\";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "    assert_eq!(result.is_ok(), true);",
          "    let with_comments = result.unwrap();",
          "    assert!(with_comments.comments.len() > 0);",
          "    assert_eq!(with_comments.ast.is_valid(), true);",
          "    assert_eq!(with_comments.ast.is_empty(), false);",
          "    assert_eq!(with_comments.ast.has_subexprs(), true);",
          "    assert!(parser_instance.parser.borrow().pos.get().offset > 0);",
          "    assert!(parser_instance.parser.borrow().comments.borrow().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(x{1,3})* # repetition comment\";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    let with_comments = result.unwrap();",
          "    assert_eq!(with_comments.comments.len(), 1);",
          "    assert_eq!(with_comments.comments[0].comment, \" repetition comment\");",
          "    assert!(matches!(with_comments.ast, Ast::Repetition(_)));",
          "    assert!(with_comments.ast.span().start < with_comments.ast.span().end);",
          "    assert!(parser_instance.parser.capture_names.borrow().is_empty());",
          "    assert_eq!(parser_instance.parser.pos.get().offset, pattern.len());",
          "    assert_eq!(parser_instance.parser.comments.borrow().len(), 0);",
          "    assert!(parser_instance.parser.stack_group.borrow().is_empty());",
          "    assert!(parser_instance.parser.stack_class.borrow().is_empty());",
          "    assert!(!parser_instance.parser.ignore_whitespace.get());"
        ],
        "code": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(x{1,3})* # repetition comment\";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "    assert_eq!(result.is_ok(), true);",
          "    let with_comments = result.unwrap();",
          "    assert_eq!(with_comments.comments.len(), 1);",
          "    assert_eq!(with_comments.comments[0].comment, \" repetition comment\");",
          "    assert!(matches!(with_comments.ast, Ast::Repetition(_)));",
          "    assert!(with_comments.ast.span().start < with_comments.ast.span().end);",
          "    assert!(parser_instance.parser.capture_names.borrow().is_empty());",
          "    assert_eq!(parser_instance.parser.pos.get().offset, pattern.len());",
          "    assert_eq!(parser_instance.parser.comments.borrow().len(), 0);",
          "    assert!(parser_instance.parser.stack_group.borrow().is_empty());",
          "    assert!(parser_instance.parser.stack_class.borrow().is_empty());",
          "    assert!(!parser_instance.parser.ignore_whitespace.get());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(a.+)* # meta character comment\";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let with_comments = result.unwrap();",
          "    assert_eq!(with_comments.comments.len(), 1);",
          "    assert_eq!(with_comments.ast.is_empty(), false);",
          "    assert!(with_comments.ast.has_subexprs());",
          "    assert!(with_comments.ast.is_literal());",
          "    assert!(with_comments.ast.is_group());",
          "    assert!(with_comments.ast.is_repetition());",
          "    assert!(with_comments.ast.is_alternation());",
          "    assert!(with_comments.ast.is_unclosed());",
          "    assert!(parser_instance.is_eof());",
          "    assert_eq!(parser_instance.char(), ')');",
          "    assert_eq!(parser_instance.pop_group(concat).is_ok(), true);",
          "    assert_eq!(parser_instance.pop_group_end(concat).is_ok(), true);",
          "    assert_eq!(NestLimiter::new(&parser_instance).check(&with_comments.ast).is_ok(), true);",
          "    assert_eq!(with_comments.comments[0].comment, \" meta character comment\");",
          "    assert_eq!(with_comments.comments[0].span.start.offset, 10);",
          "    assert_eq!(with_comments.comments[0].span.end.offset, 32);"
        ],
        "code": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(a.+)* # meta character comment\";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    let with_comments = result.unwrap();",
          "    assert_eq!(with_comments.comments.len(), 1);",
          "    assert_eq!(with_comments.ast.is_empty(), false);",
          "    assert!(with_comments.ast.has_subexprs());",
          "    assert!(with_comments.ast.is_literal());",
          "    assert!(with_comments.ast.is_group());",
          "    assert!(with_comments.ast.is_repetition());",
          "    assert!(with_comments.ast.is_alternation());",
          "    assert!(with_comments.ast.is_unclosed());",
          "    assert!(parser_instance.is_eof());",
          "    assert_eq!(parser_instance.char(), ')');",
          "    assert_eq!(parser_instance.pop_group(concat).is_ok(), true);",
          "    assert_eq!(parser_instance.pop_group_end(concat).is_ok(), true);",
          "    assert_eq!(NestLimiter::new(&parser_instance).check(&with_comments.ast).is_ok(), true);",
          "    assert_eq!(with_comments.comments[0].comment, \" meta character comment\");",
          "    assert_eq!(with_comments.comments[0].span.start.offset, 10);",
          "    assert_eq!(with_comments.comments[0].span.end.offset, 32);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(xyz)+ # \";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().ast.is_empty(), false);",
          "    assert_eq!(result.unwrap().comments.len(), 1);",
          "    assert_eq!(result.unwrap().comments[0].comment, \" \");",
          "    assert_eq!(result.unwrap().comments[0].span.start.offset, 6);",
          "    assert_eq!(result.unwrap().comments[0].span.end.offset, 8);"
        ],
        "code": [
          "{",
          "    let parser = Parser::new();",
          "    let pattern = \"(xyz)+ # \";",
          "    let parser_instance = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_instance.parse_with_comments();",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().ast.is_empty(), false);",
          "    assert_eq!(result.unwrap().comments.len(), 1);",
          "    assert_eq!(result.unwrap().comments[0].comment, \" \");",
          "    assert_eq!(result.unwrap().comments[0].span.start.offset, 6);",
          "    assert_eq!(result.unwrap().comments[0].span.end.offset, 8);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]