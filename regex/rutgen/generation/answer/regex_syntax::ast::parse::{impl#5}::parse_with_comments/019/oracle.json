[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"a*b*\";",
          "    let parser = Parser::new();",
          "    parser.reset(); // initialize parser state",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_i.parse_with_comments();",
          "    let _ = result.unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    let mut concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    self.bump_space();",
          "    assert!(!self.is_eof());",
          "    self.char() == '*';",
          "    concat = self.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore).unwrap();",
          "    assert!(self.is_eof());",
          "    let ast = self.pop_group_end(concat).unwrap();",
          "    NestLimiter::new(self).check(&ast).unwrap();",
          "    Ok(ast::WithComments { ast, comments: mem::replace(&mut *self.parser().comments.borrow_mut(), vec![]), })"
        ],
        "code": [
          "{",
          "    let pattern = \"a*b*\";",
          "    let parser = Parser::new();",
          "    parser.reset(); // initialize parser state",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_i.parse_with_comments();",
          "    let _ = result.unwrap();",
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    let mut concat = ast::Concat { span: self.span(), asts: vec![] };",
          "    self.bump_space();",
          "    assert!(!self.is_eof());",
          "    self.char() == '*';",
          "    concat = self.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore).unwrap();",
          "    assert!(self.is_eof());",
          "    let ast = self.pop_group_end(concat).unwrap();",
          "    NestLimiter::new(self).check(&ast).unwrap();",
          "    Ok(ast::WithComments { ast, comments: mem::replace(&mut *self.parser().comments.borrow_mut(), vec![]), })",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"a{1,2*\"; // malformed input",
          "    let parser = Parser::new();",
          "    parser.reset(); // initialize parser state",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_i.parse_with_comments();",
          "    let _ = result.unwrap_err();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    assert!(self.char() == '*');",
          "    assert!(self.is_eof() == false);",
          "    assert!(self.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore).is_ok());",
          "    assert!(self.is_eof() == true);",
          "    assert!(self.pop_group_end(concat).is_ok());",
          "    assert!(NestLimiter::new(self).check(&ast).is_ok());",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let pattern = \"a{1,2*\"; // malformed input",
          "    let parser = Parser::new();",
          "    parser.reset(); // initialize parser state",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_i.parse_with_comments();",
          "    let _ = result.unwrap_err();",
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    assert!(self.char() == '*');",
          "    assert!(self.is_eof() == false);",
          "    assert!(self.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore).is_ok());",
          "    assert!(self.is_eof() == true);",
          "    assert!(self.pop_group_end(concat).is_ok());",
          "    assert!(NestLimiter::new(self).check(&ast).is_ok());",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"((a|b)*c)\"; // valid inputs but nested",
          "    let parser = Parser::new();",
          "    parser.reset(); // initialize parser state",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_i.parse_with_comments();",
          "    let _ = result.unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    self.bump_space();",
          "    assert!(!self.is_eof());",
          "    self.char() == '*';",
          "    self.char() == '*';",
          "    assert!(self.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore).is_ok());",
          "    assert!(self.is_eof());",
          "    assert!(self.pop_group_end(concat).is_ok());",
          "    assert!(NestLimiter::new(self).check(&ast).is_ok());",
          "    assert_eq!(result, Ok(ast::WithComments { ast, comments: mem::replace(&mut *self.parser().comments.borrow_mut(), vec![]) }));"
        ],
        "code": [
          "{",
          "    let pattern = \"((a|b)*c)\"; // valid inputs but nested",
          "    let parser = Parser::new();",
          "    parser.reset(); // initialize parser state",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "",
          "    let result = parser_i.parse_with_comments();",
          "    let _ = result.unwrap();",
          "    assert_eq!(self.offset(), 0, \"parser can only be used once\");",
          "    self.parser().reset();",
          "    self.bump_space();",
          "    assert!(!self.is_eof());",
          "    self.char() == '*';",
          "    self.char() == '*';",
          "    assert!(self.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore).is_ok());",
          "    assert!(self.is_eof());",
          "    assert!(self.pop_group_end(concat).is_ok());",
          "    assert!(NestLimiter::new(self).check(&ast).is_ok());",
          "    assert_eq!(result, Ok(ast::WithComments { ast, comments: mem::replace(&mut *self.parser().comments.borrow_mut(), vec![]) }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]