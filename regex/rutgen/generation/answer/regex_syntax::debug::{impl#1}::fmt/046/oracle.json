[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[b'A', b'B', b'C', 0, b'D', b'E']);",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok()",
          "    utf8_decode(bytes).is_some()",
          "    result.is_ok()",
          "    result.is_ok()",
          "    ch == '\\0'",
          "    ch == '\\0'",
          "    write!(f, \"\\\\0\").is_err()"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[b'A', b'B', b'C', 0, b'D', b'E']);",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "    write!(f, \"\\\"\").is_ok()",
          "    utf8_decode(bytes).is_some()",
          "    result.is_ok()",
          "    result.is_ok()",
          "    ch == '\\0'",
          "    ch == '\\0'",
          "    write!(f, \"\\\\0\").is_err()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0xc2, 0xa9, 0]); // © followed by null",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    ch == '\\0';",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\").is_err();"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0xc2, 0xa9, 0]); // © followed by null",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    ch == '\\0';",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\").is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0xe2, 0x9c, 0x94, 0]); // ✔ followed by null",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")? == Ok(());",
          "    let result = utf8_decode(bytes);",
          "    result.is_some();",
          "    if let Some(result) = result {",
          "    matches!(result, Ok(ch));",
          "    }",
          "    matches!(result, Ok(ch)) == true;",
          "    let ch = /* assume ch is defined from the match */;",
          "    ch == '\\0';",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\")? == Ok(());",
          "    write!(f, \"\\\\0\")? == Err(_);"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0xe2, 0x9c, 0x94, 0]); // ✔ followed by null",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "    write!(f, \"\\\"\")? == Ok(());",
          "    let result = utf8_decode(bytes);",
          "    result.is_some();",
          "    if let Some(result) = result {",
          "    matches!(result, Ok(ch));",
          "    }",
          "    matches!(result, Ok(ch)) == true;",
          "    let ch = /* assume ch is defined from the match */;",
          "    ch == '\\0';",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\")? == Ok(());",
          "    write!(f, \"\\\\0\")? == Err(_);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[b'\\t', 0]); // tab followed by null",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Err(byte));",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\").is_err();",
          "    bytes.len() > 0;",
          "    bytes[0] == b'\\t';",
          "    bytes[1] == 0;",
          "    ch.len_utf8() > 0;",
          "    bytes = &bytes[ch.len_utf8()..];",
          "    assert_eq!(format!(\"{:?}\", input), \"\\\"\\\\t\\\\0\\\"\");"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[b'\\t', 0]); // tab followed by null",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Err(byte));",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\").is_err();",
          "    bytes.len() > 0;",
          "    bytes[0] == b'\\t';",
          "    bytes[1] == 0;",
          "    ch.len_utf8() > 0;",
          "    bytes = &bytes[ch.len_utf8()..];",
          "    assert_eq!(format!(\"{:?}\", input), \"\\\"\\\\t\\\\0\\\"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0xc2, 0xa9, 0xff, 0]); // © followed by invalid byte and null",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    ch == '\\0';",
          "    matches!(ch, '\\0');",
          "    write!(f, \"\\\\0\").is_err();"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0xc2, 0xa9, 0xff, 0]); // © followed by invalid byte and null",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    ch == '\\0';",
          "    matches!(ch, '\\0');",
          "    write!(f, \"\\\\0\").is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[]);",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").unwrap();",
          "    let input = Bytes(b\"Hello, \\x00World!\");",
          "    assert_eq!(core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let input = Bytes(b\"\\x01\\x02\\x03\");",
          "    assert_eq!(core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let input = Bytes(b\"\\x10\\x11\\x12\");",
          "    let expected_output = \"\\\"\\\\x10\\\\x11\\\\x12\\\"\";",
          "    assert_eq!(format!(\"{:?}\", input), expected_output);",
          "    let input = Bytes(b\"Hello\\x0aWorld\");",
          "    let expected_output = \"\\\"Hello\\\\nWorld\\\"\";",
          "    assert_eq!(format!(\"{:?}\", input), expected_output);",
          "    let input = Bytes(b\"\\x7f\");",
          "    let expected_output = \"\\\"\\\\x7f\\\"\";",
          "    assert_eq!(format!(\"{:?}\", input), expected_output);",
          "    let input = Bytes(b\"\\x80\");",
          "    assert!(core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new()).is_err());",
          "    let input = Bytes(b\"\\xff\");",
          "    assert!(core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new()).is_err());"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[]);",
          "    let _ = core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new());",
          "    write!(f, \"\\\"\").unwrap();",
          "    let input = Bytes(b\"Hello, \\x00World!\");",
          "    assert_eq!(core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let input = Bytes(b\"\\x01\\x02\\x03\");",
          "    assert_eq!(core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let input = Bytes(b\"\\x10\\x11\\x12\");",
          "    let expected_output = \"\\\"\\\\x10\\\\x11\\\\x12\\\"\";",
          "    assert_eq!(format!(\"{:?}\", input), expected_output);",
          "    let input = Bytes(b\"Hello\\x0aWorld\");",
          "    let expected_output = \"\\\"Hello\\\\nWorld\\\"\";",
          "    assert_eq!(format!(\"{:?}\", input), expected_output);",
          "    let input = Bytes(b\"\\x7f\");",
          "    let expected_output = \"\\\"\\\\x7f\\\"\";",
          "    assert_eq!(format!(\"{:?}\", input), expected_output);",
          "    let input = Bytes(b\"\\x80\");",
          "    assert!(core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new()).is_err());",
          "    let input = Bytes(b\"\\xff\");",
          "    assert!(core::fmt::Debug::fmt(&input, &mut core::fmt::Formatter::new()).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]