[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x00]); // Null character",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")?; // Precondition: line 38 returns Ok/Some",
          "    let Some(result) = utf8_decode(bytes); // Precondition: line 41 true",
          "    result.match Ok(ch); // Precondition: line 42 true",
          "    ch.match '\\0'; // Precondition: line 52 true",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?; // Precondition: line 59 returns Err/None",
          "    let input = Bytes(&[0x01]); // ASCII control character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x07]); // ASCII control character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x0b]); // Vertical tab",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x0c]); // Form feed",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x0e]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x7f]); // Delete character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[b'\\n']); // Newline character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[b'\\r']); // Carriage return",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[b'\\t']); // Horizontal tab",
          "    let _ = format!(\"{:?}\", input);"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x00]); // Null character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\")?; // Precondition: line 38 returns Ok/Some",
          "    let Some(result) = utf8_decode(bytes); // Precondition: line 41 true",
          "    result.match Ok(ch); // Precondition: line 42 true",
          "    ch.match '\\0'; // Precondition: line 52 true",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?; // Precondition: line 59 returns Err/None",
          "    let input = Bytes(&[0x01]); // ASCII control character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x07]); // ASCII control character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x0b]); // Vertical tab",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x0c]); // Form feed",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x0e]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[0x7f]); // Delete character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[b'\\n']); // Newline character",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[b'\\r']); // Carriage return",
          "    let _ = format!(\"{:?}\", input);",
          "    let input = Bytes(&[b'\\t']); // Horizontal tab",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x01]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").unwrap();",
          "    utf8_decode(bytes).is_some();",
          "    match utf8_decode(bytes) {",
          "    Some(Ok(ch)) => assert_eq!(ch, '\\x01');",
          "    _ => panic!(\"Expected Ok value\");",
          "    }",
          "    let input = Bytes(&[0x00]); // Test null character",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\0\\\"\");",
          "    let input = Bytes(&[0x7f]); // Test delete character",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\x7f\\\"\");",
          "    let input = Bytes(&[0x0b]); // Test vertical tab",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\x0b\\\"\");",
          "    let input = Bytes(&[0x0c]); // Test form feed",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\x0c\\\"\");",
          "    let input = Bytes(&[0x01, 0x02]); // Test multiple control characters",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\x01\\\\x02\\\"\");"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x01]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\").unwrap();",
          "    utf8_decode(bytes).is_some();",
          "    match utf8_decode(bytes) {",
          "    Some(Ok(ch)) => assert_eq!(ch, '\\x01');",
          "    _ => panic!(\"Expected Ok value\");",
          "    }",
          "    let input = Bytes(&[0x00]); // Test null character",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\0\\\"\");",
          "    let input = Bytes(&[0x7f]); // Test delete character",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\x7f\\\"\");",
          "    let input = Bytes(&[0x0b]); // Test vertical tab",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\x0b\\\"\");",
          "    let input = Bytes(&[0x0c]); // Test form feed",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\x0c\\\"\");",
          "    let input = Bytes(&[0x01, 0x02]); // Test multiple control characters",
          "    let result = format!(\"{:?}\", input);",
          "    assert_eq!(result, \"\\\"\\\\x01\\\\x02\\\"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x09]); // Tab character",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8_decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\t';",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    write!(f, \"\\\"\")?;",
          "    Ok(());",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x0b]); // Vertical Tab character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    let input = Bytes(&[0x0c]); // Form Feed character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    let input = Bytes(&[0x7f]); // Delete character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x01]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x0e]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x19]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x0a]); // Line Feed character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    let input = Bytes(&[0x0d]); // Carriage Return character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    let input = Bytes(&[0x00]); // Null character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\0\")?;"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x09]); // Tab character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8_decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\t';",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    write!(f, \"\\\"\")?;",
          "    Ok(());",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x0b]); // Vertical Tab character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    let input = Bytes(&[0x0c]); // Form Feed character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    let input = Bytes(&[0x7f]); // Delete character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x01]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x0e]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x19]); // Control character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    let input = Bytes(&[0x0a]); // Line Feed character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    let input = Bytes(&[0x0d]); // Carriage Return character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    let input = Bytes(&[0x00]); // Null character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\\0\")?;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x0A]); // Newline character",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8_decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\n';",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    bytes = &bytes[ch.len_utf8()..];",
          "    write!(f, \"\\\"\")?;",
          "    Ok(());"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x0A]); // Newline character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8_decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\n';",
          "    write!(f, \"{}\", ch.escape_debug())?;",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    bytes = &bytes[ch.len_utf8()..];",
          "    write!(f, \"\\\"\")?;",
          "    Ok(());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x0D]); // Carriage return character",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    if let Some(Ok(ch)) = utf8_decode(bytes) {",
          "    ch == '\\0';",
          "    ch == '\\x7f';",
          "    ch == '\\x0b';",
          "    ch == '\\t';",
          "    ch == '\\n';",
          "    ch == '\\r';",
          "    ch == '\\x0c';",
          "    (ch >= '\\x01' && ch <= '\\x08');",
          "    (ch >= '\\x01' && ch <= '\\x08') || ch == '\\x7f' || ch == '\\x0b' || ch == '\\x0c' || (ch >= '\\x0e' && ch <= '\\x19');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();",
          "    }"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x0D]); // Carriage return character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    if let Some(Ok(ch)) = utf8_decode(bytes) {",
          "    ch == '\\0';",
          "    ch == '\\x7f';",
          "    ch == '\\x0b';",
          "    ch == '\\t';",
          "    ch == '\\n';",
          "    ch == '\\r';",
          "    ch == '\\x0c';",
          "    (ch >= '\\x01' && ch <= '\\x08');",
          "    (ch >= '\\x01' && ch <= '\\x08') || ch == '\\x7f' || ch == '\\x0b' || ch == '\\x0c' || (ch >= '\\x0e' && ch <= '\\x19');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x0C]); // Form feed character",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8_decode(bytes);",
          "    result.matches(Ok(ch));",
          "    ch.matches('\\0');",
          "    ch.matches('\\x7f');",
          "    ch.matches('\\x0b');",
          "    ch.matches('\\t');",
          "    ch.matches('\\n');",
          "    ch.matches('\\r');",
          "    ch.matches('\\x0c');",
          "    ch.matches('\\x01'..='\\x08');",
          "    ch.matches('\\x01'..='\\x08');",
          "    ch.matches('\\x01'..='\\x08' or '\\x7f' or '\\x0b' or '\\x0c' or '\\x0e'..='\\x19');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch));",
          "    write!(f, \"\\\"\").is_ok();",
          "    write!(f, \"\\\"\").is_err();"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x0C]); // Form feed character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8_decode(bytes);",
          "    result.matches(Ok(ch));",
          "    ch.matches('\\0');",
          "    ch.matches('\\x7f');",
          "    ch.matches('\\x0b');",
          "    ch.matches('\\t');",
          "    ch.matches('\\n');",
          "    ch.matches('\\r');",
          "    ch.matches('\\x0c');",
          "    ch.matches('\\x01'..='\\x08');",
          "    ch.matches('\\x01'..='\\x08');",
          "    ch.matches('\\x01'..='\\x08' or '\\x7f' or '\\x0b' or '\\x0c' or '\\x0e'..='\\x19');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch));",
          "    write!(f, \"\\\"\").is_ok();",
          "    write!(f, \"\\\"\").is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x7F]); // Delete character",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    ch == '\\0';",
          "    ch == '\\x7f';",
          "    ch == '\\x0b';",
          "    ch == '\\t';",
          "    ch == '\\n';",
          "    ch == '\\r';",
          "    ch == '\\x0c';",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x01'..='\\x08') || matches!(ch, '\\x7f') || matches!(ch, '\\x0b') || matches!(ch, '\\x0c') || matches!(ch, '\\x0e'..='\\x19');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x7F]); // Delete character",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    ch == '\\0';",
          "    ch == '\\x7f';",
          "    ch == '\\x0b';",
          "    ch == '\\t';",
          "    ch == '\\n';",
          "    ch == '\\r';",
          "    ch == '\\x0c';",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x01'..='\\x08') || matches!(ch, '\\x7f') || matches!(ch, '\\x0b') || matches!(ch, '\\x0c') || matches!(ch, '\\x0e'..='\\x19');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x01, 0x02, 0x03, 0x04]); // Multiple control characters",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    match utf8_decode(bytes) { Ok(_) => true, Err(_) => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\0' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\x7f' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\x0b' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\t' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\n' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\r' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\x0c' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch >= '\\x01' && ch <= '\\x08' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch >= '\\x01' && ch <= '\\x08' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if (ch >= '\\x01' && ch <= '\\x08') || ch == '\\x7f' || ch == '\\x0b' || ch == '\\x0c' || (ch >= '\\x0e' && ch <= '\\x19') => true, _ => false };",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x01, 0x02, 0x03, 0x04]); // Multiple control characters",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8_decode(bytes).is_some();",
          "    match utf8_decode(bytes) { Ok(_) => true, Err(_) => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\0' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\x7f' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\x0b' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\t' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\n' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\r' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch == '\\x0c' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch >= '\\x01' && ch <= '\\x08' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if ch >= '\\x01' && ch <= '\\x08' => true, _ => false };",
          "    match utf8_decode(bytes) { Ok(ch) if (ch >= '\\x01' && ch <= '\\x08') || ch == '\\x7f' || ch == '\\x0b' || ch == '\\x0c' || (ch >= '\\x0e' && ch <= '\\x19') => true, _ => false };",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Bytes(&[0x01, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F]); // Mixed characters",
          "    let _ = format!(\"{:?}\", input);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")? == Ok(());",
          "    let result = utf8_decode(bytes);",
          "    result.is_some() == true;",
          "    let ch = result.unwrap().ok();",
          "    ch.is_some() == true;",
          "    ch.unwrap() == '\\0';",
          "    ch.unwrap() == '\\x7f';",
          "    ch.unwrap() == '\\x0b';",
          "    ch.unwrap() == '\\t';",
          "    ch.unwrap() == '\\n';",
          "    ch.unwrap() == '\\r';",
          "    ch.unwrap() == '\\x0c';",
          "    ch.unwrap() >= '\\x01' && ch.unwrap() <= '\\x08';",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch.unwrap()))? == Err(core::fmt::Error);",
          "    write!(f, \"{}\", ch.escape_debug())? == Ok(());",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch.unwrap()))? == Ok(());"
        ],
        "code": [
          "{",
          "    let input = Bytes(&[0x01, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F]); // Mixed characters",
          "    let _ = format!(\"{:?}\", input);",
          "    write!(f, \"\\\"\")? == Ok(());",
          "    let result = utf8_decode(bytes);",
          "    result.is_some() == true;",
          "    let ch = result.unwrap().ok();",
          "    ch.is_some() == true;",
          "    ch.unwrap() == '\\0';",
          "    ch.unwrap() == '\\x7f';",
          "    ch.unwrap() == '\\x0b';",
          "    ch.unwrap() == '\\t';",
          "    ch.unwrap() == '\\n';",
          "    ch.unwrap() == '\\r';",
          "    ch.unwrap() == '\\x0c';",
          "    ch.unwrap() >= '\\x01' && ch.unwrap() <= '\\x08';",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch.unwrap()))? == Err(core::fmt::Error);",
          "    write!(f, \"{}\", ch.escape_debug())? == Ok(());",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch.unwrap()))? == Ok(());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]