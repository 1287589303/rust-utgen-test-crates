[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let nfa = NFA::always_match();",
          "    let result = builder.build_from_nfa(nfa);",
          "}"
        ],
        "oracle": [
          "    let builder = Builder::new();",
          "    let nfa = NFA::always_match();",
          "    let result = builder.build_from_nfa(nfa);",
          "    assert!(result.is_ok());",
          "    let nfa_invalid = NFA::never_match();",
          "    let result_invalid = builder.build_from_nfa(nfa_invalid);",
          "    assert!(result_invalid.is_err());",
          "    assert!(matches!(result_invalid.unwrap_err().kind, BuildErrorKind::Word));",
          "    let empty_nfa = NFA::new(\"\");",
          "    let result_empty = builder.build_from_nfa(empty_nfa.unwrap());",
          "    assert!(result_empty.is_err());",
          "    assert!(matches!(result_empty.unwrap_err().kind, BuildErrorKind::Word));"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let nfa = NFA::always_match();",
          "    let result = builder.build_from_nfa(nfa);",
          "    let builder = Builder::new();",
          "    let nfa = NFA::always_match();",
          "    let result = builder.build_from_nfa(nfa);",
          "    assert!(result.is_ok());",
          "    let nfa_invalid = NFA::never_match();",
          "    let result_invalid = builder.build_from_nfa(nfa_invalid);",
          "    assert!(result_invalid.is_err());",
          "    assert!(matches!(result_invalid.unwrap_err().kind, BuildErrorKind::Word));",
          "    let empty_nfa = NFA::new(\"\");",
          "    let result_empty = builder.build_from_nfa(empty_nfa.unwrap());",
          "    assert!(result_empty.is_err());",
          "    assert!(matches!(result_empty.unwrap_err().kind, BuildErrorKind::Word));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let mut nfa = NFA::always_match();",
          "    let look_set = LookSet::singleton(Look::Word);",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "}"
        ],
        "oracle": [
          "    let builder = Builder::new();",
          "    let nfa = NFA::always_match();",
          "    let look_set = LookSet::singleton(Look::Word);",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Word);"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let mut nfa = NFA::always_match();",
          "    let look_set = LookSet::singleton(Look::Word);",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "    let builder = Builder::new();",
          "    let nfa = NFA::always_match();",
          "    let look_set = LookSet::singleton(Look::Word);",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Word);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let mut nfa = NFA::always_match();",
          "    let look_set = LookSet::full();",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "}"
        ],
        "oracle": [
          "    let builder = Builder::new();",
          "    let nfa = NFA::always_match();",
          "    let look_set = LookSet::empty();",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "    assert!(result.is_err());",
          "    assert!(matches!(result, Err(BuildError::word(_))));"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let mut nfa = NFA::always_match();",
          "    let look_set = LookSet::full();",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "    let builder = Builder::new();",
          "    let nfa = NFA::always_match();",
          "    let look_set = LookSet::empty();",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "    assert!(result.is_err());",
          "    assert!(matches!(result, Err(BuildError::word(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let mut nfa = NFA::always_match();",
          "    let look_set = LookSet::empty();",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Word);"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let mut nfa = NFA::always_match();",
          "    let look_set = LookSet::empty();",
          "    nfa.0.look_set_any = look_set;",
          "    let result = builder.build_from_nfa(nfa);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Word);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]