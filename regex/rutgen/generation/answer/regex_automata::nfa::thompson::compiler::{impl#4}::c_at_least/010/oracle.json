[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: vec![],",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap {",
          "            version: 1,",
          "            capacity: 10,",
          "            map: vec![],",
          "        }),",
          "    };",
          "    ",
          "    let expr = Hir::from_literal(b\"test\");",
          "    let greedy = false;",
          "    let n = 1;",
          "",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    compiler.patch(union, compiled.start).unwrap();",
          "    compiler.patch(compiled.end, union).unwrap();",
          "",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "}"
        ],
        "oracle": [
          "    let compiler = Compiler { parser: ParserBuilder::new(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State { compiled: Utf8BoundedMap::default(), uncompiled: vec![], }), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap { version: 1, capacity: 10, map: vec![], }), };",
          "    let expr = Hir::from_literal(b\"test\");",
          "    let greedy = false;",
          "    let n = 0;",
          "    assert!(compiler.c_at_least(&expr, greedy, n).is_err());",
          "    let greedy = false;",
          "    let n = 1;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    assert!(compiler.patch(union, compiled.start).is_ok());",
          "    assert!(compiler.patch(compiled.end, union).is_ok());",
          "    let result = compiler.c_at_least(&expr, greedy, n).unwrap();",
          "    assert_eq!(result, Ok(ThompsonRef { start: union, end: union }));"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: vec![],",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap {",
          "            version: 1,",
          "            capacity: 10,",
          "            map: vec![],",
          "        }),",
          "    };",
          "    ",
          "    let expr = Hir::from_literal(b\"test\");",
          "    let greedy = false;",
          "    let n = 1;",
          "",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    compiler.patch(union, compiled.start).unwrap();",
          "    compiler.patch(compiled.end, union).unwrap();",
          "",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "    let compiler = Compiler { parser: ParserBuilder::new(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State { compiled: Utf8BoundedMap::default(), uncompiled: vec![], }), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap { version: 1, capacity: 10, map: vec![], }), };",
          "    let expr = Hir::from_literal(b\"test\");",
          "    let greedy = false;",
          "    let n = 0;",
          "    assert!(compiler.c_at_least(&expr, greedy, n).is_err());",
          "    let greedy = false;",
          "    let n = 1;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    assert!(compiler.patch(union, compiled.start).is_ok());",
          "    assert!(compiler.patch(compiled.end, union).is_ok());",
          "    let result = compiler.c_at_least(&expr, greedy, n).unwrap();",
          "    assert_eq!(result, Ok(ThompsonRef { start: union, end: union }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: vec![],",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap {",
          "            version: 1,",
          "            capacity: 10,",
          "            map: vec![],",
          "        }),",
          "    };",
          "",
          "    let expr = Hir::from_literal(b\"example\");",
          "    let greedy = false;",
          "    let n = 2;",
          "",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    compiler.patch(union, compiled.start).unwrap();",
          "    compiler.patch(compiled.end, union).unwrap();",
          "",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "}"
        ],
        "oracle": [
          "    let compiler = Compiler { parser: ParserBuilder::new(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State { compiled: Utf8BoundedMap::default(), uncompiled: vec![], }), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap { version: 1, capacity: 10, map: vec![], }), };",
          "    ",
          "    let expr = Hir::from_literal(b\"example\");",
          "    let greedy = false;",
          "    let n = 0;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    let patch_result_start = compiler.patch(union, compiled.start);",
          "    let patch_result_end = compiler.patch(compiled.end, union);",
          "    ",
          "    assert_eq!(patch_result_start.is_ok(), true);",
          "    assert_eq!(patch_result_end.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: union, end: union }));",
          "    ",
          "    let expr_with_min_len = Hir::from_literal(b\"nonempty\");",
          "    let greedy = false;",
          "    let n = 0;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr_with_min_len).unwrap();",
          "    let patch_result_start = compiler.patch(union, compiled.start);",
          "    let patch_result_end = compiler.patch(compiled.end, union);",
          "    ",
          "    assert_eq!(patch_result_start.is_ok(), true);",
          "    assert_eq!(patch_result_end.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr_with_min_len, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: union, end: union }));",
          "    ",
          "    let expr_empty_match = Hir::from_literal(b\"\");",
          "    let greedy = false;",
          "    let n = 0;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr_empty_match).unwrap();",
          "    let patch_result_start = compiler.patch(union, compiled.start);",
          "    let patch_result_end = compiler.patch(compiled.end, union);",
          "    ",
          "    assert_eq!(patch_result_start.is_ok(), true);",
          "    assert_eq!(patch_result_end.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr_empty_match, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: union, end: union }));",
          "    ",
          "    let greedy = true;",
          "    let n = 1;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    let patch_result_start = compiler.patch(union, compiled.start);",
          "    let patch_result_end = compiler.patch(compiled.end, union);",
          "    ",
          "    assert_eq!(patch_result_start.is_ok(), true);",
          "    assert_eq!(patch_result_end.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: compiled.start, end: union }));",
          "    ",
          "    let n = 2;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let prefix = compiler.c_exactly(&expr, n - 1).unwrap();",
          "    let last = compiler.c(&expr).unwrap();",
          "    let patch_result_prefix_last = compiler.patch(prefix.end, last.start);",
          "    let patch_result_last_union = compiler.patch(last.end, union);",
          "    let patch_result_union_last = compiler.patch(union, last.start);",
          "    ",
          "    assert_eq!(patch_result_prefix_last.is_ok(), true);",
          "    assert_eq!(patch_result_last_union.is_ok(), true);",
          "    assert_eq!(patch_result_union_last.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: prefix.start, end: union }));"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: vec![],",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap {",
          "            version: 1,",
          "            capacity: 10,",
          "            map: vec![],",
          "        }),",
          "    };",
          "",
          "    let expr = Hir::from_literal(b\"example\");",
          "    let greedy = false;",
          "    let n = 2;",
          "",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    compiler.patch(union, compiled.start).unwrap();",
          "    compiler.patch(compiled.end, union).unwrap();",
          "",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "    let compiler = Compiler { parser: ParserBuilder::new(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State { compiled: Utf8BoundedMap::default(), uncompiled: vec![], }), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap { version: 1, capacity: 10, map: vec![], }), };",
          "    ",
          "    let expr = Hir::from_literal(b\"example\");",
          "    let greedy = false;",
          "    let n = 0;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    let patch_result_start = compiler.patch(union, compiled.start);",
          "    let patch_result_end = compiler.patch(compiled.end, union);",
          "    ",
          "    assert_eq!(patch_result_start.is_ok(), true);",
          "    assert_eq!(patch_result_end.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: union, end: union }));",
          "    ",
          "    let expr_with_min_len = Hir::from_literal(b\"nonempty\");",
          "    let greedy = false;",
          "    let n = 0;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr_with_min_len).unwrap();",
          "    let patch_result_start = compiler.patch(union, compiled.start);",
          "    let patch_result_end = compiler.patch(compiled.end, union);",
          "    ",
          "    assert_eq!(patch_result_start.is_ok(), true);",
          "    assert_eq!(patch_result_end.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr_with_min_len, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: union, end: union }));",
          "    ",
          "    let expr_empty_match = Hir::from_literal(b\"\");",
          "    let greedy = false;",
          "    let n = 0;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr_empty_match).unwrap();",
          "    let patch_result_start = compiler.patch(union, compiled.start);",
          "    let patch_result_end = compiler.patch(compiled.end, union);",
          "    ",
          "    assert_eq!(patch_result_start.is_ok(), true);",
          "    assert_eq!(patch_result_end.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr_empty_match, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: union, end: union }));",
          "    ",
          "    let greedy = true;",
          "    let n = 1;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let compiled = compiler.c(&expr).unwrap();",
          "    let patch_result_start = compiler.patch(union, compiled.start);",
          "    let patch_result_end = compiler.patch(compiled.end, union);",
          "    ",
          "    assert_eq!(patch_result_start.is_ok(), true);",
          "    assert_eq!(patch_result_end.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: compiled.start, end: union }));",
          "    ",
          "    let n = 2;",
          "    let union = compiler.add_union_reverse().unwrap();",
          "    let prefix = compiler.c_exactly(&expr, n - 1).unwrap();",
          "    let last = compiler.c(&expr).unwrap();",
          "    let patch_result_prefix_last = compiler.patch(prefix.end, last.start);",
          "    let patch_result_last_union = compiler.patch(last.end, union);",
          "    let patch_result_union_last = compiler.patch(union, last.start);",
          "    ",
          "    assert_eq!(patch_result_prefix_last.is_ok(), true);",
          "    assert_eq!(patch_result_last_union.is_ok(), true);",
          "    assert_eq!(patch_result_union_last.is_ok(), true);",
          "    let result = compiler.c_at_least(&expr, greedy, n);",
          "    assert_eq!(result, Ok(ThompsonRef { start: prefix.start, end: union }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]