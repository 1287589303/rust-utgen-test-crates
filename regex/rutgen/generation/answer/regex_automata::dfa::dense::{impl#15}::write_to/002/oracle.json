[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    let states = vec![StateID(0), StateID(1), StateID(2), StateID(3)];",
          "    let table = states.clone();",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let nwrite = transition_table.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "    ",
          "    let _ = transition_table.write_to::<Endian>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    let states = vec![StateID(0), StateID(1), StateID(2), StateID(3)];",
          "    let table = states.clone();",
          "    let transition_table = TransitionTable { table, classes, stride2 };",
          "    ",
          "    let nwrite = transition_table.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "    assert_eq!(transition_table.write_to::<Endian>(&mut buffer).is_ok(), true);",
          "    ",
          "    let mut small_buffer = vec![0u8; nwrite - 1];",
          "    assert_eq!(transition_table.write_to::<Endian>(&mut small_buffer).is_err(), true);",
          "    ",
          "    let classes_error = ByteClasses::empty();",
          "    let transition_table_error = TransitionTable { table, classes: classes_error, stride2 };",
          "    assert_eq!(transition_table_error.write_to::<Endian>(&mut buffer).is_err(), true);"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    let states = vec![StateID(0), StateID(1), StateID(2), StateID(3)];",
          "    let table = states.clone();",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let nwrite = transition_table.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "    ",
          "    let _ = transition_table.write_to::<Endian>(&mut buffer);",
          "    let classes = ByteClasses([0; 256]);",
          "    let stride2 = 1;",
          "    let states = vec![StateID(0), StateID(1), StateID(2), StateID(3)];",
          "    let table = states.clone();",
          "    let transition_table = TransitionTable { table, classes, stride2 };",
          "    ",
          "    let nwrite = transition_table.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "    assert_eq!(transition_table.write_to::<Endian>(&mut buffer).is_ok(), true);",
          "    ",
          "    let mut small_buffer = vec![0u8; nwrite - 1];",
          "    assert_eq!(transition_table.write_to::<Endian>(&mut small_buffer).is_err(), true);",
          "    ",
          "    let classes_error = ByteClasses::empty();",
          "    let transition_table_error = TransitionTable { table, classes: classes_error, stride2 };",
          "    assert_eq!(transition_table_error.write_to::<Endian>(&mut buffer).is_err(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let classes = ByteClasses([1; 256]);  // Invalid configuration",
          "    let stride2 = 2;",
          "    let states = vec![StateID(0), StateID(1), StateID(2)];",
          "    let table = states.clone();",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let nwrite = transition_table.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "    ",
          "    let _ = transition_table.write_to::<Endian>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    let classes = ByteClasses([1; 256]); // Invalid configuration",
          "    let stride2 = 2;",
          "    let states = vec![StateID(0), StateID(1), StateID(2)];",
          "    let table = states.clone();",
          "    let transition_table = TransitionTable {",
          "    table,",
          "    classes,",
          "    stride2,",
          "    };",
          "    ",
          "    let nwrite = transition_table.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite]; // dst.len() == nwrite",
          "    ",
          "    assert_eq!(transition_table.write_to::<Endian>(&mut buffer).is_err(), true); // Expected Err when self.classes.write_to(dst)? fails"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([1; 256]);  // Invalid configuration",
          "    let stride2 = 2;",
          "    let states = vec![StateID(0), StateID(1), StateID(2)];",
          "    let table = states.clone();",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2,",
          "    };",
          "",
          "    let nwrite = transition_table.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "    ",
          "    let _ = transition_table.write_to::<Endian>(&mut buffer);",
          "    let classes = ByteClasses([1; 256]); // Invalid configuration",
          "    let stride2 = 2;",
          "    let states = vec![StateID(0), StateID(1), StateID(2)];",
          "    let table = states.clone();",
          "    let transition_table = TransitionTable {",
          "    table,",
          "    classes,",
          "    stride2,",
          "    };",
          "    ",
          "    let nwrite = transition_table.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite]; // dst.len() == nwrite",
          "    ",
          "    assert_eq!(transition_table.write_to::<Endian>(&mut buffer).is_err(), true); // Expected Err when self.classes.write_to(dst)? fails",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]