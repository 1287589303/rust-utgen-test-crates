[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Literal(Literal { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, ClassInduct::from_set(&lhs_item));",
          "    assert!(matches!(_result, ClassInduct::BinaryOp(_)));",
          "    assert!(matches!(_result, ClassInduct::Item(_)));",
          "    assert!(matches!(_result, ClassInduct::Item(lhs_item)));"
        ],
        "code": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Literal(Literal { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "    assert_eq!(_result, ClassInduct::from_set(&lhs_item));",
          "    assert!(matches!(_result, ClassInduct::BinaryOp(_)));",
          "    assert!(matches!(_result, ClassInduct::Item(_)));",
          "    assert!(matches!(_result, ClassInduct::Item(lhs_item)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, ClassInduct::Item(&lhs_item));",
          "    assert!(matches!(_result, ClassInduct::Item(_)));",
          "    assert!(matches!(_result, ClassInduct::BinaryOp(_)).not());",
          "    assert!(matches!(_result, ClassInduct::BinaryOp(_)).not());",
          "    assert!(matches!(_result, ClassInduct::BinaryLHS { .. }).not());",
          "    assert!(matches!(_result, ClassInduct::BinaryRHS { .. }).not());"
        ],
        "code": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "    assert_eq!(_result, ClassInduct::Item(&lhs_item));",
          "    assert!(matches!(_result, ClassInduct::Item(_)));",
          "    assert!(matches!(_result, ClassInduct::BinaryOp(_)).not());",
          "    assert!(matches!(_result, ClassInduct::BinaryOp(_)).not());",
          "    assert!(matches!(_result, ClassInduct::BinaryLHS { .. }).not());",
          "    assert!(matches!(_result, ClassInduct::BinaryRHS { .. }).not());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Ascii(ClassAscii { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, ClassInduct::from_set(&lhs_item));",
          "    assert!(_result.is_binary_op());",
          "    assert!(_result.is_item());",
          "    assert_eq!(frame.child().lhs, lhs_item);",
          "    assert_eq!(frame.child().op, &op);",
          "    assert!(matches!(frame.child(), ClassInduct::BinaryOp(_)));",
          "    assert!(matches!(frame.child(), ClassInduct::Item(_)));"
        ],
        "code": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Ascii(ClassAscii { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "    assert_eq!(_result, ClassInduct::from_set(&lhs_item));",
          "    assert!(_result.is_binary_op());",
          "    assert!(_result.is_item());",
          "    assert_eq!(frame.child().lhs, lhs_item);",
          "    assert_eq!(frame.child().op, &op);",
          "    assert!(matches!(frame.child(), ClassInduct::BinaryOp(_)));",
          "    assert!(matches!(frame.child(), ClassInduct::Item(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, ClassInduct::from_set(&lhs_item));",
          "    assert!(matches!(_result, ClassInduct::BinaryOp(_)));",
          "    assert!(matches!(_result, ClassInduct::Item(_)));",
          "    assert!(matches!(_result, ClassInduct::Item(&ast::ClassSetItem::Unicode(_))));",
          "    assert_eq!(frame, ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item });",
          "    assert!(frame.child().is_some());"
        ],
        "code": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "    assert_eq!(_result, ClassInduct::from_set(&lhs_item));",
          "    assert!(matches!(_result, ClassInduct::BinaryOp(_)));",
          "    assert!(matches!(_result, ClassInduct::Item(_)));",
          "    assert!(matches!(_result, ClassInduct::Item(&ast::ClassSetItem::Unicode(_))));",
          "    assert_eq!(frame, ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item });",
          "    assert!(frame.child().is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Perl(ClassPerl { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "}"
        ],
        "oracle": [
          "    self.child().unwrap() == ClassInduct::from_set(&lhs_item)",
          "    self.child().unwrap() == ClassInduct::BinaryOp(&op)",
          "    self.child().is_a(ClassInduct::Item)"
        ],
        "code": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Perl(ClassPerl { /* initialize with valid data */ }));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "    self.child().unwrap() == ClassInduct::from_set(&lhs_item)",
          "    self.child().unwrap() == ClassInduct::BinaryOp(&op)",
          "    self.child().is_a(ClassInduct::Item)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* initialize with valid data */ })));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, ClassInduct::from_set(&lhs_item));",
          "    assert!(matches!(frame, ClassFrame::BinaryLHS { op, lhs, rhs }));",
          "    assert_eq!(op.kind, ClassSetBinaryOpKind::SomeKind);",
          "    assert!(matches!(lhs_item, ast::ClassSet::Item(ast::ClassSetItem::Bracketed(_))));",
          "    assert!(lhs_item != ast::ClassSet::Item(ast::ClassSetItem::Empty(_)));"
        ],
        "code": [
          "{",
          "    let lhs_item = ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* initialize with valid data */ })));",
          "    let op = ClassSetBinaryOp { span: Span { /* valid span */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs_item.clone()), rhs: Box::new(lhs_item.clone()) };",
          "    let frame = ClassFrame::BinaryLHS { op: &op, lhs: &lhs_item, rhs: &lhs_item };",
          "    let _result = frame.child();",
          "    assert_eq!(_result, ClassInduct::from_set(&lhs_item));",
          "    assert!(matches!(frame, ClassFrame::BinaryLHS { op, lhs, rhs }));",
          "    assert_eq!(op.kind, ClassSetBinaryOpKind::SomeKind);",
          "    assert!(matches!(lhs_item, ast::ClassSet::Item(ast::ClassSetItem::Bracketed(_))));",
          "    assert!(lhs_item != ast::ClassSet::Item(ast::ClassSetItem::Empty(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]