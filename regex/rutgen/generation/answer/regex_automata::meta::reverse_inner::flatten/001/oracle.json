[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal(\"a\".into()),",
          "        Hir::literal(\"b\".into()),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    _results.push(_result == Hir::alternation(vec![",
          "    Hir::literal(\"a\".into()),",
          "    Hir::literal(\"b\".into()),",
          "    ]));"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal(\"a\".into()),",
          "        Hir::literal(\"b\".into()),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "    _results.push(_result == Hir::alternation(vec![",
          "    Hir::literal(\"a\".into()),",
          "    Hir::literal(\"b\".into()),",
          "    ]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::class(vec![b'a', b'b']),",
          "        Hir::class(vec![b'1', b'2']),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::alternation(vec![Hir::class(vec![b'a', b'b']), Hir::class(vec![b'1', b'2'])]);",
          "    assert_eq!(_result.kind(), HirKind::Alternation);",
          "    assert_eq!(_result.count(), 2);",
          "    assert!(matches!(_result, Hir::Alternation(_)));",
          "    assert!(matches!(_result[0], Hir::Class(_)));",
          "    assert!(matches!(_result[1], Hir::Class(_)));",
          "    assert_eq!(_result[0].chars(), vec![b'a', b'b']);",
          "    assert_eq!(_result[1].chars(), vec![b'1', b'2']);"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::class(vec![b'a', b'b']),",
          "        Hir::class(vec![b'1', b'2']),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "    let hir = Hir::alternation(vec![Hir::class(vec![b'a', b'b']), Hir::class(vec![b'1', b'2'])]);",
          "    assert_eq!(_result.kind(), HirKind::Alternation);",
          "    assert_eq!(_result.count(), 2);",
          "    assert!(matches!(_result, Hir::Alternation(_)));",
          "    assert!(matches!(_result[0], Hir::Class(_)));",
          "    assert!(matches!(_result[1], Hir::Class(_)));",
          "    assert_eq!(_result[0].chars(), vec![b'a', b'b']);",
          "    assert_eq!(_result[1].chars(), vec![b'1', b'2']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::look(Hir::literal(\"x\".into())),",
          "        Hir::look(Hir::literal(\"y\".into())),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    flatten(&Hir::alternation(vec![Hir::look(Hir::literal(\"x\".into())), Hir::look(Hir::literal(\"y\".into()))])) == Hir::alternation(vec![Hir::look(Hir::literal(\"x\".into())), Hir::look(Hir::literal(\"y\".into()))])",
          "    flatten(&Hir::alternation(vec![Hir::literal(\"x\".into()), Hir::look(Hir::literal(\"y\".into()))])) == Hir::alternation(vec![Hir::literal(\"x\".into()), Hir::look(Hir::literal(\"y\".into()))])",
          "    flatten(&Hir::alternation(vec![Hir::class(vec!['a'.into()]), Hir::class(vec!['b'.into()])])) == Hir::alternation(vec![Hir::class(vec!['a'.into()]), Hir::class(vec!['b'.into()])])",
          "    flatten(&Hir::alternation(vec![Hir::capture(Hir::literal(\"z\".into())), Hir::look(Hir::literal(\"w\".into()))])) == Hir::alternation(vec![Hir::look(Hir::literal(\"w\".into()))])",
          "    flatten(&Hir::alternation(vec![Hir::empty(), Hir::look(Hir::literal(\"a\".into()))])) == Hir::alternation(vec![Hir::look(Hir::literal(\"a\".into()))])"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::look(Hir::literal(\"x\".into())),",
          "        Hir::look(Hir::literal(\"y\".into())),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "    flatten(&Hir::alternation(vec![Hir::look(Hir::literal(\"x\".into())), Hir::look(Hir::literal(\"y\".into()))])) == Hir::alternation(vec![Hir::look(Hir::literal(\"x\".into())), Hir::look(Hir::literal(\"y\".into()))])",
          "    flatten(&Hir::alternation(vec![Hir::literal(\"x\".into()), Hir::look(Hir::literal(\"y\".into()))])) == Hir::alternation(vec![Hir::literal(\"x\".into()), Hir::look(Hir::literal(\"y\".into()))])",
          "    flatten(&Hir::alternation(vec![Hir::class(vec!['a'.into()]), Hir::class(vec!['b'.into()])])) == Hir::alternation(vec![Hir::class(vec!['a'.into()]), Hir::class(vec!['b'.into()])])",
          "    flatten(&Hir::alternation(vec![Hir::capture(Hir::literal(\"z\".into())), Hir::look(Hir::literal(\"w\".into()))])) == Hir::alternation(vec![Hir::look(Hir::literal(\"w\".into()))])",
          "    flatten(&Hir::alternation(vec![Hir::empty(), Hir::look(Hir::literal(\"a\".into()))])) == Hir::alternation(vec![Hir::look(Hir::literal(\"a\".into()))])",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::repetition(hir::Repetition::new(Hir::literal(\"z\".into()), 1..=3)),",
          "        Hir::repetition(hir::Repetition::new(Hir::literal(\"w\".into()), 2..=4)),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    Hir::alternation(vec![Hir::repetition(hir::Repetition::new(Hir::literal(\"z\".into()), 1..=3)), Hir::repetition(hir::Repetition::new(Hir::literal(\"w\".into()), 2..=4))])",
          "    _result.kind() == HirKind::Alternation",
          "    _result.children().len() == 2",
          "    _result.children()[0].kind() == HirKind::Repetition",
          "    _result.children()[0].min() == 1",
          "    _result.children()[0].max() == 3",
          "    _result.children()[1].kind() == HirKind::Repetition",
          "    _result.children()[1].min() == 2",
          "    _result.children()[1].max() == 4"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::repetition(hir::Repetition::new(Hir::literal(\"z\".into()), 1..=3)),",
          "        Hir::repetition(hir::Repetition::new(Hir::literal(\"w\".into()), 2..=4)),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "    Hir::alternation(vec![Hir::repetition(hir::Repetition::new(Hir::literal(\"z\".into()), 1..=3)), Hir::repetition(hir::Repetition::new(Hir::literal(\"w\".into()), 2..=4))])",
          "    _result.kind() == HirKind::Alternation",
          "    _result.children().len() == 2",
          "    _result.children()[0].kind() == HirKind::Repetition",
          "    _result.children()[0].min() == 1",
          "    _result.children()[0].max() == 3",
          "    _result.children()[1].kind() == HirKind::Repetition",
          "    _result.children()[1].min() == 2",
          "    _result.children()[1].max() == 4",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::Capture {",
          "            sub: Box::new(Hir::literal(\"test\".into())),",
          "            name: None,",
          "            index: 0,",
          "        },",
          "        Hir::literal(\"no_capture\".into()),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::alternation(vec![",
          "    Hir::Capture {",
          "    sub: Box::new(Hir::literal(\"test\".into())),",
          "    name: None,",
          "    index: 0,",
          "    },",
          "    Hir::literal(\"no_capture\".into()),",
          "    ]);",
          "    assert_eq!(_result.kind(), HirKind::Alternation);",
          "    assert_eq!(_result.children().len(), 2);",
          "    assert_eq!(_result.children()[0].kind(), HirKind::Literal);",
          "    assert_eq!(_result.children()[0].to_string(), \"test\");",
          "    assert_eq!(_result.children()[1].kind(), HirKind::Literal);",
          "    assert_eq!(_result.children()[1].to_string(), \"no_capture\");"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::Capture {",
          "            sub: Box::new(Hir::literal(\"test\".into())),",
          "            name: None,",
          "            index: 0,",
          "        },",
          "        Hir::literal(\"no_capture\".into()),",
          "    ]);",
          "    let _result = flatten(&hir);",
          "    let hir = Hir::alternation(vec![",
          "    Hir::Capture {",
          "    sub: Box::new(Hir::literal(\"test\".into())),",
          "    name: None,",
          "    index: 0,",
          "    },",
          "    Hir::literal(\"no_capture\".into()),",
          "    ]);",
          "    assert_eq!(_result.kind(), HirKind::Alternation);",
          "    assert_eq!(_result.children().len(), 2);",
          "    assert_eq!(_result.children()[0].kind(), HirKind::Literal);",
          "    assert_eq!(_result.children()[0].to_string(), \"test\");",
          "    assert_eq!(_result.children()[1].kind(), HirKind::Literal);",
          "    assert_eq!(_result.children()[1].to_string(), \"no_capture\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(flatten(&Hir::alternation(vec![])), Hir::alternation(vec![]));"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![]);",
          "    let _result = flatten(&hir);",
          "    assert_eq!(flatten(&Hir::alternation(vec![])), Hir::alternation(vec![]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![Hir::literal(\"single\".into())]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::alternation(vec![Hir::literal(\"single\".into())]);",
          "    assert_eq!(_result.kind(), HirKind::Alternation);",
          "    assert_eq!(_result.len(), 1);",
          "    assert_eq!(_result[0].kind(), HirKind::Literal);",
          "    assert_eq!(_result[0].as_literal().unwrap().to_string(), \"single\");"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![Hir::literal(\"single\".into())]);",
          "    let _result = flatten(&hir);",
          "    let hir = Hir::alternation(vec![Hir::literal(\"single\".into())]);",
          "    assert_eq!(_result.kind(), HirKind::Alternation);",
          "    assert_eq!(_result.len(), 1);",
          "    assert_eq!(_result[0].kind(), HirKind::Literal);",
          "    assert_eq!(_result[0].as_literal().unwrap().to_string(), \"single\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]