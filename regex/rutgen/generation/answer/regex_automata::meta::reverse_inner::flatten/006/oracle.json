[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::empty();",
          "    let result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::class(literal::Literal::new(\"test\"));",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(hir.kind()));",
          "    let hir = Hir::class(literal::Literal::new(\"\"));",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(hir.kind()));",
          "    let hir = Hir::class(literal::Literal::new(\"abc123\"));",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(hir.kind()));"
        ],
        "code": [
          "{",
          "    let hir = Hir::empty();",
          "    let result = flatten(&hir);",
          "    let hir = Hir::class(literal::Literal::new(\"test\"));",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(hir.kind()));",
          "    let hir = Hir::class(literal::Literal::new(\"\"));",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(hir.kind()));",
          "    let hir = Hir::class(literal::Literal::new(\"abc123\"));",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(hir.kind()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::literal(literal::Literal::new(\"test\".to_string()));",
          "    let result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::class(vec![literal::Literal::new(\"a\".to_string())]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(vec![literal::Literal::new(\"a\".to_string())]));",
          "    let hir = Hir::class(vec![literal::Literal::new(\"b\".to_string()), literal::Literal::new(\"c\".to_string())]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(vec![literal::Literal::new(\"b\".to_string()), literal::Literal::new(\"c\".to_string())]));",
          "    let hir = Hir::class(vec![literal::Literal::new(\"x\".to_string()), literal::Literal::new(\"y\".to_string()), literal::Literal::new(\"z\".to_string())]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(vec![literal::Literal::new(\"x\".to_string()), literal::Literal::new(\"y\".to_string()), literal::Literal::new(\"z\".to_string())]));",
          "    let hir = Hir::class(vec![]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(vec![]));"
        ],
        "code": [
          "{",
          "    let hir = Hir::literal(literal::Literal::new(\"test\".to_string()));",
          "    let result = flatten(&hir);",
          "    let hir = Hir::class(vec![literal::Literal::new(\"a\".to_string())]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(vec![literal::Literal::new(\"a\".to_string())]));",
          "    let hir = Hir::class(vec![literal::Literal::new(\"b\".to_string()), literal::Literal::new(\"c\".to_string())]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(vec![literal::Literal::new(\"b\".to_string()), literal::Literal::new(\"c\".to_string())]));",
          "    let hir = Hir::class(vec![literal::Literal::new(\"x\".to_string()), literal::Literal::new(\"y\".to_string()), literal::Literal::new(\"z\".to_string())]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(vec![literal::Literal::new(\"x\".to_string()), literal::Literal::new(\"y\".to_string()), literal::Literal::new(\"z\".to_string())]));",
          "    let hir = Hir::class(vec![]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(vec![]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = hir::Class::new(vec!['a', 'b', 'c']);",
          "    let hir = Hir::class(class);",
          "    let result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.kind(), HirKind::Class(hir::Class::new(vec!['a', 'b', 'c'])));"
        ],
        "code": [
          "{",
          "    let class = hir::Class::new(vec!['a', 'b', 'c']);",
          "    let hir = Hir::class(class);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Class(hir::Class::new(vec!['a', 'b', 'c'])));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = hir::Look::new(hir::LookKind::LookBehind, Box::new(Hir::literal(literal::Literal::new(\"test\".to_string()))));",
          "    let hir = Hir::look(look);",
          "    let result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.kind(), HirKind::Look);",
          "    assert!(if let HirKind::Look(ref look) = result.kind() { look.kind() == hir::LookKind::LookBehind } else { false });",
          "    assert_eq!(result, hir);"
        ],
        "code": [
          "{",
          "    let look = hir::Look::new(hir::LookKind::LookBehind, Box::new(Hir::literal(literal::Literal::new(\"test\".to_string()))));",
          "    let hir = Hir::look(look);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Look);",
          "    assert!(if let HirKind::Look(ref look) = result.kind() { look.kind() == hir::LookKind::LookBehind } else { false });",
          "    assert_eq!(result, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let repetition = hir::Repetition::new(Box::new(Hir::literal(literal::Literal::new(\"test\".to_string()))), 1..=2);",
          "    let hir = Hir::repetition(repetition);",
          "    let result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    let repetition = hir::Repetition::new(Box::new(Hir::literal(literal::Literal::new(\"test\".to_string()))), 1..=2);",
          "    assert_eq!(result.kind(), HirKind::Repetition);",
          "    assert_eq!(result.sub.kinds().len(), 1);",
          "    assert_eq!(result.sub.kinds()[0], HirKind::Literal(literal::Literal::new(\"test\".to_string())));",
          "    assert_ne!(result.kind(), HirKind::Capture);"
        ],
        "code": [
          "{",
          "    let repetition = hir::Repetition::new(Box::new(Hir::literal(literal::Literal::new(\"test\".to_string()))), 1..=2);",
          "    let hir = Hir::repetition(repetition);",
          "    let result = flatten(&hir);",
          "    let repetition = hir::Repetition::new(Box::new(Hir::literal(literal::Literal::new(\"test\".to_string()))), 1..=2);",
          "    assert_eq!(result.kind(), HirKind::Repetition);",
          "    assert_eq!(result.sub.kinds().len(), 1);",
          "    assert_eq!(result.sub.kinds()[0], HirKind::Literal(literal::Literal::new(\"test\".to_string())));",
          "    assert_ne!(result.kind(), HirKind::Capture);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capture = hir::Capture {",
          "        id: 0,",
          "        sub: Box::new(Hir::literal(literal::Literal::new(\"test\".to_string()))),",
          "    };",
          "    let hir = Hir::capture(capture);",
          "    let result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.kind(), HirKind::Literal(hir::Literal(literal::Literal::new(\"test\".to_string()))));",
          "    assert!(matches!(result.kind(), HirKind::Literal(_)));",
          "    assert!(matches!(hir.kind(), HirKind::Capture(_)));",
          "    assert!(matches!(result.kind(), HirKind::Capture(_)) == false);",
          "    assert_eq!(result, Hir::literal(literal::Literal::new(\"test\".to_string())));"
        ],
        "code": [
          "{",
          "    let capture = hir::Capture {",
          "        id: 0,",
          "        sub: Box::new(Hir::literal(literal::Literal::new(\"test\".to_string()))),",
          "    };",
          "    let hir = Hir::capture(capture);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Literal(hir::Literal(literal::Literal::new(\"test\".to_string()))));",
          "    assert!(matches!(result.kind(), HirKind::Literal(_)));",
          "    assert!(matches!(hir.kind(), HirKind::Capture(_)));",
          "    assert!(matches!(result.kind(), HirKind::Capture(_)) == false);",
          "    assert_eq!(result, Hir::literal(literal::Literal::new(\"test\".to_string())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alt1 = Hir::literal(literal::Literal::new(\"a\".to_string()));",
          "    let alt2 = Hir::literal(literal::Literal::new(\"b\".to_string()));",
          "    let hir = Hir::alternation(vec![alt1, alt2]);",
          "    let result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    let expected1 = Hir::class(/* expected variant for class 1 */);",
          "    let expected2 = Hir::class(/* expected variant for class 2 */);",
          "    let expected_result = Hir::alternation(vec![expected1, expected2]);",
          "    assert_eq!(result, expected_result);"
        ],
        "code": [
          "{",
          "    let alt1 = Hir::literal(literal::Literal::new(\"a\".to_string()));",
          "    let alt2 = Hir::literal(literal::Literal::new(\"b\".to_string()));",
          "    let hir = Hir::alternation(vec![alt1, alt2]);",
          "    let result = flatten(&hir);",
          "    let expected1 = Hir::class(/* expected variant for class 1 */);",
          "    let expected2 = Hir::class(/* expected variant for class 2 */);",
          "    let expected_result = Hir::alternation(vec![expected1, expected2]);",
          "    assert_eq!(result, expected_result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let concat1 = Hir::literal(literal::Literal::new(\"a\".to_string()));",
          "    let concat2 = Hir::literal(literal::Literal::new(\"b\".to_string()));",
          "    let hir = Hir::concat(vec![concat1, concat2]);",
          "    let result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    let concat1 = Hir::literal(literal::Literal::new(\"a\".to_string()));",
          "    let concat2 = Hir::literal(literal::Literal::new(\"b\".to_string()));",
          "    let hir = Hir::concat(vec![concat1.clone(), concat2.clone()]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Concat(vec![concat1, concat2]));",
          "    assert!(matches!(result, Hir::Concat(_)));"
        ],
        "code": [
          "{",
          "    let concat1 = Hir::literal(literal::Literal::new(\"a\".to_string()));",
          "    let concat2 = Hir::literal(literal::Literal::new(\"b\".to_string()));",
          "    let hir = Hir::concat(vec![concat1, concat2]);",
          "    let result = flatten(&hir);",
          "    let concat1 = Hir::literal(literal::Literal::new(\"a\".to_string()));",
          "    let concat2 = Hir::literal(literal::Literal::new(\"b\".to_string()));",
          "    let hir = Hir::concat(vec![concat1.clone(), concat2.clone()]);",
          "    let result = flatten(&hir);",
          "    assert_eq!(result.kind(), HirKind::Concat(vec![concat1, concat2]));",
          "    assert!(matches!(result, Hir::Concat(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]