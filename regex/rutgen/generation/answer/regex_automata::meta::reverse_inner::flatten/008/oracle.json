[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::empty();",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.kind(), HirKind::Empty);"
        ],
        "code": [
          "{",
          "    let hir = Hir::empty();",
          "    let _result = flatten(&hir);",
          "    assert_eq!(_result.kind(), HirKind::Empty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::literal(literal::Literal::new('a'));",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    Hir::empty().kind() == HirKind::Empty",
          "    Hir::literal(literal::Literal::new('a')).kind() == HirKind::Literal(hir::Literal('a'))",
          "    flatten(&Hir::literal(literal::Literal::new('a'))) == Hir::literal(literal::Literal::new('a'))"
        ],
        "code": [
          "{",
          "    let hir = Hir::literal(literal::Literal::new('a'));",
          "    let _result = flatten(&hir);",
          "    Hir::empty().kind() == HirKind::Empty",
          "    Hir::literal(literal::Literal::new('a')).kind() == HirKind::Literal(hir::Literal('a'))",
          "    flatten(&Hir::literal(literal::Literal::new('a'))) == Hir::literal(literal::Literal::new('a'))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::class(regex_syntax::ast::Class::new(vec!['a', 'b', 'c'], false));",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    Hir::empty()",
          "    Hir::literal(hir::Literal::new(\"a\"))",
          "    Hir::literal(hir::Literal::new(\"b\"))",
          "    Hir::literal(hir::Literal::new(\"c\"))",
          "    Hir::class(regex_syntax::ast::Class::new(vec!['a', 'b', 'c'], false))",
          "    Hir::alternation(vec![Hir::literal(hir::Literal::new(\"a\")), Hir::literal(hir::Literal::new(\"b\")), Hir::literal(hir::Literal::new(\"c\"))])",
          "    Hir::concat(vec![Hir::literal(hir::Literal::new(\"a\")), Hir::literal(hir::Literal::new(\"b\")), Hir::literal(hir::Literal::new(\"c\"))])",
          "    Hir::repetition(Hir::class(regex_syntax::ast::Class::new(vec!['a', 'b', 'c'], true)))",
          "    Hir::look(Hir::literal(hir::Literal::new(\"a\")))",
          "    Hir::look(Hir::literal(hir::Literal::new(\"b\")))",
          "    Hir::look(Hir::literal(hir::Literal::new(\"c\")))",
          "    Hir::capture(flatten(&Hir::literal(hir::Literal::new(\"a\"))))",
          "    Hir::capture(flatten(&Hir::literal(hir::Literal::new(\"b\"))))",
          "    Hir::capture(flatten(&Hir::literal(hir::Literal::new(\"c\"))))"
        ],
        "code": [
          "{",
          "    let hir = Hir::class(regex_syntax::ast::Class::new(vec!['a', 'b', 'c'], false));",
          "    let _result = flatten(&hir);",
          "    Hir::empty()",
          "    Hir::literal(hir::Literal::new(\"a\"))",
          "    Hir::literal(hir::Literal::new(\"b\"))",
          "    Hir::literal(hir::Literal::new(\"c\"))",
          "    Hir::class(regex_syntax::ast::Class::new(vec!['a', 'b', 'c'], false))",
          "    Hir::alternation(vec![Hir::literal(hir::Literal::new(\"a\")), Hir::literal(hir::Literal::new(\"b\")), Hir::literal(hir::Literal::new(\"c\"))])",
          "    Hir::concat(vec![Hir::literal(hir::Literal::new(\"a\")), Hir::literal(hir::Literal::new(\"b\")), Hir::literal(hir::Literal::new(\"c\"))])",
          "    Hir::repetition(Hir::class(regex_syntax::ast::Class::new(vec!['a', 'b', 'c'], true)))",
          "    Hir::look(Hir::literal(hir::Literal::new(\"a\")))",
          "    Hir::look(Hir::literal(hir::Literal::new(\"b\")))",
          "    Hir::look(Hir::literal(hir::Literal::new(\"c\")))",
          "    Hir::capture(flatten(&Hir::literal(hir::Literal::new(\"a\"))))",
          "    Hir::capture(flatten(&Hir::literal(hir::Literal::new(\"b\"))))",
          "    Hir::capture(flatten(&Hir::literal(hir::Literal::new(\"c\"))))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::look(Hir::literal(literal::Literal::new('a')));",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    Hir::empty() == flatten(&Hir::empty())",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::look(Hir::literal(literal::Literal::new('a'))))",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::capture(Hir::literal(literal::Literal::new('a'))))",
          "    Hir::class(vec!['a']) == flatten(&Hir::class(vec!['a']));",
          "    Hir::look(Hir::literal(literal::Literal::new('a'))) == flatten(&Hir::look(Hir::literal(literal::Literal::new('a'))));",
          "    Hir::alternation(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]) == flatten(&Hir::alternation(vec![Hir::literal(literal::Literal::new('a')), Hir::capture(Hir::literal(literal::Literal::new('b')))]));",
          "    Hir::concat(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]) == flatten(&Hir::concat(vec![Hir::capture(Hir::literal(literal::Literal::new('a'))), Hir::literal(literal::Literal::new('b'))]));"
        ],
        "code": [
          "{",
          "    let hir = Hir::look(Hir::literal(literal::Literal::new('a')));",
          "    let _result = flatten(&hir);",
          "    Hir::empty() == flatten(&Hir::empty())",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::look(Hir::literal(literal::Literal::new('a'))))",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::capture(Hir::literal(literal::Literal::new('a'))))",
          "    Hir::class(vec!['a']) == flatten(&Hir::class(vec!['a']));",
          "    Hir::look(Hir::literal(literal::Literal::new('a'))) == flatten(&Hir::look(Hir::literal(literal::Literal::new('a'))));",
          "    Hir::alternation(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]) == flatten(&Hir::alternation(vec![Hir::literal(literal::Literal::new('a')), Hir::capture(Hir::literal(literal::Literal::new('b')))]));",
          "    Hir::concat(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]) == flatten(&Hir::concat(vec![Hir::capture(Hir::literal(literal::Literal::new('a'))), Hir::literal(literal::Literal::new('b'))]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir::literal(literal::Literal::new('a'));",
          "    let hir = Hir::repetition(hir::Repetition::new(sub_hir, 0..1));",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    Hir::empty() == flatten(&Hir::empty())",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::literal(literal::Literal::new('a')))",
          "    Hir::class(class::Class::new(vec![])) == flatten(&Hir::class(class::Class::new(vec![])))",
          "    Hir::look(HirKind::Look(x)) == flatten(&Hir::look(x))",
          "    Hir::repetition(Hir::repetition(hir::Repetition::new(sub_hir, 0..1))) == flatten(&Hir::repetition(hir::Repetition::new(sub_hir, 0..1)))",
          "    Hir::alternation(vec![Hir::literal(literal::Literal::new('a'))]) == flatten(&Hir::alternation(vec![Hir::literal(literal::Literal::new('a'))]))",
          "    Hir::concat(vec![Hir::literal(literal::Literal::new('a'))]) == flatten(&Hir::concat(vec![Hir::literal(literal::Literal::new('a'))]))"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir::literal(literal::Literal::new('a'));",
          "    let hir = Hir::repetition(hir::Repetition::new(sub_hir, 0..1));",
          "    let _result = flatten(&hir);",
          "    Hir::empty() == flatten(&Hir::empty())",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::literal(literal::Literal::new('a')))",
          "    Hir::class(class::Class::new(vec![])) == flatten(&Hir::class(class::Class::new(vec![])))",
          "    Hir::look(HirKind::Look(x)) == flatten(&Hir::look(x))",
          "    Hir::repetition(Hir::repetition(hir::Repetition::new(sub_hir, 0..1))) == flatten(&Hir::repetition(hir::Repetition::new(sub_hir, 0..1)))",
          "    Hir::alternation(vec![Hir::literal(literal::Literal::new('a'))]) == flatten(&Hir::alternation(vec![Hir::literal(literal::Literal::new('a'))]))",
          "    Hir::concat(vec![Hir::literal(literal::Literal::new('a'))]) == flatten(&Hir::concat(vec![Hir::literal(literal::Literal::new('a'))]))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir::literal(literal::Literal::new('a'));",
          "    let hir = Hir::capture(hir::Capture::new(sub_hir));",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    Hir::empty()",
          "    Hir::literal(literal::Literal::new('a'))",
          "    Hir::capture(hir::Capture::new(Hir::literal(literal::Literal::new('a'))))",
          "    flatten(&Hir::capture(hir::Capture::new(Hir::literal(literal::Literal::new('a')))))"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir::literal(literal::Literal::new('a'));",
          "    let hir = Hir::capture(hir::Capture::new(sub_hir));",
          "    let _result = flatten(&hir);",
          "    Hir::empty()",
          "    Hir::literal(literal::Literal::new('a'))",
          "    Hir::capture(hir::Capture::new(Hir::literal(literal::Literal::new('a'))))",
          "    flatten(&Hir::capture(hir::Capture::new(Hir::literal(literal::Literal::new('a')))))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir1 = Hir::literal(literal::Literal::new('a'));",
          "    let hir2 = Hir::literal(literal::Literal::new('b'));",
          "    let hir = Hir::alternation(vec![hir1, hir2]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    Hir::empty() == flatten(&Hir::empty())",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::literal(literal::Literal::new('a')))",
          "    Hir::class(vec![]) == flatten(&Hir::class(vec![]))",
          "    Hir::look(Hir::literal(literal::Literal::new('a'))) == flatten(&Hir::look(Hir::literal(literal::Literal::new('a'))))",
          "    Hir::repetition(Hir::literal(literal::Literal::new('a'))) == flatten(&Hir::repetition(Hir::literal(literal::Literal::new('a'))))",
          "    Hir::alternation(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]) == flatten(&Hir::alternation(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]))",
          "    Hir::concat(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]) == flatten(&Hir::concat(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]))"
        ],
        "code": [
          "{",
          "    let hir1 = Hir::literal(literal::Literal::new('a'));",
          "    let hir2 = Hir::literal(literal::Literal::new('b'));",
          "    let hir = Hir::alternation(vec![hir1, hir2]);",
          "    let _result = flatten(&hir);",
          "    Hir::empty() == flatten(&Hir::empty())",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::literal(literal::Literal::new('a')))",
          "    Hir::class(vec![]) == flatten(&Hir::class(vec![]))",
          "    Hir::look(Hir::literal(literal::Literal::new('a'))) == flatten(&Hir::look(Hir::literal(literal::Literal::new('a'))))",
          "    Hir::repetition(Hir::literal(literal::Literal::new('a'))) == flatten(&Hir::repetition(Hir::literal(literal::Literal::new('a'))))",
          "    Hir::alternation(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]) == flatten(&Hir::alternation(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]))",
          "    Hir::concat(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]) == flatten(&Hir::concat(vec![Hir::literal(literal::Literal::new('a')), Hir::literal(literal::Literal::new('b'))]))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir1 = Hir::literal(literal::Literal::new('a'));",
          "    let hir2 = Hir::literal(literal::Literal::new('b'));",
          "    let hir = Hir::concat(vec![hir1, hir2]);",
          "    let _result = flatten(&hir);",
          "}"
        ],
        "oracle": [
          "    Hir::empty() == flatten(&Hir::empty())",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::literal(literal::Literal::new('a')))",
          "    Hir::literal(literal::Literal::new('b')) == flatten(&Hir::literal(literal::Literal::new('b')))",
          "    Hir::class(class::Class::new()) == flatten(&Hir::class(class::Class::new()))",
          "    Hir::look(look::Look::new()) == flatten(&Hir::look(look::Look::new()))",
          "    Hir::repetition(repetition::Repetition::new(flatten(&Hir::literal(literal::Literal::new('c'))))) == flatten(&Hir::repetition(repetition::Repetition::new(Hir::literal(literal::Literal::new('c')))))",
          "    flatten(&Hir::capture(capture::Capture::new(flatten(&Hir::literal(literal::Literal::new('d')))))) == flatten(&Hir::literal(literal::Literal::new('d')))",
          "    Hir::alternation(vec![Hir::literal(literal::Literal::new('e')), Hir::literal(literal::Literal::new('f'))]) == flatten(&Hir::alternation(vec![Hir::literal(literal::Literal::new('e')), Hir::literal(literal::Literal::new('f'))]))",
          "    Hir::concat(vec![Hir::literal(literal::Literal::new('g')), Hir::literal(literal::Literal::new('h'))]) == flatten(&Hir::concat(vec![Hir::literal(literal::Literal::new('g')), Hir::literal(literal::Literal::new('h'))]))"
        ],
        "code": [
          "{",
          "    let hir1 = Hir::literal(literal::Literal::new('a'));",
          "    let hir2 = Hir::literal(literal::Literal::new('b'));",
          "    let hir = Hir::concat(vec![hir1, hir2]);",
          "    let _result = flatten(&hir);",
          "    Hir::empty() == flatten(&Hir::empty())",
          "    Hir::literal(literal::Literal::new('a')) == flatten(&Hir::literal(literal::Literal::new('a')))",
          "    Hir::literal(literal::Literal::new('b')) == flatten(&Hir::literal(literal::Literal::new('b')))",
          "    Hir::class(class::Class::new()) == flatten(&Hir::class(class::Class::new()))",
          "    Hir::look(look::Look::new()) == flatten(&Hir::look(look::Look::new()))",
          "    Hir::repetition(repetition::Repetition::new(flatten(&Hir::literal(literal::Literal::new('c'))))) == flatten(&Hir::repetition(repetition::Repetition::new(Hir::literal(literal::Literal::new('c')))))",
          "    flatten(&Hir::capture(capture::Capture::new(flatten(&Hir::literal(literal::Literal::new('d')))))) == flatten(&Hir::literal(literal::Literal::new('d')))",
          "    Hir::alternation(vec![Hir::literal(literal::Literal::new('e')), Hir::literal(literal::Literal::new('f'))]) == flatten(&Hir::alternation(vec![Hir::literal(literal::Literal::new('e')), Hir::literal(literal::Literal::new('f'))]))",
          "    Hir::concat(vec![Hir::literal(literal::Literal::new('g')), Hir::literal(literal::Literal::new('h'))]) == flatten(&Hir::concat(vec![Hir::literal(literal::Literal::new('g')), Hir::literal(literal::Literal::new('h'))]))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]