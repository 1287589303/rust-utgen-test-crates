[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "        ",
          "        fn write_char(&mut self, c: char) -> fmt::Result {",
          "            self.output.push(c);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x7F;",
          "    // The call to the function under test",
          "    let _ = writer.write_literal_byte(b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x7F)\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "        ",
          "        fn write_char(&mut self, c: char) -> fmt::Result {",
          "            self.output.push(c);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x7F;",
          "    // The call to the function under test",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x7F)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "",
          "        fn write_char(&mut self, c: char) -> fmt::Result {",
          "            self.output.push(c);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x20;",
          "    // The call to the function under test",
          "    let _ = writer.write_literal_byte(b);",
          "}"
        ],
        "oracle": [
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x7F; // Testing edge case: b == 0x7F",
          "    let result = writer.write_literal_byte(b);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x7F)\"); // Expect it to be formatted as a hex escape sequence",
          "    ",
          "    let b: u8 = 0x20; // Testing a regular ASCII character",
          "    let result = writer.write_literal_byte(b);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer.wtr.output, \" \"); // Expect it to be written as a literal space character",
          "    ",
          "    let b: u8 = 0x01; // Testing an ASCII control character (should engage the else branch)",
          "    let result = writer.write_literal_byte(b);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x01)\"); // Expect it to be formatted as a hex escape sequence",
          "    ",
          "    let b: u8 = 0x0A; // Testing a newline character (ASCII control)",
          "    let result = writer.write_literal_byte(b);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x0A)\"); // Expect it to be formatted as a hex escape sequence"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "",
          "        fn write_char(&mut self, c: char) -> fmt::Result {",
          "            self.output.push(c);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x20;",
          "    // The call to the function under test",
          "    let _ = writer.write_literal_byte(b);",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x7F; // Testing edge case: b == 0x7F",
          "    let result = writer.write_literal_byte(b);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x7F)\"); // Expect it to be formatted as a hex escape sequence",
          "    ",
          "    let b: u8 = 0x20; // Testing a regular ASCII character",
          "    let result = writer.write_literal_byte(b);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer.wtr.output, \" \"); // Expect it to be written as a literal space character",
          "    ",
          "    let b: u8 = 0x01; // Testing an ASCII control character (should engage the else branch)",
          "    let result = writer.write_literal_byte(b);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x01)\"); // Expect it to be formatted as a hex escape sequence",
          "    ",
          "    let b: u8 = 0x0A; // Testing a newline character (ASCII control)",
          "    let result = writer.write_literal_byte(b);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x0A)\"); // Expect it to be formatted as a hex escape sequence",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "",
          "        fn write_char(&mut self, c: char) -> fmt::Result {",
          "            self.output.push(c);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x2F; // ASCII '/'",
          "    // The call to the function under test",
          "    let _ = writer.write_literal_byte(b);",
          "}"
        ],
        "oracle": [
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x7F;",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x7F)\");",
          "    writer.wtr.output.clear();",
          "    let b: u8 = 0x2F;",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"/\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "",
          "        fn write_char(&mut self, c: char) -> fmt::Result {",
          "            self.output.push(c);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x2F; // ASCII '/'",
          "    // The call to the function under test",
          "    let _ = writer.write_literal_byte(b);",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x7F;",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x7F)\");",
          "    writer.wtr.output.clear();",
          "    let b: u8 = 0x2F;",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"/\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "",
          "        fn write_char(&mut self, c: char) -> fmt::Result {",
          "            self.output.push(c);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x3A; // ASCII ':'",
          "    // The call to the function under test",
          "    let _ = writer.write_literal_byte(b);",
          "}"
        ],
        "oracle": [
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x7F; // Boundary value at the edge of the precondition limit",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x7F)\"); // Expected output for non-ASCII control/whitespace byte",
          "    writer.wtr.output.clear(); // Clear output before next test",
          "    ",
          "    let b: u8 = 0x21; // Non-control, non-whitespace ASCII character '!'",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"!\"); // Expected output for valid ASCII character",
          "    ",
          "    writer.wtr.output.clear(); // Clear output before next test",
          "    ",
          "    let b: u8 = 0x0A; // ASCII control character (newline)",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x0A)\"); // Expected output for ASCII control character",
          "    ",
          "    writer.wtr.output.clear(); // Clear output before next test",
          "    ",
          "    let b: u8 = 0x20; // ASCII whitespace character (space)",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x20)\"); // Expected output for ASCII whitespace character"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "",
          "        fn write_char(&mut self, c: char) -> fmt::Result {",
          "            self.output.push(c);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x3A; // ASCII ':'",
          "    // The call to the function under test",
          "    let _ = writer.write_literal_byte(b);",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let b: u8 = 0x7F; // Boundary value at the edge of the precondition limit",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x7F)\"); // Expected output for non-ASCII control/whitespace byte",
          "    writer.wtr.output.clear(); // Clear output before next test",
          "    ",
          "    let b: u8 = 0x21; // Non-control, non-whitespace ASCII character '!'",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"!\"); // Expected output for valid ASCII character",
          "    ",
          "    writer.wtr.output.clear(); // Clear output before next test",
          "    ",
          "    let b: u8 = 0x0A; // ASCII control character (newline)",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x0A)\"); // Expected output for ASCII control character",
          "    ",
          "    writer.wtr.output.clear(); // Clear output before next test",
          "    ",
          "    let b: u8 = 0x20; // ASCII whitespace character (space)",
          "    let _ = writer.write_literal_byte(b);",
          "    assert_eq!(writer.wtr.output, \"(?-u:\\\\x20)\"); // Expected output for ASCII whitespace character",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]