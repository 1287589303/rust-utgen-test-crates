[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyNFA;",
          "    impl DummyNFA {",
          "        fn new() -> Self {",
          "            DummyNFA",
          "        }",
          "    }",
          "",
          "    let nfa = DummyNFA::new();",
          "    let classes = ByteClasses([0; 256]);",
          "    let dfa = DFA {",
          "        config: Config {},",
          "        nfa: nfa.clone(),",
          "        stride2: 9,",
          "        start_map: StartByteMap {},",
          "        classes,",
          "        quitset: ByteSet {},",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut builder = InternalBuilder {",
          "        dfa,",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 256],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config: Config::default(),",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    let dfa_id = StateID::new_unchecked(0);",
          "    let trans = thompson::Transition {",
          "        start: 0,",
          "        end: 0,",
          "        next: StateID::new_unchecked(1),",
          "    };",
          "    let epsilons = Epsilons(0);",
          "",
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(1)).unwrap();",
          "",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "}"
        ],
        "oracle": [
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(1)).unwrap();",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "    assert_eq!(result, Ok(()));",
          "    builder.classes = ByteClasses([0; 256]);",
          "    let trans = thompson::Transition { start: 1, end: 1, next: StateID::new_unchecked(1) };",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "    assert_eq!(result, Ok(()));"
        ],
        "code": [
          "{",
          "    struct DummyNFA;",
          "    impl DummyNFA {",
          "        fn new() -> Self {",
          "            DummyNFA",
          "        }",
          "    }",
          "",
          "    let nfa = DummyNFA::new();",
          "    let classes = ByteClasses([0; 256]);",
          "    let dfa = DFA {",
          "        config: Config {},",
          "        nfa: nfa.clone(),",
          "        stride2: 9,",
          "        start_map: StartByteMap {},",
          "        classes,",
          "        quitset: ByteSet {},",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut builder = InternalBuilder {",
          "        dfa,",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 256],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config: Config::default(),",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    let dfa_id = StateID::new_unchecked(0);",
          "    let trans = thompson::Transition {",
          "        start: 0,",
          "        end: 0,",
          "        next: StateID::new_unchecked(1),",
          "    };",
          "    let epsilons = Epsilons(0);",
          "",
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(1)).unwrap();",
          "",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(1)).unwrap();",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "    assert_eq!(result, Ok(()));",
          "    builder.classes = ByteClasses([0; 256]);",
          "    let trans = thompson::Transition { start: 1, end: 1, next: StateID::new_unchecked(1) };",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "    assert_eq!(result, Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyNFA;",
          "    impl DummyNFA {",
          "        fn new() -> Self {",
          "            DummyNFA",
          "        }",
          "    }",
          "",
          "    let nfa = DummyNFA::new();",
          "    let classes = ByteClasses([0; 256]);",
          "    let dfa = DFA {",
          "        config: Config {},",
          "        nfa: nfa.clone(),",
          "        stride2: 9,",
          "        start_map: StartByteMap {},",
          "        classes,",
          "        quitset: ByteSet {},",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut builder = InternalBuilder {",
          "        dfa,",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 256],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config: Config::default(),",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    let dfa_id = StateID::new_unchecked(0);",
          "    let trans = thompson::Transition {",
          "        start: 1,",
          "        end: 1,",
          "        next: StateID::new_unchecked(2),",
          "    };",
          "    let epsilons = Epsilons(0);",
          "",
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(2)).unwrap();",
          "",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "}"
        ],
        "oracle": [
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(2)).unwrap();",
          "    let trans = thompson::Transition {",
          "    start: 1,",
          "    end: 1,",
          "    next: StateID::new_unchecked(2),",
          "    };",
          "    let byte_range_empty = !builder.classes.representatives(trans.start..=trans.end).filter_map(|r| r.as_u8()).any();",
          "    assert_eq!(result, Ok(()));"
        ],
        "code": [
          "{",
          "    struct DummyNFA;",
          "    impl DummyNFA {",
          "        fn new() -> Self {",
          "            DummyNFA",
          "        }",
          "    }",
          "",
          "    let nfa = DummyNFA::new();",
          "    let classes = ByteClasses([0; 256]);",
          "    let dfa = DFA {",
          "        config: Config {},",
          "        nfa: nfa.clone(),",
          "        stride2: 9,",
          "        start_map: StartByteMap {},",
          "        classes,",
          "        quitset: ByteSet {},",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut builder = InternalBuilder {",
          "        dfa,",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 256],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config: Config::default(),",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    let dfa_id = StateID::new_unchecked(0);",
          "    let trans = thompson::Transition {",
          "        start: 1,",
          "        end: 1,",
          "        next: StateID::new_unchecked(2),",
          "    };",
          "    let epsilons = Epsilons(0);",
          "",
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(2)).unwrap();",
          "",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(2)).unwrap();",
          "    let trans = thompson::Transition {",
          "    start: 1,",
          "    end: 1,",
          "    next: StateID::new_unchecked(2),",
          "    };",
          "    let byte_range_empty = !builder.classes.representatives(trans.start..=trans.end).filter_map(|r| r.as_u8()).any();",
          "    assert_eq!(result, Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyNFA;",
          "    impl DummyNFA {",
          "        fn new() -> Self {",
          "            DummyNFA",
          "        }",
          "    }",
          "",
          "    let nfa = DummyNFA::new();",
          "    let classes = ByteClasses([0; 256]);",
          "    let dfa = DFA {",
          "        config: Config {},",
          "        nfa: nfa.clone(),",
          "        stride2: 9,",
          "        start_map: StartByteMap {},",
          "        classes,",
          "        quitset: ByteSet {},",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut builder = InternalBuilder {",
          "        dfa,",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 256],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config: Config::default(),",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    let dfa_id = StateID::new_unchecked(2);",
          "    let trans = thompson::Transition {",
          "        start: 0,",
          "        end: 255,",
          "        next: StateID::new_unchecked(3),",
          "    };",
          "    let epsilons = Epsilons(1);",
          "",
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(3)).unwrap();",
          "",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(()));",
          "    assert!(builder.dfa.transition(dfa_id, 0).state_id() != DEAD);",
          "    assert!(builder.dfa.transition(dfa_id, 255).state_id() != DEAD);",
          "    assert!(builder.nfa_to_dfa_id[StateID::new_unchecked(3)] != DEAD);"
        ],
        "code": [
          "{",
          "    struct DummyNFA;",
          "    impl DummyNFA {",
          "        fn new() -> Self {",
          "            DummyNFA",
          "        }",
          "    }",
          "",
          "    let nfa = DummyNFA::new();",
          "    let classes = ByteClasses([0; 256]);",
          "    let dfa = DFA {",
          "        config: Config {},",
          "        nfa: nfa.clone(),",
          "        stride2: 9,",
          "        start_map: StartByteMap {},",
          "        classes,",
          "        quitset: ByteSet {},",
          "        cache_capacity: 0,",
          "    };",
          "",
          "    let mut builder = InternalBuilder {",
          "        dfa,",
          "        uncompiled_nfa_ids: vec![],",
          "        nfa_to_dfa_id: vec![DEAD; 256],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config: Config::default(),",
          "        nfa: &nfa,",
          "        classes: ByteClasses([0; 256]),",
          "    };",
          "",
          "    let dfa_id = StateID::new_unchecked(2);",
          "    let trans = thompson::Transition {",
          "        start: 0,",
          "        end: 255,",
          "        next: StateID::new_unchecked(3),",
          "    };",
          "    let epsilons = Epsilons(1);",
          "",
          "    builder.add_dfa_state_for_nfa_state(StateID::new_unchecked(3)).unwrap();",
          "",
          "    let result = builder.compile_transition(dfa_id, &trans, epsilons);",
          "    assert_eq!(result, Ok(()));",
          "    assert!(builder.dfa.transition(dfa_id, 0).state_id() != DEAD);",
          "    assert!(builder.dfa.transition(dfa_id, 255).state_id() != DEAD);",
          "    assert!(builder.nfa_to_dfa_id[StateID::new_unchecked(3)] != DEAD);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]