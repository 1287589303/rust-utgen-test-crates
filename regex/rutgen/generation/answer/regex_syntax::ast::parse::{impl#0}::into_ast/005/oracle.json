[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 5 };",
          "    let lit = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
          "    let primitive = Primitive::Literal(lit);",
          "    let _ast = primitive.into_ast();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: 0, end: 5 };",
          "    let lit = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
          "    let primitive = Primitive::Literal(lit);",
          "    let expected_ast = Ast::literal(lit);",
          "    assert_eq!(_ast, expected_ast);"
        ],
        "code": [
          "{",
          "    let span = Span { start: 0, end: 5 };",
          "    let lit = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
          "    let primitive = Primitive::Literal(lit);",
          "    let _ast = primitive.into_ast();",
          "    let span = Span { start: 0, end: 5 };",
          "    let lit = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
          "    let primitive = Primitive::Literal(lit);",
          "    let expected_ast = Ast::literal(lit);",
          "    assert_eq!(_ast, expected_ast);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 1 };",
          "    let assertion = Assertion { span: span.clone(), kind: AssertionKind::WordBoundary };",
          "    let primitive = Primitive::Assertion(assertion);",
          "    let _ast = primitive.into_ast();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: 0, end: 1 };",
          "    let assertion = Assertion { span: span.clone(), kind: AssertionKind::WordBoundary };",
          "    let primitive = Primitive::Assertion(assertion);",
          "    let ast = primitive.into_ast();",
          "    assert_eq!(ast, Ast::Assertion(Box::new(assertion)));"
        ],
        "code": [
          "{",
          "    let span = Span { start: 0, end: 1 };",
          "    let assertion = Assertion { span: span.clone(), kind: AssertionKind::WordBoundary };",
          "    let primitive = Primitive::Assertion(assertion);",
          "    let _ast = primitive.into_ast();",
          "    let span = Span { start: 0, end: 1 };",
          "    let assertion = Assertion { span: span.clone(), kind: AssertionKind::WordBoundary };",
          "    let primitive = Primitive::Assertion(assertion);",
          "    let ast = primitive.into_ast();",
          "    assert_eq!(ast, Ast::Assertion(Box::new(assertion)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 1 };",
          "    let primitive = Primitive::Dot(span);",
          "    let _ast = primitive.into_ast();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_ast, Ast::dot(Box::new(span)));"
        ],
        "code": [
          "{",
          "    let span = Span { start: 0, end: 1 };",
          "    let primitive = Primitive::Dot(span);",
          "    let _ast = primitive.into_ast();",
          "    assert_eq!(_ast, Ast::dot(Box::new(span)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 2 };",
          "    let perl_class = ClassPerl { span: span.clone(), kind: ClassPerlKind::Digit, negated: false };",
          "    let primitive = Primitive::Perl(perl_class);",
          "    let _ast = primitive.into_ast();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_ast, Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 2 }, kind: ClassPerlKind::Digit, negated: false })));"
        ],
        "code": [
          "{",
          "    let span = Span { start: 0, end: 2 };",
          "    let perl_class = ClassPerl { span: span.clone(), kind: ClassPerlKind::Digit, negated: false };",
          "    let primitive = Primitive::Perl(perl_class);",
          "    let _ast = primitive.into_ast();",
          "    assert_eq!(_ast, Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 2 }, kind: ClassPerlKind::Digit, negated: false })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 3 };",
          "    let unicode_class = ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::Letter };",
          "    let primitive = Primitive::Unicode(unicode_class);",
          "    let _ast = primitive.into_ast();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: 0, end: 3 };",
          "    let unicode_class = ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::Letter };",
          "    let primitive = Primitive::Unicode(unicode_class);",
          "    let expected_ast = Ast::class_unicode(unicode_class);",
          "    assert_eq!(_ast, expected_ast);"
        ],
        "code": [
          "{",
          "    let span = Span { start: 0, end: 3 };",
          "    let unicode_class = ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::Letter };",
          "    let primitive = Primitive::Unicode(unicode_class);",
          "    let _ast = primitive.into_ast();",
          "    let span = Span { start: 0, end: 3 };",
          "    let unicode_class = ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind::Letter };",
          "    let primitive = Primitive::Unicode(unicode_class);",
          "    let expected_ast = Ast::class_unicode(unicode_class);",
          "    assert_eq!(_ast, expected_ast);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]