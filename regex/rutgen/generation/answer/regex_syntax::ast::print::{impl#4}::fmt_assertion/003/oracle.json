[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartLine,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind == ast::AssertionKind::StartLine",
          "    writer.wtr == \"^\"",
          "    assertion.kind == ast::AssertionKind::EndLine",
          "    writer.wtr == \"$\"",
          "    assertion.kind == ast::AssertionKind::StartText",
          "    writer.wtr == r\"\\A\"",
          "    assertion.kind == ast::AssertionKind::EndText",
          "    writer.wtr == r\"\\z\"",
          "    assertion.kind == ast::AssertionKind::WordBoundary",
          "    writer.wtr == r\"\\b\"",
          "    assertion.kind == ast::AssertionKind::NotWordBoundary",
          "    writer.wtr == r\"\\B\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStart",
          "    writer.wtr == r\"\\b{start}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEnd",
          "    writer.wtr == r\"\\b{end}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartAngle",
          "    writer.wtr == r\"\\<\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr == r\"\\>\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr == r\"\\b{start-half}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndHalf",
          "    writer.wtr == r\"\\b{end-half}\""
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartLine,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assertion.kind == ast::AssertionKind::StartLine",
          "    writer.wtr == \"^\"",
          "    assertion.kind == ast::AssertionKind::EndLine",
          "    writer.wtr == \"$\"",
          "    assertion.kind == ast::AssertionKind::StartText",
          "    writer.wtr == r\"\\A\"",
          "    assertion.kind == ast::AssertionKind::EndText",
          "    writer.wtr == r\"\\z\"",
          "    assertion.kind == ast::AssertionKind::WordBoundary",
          "    writer.wtr == r\"\\b\"",
          "    assertion.kind == ast::AssertionKind::NotWordBoundary",
          "    writer.wtr == r\"\\B\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStart",
          "    writer.wtr == r\"\\b{start}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEnd",
          "    writer.wtr == r\"\\b{end}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartAngle",
          "    writer.wtr == r\"\\<\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr == r\"\\>\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr == r\"\\b{start-half}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndHalf",
          "    writer.wtr == r\"\\b{end-half}\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndLine,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind should be ast::AssertionKind::EndLine",
          "    writer.wtr should match \"$\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::StartLine",
          "    writer.wtr should match \"^\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundary",
          "    writer.wtr should match r\"\\b\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::NotWordBoundary",
          "    writer.wtr should match r\"\\B\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStart",
          "    writer.wtr should match r\"\\b{start}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEnd",
          "    writer.wtr should match r\"\\b{end}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartAngle",
          "    writer.wtr should match r\"\\<\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr should match r\"\\>\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr should match r\"\\b{start-half}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndHalf",
          "    writer.wtr should match r\"\\b{end-half}\" after fmt_assertion is called"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndLine,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assertion.kind should be ast::AssertionKind::EndLine",
          "    writer.wtr should match \"$\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::StartLine",
          "    writer.wtr should match \"^\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundary",
          "    writer.wtr should match r\"\\b\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::NotWordBoundary",
          "    writer.wtr should match r\"\\B\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStart",
          "    writer.wtr should match r\"\\b{start}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEnd",
          "    writer.wtr should match r\"\\b{end}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartAngle",
          "    writer.wtr should match r\"\\<\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr should match r\"\\>\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr should match r\"\\b{start-half}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndHalf",
          "    writer.wtr should match r\"\\b{end-half}\" after fmt_assertion is called",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartText,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, \"$\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::NotWordBoundary };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\B\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartHalf };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndHalf };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartText,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, \"$\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::NotWordBoundary };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\B\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartHalf };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndHalf };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndText,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind == ast::AssertionKind::EndText",
          "    writer.wtr == \"$\"",
          "    assertion.kind == ast::AssertionKind::StartText",
          "    writer.wtr == r\"\\A\"",
          "    assertion.kind == ast::AssertionKind::WordBoundary",
          "    writer.wtr == r\"\\b\"",
          "    assertion.kind == ast::AssertionKind::NotWordBoundary",
          "    writer.wtr == r\"\\B\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStart",
          "    writer.wtr == r\"\\b{start}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEnd",
          "    writer.wtr == r\"\\b{end}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartAngle",
          "    writer.wtr == r\"\\<\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr == r\"\\>\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr == r\"\\b{start-half}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndHalf",
          "    writer.wtr == r\"\\b{end-half}\""
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndText,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assertion.kind == ast::AssertionKind::EndText",
          "    writer.wtr == \"$\"",
          "    assertion.kind == ast::AssertionKind::StartText",
          "    writer.wtr == r\"\\A\"",
          "    assertion.kind == ast::AssertionKind::WordBoundary",
          "    writer.wtr == r\"\\b\"",
          "    assertion.kind == ast::AssertionKind::NotWordBoundary",
          "    writer.wtr == r\"\\B\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStart",
          "    writer.wtr == r\"\\b{start}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEnd",
          "    writer.wtr == r\"\\b{end}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartAngle",
          "    writer.wtr == r\"\\<\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr == r\"\\>\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr == r\"\\b{start-half}\"",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndHalf",
          "    writer.wtr == r\"\\b{end-half}\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle;",
          "    writer.wtr should equal \"\\>\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStart;",
          "    writer.wtr should equal r\"\\b{start}\";",
          "    assertion.kind should be ast::AssertionKind::StartLine;",
          "    writer.wtr should equal \"^\";",
          "    assertion.kind should be ast::AssertionKind::EndLine;",
          "    writer.wtr should equal \"$\";",
          "    assertion.kind should be ast::AssertionKind::StartText;",
          "    writer.wtr should equal r\"\\A\";",
          "    assertion.kind should be ast::AssertionKind::EndText;",
          "    writer.wtr should equal r\"\\z\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundary;",
          "    writer.wtr should equal r\"\\b\";",
          "    assertion.kind should be ast::AssertionKind::NotWordBoundary;",
          "    writer.wtr should equal r\"\\B\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStart;",
          "    writer.wtr should equal r\"\\b{start}\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEnd;",
          "    writer.wtr should equal r\"\\b{end}\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartAngle;",
          "    writer.wtr should equal r\"\\<\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle;",
          "    writer.wtr should equal r\"\\>\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartHalf;",
          "    writer.wtr should equal r\"\\b{start-half}\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndHalf;",
          "    writer.wtr should equal r\"\\b{end-half}\";"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle;",
          "    writer.wtr should equal \"\\>\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStart;",
          "    writer.wtr should equal r\"\\b{start}\";",
          "    assertion.kind should be ast::AssertionKind::StartLine;",
          "    writer.wtr should equal \"^\";",
          "    assertion.kind should be ast::AssertionKind::EndLine;",
          "    writer.wtr should equal \"$\";",
          "    assertion.kind should be ast::AssertionKind::StartText;",
          "    writer.wtr should equal r\"\\A\";",
          "    assertion.kind should be ast::AssertionKind::EndText;",
          "    writer.wtr should equal r\"\\z\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundary;",
          "    writer.wtr should equal r\"\\b\";",
          "    assertion.kind should be ast::AssertionKind::NotWordBoundary;",
          "    writer.wtr should equal r\"\\B\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStart;",
          "    writer.wtr should equal r\"\\b{start}\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEnd;",
          "    writer.wtr should equal r\"\\b{end}\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartAngle;",
          "    writer.wtr should equal r\"\\<\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle;",
          "    writer.wtr should equal r\"\\>\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartHalf;",
          "    writer.wtr should equal r\"\\b{start-half}\";",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndHalf;",
          "    writer.wtr should equal r\"\\b{end-half}\";",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let result = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, \">\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartText };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let result = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let result = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, \"$\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundary };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let result = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\b\");",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let result = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, \">\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartText };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let result = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let result = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, \"$\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundary };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let result = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\b\");",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStart,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle;",
          "    writer.wtr should match \"^\";",
          "    writer.fmt_assertion(&assertion) should return Ok(()) when assertion.kind is WordBoundaryEndAngle;",
          "    writer.wtr should contain r\"\\>\";"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStart,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle;",
          "    writer.wtr should match \"^\";",
          "    writer.fmt_assertion(&assertion) should return Ok(()) when assertion.kind is WordBoundaryEndAngle;",
          "    writer.wtr should contain r\"\\>\";",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEnd,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind == ast::AssertionKind::WordBoundaryEnd;",
          "    writer.wtr.contains(r\"\\>\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEnd,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEnd;",
          "    writer.wtr.contains(r\"\\>\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartAngle,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr, r\"\\<\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartAngle,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\<\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndAngle,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr, r\"\\>\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndAngle,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartHalf,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\>\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartHalf,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndHalf,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndHalf,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    let _ = writer.fmt_assertion(&assertion);",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]