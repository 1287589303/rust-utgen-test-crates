[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartLine,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr, \"^\");",
          "    assert!(writer.fmt_assertion(&assertion).is_ok());",
          "    assert!(writer.wtr.is_empty() == false);",
          "    assert_eq!(assertion.kind, ast::AssertionKind::StartLine);",
          "    assert!(writer.wtr.contains(\"^\"));"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartLine,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, \"^\");",
          "    assert!(writer.fmt_assertion(&assertion).is_ok());",
          "    assert!(writer.wtr.is_empty() == false);",
          "    assert_eq!(assertion.kind, ast::AssertionKind::StartLine);",
          "    assert!(writer.wtr.contains(\"^\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndLine,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assertion.kind is ast::AssertionKind::StartLine;",
          "    writer.wtr should equal \"^\";"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndLine,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assertion.kind is ast::AssertionKind::StartLine;",
          "    writer.wtr should equal \"^\";",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartText,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assertion.kind == ast::AssertionKind::StartLine",
          "    writer.wtr == \"^\""
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartText,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assertion.kind == ast::AssertionKind::StartLine",
          "    writer.wtr == \"^\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndText,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assertion.kind = ast::AssertionKind::StartLine;",
          "    assertion.kind = ast::AssertionKind::EndLine;",
          "    writer.wtr = String::new();",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), \"^\");",
          "    assert_eq!(writer.wtr, \"^\");",
          "    assertion.kind = ast::AssertionKind::EndLine;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), \"$\");",
          "    assert_eq!(writer.wtr, \"$\");",
          "    assertion.kind = ast::AssertionKind::StartText;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\A\");",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    assertion.kind = ast::AssertionKind::EndText;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\z\");",
          "    assert_eq!(writer.wtr, r\"\\z\");",
          "    assertion.kind = ast::AssertionKind::WordBoundary;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b\");",
          "    assert_eq!(writer.wtr, r\"\\b\");",
          "    assertion.kind = ast::AssertionKind::NotWordBoundary;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\B\");",
          "    assert_eq!(writer.wtr, r\"\\B\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStart;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b{start}\");",
          "    assert_eq!(writer.wtr, r\"\\b{start}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEnd;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b{end}\");",
          "    assert_eq!(writer.wtr, r\"\\b{end}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStartAngle;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\<\");",
          "    assert_eq!(writer.wtr, r\"\\<\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEndAngle;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\>\");",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStartHalf;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b{start-half}\");",
          "    assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEndHalf;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b{end-half}\");",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndText,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assertion.kind = ast::AssertionKind::StartLine;",
          "    assertion.kind = ast::AssertionKind::EndLine;",
          "    writer.wtr = String::new();",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), \"^\");",
          "    assert_eq!(writer.wtr, \"^\");",
          "    assertion.kind = ast::AssertionKind::EndLine;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), \"$\");",
          "    assert_eq!(writer.wtr, \"$\");",
          "    assertion.kind = ast::AssertionKind::StartText;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\A\");",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    assertion.kind = ast::AssertionKind::EndText;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\z\");",
          "    assert_eq!(writer.wtr, r\"\\z\");",
          "    assertion.kind = ast::AssertionKind::WordBoundary;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b\");",
          "    assert_eq!(writer.wtr, r\"\\b\");",
          "    assertion.kind = ast::AssertionKind::NotWordBoundary;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\B\");",
          "    assert_eq!(writer.wtr, r\"\\B\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStart;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b{start}\");",
          "    assert_eq!(writer.wtr, r\"\\b{start}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEnd;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b{end}\");",
          "    assert_eq!(writer.wtr, r\"\\b{end}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStartAngle;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\<\");",
          "    assert_eq!(writer.wtr, r\"\\<\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEndAngle;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\>\");",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStartHalf;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b{start-half}\");",
          "    assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEndHalf;",
          "    assert_eq!(writer.fmt_assertion(&assertion).unwrap(), r\"\\b{end-half}\");",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, \"^\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, \"$\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartText };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndText };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\z\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundary };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::NotWordBoundary };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\B\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStart };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{start}\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEnd };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{end}\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartAngle };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\<\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartHalf };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndHalf };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, \"^\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, \"$\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartText };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndText };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\z\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundary };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::NotWordBoundary };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\B\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStart };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{start}\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEnd };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{end}\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartAngle };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\<\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartHalf };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    ",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndHalf };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap(); assert_eq!(writer.wtr, \"^\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine }).unwrap(); assert_eq!(writer.wtr, \"$\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartText }).unwrap(); assert_eq!(writer.wtr, r\"\\A\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndText }).unwrap(); assert_eq!(writer.wtr, r\"\\z\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundary }).unwrap(); assert_eq!(writer.wtr, r\"\\b\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::NotWordBoundary }).unwrap(); assert_eq!(writer.wtr, r\"\\B\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStart }).unwrap(); assert_eq!(writer.wtr, r\"\\b{start}\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEnd }).unwrap(); assert_eq!(writer.wtr, r\"\\b{end}\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartAngle }).unwrap(); assert_eq!(writer.wtr, r\"\\<\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle }).unwrap(); assert_eq!(writer.wtr, r\"\\>\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartHalf }).unwrap(); assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndHalf }).unwrap(); assert_eq!(writer.wtr, r\"\\b{end-half}\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap(); assert_eq!(writer.wtr, \"^\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine }).unwrap(); assert_eq!(writer.wtr, \"$\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartText }).unwrap(); assert_eq!(writer.wtr, r\"\\A\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndText }).unwrap(); assert_eq!(writer.wtr, r\"\\z\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundary }).unwrap(); assert_eq!(writer.wtr, r\"\\b\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::NotWordBoundary }).unwrap(); assert_eq!(writer.wtr, r\"\\B\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStart }).unwrap(); assert_eq!(writer.wtr, r\"\\b{start}\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEnd }).unwrap(); assert_eq!(writer.wtr, r\"\\b{end}\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartAngle }).unwrap(); assert_eq!(writer.wtr, r\"\\<\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndAngle }).unwrap(); assert_eq!(writer.wtr, r\"\\>\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartHalf }).unwrap(); assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    ",
          "    writer.fmt_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndHalf }).unwrap(); assert_eq!(writer.wtr, r\"\\b{end-half}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStart,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStart",
          "    writer.wtr should equal r\"\\b{start}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::StartLine",
          "    writer.wtr should equal r\"^\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::EndLine",
          "    writer.wtr should equal r\"$\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::StartText",
          "    writer.wtr should equal r\"\\A\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::EndText",
          "    writer.wtr should equal r\"\\z\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundary",
          "    writer.wtr should equal r\"\\b\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::NotWordBoundary",
          "    writer.wtr should equal r\"\\B\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEnd",
          "    writer.wtr should equal r\"\\b{end}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartAngle",
          "    writer.wtr should equal r\"\\<\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr should equal r\"\\>\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr should equal r\"\\b{start-half}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndHalf",
          "    writer.wtr should equal r\"\\b{end-half}\" after fmt_assertion is called"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStart,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStart",
          "    writer.wtr should equal r\"\\b{start}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::StartLine",
          "    writer.wtr should equal r\"^\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::EndLine",
          "    writer.wtr should equal r\"$\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::StartText",
          "    writer.wtr should equal r\"\\A\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::EndText",
          "    writer.wtr should equal r\"\\z\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundary",
          "    writer.wtr should equal r\"\\b\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::NotWordBoundary",
          "    writer.wtr should equal r\"\\B\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEnd",
          "    writer.wtr should equal r\"\\b{end}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartAngle",
          "    writer.wtr should equal r\"\\<\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr should equal r\"\\>\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr should equal r\"\\b{start-half}\" after fmt_assertion is called",
          "    assertion.kind should be ast::AssertionKind::WordBoundaryEndHalf",
          "    writer.wtr should equal r\"\\b{end-half}\" after fmt_assertion is called",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEnd,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assertion.kind = ast::AssertionKind::StartLine;",
          "    assert_eq!(writer.wtr, \"^\");",
          "    assertion.kind = ast::AssertionKind::EndLine;",
          "    assert_eq!(writer.wtr, \"$\");",
          "    assertion.kind = ast::AssertionKind::StartText;",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    assertion.kind = ast::AssertionKind::EndText;",
          "    assert_eq!(writer.wtr, r\"\\z\");",
          "    assertion.kind = ast::AssertionKind::WordBoundary;",
          "    assert_eq!(writer.wtr, r\"\\b\");",
          "    assertion.kind = ast::AssertionKind::NotWordBoundary;",
          "    assert_eq!(writer.wtr, r\"\\B\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStart;",
          "    assert_eq!(writer.wtr, r\"\\b{start}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEnd;",
          "    assert_eq!(writer.wtr, r\"\\b{end}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStartAngle;",
          "    assert_eq!(writer.wtr, r\"\\<\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEndAngle;",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStartHalf;",
          "    assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEndHalf;",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEnd,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assertion.kind = ast::AssertionKind::StartLine;",
          "    assert_eq!(writer.wtr, \"^\");",
          "    assertion.kind = ast::AssertionKind::EndLine;",
          "    assert_eq!(writer.wtr, \"$\");",
          "    assertion.kind = ast::AssertionKind::StartText;",
          "    assert_eq!(writer.wtr, r\"\\A\");",
          "    assertion.kind = ast::AssertionKind::EndText;",
          "    assert_eq!(writer.wtr, r\"\\z\");",
          "    assertion.kind = ast::AssertionKind::WordBoundary;",
          "    assert_eq!(writer.wtr, r\"\\b\");",
          "    assertion.kind = ast::AssertionKind::NotWordBoundary;",
          "    assert_eq!(writer.wtr, r\"\\B\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStart;",
          "    assert_eq!(writer.wtr, r\"\\b{start}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEnd;",
          "    assert_eq!(writer.wtr, r\"\\b{end}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStartAngle;",
          "    assert_eq!(writer.wtr, r\"\\<\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEndAngle;",
          "    assert_eq!(writer.wtr, r\"\\>\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryStartHalf;",
          "    assert_eq!(writer.wtr, r\"\\b{start-half}\");",
          "    assertion.kind = ast::AssertionKind::WordBoundaryEndHalf;",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartAngle,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr, r\"\\<\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartAngle,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\<\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndAngle,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr == r\"\\>\"",
          "    writer.fmt_assertion(&assertion).is_ok()"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndAngle,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assertion.kind == ast::AssertionKind::WordBoundaryEndAngle",
          "    writer.wtr == r\"\\>\"",
          "    writer.fmt_assertion(&assertion).is_ok()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartHalf,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr == r\"\\b{start-half}\""
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartHalf,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assertion.kind == ast::AssertionKind::WordBoundaryStartHalf",
          "    writer.wtr == r\"\\b{start-half}\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndHalf,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");"
        ],
        "code": [
          "{",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndHalf,",
          "    };",
          "    let mut writer = Writer { wtr: String::new() };",
          "    writer.fmt_assertion(&assertion).unwrap();",
          "    assert_eq!(writer.wtr, r\"\\b{end-half}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]