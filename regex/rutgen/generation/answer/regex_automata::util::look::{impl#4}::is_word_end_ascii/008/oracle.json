[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\"; // empty haystack",
          "    let at = 0;",
          "    matcher.is_word_end_ascii(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(matcher.is_word_end_ascii(haystack, at), false);  // at == 0, word_before is false",
          "    assert_eq!(matcher.is_word_end_ascii(haystack, haystack.len()), false); // at == haystack.len(), word_after is false",
          "    assert_eq!(matcher.is_word_end_ascii(haystack, 1), false);  // at > 0, haystack is empty, should panic",
          "    assert!(std::panic::catch_unwind(|| matcher.is_word_end_ascii(haystack, 1)).is_err());  // ensure panic when at is out of bounds"
        ],
        "code": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\"; // empty haystack",
          "    let at = 0;",
          "    matcher.is_word_end_ascii(haystack, at);",
          "    assert_eq!(matcher.is_word_end_ascii(haystack, at), false);  // at == 0, word_before is false",
          "    assert_eq!(matcher.is_word_end_ascii(haystack, haystack.len()), false); // at == haystack.len(), word_after is false",
          "    assert_eq!(matcher.is_word_end_ascii(haystack, 1), false);  // at > 0, haystack is empty, should panic",
          "    assert!(std::panic::catch_unwind(|| matcher.is_word_end_ascii(haystack, 1)).is_err());  // ensure panic when at is out of bounds",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\"; // empty haystack",
          "    let at = haystack.len(); // at == len(haystack)",
          "    matcher.is_word_end_ascii(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(matcher.is_word_end_ascii(haystack, at), false);"
        ],
        "code": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\"\"; // empty haystack",
          "    let at = haystack.len(); // at == len(haystack)",
          "    matcher.is_word_end_ascii(haystack, at);",
          "    assert_eq!(matcher.is_word_end_ascii(haystack, at), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\".\"; // non-word byte before the specified position",
          "    let at = 1; // at == haystack.len() - 1 (1) with non-word byte",
          "    matcher.is_word_end_ascii(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(matcher.is_word_end_ascii(haystack, 0), false); // at == 0, expected return false",
          "    assert_eq!(matcher.is_word_end_ascii(b\"abc\", 3), false); // at == haystack.len(), expected return false",
          "    assert_eq!(matcher.is_word_end_ascii(b\"abc_\", 3), true); // at == haystack.len() with word byte before, expected return true",
          "    assert_eq!(matcher.is_word_end_ascii(b\"abc\", 2), true); // at=2, word before and no word after, expected return true",
          "    assert_eq!(matcher.is_word_end_ascii(b\"abc_\", 2), false); // at=2, word before and word after, expected return false"
        ],
        "code": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack: &[u8] = b\".\"; // non-word byte before the specified position",
          "    let at = 1; // at == haystack.len() - 1 (1) with non-word byte",
          "    matcher.is_word_end_ascii(haystack, at);",
          "    assert_eq!(matcher.is_word_end_ascii(haystack, 0), false); // at == 0, expected return false",
          "    assert_eq!(matcher.is_word_end_ascii(b\"abc\", 3), false); // at == haystack.len(), expected return false",
          "    assert_eq!(matcher.is_word_end_ascii(b\"abc_\", 3), true); // at == haystack.len() with word byte before, expected return true",
          "    assert_eq!(matcher.is_word_end_ascii(b\"abc\", 2), true); // at=2, word before and no word after, expected return true",
          "    assert_eq!(matcher.is_word_end_ascii(b\"abc_\", 2), false); // at=2, word before and word after, expected return false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]