[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seq = Utf8Sequence::One(Utf8Range::new(0x61, 0x61)); // 'a'",
          "    let bytes = &[0x61]; // Matches 'a'",
          "    let result = seq.matches(bytes);",
          "}"
        ],
        "oracle": [
          "    let seq = Utf8Sequence::One(Utf8Range::new(0x61, 0x61)); // 'a'",
          "    let bytes = &[0x61]; // Matches 'a'",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62)]); // 'a', 'b'",
          "    let bytes = &[0x61, 0x62]; // Matches 'a', 'b'",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::Three([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62), Utf8Range::new(0x63, 0x63)]); // 'a', 'b', 'c'",
          "    let bytes = &[0x61, 0x62, 0x63]; // Matches 'a', 'b', 'c'",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::Four([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62), Utf8Range::new(0x63, 0x63), Utf8Range::new(0x64, 0x64)]); // 'a', 'b', 'c', 'd'",
          "    let bytes = &[0x61, 0x62, 0x63, 0x64]; // Matches 'a', 'b', 'c', 'd'",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::One(Utf8Range::new(0x61, 0x61)); // 'a'",
          "    let bytes = &[0x62]; // Does not match 'a'",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62)]); // 'a', 'b'",
          "    let bytes = &[0x61]; // Does not match complete sequence",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Three([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62), Utf8Range::new(0x63, 0x63)]); // 'a', 'b', 'c'",
          "    let bytes = &[0x61, 0x63]; // 'a' matches, but 'c' does not match",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Four([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62), Utf8Range::new(0x63, 0x63), Utf8Range::new(0x64, 0x64)]); // 'a', 'b', 'c', 'd'",
          "    let bytes = &[0x61, 0x62, 0x63]; // Does not match complete sequence",
          "    assert_eq!(seq.matches(bytes), false);"
        ],
        "code": [
          "{",
          "    let seq = Utf8Sequence::One(Utf8Range::new(0x61, 0x61)); // 'a'",
          "    let bytes = &[0x61]; // Matches 'a'",
          "    let result = seq.matches(bytes);",
          "    let seq = Utf8Sequence::One(Utf8Range::new(0x61, 0x61)); // 'a'",
          "    let bytes = &[0x61]; // Matches 'a'",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62)]); // 'a', 'b'",
          "    let bytes = &[0x61, 0x62]; // Matches 'a', 'b'",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::Three([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62), Utf8Range::new(0x63, 0x63)]); // 'a', 'b', 'c'",
          "    let bytes = &[0x61, 0x62, 0x63]; // Matches 'a', 'b', 'c'",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::Four([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62), Utf8Range::new(0x63, 0x63), Utf8Range::new(0x64, 0x64)]); // 'a', 'b', 'c', 'd'",
          "    let bytes = &[0x61, 0x62, 0x63, 0x64]; // Matches 'a', 'b', 'c', 'd'",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::One(Utf8Range::new(0x61, 0x61)); // 'a'",
          "    let bytes = &[0x62]; // Does not match 'a'",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62)]); // 'a', 'b'",
          "    let bytes = &[0x61]; // Does not match complete sequence",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Three([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62), Utf8Range::new(0x63, 0x63)]); // 'a', 'b', 'c'",
          "    let bytes = &[0x61, 0x63]; // 'a' matches, but 'c' does not match",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Four([Utf8Range::new(0x61, 0x61), Utf8Range::new(0x62, 0x62), Utf8Range::new(0x63, 0x63), Utf8Range::new(0x64, 0x64)]); // 'a', 'b', 'c', 'd'",
          "    let bytes = &[0x61, 0x62, 0x63]; // Does not match complete sequence",
          "    assert_eq!(seq.matches(bytes), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seq = Utf8Sequence::Two([",
          "        Utf8Range::new(0xC2, 0xC2), // 'Â'",
          "        Utf8Range::new(0xA0, 0xA0), // ' '",
          "    ]);",
          "    let bytes = &[0xC2, 0xA0]; // Matches 'Â '",
          "    let result = seq.matches(bytes);",
          "}"
        ],
        "oracle": [
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0xC2, 0xC2), Utf8Range::new(0xA0, 0xA0)]);",
          "    let bytes = &[0xC2, 0xA0];",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0xC2, 0xC2), Utf8Range::new(0xA0, 0xA0)]);",
          "    let bytes = &[0xC2, 0xA1];",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0xC2, 0xC2), Utf8Range::new(0xA0, 0xA0)]);",
          "    let bytes = &[0xC1, 0xA0];",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0xC2, 0xC2), Utf8Range::new(0xA0, 0xA0)]);",
          "    let bytes = &[0xC2];",
          "    assert_eq!(seq.matches(bytes), false);"
        ],
        "code": [
          "{",
          "    let seq = Utf8Sequence::Two([",
          "        Utf8Range::new(0xC2, 0xC2), // 'Â'",
          "        Utf8Range::new(0xA0, 0xA0), // ' '",
          "    ]);",
          "    let bytes = &[0xC2, 0xA0]; // Matches 'Â '",
          "    let result = seq.matches(bytes);",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0xC2, 0xC2), Utf8Range::new(0xA0, 0xA0)]);",
          "    let bytes = &[0xC2, 0xA0];",
          "    assert_eq!(seq.matches(bytes), true);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0xC2, 0xC2), Utf8Range::new(0xA0, 0xA0)]);",
          "    let bytes = &[0xC2, 0xA1];",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0xC2, 0xC2), Utf8Range::new(0xA0, 0xA0)]);",
          "    let bytes = &[0xC1, 0xA0];",
          "    assert_eq!(seq.matches(bytes), false);",
          "    ",
          "    let seq = Utf8Sequence::Two([Utf8Range::new(0xC2, 0xC2), Utf8Range::new(0xA0, 0xA0)]);",
          "    let bytes = &[0xC2];",
          "    assert_eq!(seq.matches(bytes), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seq = Utf8Sequence::Three([",
          "        Utf8Range::new(0xE2, 0xE2), // 'â'",
          "        Utf8Range::new(0x82, 0x82), // '‚'",
          "        Utf8Range::new(0xAC, 0xAC), // '¬'",
          "    ]);",
          "    let bytes = &[0xE2, 0x82, 0xAC]; // Matches 'â‚¬'",
          "    let result = seq.matches(bytes);",
          "}"
        ],
        "oracle": [
          "    assert!(result);",
          "    assert_eq!(seq.len(), 3);",
          "    assert!(seq.matches(&[0xE2, 0x82, 0xAC]));",
          "    assert!(!seq.matches(&[0xE3, 0x82, 0xAC]));",
          "    assert!(!seq.matches(&[0xE2, 0x81]));"
        ],
        "code": [
          "{",
          "    let seq = Utf8Sequence::Three([",
          "        Utf8Range::new(0xE2, 0xE2), // 'â'",
          "        Utf8Range::new(0x82, 0x82), // '‚'",
          "        Utf8Range::new(0xAC, 0xAC), // '¬'",
          "    ]);",
          "    let bytes = &[0xE2, 0x82, 0xAC]; // Matches 'â‚¬'",
          "    let result = seq.matches(bytes);",
          "    assert!(result);",
          "    assert_eq!(seq.len(), 3);",
          "    assert!(seq.matches(&[0xE2, 0x82, 0xAC]));",
          "    assert!(!seq.matches(&[0xE3, 0x82, 0xAC]));",
          "    assert!(!seq.matches(&[0xE2, 0x81]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seq = Utf8Sequence::Four([",
          "        Utf8Range::new(0xF0, 0xF0), // 'ð'",
          "        Utf8Range::new(0x9F, 0x9F), // 'Ÿ'",
          "        Utf8Range::new(0x92, 0x92), // '’'",
          "        Utf8Range::new(0xA8, 0xA8), // '¨'",
          "    ]);",
          "    let bytes = &[0xF0, 0x9F, 0x92, 0xA8]; // Matches 'ðŸ’¨'",
          "    let result = seq.matches(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.len(), 4);",
          "    assert!(seq.matches(bytes));",
          "    assert!(seq.matches(&[0xF0, 0x9F, 0x92, 0xA8]));",
          "    assert!(!seq.matches(&[0xF0, 0x9F, 0x92]));"
        ],
        "code": [
          "{",
          "    let seq = Utf8Sequence::Four([",
          "        Utf8Range::new(0xF0, 0xF0), // 'ð'",
          "        Utf8Range::new(0x9F, 0x9F), // 'Ÿ'",
          "        Utf8Range::new(0x92, 0x92), // '’'",
          "        Utf8Range::new(0xA8, 0xA8), // '¨'",
          "    ]);",
          "    let bytes = &[0xF0, 0x9F, 0x92, 0xA8]; // Matches 'ðŸ’¨'",
          "    let result = seq.matches(bytes);",
          "    assert_eq!(seq.len(), 4);",
          "    assert!(seq.matches(bytes));",
          "    assert!(seq.matches(&[0xF0, 0x9F, 0x92, 0xA8]));",
          "    assert!(!seq.matches(&[0xF0, 0x9F, 0x92]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]