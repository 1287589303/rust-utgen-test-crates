[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literal = Literal::exact(vec![1]);",
          "    literal.reverse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(literal.as_bytes(), &[1]);",
          "    let mut literal = Literal::exact(vec![1, 2, 3]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[3, 2, 1]);",
          "    let mut literal = Literal::exact(vec![]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[]);",
          "    let mut literal = Literal::exact(vec![5, 10, 15, 20]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[20, 15, 10, 5]);",
          "    let mut literal = Literal::inexact(vec![7, 8]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[8, 7]);",
          "    let literal = Literal::exact(vec![42]);",
          "    let literal_copy = literal.clone();",
          "    literal_copy.reverse();",
          "    assert_eq!(literal_copy.as_bytes(), &[42]);"
        ],
        "code": [
          "{",
          "    let mut literal = Literal::exact(vec![1]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[1]);",
          "    let mut literal = Literal::exact(vec![1, 2, 3]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[3, 2, 1]);",
          "    let mut literal = Literal::exact(vec![]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[]);",
          "    let mut literal = Literal::exact(vec![5, 10, 15, 20]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[20, 15, 10, 5]);",
          "    let mut literal = Literal::inexact(vec![7, 8]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[8, 7]);",
          "    let literal = Literal::exact(vec![42]);",
          "    let literal_copy = literal.clone();",
          "    literal_copy.reverse();",
          "    assert_eq!(literal_copy.as_bytes(), &[42]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literal = Literal::exact(vec![1, 2]);",
          "    literal.reverse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(literal.as_bytes(), &[2, 1]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[1, 2]);",
          "    let mut empty_literal = Literal::exact(vec![]);",
          "    empty_literal.reverse();",
          "    assert!(empty_literal.is_empty());",
          "    let mut single_byte_literal = Literal::exact(vec![42]);",
          "    single_byte_literal.reverse();",
          "    assert_eq!(single_byte_literal.as_bytes(), &[42]);",
          "    let mut inexact_literal = Literal::inexact(vec![3, 4, 5]);",
          "    inexact_literal.reverse();",
          "    assert_eq!(inexact_literal.as_bytes(), &[5, 4, 3]);"
        ],
        "code": [
          "{",
          "    let mut literal = Literal::exact(vec![1, 2]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[2, 1]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[1, 2]);",
          "    let mut empty_literal = Literal::exact(vec![]);",
          "    empty_literal.reverse();",
          "    assert!(empty_literal.is_empty());",
          "    let mut single_byte_literal = Literal::exact(vec![42]);",
          "    single_byte_literal.reverse();",
          "    assert_eq!(single_byte_literal.as_bytes(), &[42]);",
          "    let mut inexact_literal = Literal::inexact(vec![3, 4, 5]);",
          "    inexact_literal.reverse();",
          "    assert_eq!(inexact_literal.as_bytes(), &[5, 4, 3]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literal = Literal::exact(vec![1, 2, 3, 4, 5]);",
          "    literal.reverse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(literal.as_bytes(), &[5, 4, 3, 2, 1]);",
          "    assert_eq!(literal.len(), 5);",
          "    assert!(!literal.is_empty());",
          "    assert!(literal.is_exact());",
          "    literal.make_inexact();",
          "    assert!(!literal.is_exact());"
        ],
        "code": [
          "{",
          "    let mut literal = Literal::exact(vec![1, 2, 3, 4, 5]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[5, 4, 3, 2, 1]);",
          "    assert_eq!(literal.len(), 5);",
          "    assert!(!literal.is_empty());",
          "    assert!(literal.is_exact());",
          "    literal.make_inexact();",
          "    assert!(!literal.is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literal = Literal::exact((0..1000).map(|x| x as u8).collect::<Vec<u8>>());",
          "    literal.reverse();",
          "}"
        ],
        "oracle": [
          "    let mut literal = Literal::exact((0..1000).map(|x| x as u8).collect::<Vec<u8>>());",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), (0..1000).rev().map(|x| x as u8).collect::<Vec<u8>>().as_slice());",
          "    assert_eq!(literal.len(), 1000);",
          "    assert!(!literal.is_empty());",
          "    assert!(literal.is_exact());"
        ],
        "code": [
          "{",
          "    let mut literal = Literal::exact((0..1000).map(|x| x as u8).collect::<Vec<u8>>());",
          "    literal.reverse();",
          "    let mut literal = Literal::exact((0..1000).map(|x| x as u8).collect::<Vec<u8>>());",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), (0..1000).rev().map(|x| x as u8).collect::<Vec<u8>>().as_slice());",
          "    assert_eq!(literal.len(), 1000);",
          "    assert!(!literal.is_empty());",
          "    assert!(literal.is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literal = Literal::exact(vec![0]);",
          "    literal.reverse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(literal.as_bytes(), &[0]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[0]);",
          "    let mut literal = Literal::exact(vec![1, 2, 3]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[3, 2, 1]);",
          "    let mut literal = Literal::exact(vec![4, 5, 6, 7]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[7, 6, 5, 4]);",
          "    let mut literal = Literal::exact(vec![]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[]);"
        ],
        "code": [
          "{",
          "    let mut literal = Literal::exact(vec![0]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[0]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[0]);",
          "    let mut literal = Literal::exact(vec![1, 2, 3]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[3, 2, 1]);",
          "    let mut literal = Literal::exact(vec![4, 5, 6, 7]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[7, 6, 5, 4]);",
          "    let mut literal = Literal::exact(vec![]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literal = Literal::exact(vec![255; 1000]);",
          "    literal.reverse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(literal.as_bytes(), &[255; 1000].iter().rev().cloned().collect::<Vec<u8>>().as_slice());",
          "    assert!(literal.is_exact());",
          "    assert_eq!(literal.len(), 1000);",
          "    assert!(!literal.is_empty());",
          "    assert_eq!(literal.into_bytes(), vec![255; 1000].iter().rev().cloned().collect::<Vec<u8>>());"
        ],
        "code": [
          "{",
          "    let mut literal = Literal::exact(vec![255; 1000]);",
          "    literal.reverse();",
          "    assert_eq!(literal.as_bytes(), &[255; 1000].iter().rev().cloned().collect::<Vec<u8>>().as_slice());",
          "    assert!(literal.is_exact());",
          "    assert_eq!(literal.len(), 1000);",
          "    assert!(!literal.is_empty());",
          "    assert_eq!(literal.into_bytes(), vec![255; 1000].iter().rev().cloned().collect::<Vec<u8>>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]