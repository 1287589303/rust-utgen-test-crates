[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let range = ClassBytesRange { start: 0x41, end: 0x41 }; // 'A'",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    let _result = class_bytes.to_unicode_class();",
          "}"
        ],
        "oracle": [
          "    assert!(_result.is_some());",
          "    let class_unicode = _result.unwrap();",
          "    assert_eq!(class_unicode.ranges().len(), 1);",
          "    assert_eq!(class_unicode.ranges()[0].start, char::from(0x41));",
          "    assert_eq!(class_unicode.ranges()[0].end, char::from(0x41));",
          "    assert!(class_bytes.is_ascii());"
        ],
        "code": [
          "{",
          "    let range = ClassBytesRange { start: 0x41, end: 0x41 }; // 'A'",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    let _result = class_bytes.to_unicode_class();",
          "    assert!(_result.is_some());",
          "    let class_unicode = _result.unwrap();",
          "    assert_eq!(class_unicode.ranges().len(), 1);",
          "    assert_eq!(class_unicode.ranges()[0].start, char::from(0x41));",
          "    assert_eq!(class_unicode.ranges()[0].end, char::from(0x41));",
          "    assert!(class_bytes.is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassBytesRange { start: 0x30, end: 0x39 }, // '0'-'9'",
          "        ClassBytesRange { start: 0x41, end: 0x5A }, // 'A'-'Z'",
          "        ClassBytesRange { start: 0x61, end: 0x7A }, // 'a'-'z'",
          "    ];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let _result = class_bytes.to_unicode_class();",
          "}"
        ],
        "oracle": [
          "    let ranges = vec![ClassBytesRange { start: 0x30, end: 0x39 }, ClassBytesRange { start: 0x41, end: 0x5A }, ClassBytesRange { start: 0x61, end: 0x7A }];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let result = class_bytes.to_unicode_class();",
          "    assert!(result.is_some());",
          "    let unicode_class = result.unwrap();",
          "    assert_eq!(unicode_class.ranges().len(), 3);",
          "    assert_eq!(unicode_class.ranges()[0], ClassUnicodeRange { start: '0', end: '9' });",
          "    assert_eq!(unicode_class.ranges()[1], ClassUnicodeRange { start: 'A', end: 'Z' });",
          "    assert_eq!(unicode_class.ranges()[2], ClassUnicodeRange { start: 'a', end: 'z' });"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassBytesRange { start: 0x30, end: 0x39 }, // '0'-'9'",
          "        ClassBytesRange { start: 0x41, end: 0x5A }, // 'A'-'Z'",
          "        ClassBytesRange { start: 0x61, end: 0x7A }, // 'a'-'z'",
          "    ];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let _result = class_bytes.to_unicode_class();",
          "    let ranges = vec![ClassBytesRange { start: 0x30, end: 0x39 }, ClassBytesRange { start: 0x41, end: 0x5A }, ClassBytesRange { start: 0x61, end: 0x7A }];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let result = class_bytes.to_unicode_class();",
          "    assert!(result.is_some());",
          "    let unicode_class = result.unwrap();",
          "    assert_eq!(unicode_class.ranges().len(), 3);",
          "    assert_eq!(unicode_class.ranges()[0], ClassUnicodeRange { start: '0', end: '9' });",
          "    assert_eq!(unicode_class.ranges()[1], ClassUnicodeRange { start: 'A', end: 'Z' });",
          "    assert_eq!(unicode_class.ranges()[2], ClassUnicodeRange { start: 'a', end: 'z' });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let range = ClassBytesRange { start: 0x00, end: 0x7F }; // Full ASCII range",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    let _result = class_bytes.to_unicode_class();",
          "}"
        ],
        "oracle": [
          "    _result.unwrap().set.ranges.iter().map(|r| r.start).collect::<Vec<_>>() == vec![0x00]",
          "    _result.unwrap().set.ranges.iter().map(|r| r.end).collect::<Vec<_>>() == vec![0x7F]",
          "    _result.unwrap().set.is_ascii() == true",
          "    _result.is_some() == true"
        ],
        "code": [
          "{",
          "    let range = ClassBytesRange { start: 0x00, end: 0x7F }; // Full ASCII range",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    let _result = class_bytes.to_unicode_class();",
          "    _result.unwrap().set.ranges.iter().map(|r| r.start).collect::<Vec<_>>() == vec![0x00]",
          "    _result.unwrap().set.ranges.iter().map(|r| r.end).collect::<Vec<_>>() == vec![0x7F]",
          "    _result.unwrap().set.is_ascii() == true",
          "    _result.is_some() == true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassBytesRange { start: 0x20, end: 0x20 }, // Space",
          "        ClassBytesRange { start: 0x21, end: 0x21 }, // '!'",
          "        ClassBytesRange { start: 0x7E, end: 0x7E }, // '~'",
          "    ];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let _result = class_bytes.to_unicode_class();",
          "}"
        ],
        "oracle": [
          "    assert!(_result.is_some());",
          "    let unicode_class = _result.unwrap();",
          "    let expected_ranges = vec![",
          "    ClassUnicodeRange { start: char::from(0x20), end: char::from(0x20) },",
          "    ClassUnicodeRange { start: char::from(0x21), end: char::from(0x21) },",
          "    ClassUnicodeRange { start: char::from(0x7E), end: char::from(0x7E) },",
          "    ];",
          "    assert_eq!(unicode_class.ranges(), expected_ranges.as_slice());"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassBytesRange { start: 0x20, end: 0x20 }, // Space",
          "        ClassBytesRange { start: 0x21, end: 0x21 }, // '!'",
          "        ClassBytesRange { start: 0x7E, end: 0x7E }, // '~'",
          "    ];",
          "    let class_bytes = ClassBytes::new(ranges);",
          "    let _result = class_bytes.to_unicode_class();",
          "    assert!(_result.is_some());",
          "    let unicode_class = _result.unwrap();",
          "    let expected_ranges = vec![",
          "    ClassUnicodeRange { start: char::from(0x20), end: char::from(0x20) },",
          "    ClassUnicodeRange { start: char::from(0x21), end: char::from(0x21) },",
          "    ClassUnicodeRange { start: char::from(0x7E), end: char::from(0x7E) },",
          "    ];",
          "    assert_eq!(unicode_class.ranges(), expected_ranges.as_slice());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]