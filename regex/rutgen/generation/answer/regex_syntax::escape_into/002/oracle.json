[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"hello world\"; // ASCII characters that are not meta characters",
          "    escape_into(text, &mut buf);",
          "}"
        ],
        "oracle": [
          "    buf.is_empty() // Ensure buffer is empty before the call",
          "    buf.len() == 11 // Validate buffer length matches input text length",
          "    buf == \"hello world\" // Verify the buffer content matches the original text"
        ],
        "code": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"hello world\"; // ASCII characters that are not meta characters",
          "    escape_into(text, &mut buf);",
          "    buf.is_empty() // Ensure buffer is empty before the call",
          "    buf.len() == 11 // Validate buffer length matches input text length",
          "    buf == \"hello world\" // Verify the buffer content matches the original text",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"hello_world\"; // Contains an underscore, which is not a meta character",
          "    escape_into(text, &mut buf);",
          "}"
        ],
        "oracle": [
          "    buf == \"hello_world\"",
          "    buf.len() == 11",
          "    buf.capacity() >= text.len()"
        ],
        "code": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"hello_world\"; // Contains an underscore, which is not a meta character",
          "    escape_into(text, &mut buf);",
          "    buf == \"hello_world\"",
          "    buf.len() == 11",
          "    buf.capacity() >= text.len()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"\"; // Empty input",
          "    escape_into(text, &mut buf);",
          "}"
        ],
        "oracle": [
          "    buf.is_empty()",
          "    buf.len() == 0",
          "    buf == \"\"",
          "    buf.capacity() == text.len()",
          "    buf.push('a'); escape_into(\"a\", &mut buf); assert_eq!(buf, \"\\\\a\")",
          "    buf.push('b'); escape_into(\"b\", &mut buf); assert_eq!(buf, \"\\\\b\")",
          "    buf.push('c'); escape_into(\"c\", &mut buf); assert_eq!(buf, \"\\\\c\")",
          "    buf.push('1'); escape_into(\"1\", &mut buf); assert_eq!(buf, \"\\\\1\")",
          "    buf.push(' '); escape_into(\" \", &mut buf); assert_eq!(buf, \"\\\\ \")",
          "    buf.push('\\n'); escape_into(\"\\n\", &mut buf); assert_eq!(buf, \"\\\\n\")",
          "    escape_into(\"abc\", &mut buf); assert_eq!(buf, \"abc\")",
          "    escape_into(\"no_meta\", &mut buf); assert_eq!(buf, \"no_meta\")",
          "    escape_into(\"..?\", &mut buf); assert_eq!(buf, \"\\\\.\\\\.\\\\?\")",
          "    escape_into(\"100%\", &mut buf); assert_eq!(buf, \"100%\")",
          "    escape_into(\"a|b\", &mut buf); assert_eq!(buf, \"\\\\a|\\\\b\")",
          "    escape_into(\"(){}\", &mut buf); assert_eq!(buf, \"\\\\(\\\\)\\\\{\\\\}\")"
        ],
        "code": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"\"; // Empty input",
          "    escape_into(text, &mut buf);",
          "    buf.is_empty()",
          "    buf.len() == 0",
          "    buf == \"\"",
          "    buf.capacity() == text.len()",
          "    buf.push('a'); escape_into(\"a\", &mut buf); assert_eq!(buf, \"\\\\a\")",
          "    buf.push('b'); escape_into(\"b\", &mut buf); assert_eq!(buf, \"\\\\b\")",
          "    buf.push('c'); escape_into(\"c\", &mut buf); assert_eq!(buf, \"\\\\c\")",
          "    buf.push('1'); escape_into(\"1\", &mut buf); assert_eq!(buf, \"\\\\1\")",
          "    buf.push(' '); escape_into(\" \", &mut buf); assert_eq!(buf, \"\\\\ \")",
          "    buf.push('\\n'); escape_into(\"\\n\", &mut buf); assert_eq!(buf, \"\\\\n\")",
          "    escape_into(\"abc\", &mut buf); assert_eq!(buf, \"abc\")",
          "    escape_into(\"no_meta\", &mut buf); assert_eq!(buf, \"no_meta\")",
          "    escape_into(\"..?\", &mut buf); assert_eq!(buf, \"\\\\.\\\\.\\\\?\")",
          "    escape_into(\"100%\", &mut buf); assert_eq!(buf, \"100%\")",
          "    escape_into(\"a|b\", &mut buf); assert_eq!(buf, \"\\\\a|\\\\b\")",
          "    escape_into(\"(){}\", &mut buf); assert_eq!(buf, \"\\\\(\\\\)\\\\{\\\\}\")",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"a\"; // Single ASCII character that is not a meta character",
          "    escape_into(text, &mut buf);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, \"a\");"
        ],
        "code": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"a\"; // Single ASCII character that is not a meta character",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \"a\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"12345\"; // Only numerical characters, none are meta characters",
          "    escape_into(text, &mut buf);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, \"12345\");",
          "    buf.clear();",
          "    let text = \"abcde\"; // Only alphabetical characters, none are meta characters",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \"abcde\");",
          "    buf.clear();",
          "    let text = \"!@#$%\"; // Only special characters, none are meta characters",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \"!@#$%\");",
          "    buf.clear();",
          "    let text = \" \"; // A single space character, which is not a meta character",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \" \");",
          "    buf.clear();",
          "    let text = \"\"; // An empty string input",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \"\");",
          "    buf.clear();"
        ],
        "code": [
          "{",
          "    let mut buf = String::new();",
          "    let text = \"12345\"; // Only numerical characters, none are meta characters",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \"12345\");",
          "    buf.clear();",
          "    let text = \"abcde\"; // Only alphabetical characters, none are meta characters",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \"abcde\");",
          "    buf.clear();",
          "    let text = \"!@#$%\"; // Only special characters, none are meta characters",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \"!@#$%\");",
          "    buf.clear();",
          "    let text = \" \"; // A single space character, which is not a meta character",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \" \");",
          "    buf.clear();",
          "    let text = \"\"; // An empty string input",
          "    escape_into(text, &mut buf);",
          "    assert_eq!(buf, \"\");",
          "    buf.clear();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]