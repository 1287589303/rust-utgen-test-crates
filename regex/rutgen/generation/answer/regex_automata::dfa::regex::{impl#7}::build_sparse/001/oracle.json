[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(\"\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Parse);"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(\"\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Parse);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(\"abc\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let regex = result.unwrap();",
          "    assert_eq!(regex.to_string(), \"abc\");",
          "    assert!(regex.is_match(\"abc\"));",
          "    assert!(!regex.is_match(\"def\"));",
          "    let result_empty = builder.build_sparse(\"\");",
          "    assert!(result_empty.is_err());",
          "    let result_special = builder.build_sparse(\".*\");",
          "    assert!(result_special.is_ok());",
          "    let regex_special = result_special.unwrap();",
          "    assert!(regex_special.is_match(\"anything\"));",
          "    setq!(regex_special.to_string(), \".*\");"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(\"abc\");",
          "    assert!(result.is_ok());",
          "    let regex = result.unwrap();",
          "    assert_eq!(regex.to_string(), \"abc\");",
          "    assert!(regex.is_match(\"abc\"));",
          "    assert!(!regex.is_match(\"def\"));",
          "    let result_empty = builder.build_sparse(\"\");",
          "    assert!(result_empty.is_err());",
          "    let result_special = builder.build_sparse(\".*\");",
          "    assert!(result_special.is_ok());",
          "    let regex_special = result_special.unwrap();",
          "    assert!(regex_special.is_match(\"anything\"));",
          "    setq!(regex_special.to_string(), \".*\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(r\"\\d{3}-\\d{2}-\\d{4}\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let regex = result.unwrap();",
          "    assert_eq!(regex.pattern(), r\"\\d{3}-\\d{2}-\\d{4}\");",
          "    assert!(regex.is_sparse());",
          "    ",
          "    let result_invalid = builder.build_sparse(r\"[\"); // Invalid regex",
          "    assert!(result_invalid.is_err());",
          "    ",
          "    let result_empty = builder.build_sparse(\"\"); // Empty pattern",
          "    assert!(result_empty.is_ok());",
          "    let regex_empty = result_empty.unwrap();",
          "    assert_eq!(regex_empty.pattern(), \"\");"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(r\"\\d{3}-\\d{2}-\\d{4}\");",
          "    assert!(result.is_ok());",
          "    let regex = result.unwrap();",
          "    assert_eq!(regex.pattern(), r\"\\d{3}-\\d{2}-\\d{4}\");",
          "    assert!(regex.is_sparse());",
          "    ",
          "    let result_invalid = builder.build_sparse(r\"[\"); // Invalid regex",
          "    assert!(result_invalid.is_err());",
          "    ",
          "    let result_empty = builder.build_sparse(\"\"); // Empty pattern",
          "    assert!(result_empty.is_ok());",
          "    let regex_empty = result_empty.unwrap();",
          "    assert_eq!(regex_empty.pattern(), \"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let long_pattern = \"a\".repeat(1024);",
          "    let result = builder.build_sparse(&long_pattern);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(result.unwrap().is_some());",
          "    assert!(result.unwrap().forward().is_sparse());",
          "    assert!(result.unwrap().reverse().is_sparse());",
          "    assert_eq!(result.unwrap().pattern(), long_pattern);"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let long_pattern = \"a\".repeat(1024);",
          "    let result = builder.build_sparse(&long_pattern);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(result.unwrap().is_some());",
          "    assert!(result.unwrap().forward().is_sparse());",
          "    assert!(result.unwrap().reverse().is_sparse());",
          "    assert_eq!(result.unwrap().pattern(), long_pattern);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(r\"^(?P<year>\\d{4})-(?P<month>[01]\\d)-(?P<day>[0-3]\\d)$\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let regex = result.unwrap();",
          "    assert_eq!(regex.pattern(), r\"^(?P<year>\\d{4})-(?P<month>[01]\\d)-(?P<day>[0-3]\\d)$\");",
          "    assert!(regex.is_sparse());",
          "    assert!(regex.captures().len() == 3);",
          "    assert!(regex.capture_name(0).is_none());",
          "    assert_eq!(regex.capture_name(1), Some(\"year\"));",
          "    assert_eq!(regex.capture_name(2), Some(\"month\"));",
          "    assert_eq!(regex.capture_name(3), Some(\"day\"));"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(r\"^(?P<year>\\d{4})-(?P<month>[01]\\d)-(?P<day>[0-3]\\d)$\");",
          "    assert!(result.is_ok());",
          "    let regex = result.unwrap();",
          "    assert_eq!(regex.pattern(), r\"^(?P<year>\\d{4})-(?P<month>[01]\\d)-(?P<day>[0-3]\\d)$\");",
          "    assert!(regex.is_sparse());",
          "    assert!(regex.captures().len() == 3);",
          "    assert!(regex.capture_name(0).is_none());",
          "    assert_eq!(regex.capture_name(1), Some(\"year\"));",
          "    assert_eq!(regex.capture_name(2), Some(\"month\"));",
          "    assert_eq!(regex.capture_name(3), Some(\"day\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(\"[a-z\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().kind, BuildErrorKind::Syntax);",
          "    assert_eq!(result.unwrap_err().to_string(), \"Expected ')' at end of regex.\");"
        ],
        "code": [
          "{",
          "    let builder = Builder::new();",
          "    let result = builder.build_sparse(\"[a-z\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().kind, BuildErrorKind::Syntax);",
          "    assert_eq!(result.unwrap_err().to_string(), \"Expected ')' at end of regex.\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]