[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    ",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(0);",
          "    byte_set.add(1);",
          "    byte_set.add(2);",
          "    ",
          "    // Valid range: (0, 2)",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Additional valid range: (0, 255)",
          "    byte_set = ByteSet::empty();",
          "    for i in 0..=255 {",
          "        byte_set.add(i);",
          "    }",
          "    byte_class_set.add_set(&byte_set);",
          "}"
        ],
        "oracle": [
          "    byte_class_set.add_set(&byte_set); // Valid range: (0, 2)",
          "    assert!(byte_class_set.0.contains_range(0, 2)); // Check if range (0, 2) is added",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    for i in 0..=255 {",
          "    byte_set.add(i);",
          "    }",
          "    byte_class_set.add_set(&byte_set); // Additional valid range: (0, 255)",
          "    assert!(byte_class_set.0.contains_range(0, 255)); // Check if range (0, 255) is added",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_class_set.add_set(&byte_set); // Empty set",
          "    assert!(byte_class_set.0.is_empty()); // Check if byte class set remains empty",
          "    ",
          "    let invalid_byte_set = ByteSet::empty();",
          "    byte_class_set.add_set(&invalid_byte_set); // Add set with no ranges",
          "    assert!(byte_class_set.0.is_empty()); // Ensure still empty after adding empty range set"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    ",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(0);",
          "    byte_set.add(1);",
          "    byte_set.add(2);",
          "    ",
          "    // Valid range: (0, 2)",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Additional valid range: (0, 255)",
          "    byte_set = ByteSet::empty();",
          "    for i in 0..=255 {",
          "        byte_set.add(i);",
          "    }",
          "    byte_class_set.add_set(&byte_set);",
          "    byte_class_set.add_set(&byte_set); // Valid range: (0, 2)",
          "    assert!(byte_class_set.0.contains_range(0, 2)); // Check if range (0, 2) is added",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    for i in 0..=255 {",
          "    byte_set.add(i);",
          "    }",
          "    byte_class_set.add_set(&byte_set); // Additional valid range: (0, 255)",
          "    assert!(byte_class_set.0.contains_range(0, 255)); // Check if range (0, 255) is added",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_class_set.add_set(&byte_set); // Empty set",
          "    assert!(byte_class_set.0.is_empty()); // Check if byte class set remains empty",
          "    ",
          "    let invalid_byte_set = ByteSet::empty();",
          "    byte_class_set.add_set(&invalid_byte_set); // Add set with no ranges",
          "    assert!(byte_class_set.0.is_empty()); // Ensure still empty after adding empty range set",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    ",
          "    let mut byte_set = ByteSet::empty();",
          "    ",
          "    // Invalid range: (1, 0) - start > end",
          "    byte_set.add(1);",
          "    byte_set.add(0);",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Invalid range: (-1, 256) - out of bounds",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(256);",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Other invalid ranges",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(257); // still remains empty since 257 is out of bounds",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Edge case: (0, 0) - only one element",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(0);",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Edge case: (255, 255) - only one element at high boundary",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(255);",
          "    byte_class_set.add_set(&byte_set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(byte_class_set.0.is_empty(), true);  // Precondition: set.iter_ranges() returns no valid ranges",
          "    ",
          "    ",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(1);",
          "    byte_set.add(0);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.is_empty(), true);  // Invalid range: (1, 0)",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(256);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.is_empty(), true);  // Invalid range: (256, 256)",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(257);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.is_empty(), true);  // Out of bounds: (257, 257)",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(0);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.contains(0), true);  // Edge case: (0, 0)",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(255);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.contains(255), true);  // Edge case: (255, 255)"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    ",
          "    let mut byte_set = ByteSet::empty();",
          "    ",
          "    // Invalid range: (1, 0) - start > end",
          "    byte_set.add(1);",
          "    byte_set.add(0);",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Invalid range: (-1, 256) - out of bounds",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(256);",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Other invalid ranges",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(257); // still remains empty since 257 is out of bounds",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Edge case: (0, 0) - only one element",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(0);",
          "    byte_class_set.add_set(&byte_set);",
          "    ",
          "    // Edge case: (255, 255) - only one element at high boundary",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(255);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.is_empty(), true);  // Precondition: set.iter_ranges() returns no valid ranges",
          "    ",
          "    ",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(1);",
          "    byte_set.add(0);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.is_empty(), true);  // Invalid range: (1, 0)",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(256);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.is_empty(), true);  // Invalid range: (256, 256)",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(257);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.is_empty(), true);  // Out of bounds: (257, 257)",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(0);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.contains(0), true);  // Edge case: (0, 0)",
          "    ",
          "    byte_set = ByteSet::empty();",
          "    byte_set.add(255);",
          "    byte_class_set.add_set(&byte_set);",
          "    assert_eq!(byte_class_set.0.contains(255), true);  // Edge case: (255, 255)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]