[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0000}', '\\u{0001}')]));",
          "    class_unicode.minimum_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.minimum_len(), Some(1));"
        ],
        "code": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0000}', '\\u{0001}')]));",
          "    class_unicode.minimum_len();",
          "    assert_eq!(class_unicode.minimum_len(), Some(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0100}', '\\u{0101}')]));",
          "    class_unicode.minimum_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.minimum_len(), Some(2));"
        ],
        "code": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0100}', '\\u{0101}')]));",
          "    class_unicode.minimum_len();",
          "    assert_eq!(class_unicode.minimum_len(), Some(2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{1000}', '\\u{1002}')]));",
          "    class_unicode.minimum_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.minimum_len(), Some(1));",
          "    assert_eq!(class_unicode.minimum_len(), Some(2));",
          "    assert_eq!(class_unicode.minimum_len(), Some(3));",
          "    assert_eq!(class_unicode.minimum_len(), Some(4));",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert!(class_unicode.is_utf8());",
          "    assert!(!class_unicode.is_empty());",
          "    assert_eq!(class_unicode.literal(), None);"
        ],
        "code": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{1000}', '\\u{1002}')]));",
          "    class_unicode.minimum_len();",
          "    assert_eq!(class_unicode.minimum_len(), Some(1));",
          "    assert_eq!(class_unicode.minimum_len(), Some(2));",
          "    assert_eq!(class_unicode.minimum_len(), Some(3));",
          "    assert_eq!(class_unicode.minimum_len(), Some(4));",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert!(class_unicode.is_utf8());",
          "    assert!(!class_unicode.is_empty());",
          "    assert_eq!(class_unicode.literal(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{20000}', '\\u{20002}')]));",
          "    class_unicode.minimum_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.minimum_len(), Some(3));"
        ],
        "code": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{20000}', '\\u{20002}')]));",
          "    class_unicode.minimum_len();",
          "    assert_eq!(class_unicode.minimum_len(), Some(3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::empty());",
          "    class_unicode.minimum_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(None, class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{0000}\"..=\"\\u{007F}\"]));",
          "    assert_eq!(Some(1), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{0400}\"..=\"\\u{04FF}\"]));",
          "    assert_eq!(Some(2), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{300}\"..=\"\\u{303}\"]));",
          "    assert_eq!(Some(1), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{1F600}\"..=\"\\u{1F64F}\"]));",
          "    assert_eq!(Some(4), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{1F300}\"..=\"\\u{1F5FF}\"]));",
          "    assert_eq!(Some(4), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![]));",
          "    assert_eq!(None, class_unicode.minimum_len());"
        ],
        "code": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::empty());",
          "    class_unicode.minimum_len();",
          "    assert_eq!(None, class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{0000}\"..=\"\\u{007F}\"]));",
          "    assert_eq!(Some(1), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{0400}\"..=\"\\u{04FF}\"]));",
          "    assert_eq!(Some(2), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{300}\"..=\"\\u{303}\"]));",
          "    assert_eq!(Some(1), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{1F600}\"..=\"\\u{1F64F}\"]));",
          "    assert_eq!(Some(4), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![\"\\u{1F300}\"..=\"\\u{1F5FF}\"]));",
          "    assert_eq!(Some(4), class_unicode.minimum_len());",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![]));",
          "    assert_eq!(None, class_unicode.minimum_len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![]));",
          "    class_unicode.minimum_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    let class_unicode_non_empty = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a'..='z')]));",
          "    assert_eq!(class_unicode_non_empty.minimum_len(), Some(1));",
          "    let class_unicode_cyrillic = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('а'..='я')]));",
          "    assert_eq!(class_unicode_cyrillic.minimum_len(), Some(2));",
          "    let class_unicode_mixed = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a'..='z'), ClassUnicodeRange::new('А'..='Я')]));",
          "    assert_eq!(class_unicode_mixed.minimum_len(), Some(1));",
          "    let class_unicode_negated = Class::Unicode(ClassUnicode { spans: vec![], negated: true, kind: ClassUnicodeKind::SomeKind });",
          "    assert_eq!(class_unicode_negated.minimum_len(), None);",
          "    let class_unicode_empty = Class::Unicode(ClassUnicode::empty());",
          "    assert_eq!(class_unicode_empty.minimum_len(), None);"
        ],
        "code": [
          "{",
          "    let class_unicode = Class::Unicode(ClassUnicode::new(vec![]));",
          "    class_unicode.minimum_len();",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    let class_unicode_non_empty = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a'..='z')]));",
          "    assert_eq!(class_unicode_non_empty.minimum_len(), Some(1));",
          "    let class_unicode_cyrillic = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('а'..='я')]));",
          "    assert_eq!(class_unicode_cyrillic.minimum_len(), Some(2));",
          "    let class_unicode_mixed = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a'..='z'), ClassUnicodeRange::new('А'..='Я')]));",
          "    assert_eq!(class_unicode_mixed.minimum_len(), Some(1));",
          "    let class_unicode_negated = Class::Unicode(ClassUnicode { spans: vec![], negated: true, kind: ClassUnicodeKind::SomeKind });",
          "    assert_eq!(class_unicode_negated.minimum_len(), None);",
          "    let class_unicode_empty = Class::Unicode(ClassUnicode::empty());",
          "    assert_eq!(class_unicode_empty.minimum_len(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]