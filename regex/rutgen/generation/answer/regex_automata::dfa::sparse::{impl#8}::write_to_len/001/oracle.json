[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses::empty();",
          "    let sparse: &[u8] = &[];",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.write_to_len();",
          "}"
        ],
        "oracle": [
          "    let classes = ByteClasses::empty();",
          "    let sparse: &[u8] = &[];",
          "    let transitions = Transitions { sparse, classes, state_len: 1, pattern_len: 0 };",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse().len());",
          "    ",
          "    let classes = ByteClasses::singletons();",
          "    let sparse: &[u8] = &[1, 2, 3];",
          "    let transitions = Transitions { sparse, classes, state_len: 1, pattern_len: 2 };",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse().len());",
          "    ",
          "    let classes = ByteClasses::empty();",
          "    let sparse: &[u8] = &[4, 5, 6, 7];",
          "    let transitions = Transitions { sparse, classes, state_len: 3, pattern_len: 1 };",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse().len());"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses::empty();",
          "    let sparse: &[u8] = &[];",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.write_to_len();",
          "    let classes = ByteClasses::empty();",
          "    let sparse: &[u8] = &[];",
          "    let transitions = Transitions { sparse, classes, state_len: 1, pattern_len: 0 };",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse().len());",
          "    ",
          "    let classes = ByteClasses::singletons();",
          "    let sparse: &[u8] = &[1, 2, 3];",
          "    let transitions = Transitions { sparse, classes, state_len: 1, pattern_len: 2 };",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse().len());",
          "    ",
          "    let classes = ByteClasses::empty();",
          "    let sparse: &[u8] = &[4, 5, 6, 7];",
          "    let transitions = Transitions { sparse, classes, state_len: 3, pattern_len: 1 };",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse().len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses::singletons();",
          "    let sparse: &[u8] = &[0u8];",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 1,",
          "    };",
          "    transitions.write_to_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse.len());"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses::singletons();",
          "    let sparse: &[u8] = &[0u8];",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 1,",
          "    };",
          "    transitions.write_to_len();",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses::empty();",
          "    let sparse: &[u8] = &[1u8, 2u8, 3u8];",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 2,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.write_to_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transitions.state_len, 2);",
          "    assert_eq!(transitions.pattern_len, 0);",
          "    assert_eq!(transitions.classes.write_to_len(), 256);",
          "    assert_eq!(transitions.sparse().len(), 3);",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + 256 + size_of::<u32>() + 3);"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses::empty();",
          "    let sparse: &[u8] = &[1u8, 2u8, 3u8];",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 2,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.write_to_len();",
          "    assert_eq!(transitions.state_len, 2);",
          "    assert_eq!(transitions.pattern_len, 0);",
          "    assert_eq!(transitions.classes.write_to_len(), 256);",
          "    assert_eq!(transitions.sparse().len(), 3);",
          "    assert_eq!(transitions.write_to_len(), size_of::<u32>() + size_of::<u32>() + 256 + size_of::<u32>() + 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses::singletons();",
          "    let sparse: &[u8] = &vec![0u8; 256]; // maximum length for a byte array",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 2,",
          "        pattern_len: 5,",
          "    };",
          "    transitions.write_to_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(size_of::<u32>(), 4); // state length",
          "    assert_eq!(size_of::<u32>(), 4); // pattern length",
          "    assert_eq!(transitions.classes.write_to_len(), 256); // size of ByteClasses",
          "    assert_eq!(size_of::<u32>(), 4); // sparse transitions length",
          "    assert_eq!(transitions.sparse().len(), 256); // length of sparse transitions",
          "    assert_eq!(transitions.write_to_len(), 4 + 4 + 256 + 4 + 256); // total length"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses::singletons();",
          "    let sparse: &[u8] = &vec![0u8; 256]; // maximum length for a byte array",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 2,",
          "        pattern_len: 5,",
          "    };",
          "    transitions.write_to_len();",
          "    assert_eq!(size_of::<u32>(), 4); // state length",
          "    assert_eq!(size_of::<u32>(), 4); // pattern length",
          "    assert_eq!(transitions.classes.write_to_len(), 256); // size of ByteClasses",
          "    assert_eq!(size_of::<u32>(), 4); // sparse transitions length",
          "    assert_eq!(transitions.sparse().len(), 256); // length of sparse transitions",
          "    assert_eq!(transitions.write_to_len(), 4 + 4 + 256 + 4 + 256); // total length",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_classes = ByteClasses::empty();",
          "    byte_classes.set(0u8, 0u8);",
          "",
          "    let sparse: &[u8] = &[0u8, 1u8, 2u8];",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes: byte_classes,",
          "        state_len: 2,",
          "        pattern_len: 1,",
          "    };",
          "    transitions.write_to_len();",
          "}"
        ],
        "oracle": [
          "    size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse().len() == 16;",
          "    transitions.state_len == 2;",
          "    transitions.pattern_len == 1;",
          "    transitions.sparse.len() == 3;",
          "    transitions.classes.get(0u8) == 0u8;"
        ],
        "code": [
          "{",
          "    let mut byte_classes = ByteClasses::empty();",
          "    byte_classes.set(0u8, 0u8);",
          "",
          "    let sparse: &[u8] = &[0u8, 1u8, 2u8];",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes: byte_classes,",
          "        state_len: 2,",
          "        pattern_len: 1,",
          "    };",
          "    transitions.write_to_len();",
          "    size_of::<u32>() + size_of::<u32>() + transitions.classes.write_to_len() + size_of::<u32>() + transitions.sparse().len() == 16;",
          "    transitions.state_len == 2;",
          "    transitions.pattern_len == 1;",
          "    transitions.sparse.len() == 3;",
          "    transitions.classes.get(0u8) == 0u8;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]