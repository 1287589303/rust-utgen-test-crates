[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: None,",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::StartText,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: None,",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: None,",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::StartText,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::Start)));"
        ],
        "code": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: None,",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::StartText,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: None,",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: None,",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::StartText,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::Start)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: None,",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::EndText,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    _assertion.kind = ast::AssertionKind::StartText;",
          "    _result.unwrap() == Hir::look(hir::Look::Start);",
          "    ",
          "    _assertion.kind = ast::AssertionKind::EndText;",
          "    _result.unwrap() == Hir::look(hir::Look::End);",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundary;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordUnicode",
          "    } else {",
          "    hir::Look::WordAscii",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::NotWordBoundary;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordUnicodeNegate",
          "    } else {",
          "    hir::Look::WordAsciiNegate",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundaryStart;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordStartUnicode",
          "    } else {",
          "    hir::Look::WordStartAscii",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundaryEnd;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordEndUnicode",
          "    } else {",
          "    hir::Look::WordEndAscii",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundaryStartHalf;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordStartHalfUnicode",
          "    } else {",
          "    hir::Look::WordStartHalfAscii",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundaryEndHalf;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordEndHalfUnicode",
          "    } else {",
          "    hir::Look::WordEndHalfAscii",
          "    });"
        ],
        "code": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: None,",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::EndText,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "    _assertion.kind = ast::AssertionKind::StartText;",
          "    _result.unwrap() == Hir::look(hir::Look::Start);",
          "    ",
          "    _assertion.kind = ast::AssertionKind::EndText;",
          "    _result.unwrap() == Hir::look(hir::Look::End);",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundary;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordUnicode",
          "    } else {",
          "    hir::Look::WordAscii",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::NotWordBoundary;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordUnicodeNegate",
          "    } else {",
          "    hir::Look::WordAsciiNegate",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundaryStart;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordStartUnicode",
          "    } else {",
          "    hir::Look::WordStartAscii",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundaryEnd;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordEndUnicode",
          "    } else {",
          "    hir::Look::WordEndAscii",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundaryStartHalf;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordStartHalfUnicode",
          "    } else {",
          "    hir::Look::WordStartHalfAscii",
          "    });",
          "    ",
          "    _assertion.kind = ast::AssertionKind::WordBoundaryEndHalf;",
          "    _result.unwrap() == Hir::look(if trans.flags.get().unicode {",
          "    hir::Look::WordEndHalfUnicode",
          "    } else {",
          "    hir::Look::WordEndHalfAscii",
          "    });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(true),",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), crlf: None, }), utf8: true, line_terminator: b'\\n', };",
          "    ",
          "    let assertion_start_text = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::StartText, };",
          "    let result_start_text = translator.hir_assertion(&assertion_start_text);",
          "    assert_eq!(result_start_text, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let assertion_end_text = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::EndText, };",
          "    let result_end_text = translator.hir_assertion(&assertion_end_text);",
          "    assert_eq!(result_end_text, Ok(Hir::look(hir::Look::End)));",
          "    ",
          "    let assertion_word_boundary = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundary, };",
          "    let result_word_boundary = translator.hir_assertion(&assertion_word_boundary);",
          "    assert_eq!(result_word_boundary, Ok(Hir::look(hir::Look::WordUnicode)));",
          "    ",
          "    let assertion_not_word_boundary = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::NotWordBoundary, };",
          "    let result_not_word_boundary = translator.hir_assertion(&assertion_not_word_boundary);",
          "    assert_eq!(result_not_word_boundary, Ok(Hir::look(hir::Look::WordUnicodeNegate)));",
          "    ",
          "    let assertion_word_boundary_start = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundaryStart, };",
          "    let result_word_boundary_start = translator.hir_assertion(&assertion_word_boundary_start);",
          "    assert_eq!(result_word_boundary_start, Ok(Hir::look(hir::Look::WordStartUnicode)));",
          "    ",
          "    let assertion_word_boundary_end = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundaryEnd, };",
          "    let result_word_boundary_end = translator.hir_assertion(&assertion_word_boundary_end);",
          "    assert_eq!(result_word_boundary_end, Ok(Hir::look(hir::Look::WordEndUnicode)));",
          "    ",
          "    let assertion_word_boundary_start_half = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundaryStartHalf, };",
          "    let result_word_boundary_start_half = translator.hir_assertion(&assertion_word_boundary_start_half);",
          "    assert_eq!(result_word_boundary_start_half, Ok(Hir::look(hir::Look::WordStartHalfUnicode)));",
          "    ",
          "    let assertion_word_boundary_end_half = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundaryEndHalf, };",
          "    let result_word_boundary_end_half = translator.hir_assertion(&assertion_word_boundary_end_half);",
          "    assert_eq!(result_word_boundary_end_half, Ok(Hir::look(hir::Look::WordEndHalfUnicode)));"
        ],
        "code": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(true),",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), crlf: None, }), utf8: true, line_terminator: b'\\n', };",
          "    ",
          "    let assertion_start_text = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::StartText, };",
          "    let result_start_text = translator.hir_assertion(&assertion_start_text);",
          "    assert_eq!(result_start_text, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let assertion_end_text = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::EndText, };",
          "    let result_end_text = translator.hir_assertion(&assertion_end_text);",
          "    assert_eq!(result_end_text, Ok(Hir::look(hir::Look::End)));",
          "    ",
          "    let assertion_word_boundary = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundary, };",
          "    let result_word_boundary = translator.hir_assertion(&assertion_word_boundary);",
          "    assert_eq!(result_word_boundary, Ok(Hir::look(hir::Look::WordUnicode)));",
          "    ",
          "    let assertion_not_word_boundary = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::NotWordBoundary, };",
          "    let result_not_word_boundary = translator.hir_assertion(&assertion_not_word_boundary);",
          "    assert_eq!(result_not_word_boundary, Ok(Hir::look(hir::Look::WordUnicodeNegate)));",
          "    ",
          "    let assertion_word_boundary_start = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundaryStart, };",
          "    let result_word_boundary_start = translator.hir_assertion(&assertion_word_boundary_start);",
          "    assert_eq!(result_word_boundary_start, Ok(Hir::look(hir::Look::WordStartUnicode)));",
          "    ",
          "    let assertion_word_boundary_end = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundaryEnd, };",
          "    let result_word_boundary_end = translator.hir_assertion(&assertion_word_boundary_end);",
          "    assert_eq!(result_word_boundary_end, Ok(Hir::look(hir::Look::WordEndUnicode)));",
          "    ",
          "    let assertion_word_boundary_start_half = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundaryStartHalf, };",
          "    let result_word_boundary_start_half = translator.hir_assertion(&assertion_word_boundary_start_half);",
          "    assert_eq!(result_word_boundary_start_half, Ok(Hir::look(hir::Look::WordStartHalfUnicode)));",
          "    ",
          "    let assertion_word_boundary_end_half = ast::Assertion { span: Span::new(0, 1), kind: ast::AssertionKind::WordBoundaryEndHalf, };",
          "    let result_word_boundary_end_half = translator.hir_assertion(&assertion_word_boundary_end_half);",
          "    assert_eq!(result_word_boundary_end_half, Ok(Hir::look(hir::Look::WordEndHalfUnicode)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(false),",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: None,",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: Some(false),",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion_start_text = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::StartText,",
          "    };",
          "    let result_start_text = translator.hir_assertion(&assertion_start_text);",
          "    assert_eq!(result_start_text, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let assertion_end_text = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::EndText,",
          "    };",
          "    let result_end_text = translator.hir_assertion(&assertion_end_text);",
          "    assert_eq!(result_end_text, Ok(Hir::look(hir::Look::End)));",
          "    ",
          "    let assertion_word_boundary = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    let result_word_boundary = translator.hir_assertion(&assertion_word_boundary);",
          "    assert_eq!(result_word_boundary, Ok(Hir::look(hir::Look::WordAscii)));",
          "    ",
          "    let assertion_not_word_boundary = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    let result_not_word_boundary = translator.hir_assertion(&assertion_not_word_boundary);",
          "    assert_eq!(result_not_word_boundary, Ok(Hir::look(hir::Look::WordAsciiNegate)));",
          "    ",
          "    let assertion_word_boundary_start = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::WordBoundaryStart,",
          "    };",
          "    let result_word_boundary_start = translator.hir_assertion(&assertion_word_boundary_start);",
          "    assert_eq!(result_word_boundary_start, Ok(Hir::look(hir::Look::WordStartAscii)));",
          "    ",
          "    let assertion_word_boundary_end = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::WordBoundaryEnd,",
          "    };",
          "    let result_word_boundary_end = translator.hir_assertion(&assertion_word_boundary_end);",
          "    assert_eq!(result_word_boundary_end, Ok(Hir::look(hir::Look::WordEndAscii)));"
        ],
        "code": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(false),",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: None,",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: Some(false),",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion_start_text = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::StartText,",
          "    };",
          "    let result_start_text = translator.hir_assertion(&assertion_start_text);",
          "    assert_eq!(result_start_text, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let assertion_end_text = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::EndText,",
          "    };",
          "    let result_end_text = translator.hir_assertion(&assertion_end_text);",
          "    assert_eq!(result_end_text, Ok(Hir::look(hir::Look::End)));",
          "    ",
          "    let assertion_word_boundary = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    let result_word_boundary = translator.hir_assertion(&assertion_word_boundary);",
          "    assert_eq!(result_word_boundary, Ok(Hir::look(hir::Look::WordAscii)));",
          "    ",
          "    let assertion_not_word_boundary = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    let result_not_word_boundary = translator.hir_assertion(&assertion_not_word_boundary);",
          "    assert_eq!(result_not_word_boundary, Ok(Hir::look(hir::Look::WordAsciiNegate)));",
          "    ",
          "    let assertion_word_boundary_start = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::WordBoundaryStart,",
          "    };",
          "    let result_word_boundary_start = translator.hir_assertion(&assertion_word_boundary_start);",
          "    assert_eq!(result_word_boundary_start, Ok(Hir::look(hir::Look::WordStartAscii)));",
          "    ",
          "    let assertion_word_boundary_end = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::WordBoundaryEnd,",
          "    };",
          "    let result_word_boundary_end = translator.hir_assertion(&assertion_word_boundary_end);",
          "    assert_eq!(result_word_boundary_end, Ok(Hir::look(hir::Look::WordEndAscii)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: Some(true),",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: None,",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::StartLine,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: Some(true),",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: None,",
          "    crlf: Some(true),",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::StartLine,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::StartCRLF)));",
          "    ",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: Some(true),",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: Some(true),",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::StartLine,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: Some(false),",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: None,",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::EndLine,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::End)));",
          "    ",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: Some(true),",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: Some(true),",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::WordUnicode)));",
          "    ",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: None,",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: Some(false),",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::WordAsciiNegate)));"
        ],
        "code": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: Some(true),",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: None,",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::StartLine,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: Some(true),",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: None,",
          "    crlf: Some(true),",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::StartLine,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::StartCRLF)));",
          "    ",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: Some(true),",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: Some(true),",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::StartLine,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: Some(false),",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: None,",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::EndLine,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::End)));",
          "    ",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: Some(true),",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: Some(true),",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::WordUnicode)));",
          "    ",
          "    let trans = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    case_insensitive: None,",
          "    multi_line: None,",
          "    dot_matches_new_line: None,",
          "    swap_greed: None,",
          "    unicode: Some(false),",
          "    crlf: None,",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    let assertion = ast::Assertion {",
          "    span: Span::new(0, 1),",
          "    kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let result = translator.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::WordAsciiNegate)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: Some(true),",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: None,",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::EndLine,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind == ast::AssertionKind::StartText",
          "    assertion.kind == ast::AssertionKind::EndLine",
          "    result.is_ok()",
          "    result.unwrap() == Hir::look(hir::Look::End)",
          "    result.unwrap() == Hir::look(if trans.flags().multi_line() { hir::Look::EndLF } else { hir::Look::End })",
          "    trans.flags().unicode() == false",
          "    trans.flags().multi_line() == true",
          "    trans.flags().crlf() == false",
          "    trans.flags().case_insensitive() == false",
          "    trans.stack.borrow().is_empty()"
        ],
        "code": [
          "{",
          "    let trans = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: Some(true),",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: None,",
          "            crlf: None,",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let assertion = ast::Assertion {",
          "        span: Span::new(0, 1),",
          "        kind: ast::AssertionKind::EndLine,",
          "    };",
          "    ",
          "    let translator = TranslatorI::new(&trans, \"test\");",
          "    let _result = translator.hir_assertion(&assertion);",
          "    assertion.kind == ast::AssertionKind::StartText",
          "    assertion.kind == ast::AssertionKind::EndLine",
          "    result.is_ok()",
          "    result.unwrap() == Hir::look(hir::Look::End)",
          "    result.unwrap() == Hir::look(if trans.flags().multi_line() { hir::Look::EndLF } else { hir::Look::End })",
          "    trans.flags().unicode() == false",
          "    trans.flags().multi_line() == true",
          "    trans.flags().crlf() == false",
          "    trans.flags().case_insensitive() == false",
          "    trans.stack.borrow().is_empty()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]