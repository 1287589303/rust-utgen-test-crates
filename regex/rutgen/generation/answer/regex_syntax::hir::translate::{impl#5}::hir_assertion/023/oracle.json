[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartLine,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(visitor.trans.hir_assertion(&assertion), Ok(Hir::look(hir::Look::Start)));",
          "    assert_eq!(visitor.trans.flags().multi_line(), true);",
          "    assert_eq!(visitor.trans.flags().crlf(), false);",
          "    assert_eq!(visitor.trans.flags().unicode(), true);"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartLine,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    assert_eq!(visitor.trans.hir_assertion(&assertion), Ok(Hir::look(hir::Look::Start)));",
          "    assert_eq!(visitor.trans.flags().multi_line(), true);",
          "    assert_eq!(visitor.trans.flags().crlf(), false);",
          "    assert_eq!(visitor.trans.flags().unicode(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndLine,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind == ast::AssertionKind::StartLine",
          "    visitor.trans.flags().multi_line == true",
          "    visitor.trans.flags().crlf == false",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, .. }) == Ok(Hir::look(hir::Look::Start))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndLine, .. }) == Ok(Hir::look(hir::Look::End))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartText, .. }) == Ok(Hir::look(hir::Look::Start))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndText, .. }) == Ok(Hir::look(hir::Look::End))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, .. }) == Ok(Hir::look(hir::Look::WordAscii))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, .. }) == Ok(Hir::look(hir::Look::WordAsciiNegate))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, .. }) == Ok(Hir::look(hir::Look::WordStartAscii))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, .. }) == Ok(Hir::look(hir::Look::WordEndAscii))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, .. }) == Ok(Hir::look(hir::Look::WordStartHalfAscii))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, .. }) == Ok(Hir::look(hir::Look::WordEndHalfAscii))"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndLine,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    assertion.kind == ast::AssertionKind::StartLine",
          "    visitor.trans.flags().multi_line == true",
          "    visitor.trans.flags().crlf == false",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, .. }) == Ok(Hir::look(hir::Look::Start))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndLine, .. }) == Ok(Hir::look(hir::Look::End))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartText, .. }) == Ok(Hir::look(hir::Look::Start))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndText, .. }) == Ok(Hir::look(hir::Look::End))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, .. }) == Ok(Hir::look(hir::Look::WordAscii))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, .. }) == Ok(Hir::look(hir::Look::WordAsciiNegate))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, .. }) == Ok(Hir::look(hir::Look::WordStartAscii))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, .. }) == Ok(Hir::look(hir::Look::WordEndAscii))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, .. }) == Ok(Hir::look(hir::Look::WordStartHalfAscii))",
          "    assert visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, .. }) == Ok(Hir::look(hir::Look::WordEndHalfAscii))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartText,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, ..assertion });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, ..assertion }).unwrap(), Hir::look(hir::Look::Start));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), crlf: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndLine, ..assertion }).unwrap(), Hir::look(hir::Look::End));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(false), crlf: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartText, ..assertion }).unwrap(), Hir::look(hir::Look::Start));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), crlf: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, ..assertion }).unwrap(), Hir::look(hir::Look::StartCRLF));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), crlf: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, ..assertion }).unwrap(), Hir::look(hir::Look::WordUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, ..assertion }).unwrap(), Hir::look(hir::Look::WordAscii));",
          "    visitor.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, ..assertion }).unwrap(), Hir::look(hir::Look::WordUnicodeNegate));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, ..assertion }).unwrap(), Hir::look(hir::Look::WordAsciiNegate));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, ..assertion }).unwrap(), Hir::look(hir::Look::WordStartUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, ..assertion }).unwrap(), Hir::look(hir::Look::WordStartAscii));",
          "    visitor.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, ..assertion }).unwrap(), Hir::look(hir::Look::WordEndUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, ..assertion }).unwrap(), Hir::look(hir::Look::WordEndAscii));",
          "    visitor.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, ..assertion }).unwrap(), Hir::look(hir::Look::WordStartHalfUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, ..assertion }).unwrap(), Hir::look(hir::Look::WordStartHalfAscii));",
          "    visitor.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, ..assertion }).unwrap(), Hir::look(hir::Look::WordEndHalfUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, ..assertion }).unwrap(), Hir::look(hir::Look::WordEndHalfAscii));"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::StartText,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, ..assertion });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, ..assertion }).unwrap(), Hir::look(hir::Look::Start));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), crlf: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndLine, ..assertion }).unwrap(), Hir::look(hir::Look::End));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(false), crlf: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartText, ..assertion }).unwrap(), Hir::look(hir::Look::Start));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), crlf: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, ..assertion }).unwrap(), Hir::look(hir::Look::StartCRLF));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), crlf: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, ..assertion }).unwrap(), Hir::look(hir::Look::WordUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, ..assertion }).unwrap(), Hir::look(hir::Look::WordAscii));",
          "    visitor.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, ..assertion }).unwrap(), Hir::look(hir::Look::WordUnicodeNegate));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, ..assertion }).unwrap(), Hir::look(hir::Look::WordAsciiNegate));",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, ..assertion }).unwrap(), Hir::look(hir::Look::WordStartUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, ..assertion }).unwrap(), Hir::look(hir::Look::WordStartAscii));",
          "    visitor.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, ..assertion }).unwrap(), Hir::look(hir::Look::WordEndUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, ..assertion }).unwrap(), Hir::look(hir::Look::WordEndAscii));",
          "    visitor.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, ..assertion }).unwrap(), Hir::look(hir::Look::WordStartHalfUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, ..assertion }).unwrap(), Hir::look(hir::Look::WordStartHalfAscii));",
          "    visitor.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, ..assertion }).unwrap(), Hir::look(hir::Look::WordEndHalfUnicode));",
          "    visitor.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, ..assertion }).unwrap(), Hir::look(hir::Look::WordEndHalfAscii));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndText,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    visitor.trans.flags().multi_line == true",
          "    visitor.trans.flags().crlf == false",
          "    let assertion = ast::Assertion { kind: ast::AssertionKind::StartLine, .. }",
          "    assert_eq!(visitor.trans.hir_assertion(&assertion), Ok(Hir::look(hir::Look::Start)))"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::EndText,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    visitor.trans.flags().multi_line == true",
          "    visitor.trans.flags().crlf == false",
          "    let assertion = ast::Assertion { kind: ast::AssertionKind::StartLine, .. }",
          "    assert_eq!(visitor.trans.hir_assertion(&assertion), Ok(Hir::look(hir::Look::Start)))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap() == Hir::look(hir::Look::Start)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap() == Hir::look(hir::Look::StartLF)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap() == Hir::look(hir::Look::StartCRLF)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine }).unwrap() == Hir::look(hir::Look::End)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine }).unwrap() == Hir::look(hir::Look::EndLF)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine }).unwrap() == Hir::look(hir::Look::EndCRLF)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartText }).unwrap() == Hir::look(hir::Look::Start)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndText }).unwrap() == Hir::look(hir::Look::End)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundary }).unwrap() == Hir::look(hir::Look::WordUnicode)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::NotWordBoundary }).unwrap() == Hir::look(hir::Look::WordUnicodeNegate)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStart }).unwrap() == Hir::look(hir::Look::WordStartUnicode)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEnd }).unwrap() == Hir::look(hir::Look::WordEndUnicode)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartHalf }).unwrap() == Hir::look(hir::Look::WordStartHalfUnicode)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndHalf }).unwrap() == Hir::look(hir::Look::WordEndHalfUnicode)"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundary,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap() == Hir::look(hir::Look::Start)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap() == Hir::look(hir::Look::StartLF)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap() == Hir::look(hir::Look::StartCRLF)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine }).unwrap() == Hir::look(hir::Look::End)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine }).unwrap() == Hir::look(hir::Look::EndLF)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndLine }).unwrap() == Hir::look(hir::Look::EndCRLF)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartText }).unwrap() == Hir::look(hir::Look::Start)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::EndText }).unwrap() == Hir::look(hir::Look::End)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundary }).unwrap() == Hir::look(hir::Look::WordUnicode)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::NotWordBoundary }).unwrap() == Hir::look(hir::Look::WordUnicodeNegate)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStart }).unwrap() == Hir::look(hir::Look::WordStartUnicode)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEnd }).unwrap() == Hir::look(hir::Look::WordEndUnicode)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryStartHalf }).unwrap() == Hir::look(hir::Look::WordStartHalfUnicode)",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::WordBoundaryEndHalf }).unwrap() == Hir::look(hir::Look::WordEndHalfUnicode)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    assertion.kind = ast::AssertionKind::StartLine;",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), crlf: Some(false), unicode: Some(true), ..Flags::default() });",
          "    let result = visitor.trans.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::Start)));"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::NotWordBoundary,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    assertion.kind = ast::AssertionKind::StartLine;",
          "    visitor.trans.flags.set(Flags { multi_line: Some(true), crlf: Some(false), unicode: Some(true), ..Flags::default() });",
          "    let result = visitor.trans.hir_assertion(&assertion);",
          "    assert_eq!(result, Ok(Hir::look(hir::Look::Start)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStart,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    visitor.trans.flags().multi_line.unwrap() == true",
          "    visitor.trans.flags().crlf.unwrap() == false",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }",
          "    let result = visitor.trans.hir_assertion(&assertion);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Hir::look(hir::Look::Start));"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStart,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    visitor.trans.flags().multi_line.unwrap() == true",
          "    visitor.trans.flags().crlf.unwrap() == false",
          "    let assertion = ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }",
          "    let result = visitor.trans.hir_assertion(&assertion);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Hir::look(hir::Look::Start));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEnd,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine });",
          "    assert_eq!(visitor.trans.flags().multi_line, Some(true));",
          "    assert_eq!(visitor.trans.flags().crlf, Some(false));",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap(), Hir::look(hir::Look::Start));"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEnd,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine });",
          "    assert_eq!(visitor.trans.flags().multi_line, Some(true));",
          "    assert_eq!(visitor.trans.flags().crlf, Some(false));",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { span: Span::default(), kind: ast::AssertionKind::StartLine }).unwrap(), Hir::look(hir::Look::Start));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartHalf,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    visitor.trans.flags.get().multi_line == true",
          "    visitor.trans.flags.get().crlf == false",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, .. }) == Ok(Hir::look(hir::Look::Start))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndLine, .. }) == Ok(Hir::look(hir::Look::End))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartText, .. }) == Ok(Hir::look(hir::Look::Start))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndText, .. }) == Ok(Hir::look(hir::Look::End))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, .. }) == Ok(Hir::look(hir::Look::WordUnicode))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, .. }) == Ok(Hir::look(hir::Look::WordUnicodeNegate))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, .. }) == Ok(Hir::look(hir::Look::WordStartUnicode))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, .. }) == Ok(Hir::look(hir::Look::WordEndUnicode))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, .. }) == Ok(Hir::look(hir::Look::WordStartHalfUnicode))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, .. }) == Ok(Hir::look(hir::Look::WordEndHalfUnicode))"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryStartHalf,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    visitor.trans.flags.get().multi_line == true",
          "    visitor.trans.flags.get().crlf == false",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, .. }) == Ok(Hir::look(hir::Look::Start))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndLine, .. }) == Ok(Hir::look(hir::Look::End))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartText, .. }) == Ok(Hir::look(hir::Look::Start))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndText, .. }) == Ok(Hir::look(hir::Look::End))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, .. }) == Ok(Hir::look(hir::Look::WordUnicode))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, .. }) == Ok(Hir::look(hir::Look::WordUnicodeNegate))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, .. }) == Ok(Hir::look(hir::Look::WordStartUnicode))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, .. }) == Ok(Hir::look(hir::Look::WordEndUnicode))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, .. }) == Ok(Hir::look(hir::Look::WordStartHalfUnicode))",
          "    visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, .. }) == Ok(Hir::look(hir::Look::WordEndHalfUnicode))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndHalf,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "}"
        ],
        "oracle": [
          "    visitor.trans.flags().multi_line.unwrap() == true",
          "    visitor.trans.flags().crlf.unwrap() == false",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, ..Default::default() }), Ok(Hir::look(hir::Look::Start)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndLine, ..Default::default() }), Ok(Hir::look(hir::Look::End)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartText, ..Default::default() }), Ok(Hir::look(hir::Look::Start)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndText, ..Default::default() }), Ok(Hir::look(hir::Look::End)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, ..Default::default() }), Ok(Hir::look(hir::Look::WordUnicode)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, ..Default::default() }), Ok(Hir::look(hir::Look::WordUnicodeNegate)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, ..Default::default() }), Ok(Hir::look(hir::Look::WordStartUnicode)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, ..Default::default() }), Ok(Hir::look(hir::Look::WordEndUnicode)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, ..Default::default() }), Ok(Hir::look(hir::Look::WordStartHalfUnicode)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, ..Default::default() }), Ok(Hir::look(hir::Look::WordEndHalfUnicode)))"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        trans: Translator,",
          "    }",
          "",
          "    let mut visitor = TestVisitor {",
          "        trans: Translator {",
          "            stack: RefCell::new(vec![]),",
          "            flags: Cell::new(Flags {",
          "                multi_line: Some(true),",
          "                crlf: Some(false),",
          "                unicode: Some(true),",
          "                ..Flags::default()",
          "            }),",
          "            utf8: false,",
          "            line_terminator: b'\\n',",
          "        },",
          "    };",
          "",
          "    let assertion = ast::Assertion {",
          "        span: Span::default(),",
          "        kind: ast::AssertionKind::WordBoundaryEndHalf,",
          "    };",
          "",
          "    visitor.trans.hir_assertion(&assertion);",
          "    visitor.trans.flags().multi_line.unwrap() == true",
          "    visitor.trans.flags().crlf.unwrap() == false",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartLine, ..Default::default() }), Ok(Hir::look(hir::Look::Start)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndLine, ..Default::default() }), Ok(Hir::look(hir::Look::End)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::StartText, ..Default::default() }), Ok(Hir::look(hir::Look::Start)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::EndText, ..Default::default() }), Ok(Hir::look(hir::Look::End)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundary, ..Default::default() }), Ok(Hir::look(hir::Look::WordUnicode)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, ..Default::default() }), Ok(Hir::look(hir::Look::WordUnicodeNegate)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStart, ..Default::default() }), Ok(Hir::look(hir::Look::WordStartUnicode)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEnd, ..Default::default() }), Ok(Hir::look(hir::Look::WordEndUnicode)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryStartHalf, ..Default::default() }), Ok(Hir::look(hir::Look::WordStartHalfUnicode)))",
          "    assert_eq!(visitor.trans.hir_assertion(&ast::Assertion { kind: ast::AssertionKind::WordBoundaryEndHalf, ..Default::default() }), Ok(Hir::look(hir::Look::WordEndHalfUnicode)))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]