[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"test input\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input {",
          "        haystack,",
          "        span,",
          "        anchored: Anchored::No,",
          "        earliest: false,",
          "    };",
          "",
          "    let state_id = StateID(SmallIndex::new(1));",
          "    let slot_table = SlotTable { ",
          "        table: vec![Some(NonMaxUsize(1)); 2], ",
          "        slots_per_state: 2, ",
          "        slots_for_captures: 2 ",
          "    };",
          "",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet {",
          "        len: 1,",
          "        dense: vec![state_id],",
          "        sparse: vec![state_id],",
          "    };",
          "",
          "    let curr = ActiveStates {",
          "        set: sparse_set,",
          "        slot_table,",
          "    };",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(0),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::All),",
          "        ..Default::default()",
          "    };",
          "",
          "    let pike_vm = PikeVM {",
          "        config,",
          "        nfa: NFA(Arc::new(Inner::default())),",
          "    };",
          "",
          "    let at = 0;",
          "",
          "    let _pid = pike_vm.nexts(",
          "        &mut stack,",
          "        &mut curr,",
          "        &mut next,",
          "        &input,",
          "        at,",
          "        &mut slots,",
          "    );",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = b\"test input\";",
          "    let input = Input { haystack, span: Span::new(0, haystack.len()), anchored: Anchored::No, earliest: false };",
          "    let state_id = StateID(SmallIndex::new(1));",
          "    let slot_table = SlotTable { table: vec![Some(NonMaxUsize(1)); 2], slots_per_state: 2, slots_for_captures: 2 };",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet { len: 1, dense: vec![state_id], sparse: vec![state_id] };",
          "    let curr = ActiveStates { set: sparse_set, slot_table };",
          "    let mut next = ActiveStates { set: SparseSet::new(0), slot_table: SlotTable::new() };",
          "    let config = Config { match_kind: Some(MatchKind::All), ..Default::default() };",
          "    let pike_vm = PikeVM { config, nfa: NFA(Arc::new(Inner::default())) };",
          "    let at = 0;",
          "    let pid = pike_vm.nexts(&mut stack, &mut curr, &mut next, &input, at, &mut slots);",
          "    assert!(pid.is_some());",
          "    ",
          "    let no_match_pid = { let mut curr_no_match = curr.clone(); curr_no_match.set.len = 0; pike_vm.nexts(&mut stack, &mut curr_no_match, &mut next, &input, at, &mut slots) };",
          "    assert!(no_match_pid.is_none());",
          "    ",
          "    let empty_stack_pid = { let mut curr_empty_stack = curr.clone(); pike_vm.nexts(&mut Vec::new(), &mut curr_empty_stack, &mut next, &input, at, &mut slots) };",
          "    assert!(empty_stack_pid.is_some());",
          "    ",
          "    let kind_match_pid = {",
          "    let mut kind_curr = ActiveStates {",
          "    set: SparseSet { len: 1, dense: vec![StateID(SmallIndex::new(0))], sparse: vec![StateID(SmallIndex::new(0))] },",
          "    slot_table: SlotTable { table: vec![Some(NonMaxUsize(1)); 2], slots_per_state: 2, slots_for_captures: 2 }",
          "    };",
          "    pike_vm.nexts(&mut stack, &mut kind_curr, &mut next, &input, at, &mut slots)",
          "    };",
          "    assert_eq!(kind_match_pid, pid);"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"test input\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input {",
          "        haystack,",
          "        span,",
          "        anchored: Anchored::No,",
          "        earliest: false,",
          "    };",
          "",
          "    let state_id = StateID(SmallIndex::new(1));",
          "    let slot_table = SlotTable { ",
          "        table: vec![Some(NonMaxUsize(1)); 2], ",
          "        slots_per_state: 2, ",
          "        slots_for_captures: 2 ",
          "    };",
          "",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet {",
          "        len: 1,",
          "        dense: vec![state_id],",
          "        sparse: vec![state_id],",
          "    };",
          "",
          "    let curr = ActiveStates {",
          "        set: sparse_set,",
          "        slot_table,",
          "    };",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(0),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::All),",
          "        ..Default::default()",
          "    };",
          "",
          "    let pike_vm = PikeVM {",
          "        config,",
          "        nfa: NFA(Arc::new(Inner::default())),",
          "    };",
          "",
          "    let at = 0;",
          "",
          "    let _pid = pike_vm.nexts(",
          "        &mut stack,",
          "        &mut curr,",
          "        &mut next,",
          "        &input,",
          "        at,",
          "        &mut slots,",
          "    );",
          "    let haystack: &[u8] = b\"test input\";",
          "    let input = Input { haystack, span: Span::new(0, haystack.len()), anchored: Anchored::No, earliest: false };",
          "    let state_id = StateID(SmallIndex::new(1));",
          "    let slot_table = SlotTable { table: vec![Some(NonMaxUsize(1)); 2], slots_per_state: 2, slots_for_captures: 2 };",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet { len: 1, dense: vec![state_id], sparse: vec![state_id] };",
          "    let curr = ActiveStates { set: sparse_set, slot_table };",
          "    let mut next = ActiveStates { set: SparseSet::new(0), slot_table: SlotTable::new() };",
          "    let config = Config { match_kind: Some(MatchKind::All), ..Default::default() };",
          "    let pike_vm = PikeVM { config, nfa: NFA(Arc::new(Inner::default())) };",
          "    let at = 0;",
          "    let pid = pike_vm.nexts(&mut stack, &mut curr, &mut next, &input, at, &mut slots);",
          "    assert!(pid.is_some());",
          "    ",
          "    let no_match_pid = { let mut curr_no_match = curr.clone(); curr_no_match.set.len = 0; pike_vm.nexts(&mut stack, &mut curr_no_match, &mut next, &input, at, &mut slots) };",
          "    assert!(no_match_pid.is_none());",
          "    ",
          "    let empty_stack_pid = { let mut curr_empty_stack = curr.clone(); pike_vm.nexts(&mut Vec::new(), &mut curr_empty_stack, &mut next, &input, at, &mut slots) };",
          "    assert!(empty_stack_pid.is_some());",
          "    ",
          "    let kind_match_pid = {",
          "    let mut kind_curr = ActiveStates {",
          "    set: SparseSet { len: 1, dense: vec![StateID(SmallIndex::new(0))], sparse: vec![StateID(SmallIndex::new(0))] },",
          "    slot_table: SlotTable { table: vec![Some(NonMaxUsize(1)); 2], slots_per_state: 2, slots_for_captures: 2 }",
          "    };",
          "    pike_vm.nexts(&mut stack, &mut kind_curr, &mut next, &input, at, &mut slots)",
          "    };",
          "    assert_eq!(kind_match_pid, pid);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"sample\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input {",
          "        haystack,",
          "        span,",
          "        anchored: Anchored::No,",
          "        earliest: false,",
          "    };",
          "",
          "    let state_id = StateID(SmallIndex::new(2));",
          "    let slot_table = SlotTable {",
          "        table: vec![],",
          "        slots_per_state: 1,",
          "        slots_for_captures: 0,",
          "    };",
          "",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet {",
          "        len: 1,",
          "        dense: vec![state_id],",
          "        sparse: vec![state_id],",
          "    };",
          "",
          "    let curr = ActiveStates {",
          "        set: sparse_set,",
          "        slot_table,",
          "    };",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(0),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::All),",
          "        ..Default::default()",
          "    };",
          "",
          "    let pike_vm = PikeVM {",
          "        config,",
          "        nfa: NFA(Arc::new(Inner::default())),",
          "    };",
          "",
          "    let at = 0;",
          "",
          "    let _pid = pike_vm.nexts(",
          "        &mut stack,",
          "        &mut curr,",
          "        &mut next,",
          "        &input,",
          "        at,",
          "        &mut slots,",
          "    );",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = b\"sample\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input { haystack, span, anchored: Anchored::No, earliest: false };",
          "    let state_id = StateID(SmallIndex::new(2));",
          "    let slot_table = SlotTable { table: vec![], slots_per_state: 1, slots_for_captures: 0 };",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet { len: 1, dense: vec![state_id], sparse: vec![state_id] };",
          "    let curr = ActiveStates { set: sparse_set, slot_table };",
          "    let mut next = ActiveStates { set: SparseSet::new(0), slot_table: SlotTable::new() };",
          "    let config = Config { match_kind: Some(MatchKind::All), ..Default::default() };",
          "    let pike_vm = PikeVM { config, nfa: NFA(Arc::new(Inner::default())) };",
          "    let at = 0;",
          "    let _pid = pike_vm.nexts(&mut stack, &mut curr, &mut next, &input, at, &mut slots);",
          "    ",
          "    // Test oracles",
          "    ",
          "    assert!(sparse_set.len > 0);",
          "    assert!(self.next(&mut stack, &slot_table, &mut next, &input, at, state_id).is_some());",
          "    assert!(self.config.get_match_kind().continue_past_first_match());",
          "    assert!(curr.set.len() == 1);"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"sample\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input {",
          "        haystack,",
          "        span,",
          "        anchored: Anchored::No,",
          "        earliest: false,",
          "    };",
          "",
          "    let state_id = StateID(SmallIndex::new(2));",
          "    let slot_table = SlotTable {",
          "        table: vec![],",
          "        slots_per_state: 1,",
          "        slots_for_captures: 0,",
          "    };",
          "",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet {",
          "        len: 1,",
          "        dense: vec![state_id],",
          "        sparse: vec![state_id],",
          "    };",
          "",
          "    let curr = ActiveStates {",
          "        set: sparse_set,",
          "        slot_table,",
          "    };",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(0),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::All),",
          "        ..Default::default()",
          "    };",
          "",
          "    let pike_vm = PikeVM {",
          "        config,",
          "        nfa: NFA(Arc::new(Inner::default())),",
          "    };",
          "",
          "    let at = 0;",
          "",
          "    let _pid = pike_vm.nexts(",
          "        &mut stack,",
          "        &mut curr,",
          "        &mut next,",
          "        &input,",
          "        at,",
          "        &mut slots,",
          "    );",
          "    let haystack: &[u8] = b\"sample\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input { haystack, span, anchored: Anchored::No, earliest: false };",
          "    let state_id = StateID(SmallIndex::new(2));",
          "    let slot_table = SlotTable { table: vec![], slots_per_state: 1, slots_for_captures: 0 };",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet { len: 1, dense: vec![state_id], sparse: vec![state_id] };",
          "    let curr = ActiveStates { set: sparse_set, slot_table };",
          "    let mut next = ActiveStates { set: SparseSet::new(0), slot_table: SlotTable::new() };",
          "    let config = Config { match_kind: Some(MatchKind::All), ..Default::default() };",
          "    let pike_vm = PikeVM { config, nfa: NFA(Arc::new(Inner::default())) };",
          "    let at = 0;",
          "    let _pid = pike_vm.nexts(&mut stack, &mut curr, &mut next, &input, at, &mut slots);",
          "    ",
          "    // Test oracles",
          "    ",
          "    assert!(sparse_set.len > 0);",
          "    assert!(self.next(&mut stack, &slot_table, &mut next, &input, at, state_id).is_some());",
          "    assert!(self.config.get_match_kind().continue_past_first_match());",
          "    assert!(curr.set.len() == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"regex-automata testing\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input {",
          "        haystack,",
          "        span,",
          "        anchored: Anchored::No,",
          "        earliest: false,",
          "    };",
          "",
          "    let state_id = StateID(SmallIndex::new(3));",
          "    let slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(2)); 2],",
          "        slots_per_state: 2,",
          "        slots_for_captures: 2,",
          "    };",
          "",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet {",
          "        len: 1,",
          "        dense: vec![state_id],",
          "        sparse: vec![state_id],",
          "    };",
          "",
          "    let curr = ActiveStates {",
          "        set: sparse_set,",
          "        slot_table,",
          "    };",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(0),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::All),",
          "        ..Default::default()",
          "    };",
          "",
          "    let pike_vm = PikeVM {",
          "        config,",
          "        nfa: NFA(Arc::new(Inner::default())),",
          "    };",
          "",
          "    let at = 0;",
          "",
          "    let _pid = pike_vm.nexts(",
          "        &mut stack,",
          "        &mut curr,",
          "        &mut next,",
          "        &input,",
          "        at,",
          "        &mut slots,",
          "    );",
          "}"
        ],
        "oracle": [
          "    assert!(curr.set.len() == 1);",
          "    assert!(self.next(&mut stack, &mut curr.slot_table, &mut next, &input, at, state_id).is_some());",
          "    assert!(self.config.get_match_kind().continue_past_first_match() == true);",
          "    assert!(curr.set.len() == 0);",
          "    assert!(pid.is_some());"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"regex-automata testing\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input {",
          "        haystack,",
          "        span,",
          "        anchored: Anchored::No,",
          "        earliest: false,",
          "    };",
          "",
          "    let state_id = StateID(SmallIndex::new(3));",
          "    let slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(2)); 2],",
          "        slots_per_state: 2,",
          "        slots_for_captures: 2,",
          "    };",
          "",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet {",
          "        len: 1,",
          "        dense: vec![state_id],",
          "        sparse: vec![state_id],",
          "    };",
          "",
          "    let curr = ActiveStates {",
          "        set: sparse_set,",
          "        slot_table,",
          "    };",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(0),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::All),",
          "        ..Default::default()",
          "    };",
          "",
          "    let pike_vm = PikeVM {",
          "        config,",
          "        nfa: NFA(Arc::new(Inner::default())),",
          "    };",
          "",
          "    let at = 0;",
          "",
          "    let _pid = pike_vm.nexts(",
          "        &mut stack,",
          "        &mut curr,",
          "        &mut next,",
          "        &input,",
          "        at,",
          "        &mut slots,",
          "    );",
          "    assert!(curr.set.len() == 1);",
          "    assert!(self.next(&mut stack, &mut curr.slot_table, &mut next, &input, at, state_id).is_some());",
          "    assert!(self.config.get_match_kind().continue_past_first_match() == true);",
          "    assert!(curr.set.len() == 0);",
          "    assert!(pid.is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"boundary test\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input {",
          "        haystack,",
          "        span,",
          "        anchored: Anchored::No,",
          "        earliest: false,",
          "    };",
          "",
          "    let state_id = StateID(SmallIndex::new(4));",
          "    let slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(3)); 2],",
          "        slots_per_state: 2,",
          "        slots_for_captures: 2,",
          "    };",
          "",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet {",
          "        len: 1,",
          "        dense: vec![state_id],",
          "        sparse: vec![state_id],",
          "    };",
          "",
          "    let curr = ActiveStates {",
          "        set: sparse_set,",
          "        slot_table,",
          "    };",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(0),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::All),",
          "        ..Default::default()",
          "    };",
          "",
          "    let pike_vm = PikeVM {",
          "        config,",
          "        nfa: NFA(Arc::new(Inner::default())),",
          "    };",
          "",
          "    let at = 1; // boundary condition with at",
          "",
          "    let _pid = pike_vm.nexts(",
          "        &mut stack,",
          "        &mut curr,",
          "        &mut next,",
          "        &input,",
          "        at,",
          "        &mut slots,",
          "    );",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = b\"boundary test\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input { haystack, span, anchored: Anchored::No, earliest: false };",
          "    let state_id = StateID(SmallIndex::new(4));",
          "    let slot_table = SlotTable { table: vec![Some(NonMaxUsize(3)); 2], slots_per_state: 2, slots_for_captures: 2 };",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet { len: 1, dense: vec![state_id], sparse: vec![state_id] };",
          "    let curr = ActiveStates { set: sparse_set, slot_table };",
          "    let mut next = ActiveStates { set: SparseSet::new(0), slot_table: SlotTable::new() };",
          "    let config = Config { match_kind: Some(MatchKind::All), ..Default::default() };",
          "    let pike_vm = PikeVM { config, nfa: NFA(Arc::new(Inner::default())) };",
          "    let at = 1; // boundary condition with at",
          "    let _pid = pike_vm.nexts(&mut stack, &mut curr, &mut next, &input, at, &mut slots);",
          "    assert!(curr.set.len() == 1);",
          "    assert!(matches!(_pid, Some(_)));",
          "    assert!(pike_vm.config.get_match_kind().continue_past_first_match());",
          "    assert!(curr.set contains state_id);",
          "    assert!(next.set.len() == 0);"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"boundary test\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input {",
          "        haystack,",
          "        span,",
          "        anchored: Anchored::No,",
          "        earliest: false,",
          "    };",
          "",
          "    let state_id = StateID(SmallIndex::new(4));",
          "    let slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(3)); 2],",
          "        slots_per_state: 2,",
          "        slots_for_captures: 2,",
          "    };",
          "",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet {",
          "        len: 1,",
          "        dense: vec![state_id],",
          "        sparse: vec![state_id],",
          "    };",
          "",
          "    let curr = ActiveStates {",
          "        set: sparse_set,",
          "        slot_table,",
          "    };",
          "    let mut next = ActiveStates {",
          "        set: SparseSet::new(0),",
          "        slot_table: SlotTable::new(),",
          "    };",
          "",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::All),",
          "        ..Default::default()",
          "    };",
          "",
          "    let pike_vm = PikeVM {",
          "        config,",
          "        nfa: NFA(Arc::new(Inner::default())),",
          "    };",
          "",
          "    let at = 1; // boundary condition with at",
          "",
          "    let _pid = pike_vm.nexts(",
          "        &mut stack,",
          "        &mut curr,",
          "        &mut next,",
          "        &input,",
          "        at,",
          "        &mut slots,",
          "    );",
          "    let haystack: &[u8] = b\"boundary test\";",
          "    let span = Span::new(0, haystack.len());",
          "    let input = Input { haystack, span, anchored: Anchored::No, earliest: false };",
          "    let state_id = StateID(SmallIndex::new(4));",
          "    let slot_table = SlotTable { table: vec![Some(NonMaxUsize(3)); 2], slots_per_state: 2, slots_for_captures: 2 };",
          "    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 2];",
          "    let mut stack: Vec<FollowEpsilon> = Vec::new();",
          "    let sparse_set = SparseSet { len: 1, dense: vec![state_id], sparse: vec![state_id] };",
          "    let curr = ActiveStates { set: sparse_set, slot_table };",
          "    let mut next = ActiveStates { set: SparseSet::new(0), slot_table: SlotTable::new() };",
          "    let config = Config { match_kind: Some(MatchKind::All), ..Default::default() };",
          "    let pike_vm = PikeVM { config, nfa: NFA(Arc::new(Inner::default())) };",
          "    let at = 1; // boundary condition with at",
          "    let _pid = pike_vm.nexts(&mut stack, &mut curr, &mut next, &input, at, &mut slots);",
          "    assert!(curr.set.len() == 1);",
          "    assert!(matches!(_pid, Some(_)));",
          "    assert!(pike_vm.config.get_match_kind().continue_past_first_match());",
          "    assert!(curr.set contains state_id);",
          "    assert!(next.set.len() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]