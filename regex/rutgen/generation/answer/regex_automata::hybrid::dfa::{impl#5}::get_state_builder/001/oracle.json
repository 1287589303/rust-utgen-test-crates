[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        stack: Vec::new(),",
          "        curr: ActiveStates::new(),",
          "        next: ActiveStates::new(),",
          "    };",
          "    ",
          "    let dfa = DFA {",
          "        tt: Transitions::new(),",
          "        st: StartTable::new(),",
          "        special: Special::new(),",
          "        pre: None,",
          "        quitset: ByteSet::new(),",
          "        flags: Flags::new(),",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let builder = lazy.get_state_builder();",
          "}"
        ],
        "oracle": [
          "    let cache = Cache { stack: Vec::new(), curr: ActiveStates::new(), next: ActiveStates::new() };",
          "    let dfa = DFA { tt: Transitions::new(), st: StartTable::new(), special: Special::new(), pre: None, quitset: ByteSet::new(), flags: Flags::new() };",
          "    let mut lazy = Lazy { dfa: &dfa, cache: &mut cache };",
          "    let builder = lazy.get_state_builder();",
          "    assert_eq!(builder.capacity(), 0);",
          "    lazy.put_state_builder(builder);",
          "    let reused_builder = lazy.get_state_builder();",
          "    assert_eq!(reused_builder.capacity(), 0);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        stack: Vec::new(),",
          "        curr: ActiveStates::new(),",
          "        next: ActiveStates::new(),",
          "    };",
          "    ",
          "    let dfa = DFA {",
          "        tt: Transitions::new(),",
          "        st: StartTable::new(),",
          "        special: Special::new(),",
          "        pre: None,",
          "        quitset: ByteSet::new(),",
          "        flags: Flags::new(),",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let builder = lazy.get_state_builder();",
          "    let cache = Cache { stack: Vec::new(), curr: ActiveStates::new(), next: ActiveStates::new() };",
          "    let dfa = DFA { tt: Transitions::new(), st: StartTable::new(), special: Special::new(), pre: None, quitset: ByteSet::new(), flags: Flags::new() };",
          "    let mut lazy = Lazy { dfa: &dfa, cache: &mut cache };",
          "    let builder = lazy.get_state_builder();",
          "    assert_eq!(builder.capacity(), 0);",
          "    lazy.put_state_builder(builder);",
          "    let reused_builder = lazy.get_state_builder();",
          "    assert_eq!(reused_builder.capacity(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        stack: Vec::new(),",
          "        curr: ActiveStates::new(),",
          "        next: ActiveStates::new(),",
          "    };",
          "",
          "    let dfa = DFA {",
          "        tt: Transitions::new(),",
          "        st: StartTable::new(),",
          "        special: Special::new(),",
          "        pre: None,",
          "        quitset: ByteSet::new(),",
          "        flags: Flags::new(),",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    cache.scratch_state_builder = StateBuilderEmpty::new();",
          "",
          "    let builder = lazy.get_state_builder();",
          "}"
        ],
        "oracle": [
          "    assert!(builder.capacity() == 0);",
          "    assert!(cache.scratch_state_builder.capacity() == 0);",
          "    assert_eq!(builder, StateBuilderEmpty::new());",
          "    cache.put_state_builder(builder);",
          "    assert!(cache.scratch_state_builder.capacity() == 0);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        stack: Vec::new(),",
          "        curr: ActiveStates::new(),",
          "        next: ActiveStates::new(),",
          "    };",
          "",
          "    let dfa = DFA {",
          "        tt: Transitions::new(),",
          "        st: StartTable::new(),",
          "        special: Special::new(),",
          "        pre: None,",
          "        quitset: ByteSet::new(),",
          "        flags: Flags::new(),",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    cache.scratch_state_builder = StateBuilderEmpty::new();",
          "",
          "    let builder = lazy.get_state_builder();",
          "    assert!(builder.capacity() == 0);",
          "    assert!(cache.scratch_state_builder.capacity() == 0);",
          "    assert_eq!(builder, StateBuilderEmpty::new());",
          "    cache.put_state_builder(builder);",
          "    assert!(cache.scratch_state_builder.capacity() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        stack: Vec::new(),",
          "        curr: ActiveStates::new(),",
          "        next: ActiveStates::new(),",
          "    };",
          "",
          "    let dfa = DFA {",
          "        tt: Transitions::new(),",
          "        st: StartTable::new(),",
          "        special: Special::new(),",
          "        pre: None,",
          "        quitset: ByteSet::new(),",
          "        flags: Flags::new(),",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    cache.scratch_state_builder = StateBuilderEmpty::new();",
          "",
          "    let builder = lazy.get_state_builder();",
          "    let new_builder = StateBuilderEmpty::new();",
          "    ",
          "    lazy.cache.scratch_state_builder = new_builder;",
          "}"
        ],
        "oracle": [
          "    let mut cache = Cache { stack: Vec::new(), curr: ActiveStates::new(), next: ActiveStates::new() };",
          "    let dfa = DFA { tt: Transitions::new(), st: StartTable::new(), special: Special::new(), pre: None, quitset: ByteSet::new(), flags: Flags::new() };",
          "    let mut lazy = Lazy { dfa: &dfa, cache: &mut cache };",
          "    cache.scratch_state_builder = StateBuilderEmpty::new();",
          "    let builder = lazy.get_state_builder();",
          "    assert!(builder.capacity() == 0);",
          "    lazy.cache.scratch_state_builder = StateBuilderEmpty::new();"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        stack: Vec::new(),",
          "        curr: ActiveStates::new(),",
          "        next: ActiveStates::new(),",
          "    };",
          "",
          "    let dfa = DFA {",
          "        tt: Transitions::new(),",
          "        st: StartTable::new(),",
          "        special: Special::new(),",
          "        pre: None,",
          "        quitset: ByteSet::new(),",
          "        flags: Flags::new(),",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    cache.scratch_state_builder = StateBuilderEmpty::new();",
          "",
          "    let builder = lazy.get_state_builder();",
          "    let new_builder = StateBuilderEmpty::new();",
          "    ",
          "    lazy.cache.scratch_state_builder = new_builder;",
          "    let mut cache = Cache { stack: Vec::new(), curr: ActiveStates::new(), next: ActiveStates::new() };",
          "    let dfa = DFA { tt: Transitions::new(), st: StartTable::new(), special: Special::new(), pre: None, quitset: ByteSet::new(), flags: Flags::new() };",
          "    let mut lazy = Lazy { dfa: &dfa, cache: &mut cache };",
          "    cache.scratch_state_builder = StateBuilderEmpty::new();",
          "    let builder = lazy.get_state_builder();",
          "    assert!(builder.capacity() == 0);",
          "    lazy.cache.scratch_state_builder = StateBuilderEmpty::new();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        stack: Vec::new(),",
          "        curr: ActiveStates::new(),",
          "        next: ActiveStates::new(),",
          "    };",
          "",
          "    let dfa = DFA {",
          "        tt: Transitions::new(),",
          "        st: StartTable::new(),",
          "        special: Special::new(),",
          "        pre: None,",
          "        quitset: ByteSet::new(),",
          "        flags: Flags::new(),",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let builder = lazy.get_state_builder();",
          "    ",
          "    lazy.cache.scratch_state_builder.clear();",
          "",
          "    let new_builder = lazy.get_state_builder();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(builder.capacity(), 0);",
          "    assert_eq!(new_builder.capacity(), 0);",
          "    assert_eq!(lazy.cache.scratch_state_builder.capacity(), 0);",
          "    assert!(lazy.cache.scratch_state_builder.0.is_empty());",
          "    assert!(lazy.cache.scratch_state_builder.0.len() <= lazy.cache.scratch_state_builder.capacity());"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        stack: Vec::new(),",
          "        curr: ActiveStates::new(),",
          "        next: ActiveStates::new(),",
          "    };",
          "",
          "    let dfa = DFA {",
          "        tt: Transitions::new(),",
          "        st: StartTable::new(),",
          "        special: Special::new(),",
          "        pre: None,",
          "        quitset: ByteSet::new(),",
          "        flags: Flags::new(),",
          "    };",
          "",
          "    let mut lazy = Lazy {",
          "        dfa: &dfa,",
          "        cache: &mut cache,",
          "    };",
          "",
          "    let builder = lazy.get_state_builder();",
          "    ",
          "    lazy.cache.scratch_state_builder.clear();",
          "",
          "    let new_builder = lazy.get_state_builder();",
          "    assert_eq!(builder.capacity(), 0);",
          "    assert_eq!(new_builder.capacity(), 0);",
          "    assert_eq!(lazy.cache.scratch_state_builder.capacity(), 0);",
          "    assert!(lazy.cache.scratch_state_builder.0.is_empty());",
          "    assert!(lazy.cache.scratch_state_builder.0.len() <= lazy.cache.scratch_state_builder.capacity());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]