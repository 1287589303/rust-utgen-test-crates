[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::default();",
          "    let _result = state.chunks();",
          "}"
        ],
        "oracle": [
          "    assert_eq!((_result.transitions, _result.chunks.len(), _result.active.is_some()), (&*state.transitions, 0, true));"
        ],
        "code": [
          "{",
          "    let state = State::default();",
          "    let _result = state.chunks();",
          "    assert_eq!((_result.transitions, _result.chunks.len(), _result.active.is_some()), (&*state.transitions, 0, true));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut state = State::default();",
          "    state.transitions.push(Transition { start: 0u8, end: 1u8, next: 0 });",
          "    let _result = state.chunks();",
          "}"
        ],
        "oracle": [
          "    let state = State::default();",
          "    assert_eq!(_result.transitions, &*state.transitions);",
          "    assert_eq!(_result.chunks.as_slice(), state.chunks.iter().collect::<Vec<_>>().as_slice());",
          "    assert_eq!(_result.active, Some(state.active_chunk()));"
        ],
        "code": [
          "{",
          "    let mut state = State::default();",
          "    state.transitions.push(Transition { start: 0u8, end: 1u8, next: 0 });",
          "    let _result = state.chunks();",
          "    let state = State::default();",
          "    assert_eq!(_result.transitions, &*state.transitions);",
          "    assert_eq!(_result.chunks.as_slice(), state.chunks.iter().collect::<Vec<_>>().as_slice());",
          "    assert_eq!(_result.active, Some(state.active_chunk()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut state = State::default();",
          "    state.transitions.push(Transition { start: 0u8, end: 0u8, next: 1 });",
          "    state.chunks.push((0, 0));",
          "    let _result = state.chunks();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.transitions.len(), state.transitions.len());",
          "    assert_eq!(_result.chunks.len(), state.chunks.len());",
          "    assert!(matches!(_result.active, Some(_)));"
        ],
        "code": [
          "{",
          "    let mut state = State::default();",
          "    state.transitions.push(Transition { start: 0u8, end: 0u8, next: 1 });",
          "    state.chunks.push((0, 0));",
          "    let _result = state.chunks();",
          "    assert_eq!(_result.transitions.len(), state.transitions.len());",
          "    assert_eq!(_result.chunks.len(), state.chunks.len());",
          "    assert!(matches!(_result.active, Some(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut state = State::default();",
          "    state.transitions.push(Transition { start: 0u8, end: 1u8, next: 1 });",
          "    state.transitions.push(Transition { start: 2u8, end: 3u8, next: 2 });",
          "    state.chunks.push((0, 1));",
          "    state.chunks.push((2, 3));",
          "    let _result = state.chunks();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.transitions, &*state.transitions);",
          "    assert_eq!(_result.chunks.len(), state.chunks.len());",
          "    assert_eq!(_result.active.unwrap(), state.active_chunk());",
          "    assert!(_result.chunks.as_slice().iter().all(|chunk| chunk.1 >= chunk.0));"
        ],
        "code": [
          "{",
          "    let mut state = State::default();",
          "    state.transitions.push(Transition { start: 0u8, end: 1u8, next: 1 });",
          "    state.transitions.push(Transition { start: 2u8, end: 3u8, next: 2 });",
          "    state.chunks.push((0, 1));",
          "    state.chunks.push((2, 3));",
          "    let _result = state.chunks();",
          "    assert_eq!(_result.transitions, &*state.transitions);",
          "    assert_eq!(_result.chunks.len(), state.chunks.len());",
          "    assert_eq!(_result.active.unwrap(), state.active_chunk());",
          "    assert!(_result.chunks.as_slice().iter().all(|chunk| chunk.1 >= chunk.0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut state = State::default();",
          "    state.transitions.push(Transition { start: 0u8, end: 1u8, next: 1 });",
          "    state.chunks.push((0, 1));",
          "    let _result = state.chunks();",
          "}"
        ],
        "oracle": [
          "    _result.transitions == &*state.transitions",
          "    _result.chunks == state.chunks.iter()",
          "    _result.active == Some(state.active_chunk())"
        ],
        "code": [
          "{",
          "    let mut state = State::default();",
          "    state.transitions.push(Transition { start: 0u8, end: 1u8, next: 1 });",
          "    state.chunks.push((0, 1));",
          "    let _result = state.chunks();",
          "    _result.transitions == &*state.transitions",
          "    _result.chunks == state.chunks.iter()",
          "    _result.active == Some(state.active_chunk())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]