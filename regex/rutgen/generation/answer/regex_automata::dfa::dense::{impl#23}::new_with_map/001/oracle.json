[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matches = BTreeMap::new();",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let pattern_id = PatternID(SmallIndex::new(0));",
          "    matches.insert(state_id, vec![pattern_id]);",
          "    let match_states = MatchStates::empty(1);",
          "    let _ = match_states.new_with_map(&matches);",
          "}"
        ],
        "oracle": [
          "    assert!(matches.len() == 1);",
          "    assert!(matches.contains_key(&state_id));",
          "    assert_eq!(matches[&state_id], vec![pattern_id]);",
          "    assert!(match_states.pattern_len == 1);",
          "    assert!(match_states.slices.is_empty());",
          "    assert!(match_states.pattern_ids.is_empty());",
          "    assert!(match_states.pattern_len == match_states.pattern_ids.len());",
          "    assert!(match_states.pattern_len == 0 || match_states.slices.len() > 0);",
          "    assert!(match_states.new_with_map(&matches).is_ok());",
          "    assert!(match_states.new_with_map(&matches).unwrap().pattern_len == 1);"
        ],
        "code": [
          "{",
          "    let mut matches = BTreeMap::new();",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let pattern_id = PatternID(SmallIndex::new(0));",
          "    matches.insert(state_id, vec![pattern_id]);",
          "    let match_states = MatchStates::empty(1);",
          "    let _ = match_states.new_with_map(&matches);",
          "    assert!(matches.len() == 1);",
          "    assert!(matches.contains_key(&state_id));",
          "    assert_eq!(matches[&state_id], vec![pattern_id]);",
          "    assert!(match_states.pattern_len == 1);",
          "    assert!(match_states.slices.is_empty());",
          "    assert!(match_states.pattern_ids.is_empty());",
          "    assert!(match_states.pattern_len == match_states.pattern_ids.len());",
          "    assert!(match_states.pattern_len == 0 || match_states.slices.len() > 0);",
          "    assert!(match_states.new_with_map(&matches).is_ok());",
          "    assert!(match_states.new_with_map(&matches).unwrap().pattern_len == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matches = BTreeMap::new();",
          "    let state_id_1 = StateID(SmallIndex::new(0));",
          "    let state_id_2 = StateID(SmallIndex::new(1));",
          "    let pattern_id_1 = PatternID(SmallIndex::new(0));",
          "    let pattern_id_2 = PatternID(SmallIndex::new(1));",
          "    matches.insert(state_id_1, vec![pattern_id_1]);",
          "    matches.insert(state_id_2, vec![pattern_id_2, pattern_id_1]);",
          "    let match_states = MatchStates::empty(2);",
          "    let _ = match_states.new_with_map(&matches);",
          "}"
        ],
        "oracle": [
          "    assert!(matches.len() == 2);",
          "    assert!(matches.get(&state_id_1) == Some(&vec![pattern_id_1]));",
          "    assert!(matches.get(&state_id_2) == Some(&vec![pattern_id_2, pattern_id_1]));",
          "    assert!(match_states.pattern_len == 2);",
          "    assert!(match_states.slices.is_empty());",
          "    assert!(match_states.pattern_ids.is_empty());",
          "    assert!(match_states.new_with_map(&matches).is_ok());",
          "    assert!(match_states.new_with_map(&BTreeMap::new()).is_ok());"
        ],
        "code": [
          "{",
          "    let mut matches = BTreeMap::new();",
          "    let state_id_1 = StateID(SmallIndex::new(0));",
          "    let state_id_2 = StateID(SmallIndex::new(1));",
          "    let pattern_id_1 = PatternID(SmallIndex::new(0));",
          "    let pattern_id_2 = PatternID(SmallIndex::new(1));",
          "    matches.insert(state_id_1, vec![pattern_id_1]);",
          "    matches.insert(state_id_2, vec![pattern_id_2, pattern_id_1]);",
          "    let match_states = MatchStates::empty(2);",
          "    let _ = match_states.new_with_map(&matches);",
          "    assert!(matches.len() == 2);",
          "    assert!(matches.get(&state_id_1) == Some(&vec![pattern_id_1]));",
          "    assert!(matches.get(&state_id_2) == Some(&vec![pattern_id_2, pattern_id_1]));",
          "    assert!(match_states.pattern_len == 2);",
          "    assert!(match_states.slices.is_empty());",
          "    assert!(match_states.pattern_ids.is_empty());",
          "    assert!(match_states.new_with_map(&matches).is_ok());",
          "    assert!(match_states.new_with_map(&BTreeMap::new()).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matches = BTreeMap::new();",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let pattern_id = PatternID(SmallIndex::new(0));",
          "    matches.insert(state_id, vec![pattern_id]);",
          "    let match_states = MatchStates::empty(0);",
          "    let _ = match_states.new_with_map(&matches);",
          "}"
        ],
        "oracle": [
          "    assert!(matches.len() == 1);",
          "    assert_eq!(matches.get(&state_id).unwrap(), &vec![pattern_id]);",
          "    assert!(match_states.pattern_len == 0);",
          "    assert!(match_states.slices.is_empty());",
          "    assert!(match_states.pattern_ids.is_empty());",
          "    assert!(match_states.new_with_map(&matches).is_ok());",
          "    assert!(match_states.new_with_map(&matches).unwrap().pattern_len == 0);"
        ],
        "code": [
          "{",
          "    let mut matches = BTreeMap::new();",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let pattern_id = PatternID(SmallIndex::new(0));",
          "    matches.insert(state_id, vec![pattern_id]);",
          "    let match_states = MatchStates::empty(0);",
          "    let _ = match_states.new_with_map(&matches);",
          "    assert!(matches.len() == 1);",
          "    assert_eq!(matches.get(&state_id).unwrap(), &vec![pattern_id]);",
          "    assert!(match_states.pattern_len == 0);",
          "    assert!(match_states.slices.is_empty());",
          "    assert!(match_states.pattern_ids.is_empty());",
          "    assert!(match_states.new_with_map(&matches).is_ok());",
          "    assert!(match_states.new_with_map(&matches).unwrap().pattern_len == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matches = BTreeMap::new();",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let pattern_ids: Vec<PatternID> = (0..10).map(|i| PatternID(SmallIndex::new(i))).collect();",
          "    matches.insert(state_id, pattern_ids.clone());",
          "    let match_states = MatchStates::empty(pattern_ids.len());",
          "    let _ = match_states.new_with_map(&matches);",
          "}"
        ],
        "oracle": [
          "    let matches = BTreeMap::new();",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let pattern_ids: Vec<PatternID> = (0..10).map(|i| PatternID(SmallIndex::new(i))).collect();",
          "    matches.insert(state_id, pattern_ids.clone());",
          "    let match_states = MatchStates::empty(pattern_ids.len());",
          "    let result = match_states.new_with_map(&matches);",
          "    assert!(result.is_ok());",
          "    let match_states_result = result.unwrap();",
          "    assert_eq!(match_states_result.pattern_len, pattern_ids.len());",
          "    assert_eq!(match_states_result.slices.len(), matches.len());",
          "    assert_eq!(match_states_result.pattern_ids.len(), pattern_ids.len());"
        ],
        "code": [
          "{",
          "    let mut matches = BTreeMap::new();",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let pattern_ids: Vec<PatternID> = (0..10).map(|i| PatternID(SmallIndex::new(i))).collect();",
          "    matches.insert(state_id, pattern_ids.clone());",
          "    let match_states = MatchStates::empty(pattern_ids.len());",
          "    let _ = match_states.new_with_map(&matches);",
          "    let matches = BTreeMap::new();",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let pattern_ids: Vec<PatternID> = (0..10).map(|i| PatternID(SmallIndex::new(i))).collect();",
          "    matches.insert(state_id, pattern_ids.clone());",
          "    let match_states = MatchStates::empty(pattern_ids.len());",
          "    let result = match_states.new_with_map(&matches);",
          "    assert!(result.is_ok());",
          "    let match_states_result = result.unwrap();",
          "    assert_eq!(match_states_result.pattern_len, pattern_ids.len());",
          "    assert_eq!(match_states_result.slices.len(), matches.len());",
          "    assert_eq!(match_states_result.pattern_ids.len(), pattern_ids.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]