[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 8,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 1024,",
          "    };",
          "",
          "    let cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let _lazy_ref = LazyRef::new(&dfa, &cache);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_lazy_ref.dfa, &dfa);",
          "    assert_eq!(_lazy_ref.cache, &cache);",
          "    assert!(std::mem::size_of::<LazyRef>() > 0);",
          "    assert!(std::mem::align_of::<LazyRef>() > 0);"
        ],
        "code": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 8,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 1024,",
          "    };",
          "",
          "    let cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let _lazy_ref = LazyRef::new(&dfa, &cache);",
          "    assert_eq!(_lazy_ref.dfa, &dfa);",
          "    assert_eq!(_lazy_ref.cache, &cache);",
          "    assert!(std::mem::size_of::<LazyRef>() > 0);",
          "    assert!(std::mem::align_of::<LazyRef>() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 16,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 512,",
          "    };",
          "",
          "    let cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let _lazy_ref = LazyRef::new(&dfa, &cache);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_lazy_ref.dfa, &dfa);",
          "    assert_eq!(_lazy_ref.cache, &cache);",
          "    assert!(_lazy_ref.is_valid(_lazy_ref.unknown_id()));",
          "    assert!(_lazy_ref.is_valid(_lazy_ref.dead_id()));",
          "    assert!(!_lazy_ref.is_valid(LazyStateID::default()));"
        ],
        "code": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 16,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 512,",
          "    };",
          "",
          "    let cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let _lazy_ref = LazyRef::new(&dfa, &cache);",
          "    assert_eq!(_lazy_ref.dfa, &dfa);",
          "    assert_eq!(_lazy_ref.cache, &cache);",
          "    assert!(_lazy_ref.is_valid(_lazy_ref.unknown_id()));",
          "    assert!(_lazy_ref.is_valid(_lazy_ref.dead_id()));",
          "    assert!(!_lazy_ref.is_valid(LazyStateID::default()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let _lazy_ref = LazyRef::new(std::ptr::null(), &cache);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(LazyRef::new(std::ptr::null(), &cache).dfa, std::ptr::null());",
          "    assert_eq!(LazyRef::new(std::ptr::null(), &cache).cache, &cache);",
          "    assert!(std::ptr::null().is_null());",
          "    assert!(LazyRef::new(&dfa_instance, &cache_instance).dfa.is_not_null());",
          "    assert!(LazyRef::new(&dfa_instance, &cache_instance).cache.is_not_null());"
        ],
        "code": [
          "{",
          "    let cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let _lazy_ref = LazyRef::new(std::ptr::null(), &cache);",
          "    assert_eq!(LazyRef::new(std::ptr::null(), &cache).dfa, std::ptr::null());",
          "    assert_eq!(LazyRef::new(std::ptr::null(), &cache).cache, &cache);",
          "    assert!(std::ptr::null().is_null());",
          "    assert!(LazyRef::new(&dfa_instance, &cache_instance).dfa.is_not_null());",
          "    assert!(LazyRef::new(&dfa_instance, &cache_instance).cache.is_not_null());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 8,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 1024,",
          "    };",
          "",
          "    let _lazy_ref = LazyRef::new(&dfa, std::ptr::null());",
          "}"
        ],
        "oracle": [
          "    let dfa = DFA { config: Config::default(), nfa: thompson::NFA::new(), stride2: 8, start_map: StartByteMap::default(), classes: ByteClasses::default(), quitset: ByteSet::default(), cache_capacity: 1024 };",
          "    let lazy_ref = LazyRef::new(&dfa, std::ptr::null());",
          "    assert!(lazy_ref.dfa == &dfa);",
          "    assert!(lazy_ref.cache.is_null());",
          "    assert_eq!(std::mem::size_of::<LazyRef>(), expected_size);"
        ],
        "code": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 8,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 1024,",
          "    };",
          "",
          "    let _lazy_ref = LazyRef::new(&dfa, std::ptr::null());",
          "    let dfa = DFA { config: Config::default(), nfa: thompson::NFA::new(), stride2: 8, start_map: StartByteMap::default(), classes: ByteClasses::default(), quitset: ByteSet::default(), cache_capacity: 1024 };",
          "    let lazy_ref = LazyRef::new(&dfa, std::ptr::null());",
          "    assert!(lazy_ref.dfa == &dfa);",
          "    assert!(lazy_ref.cache.is_null());",
          "    assert_eq!(std::mem::size_of::<LazyRef>(), expected_size);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]