[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&value.to_le_bytes());",
          "        }",
          "    }",
          "",
          "    let state_id = StateID(0); // Minimum valid StateID",
          "    let mut buffer = [0u8; 4]; // At least StateID::SIZE",
          "    let written_bytes = write_state_id::<LittleEndian>(state_id, &mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(written_bytes, StateID::SIZE);",
          "    assert_eq!(buffer, [0, 0, 0, 0]);"
        ],
        "code": [
          "{",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&value.to_le_bytes());",
          "        }",
          "    }",
          "",
          "    let state_id = StateID(0); // Minimum valid StateID",
          "    let mut buffer = [0u8; 4]; // At least StateID::SIZE",
          "    let written_bytes = write_state_id::<LittleEndian>(state_id, &mut buffer);",
          "    assert_eq!(written_bytes, StateID::SIZE);",
          "    assert_eq!(buffer, [0, 0, 0, 0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct BigEndian;",
          "    impl Endian for BigEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&value.to_be_bytes());",
          "        }",
          "    }",
          "",
          "    let state_id = StateID(u32::MAX); // Maximum valid StateID",
          "    let mut buffer = [0u8; 4]; // At least StateID::SIZE",
          "    let written_bytes = write_state_id::<BigEndian>(state_id, &mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(written_bytes, StateID::SIZE);",
          "    assert_eq!(buffer, u32::MAX.to_be_bytes());"
        ],
        "code": [
          "{",
          "    struct BigEndian;",
          "    impl Endian for BigEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&value.to_be_bytes());",
          "        }",
          "    }",
          "",
          "    let state_id = StateID(u32::MAX); // Maximum valid StateID",
          "    let mut buffer = [0u8; 4]; // At least StateID::SIZE",
          "    let written_bytes = write_state_id::<BigEndian>(state_id, &mut buffer);",
          "    assert_eq!(written_bytes, StateID::SIZE);",
          "    assert_eq!(buffer, u32::MAX.to_be_bytes());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&value.to_le_bytes());",
          "        }",
          "    }",
          "",
          "    let state_id = StateID(1); // A valid StateID just above minimum",
          "    let mut buffer = [0u8; 4]; // At least StateID::SIZE",
          "    let written_bytes = write_state_id::<LittleEndian>(state_id, &mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(written_bytes, StateID::SIZE);",
          "    assert_eq!(&buffer, &[1, 0, 0, 0]);",
          "    let mut small_buffer = [0u8; 3];",
          "    let result = std::panic::catch_unwind(|| write_state_id::<LittleEndian>(state_id, &mut small_buffer));",
          "    assert!(result.is_err());",
          "    let state_id_zero = StateID(0);",
          "    let mut buffer_zero = [0u8; 4];",
          "    let written_bytes_zero = write_state_id::<LittleEndian>(state_id_zero, &mut buffer_zero);",
          "    assert_eq!(written_bytes_zero, StateID::SIZE);",
          "    assert_eq!(&buffer_zero, &[0, 0, 0, 0]);",
          "    let state_id_max = StateID(u32::MAX);",
          "    let mut buffer_max = [0u8; 4];",
          "    let written_bytes_max = write_state_id::<LittleEndian>(state_id_max, &mut buffer_max);",
          "    assert_eq!(written_bytes_max, StateID::SIZE);",
          "    assert_eq!(&buffer_max, &u32::MAX.to_le_bytes());",
          "    let empty_buffer: &mut [u8] = &mut [];",
          "    let result_empty = std::panic::catch_unwind(|| write_state_id::<LittleEndian>(state_id, empty_buffer));",
          "    assert!(result_empty.is_err());"
        ],
        "code": [
          "{",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&value.to_le_bytes());",
          "        }",
          "    }",
          "",
          "    let state_id = StateID(1); // A valid StateID just above minimum",
          "    let mut buffer = [0u8; 4]; // At least StateID::SIZE",
          "    let written_bytes = write_state_id::<LittleEndian>(state_id, &mut buffer);",
          "    assert_eq!(written_bytes, StateID::SIZE);",
          "    assert_eq!(&buffer, &[1, 0, 0, 0]);",
          "    let mut small_buffer = [0u8; 3];",
          "    let result = std::panic::catch_unwind(|| write_state_id::<LittleEndian>(state_id, &mut small_buffer));",
          "    assert!(result.is_err());",
          "    let state_id_zero = StateID(0);",
          "    let mut buffer_zero = [0u8; 4];",
          "    let written_bytes_zero = write_state_id::<LittleEndian>(state_id_zero, &mut buffer_zero);",
          "    assert_eq!(written_bytes_zero, StateID::SIZE);",
          "    assert_eq!(&buffer_zero, &[0, 0, 0, 0]);",
          "    let state_id_max = StateID(u32::MAX);",
          "    let mut buffer_max = [0u8; 4];",
          "    let written_bytes_max = write_state_id::<LittleEndian>(state_id_max, &mut buffer_max);",
          "    assert_eq!(written_bytes_max, StateID::SIZE);",
          "    assert_eq!(&buffer_max, &u32::MAX.to_le_bytes());",
          "    let empty_buffer: &mut [u8] = &mut [];",
          "    let result_empty = std::panic::catch_unwind(|| write_state_id::<LittleEndian>(state_id, empty_buffer));",
          "    assert!(result_empty.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct BigEndian;",
          "    impl Endian for BigEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&value.to_be_bytes());",
          "        }",
          "    }",
          "",
          "    let state_id = StateID(u32::MAX - 1); // Valid StateID just below maximum",
          "    let mut buffer = [0u8; 4]; // At least StateID::SIZE",
          "    let written_bytes = write_state_id::<BigEndian>(state_id, &mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(written_bytes, StateID::SIZE);",
          "    assert_eq!(buffer, (u32::MAX - 1).to_be_bytes());"
        ],
        "code": [
          "{",
          "    struct BigEndian;",
          "    impl Endian for BigEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst.copy_from_slice(&value.to_be_bytes());",
          "        }",
          "    }",
          "",
          "    let state_id = StateID(u32::MAX - 1); // Valid StateID just below maximum",
          "    let mut buffer = [0u8; 4]; // At least StateID::SIZE",
          "    let written_bytes = write_state_id::<BigEndian>(state_id, &mut buffer);",
          "    assert_eq!(written_bytes, StateID::SIZE);",
          "    assert_eq!(buffer, (u32::MAX - 1).to_be_bytes());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]