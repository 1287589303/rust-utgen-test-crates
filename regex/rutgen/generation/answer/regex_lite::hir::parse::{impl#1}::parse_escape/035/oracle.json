[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"w\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('w')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"w\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('w')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_perl_class())); // for 'w'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('0')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_BACKREF_UNSUPPORTED))); // for '0'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('p')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED))); // for 'p'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('x')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_hex())); // for 'x'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('u')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_hex())); // for 'u'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('D')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_perl_class())); // for 'D'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('S')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_perl_class())); // for 'S'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('W')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_perl_class())); // for 'W'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('A')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Start))); // for 'A'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('z')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::End))); // for 'z'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('b')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word))); // for 'b'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('B')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordNegate))); // for 'B'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('<')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordStart))); // for '<'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('>')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordEnd))); // for '>'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('f')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\x0C'))); // for 'f'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('t')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\t'))); // for 't'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('n')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\n'))); // for 'n'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('r')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\r'))); // for 'r'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('v')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\x0B'))); // for 'v'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('a')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\x07'))); // for 'a'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('X')), // unrecognized escape sequence",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED))); // for 'X'"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"w\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('w')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"w\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('w')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_perl_class())); // for 'w'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('0')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_BACKREF_UNSUPPORTED))); // for '0'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('p')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED))); // for 'p'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('x')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_hex())); // for 'x'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('u')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_hex())); // for 'u'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('D')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_perl_class())); // for 'D'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('S')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_perl_class())); // for 'S'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('W')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.parse_perl_class())); // for 'W'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('A')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Start))); // for 'A'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('z')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::End))); // for 'z'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('b')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word))); // for 'b'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('B')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordNegate))); // for 'B'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('<')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordStart))); // for '<'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('>')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordEnd))); // for '>'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('f')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\x0C'))); // for 'f'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('t')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\t'))); // for 't'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('n')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\n'))); // for 'n'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('r')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\r'))); // for 'r'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('v')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\x0B'))); // for 'v'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('a')),",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(parser.hir_char('\\x07'))); // for 'a'",
          "    ",
          "    let parser = Parser {",
          "    char: Cell::new(Some('X')), // unrecognized escape sequence",
          "    ..parser",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED))); // for 'X'",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"p\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('p')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"0\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('0')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result, Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"p\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('p')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"u\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('u')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"x\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('x')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"w\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('w')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"d\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('d')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"D\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('D')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"s\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('s')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"S\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('S')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"b\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('b')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"A\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('A')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"z\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('z')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"a\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('a')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.ok().unwrap().is_start_anchored());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"B\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('B')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.ok().unwrap().kind(), &HirKind::Look(hir::Look::WordNegate));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"<\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('<')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.ok().unwrap().kind(), &HirKind::Look(hir::Look::WordStart));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \">\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('>')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.ok().unwrap().kind(), &HirKind::Look(hir::Look::WordEnd));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"p\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('p')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"0\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('0')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result, Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"p\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('p')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"u\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('u')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"x\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('x')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"w\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('w')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"d\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('d')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"D\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('D')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"s\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('s')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"S\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('S')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"b\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('b')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"A\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('A')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"z\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('z')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"a\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('a')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.ok().unwrap().is_start_anchored());",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"B\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('B')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.ok().unwrap().kind(), &HirKind::Look(hir::Look::WordNegate));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"<\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('<')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.ok().unwrap().kind(), &HirKind::Look(hir::Look::WordStart));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \">\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('>')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.ok().unwrap().kind(), &HirKind::Look(hir::Look::WordEnd));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"d\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('d')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    parser.is_done() == false",
          "    parser.char() == '0'..='9' == false",
          "    parser.char() == 'w' == true",
          "    parser.char() == 'p' == true",
          "    parser.char() == 'd' == true",
          "    parser.char() == 'D' == true",
          "    parser.char() == 'u' == true",
          "    parser.char() == 'x' == true",
          "    parser.char() == 'U' == true",
          "    parser.char() == 's' == true",
          "    parser.char() == 'P' == true",
          "    parser.char() == 'S' == true",
          "    parser.char() == _ == true",
          "    hir::is_meta_character(parser.char()) == false",
          "    hir::is_escapeable_character(parser.char()) == false",
          "    parser.char() == 'z' == true",
          "    parser.char() == 'n' == true",
          "    parser.char() == 'r' == true",
          "    parser.char() == 'f' == true",
          "    parser.char() == 't' == true",
          "    parser.char() == 'v' == true",
          "    parser.char() == 'b' == true",
          "    parser.char() == 'a' == true",
          "    parser.char() == 'B' == true",
          "    parser.char() == '<' == true",
          "    parser.char() == '>' == true",
          "    parser.char() == 'A' == true",
          "    parser.char() == _ == true",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"d\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('d')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    parser.is_done() == false",
          "    parser.char() == '0'..='9' == false",
          "    parser.char() == 'w' == true",
          "    parser.char() == 'p' == true",
          "    parser.char() == 'd' == true",
          "    parser.char() == 'D' == true",
          "    parser.char() == 'u' == true",
          "    parser.char() == 'x' == true",
          "    parser.char() == 'U' == true",
          "    parser.char() == 's' == true",
          "    parser.char() == 'P' == true",
          "    parser.char() == 'S' == true",
          "    parser.char() == _ == true",
          "    hir::is_meta_character(parser.char()) == false",
          "    hir::is_escapeable_character(parser.char()) == false",
          "    parser.char() == 'z' == true",
          "    parser.char() == 'n' == true",
          "    parser.char() == 'r' == true",
          "    parser.char() == 'f' == true",
          "    parser.char() == 't' == true",
          "    parser.char() == 'v' == true",
          "    parser.char() == 'b' == true",
          "    parser.char() == 'a' == true",
          "    parser.char() == 'B' == true",
          "    parser.char() == '<' == true",
          "    parser.char() == '>' == true",
          "    parser.char() == 'A' == true",
          "    parser.char() == _ == true",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"D\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('D')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"D\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"D\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('D')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"D\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"u\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('u')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"u\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"x\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"p\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"P\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('P')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"d\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('d')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"D\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"w\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('w')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"W\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('W')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"s\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"S\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('S')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"A\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"z\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('z')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::End)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"b\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Word)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"B\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordNegate)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \">\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordEnd)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordStart)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('a')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\x07')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"f\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\x0C')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"t\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\t')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"n\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\n')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"r\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\r')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"v\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\x0B')));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"u\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('u')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"u\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"x\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"p\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"P\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('P')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"d\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('d')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"D\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"w\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('w')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"W\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('W')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"s\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"S\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('S')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"A\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"z\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('z')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::End)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"b\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Word)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"B\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordNegate)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \">\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordEnd)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordStart)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('a')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\x07')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"f\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\x0C')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"t\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\t')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"n\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\n')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"r\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\r')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"v\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::char('\\x0B')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"x\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('x')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"x\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('x')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"U\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('U')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_ , Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "    assert!(self.is_done() == false);",
          "    assert!(self.char() == Some('U'));",
          "    assert!(self.char() != Some('0'));",
          "    assert!(self.char() == Some('U') || self.char() == Some('u'));",
          "    assert!(self.char() == Some('d') || self.char() == Some('D') || self.char() == Some('w') || self.char() == Some('W'));",
          "    assert!(self.char() != Some('p') && self.char() != Some('P') && self.char() != Some('s') && self.char() != Some('S'));",
          "    assert!(hir::is_meta_character(self.char().unwrap()) == false);",
          "    assert!(hir::is_escapeable_character(self.char().unwrap()) == false);",
          "    assert!(self.char() != Some('n') && self.char() != Some('f') && self.char() != Some('t') && self.char() != Some('r') && self.char() != Some('v') && self.char() != Some('a') && self.char() != Some('B') && self.char() != Some('<') && self.char() != Some('>'));",
          "    assert!(self.char() == Some('b') || self.char() == Some('A') || self.char() == Some('z'));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"U\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('U')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(_ , Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "    assert!(self.is_done() == false);",
          "    assert!(self.char() == Some('U'));",
          "    assert!(self.char() != Some('0'));",
          "    assert!(self.char() == Some('U') || self.char() == Some('u'));",
          "    assert!(self.char() == Some('d') || self.char() == Some('D') || self.char() == Some('w') || self.char() == Some('W'));",
          "    assert!(self.char() != Some('p') && self.char() != Some('P') && self.char() != Some('s') && self.char() != Some('S'));",
          "    assert!(hir::is_meta_character(self.char().unwrap()) == false);",
          "    assert!(hir::is_escapeable_character(self.char().unwrap()) == false);",
          "    assert!(self.char() != Some('n') && self.char() != Some('f') && self.char() != Some('t') && self.char() != Some('r') && self.char() != Some('v') && self.char() != Some('a') && self.char() != Some('B') && self.char() != Some('<') && self.char() != Some('>'));",
          "    assert!(self.char() == Some('b') || self.char() == Some('A') || self.char() == Some('z'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"s\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('s')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"s\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('s')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"P\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('P')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"P\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('P')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"0\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"d\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('d')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"D\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"u\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_hex()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"x\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_hex()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"U\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('U')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_hex()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"s\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"S\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('S')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"w\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('w')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"b\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"B\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordNegate)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordStart)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \">\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordEnd)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('a')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x07')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"f\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x0C')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"t\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\t')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"n\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\n')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"r\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\r')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"v\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x0B')));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"P\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('P')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"P\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('P')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"0\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"d\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('d')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"D\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"u\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_hex()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"x\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_hex()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"U\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('U')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_hex()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"s\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"S\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('S')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"w\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('w')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"b\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"B\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordNegate)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordStart)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \">\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordEnd)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('a')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x07')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"f\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x0C')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"t\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\t')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"n\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\n')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"r\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\r')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"v\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x0B')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"S\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('S')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(_ , Err(Error { msg: ERR_ESCAPE_UNRECOGNIZED })));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"S\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('S')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert!(matches!(_ , Err(Error { msg: ERR_ESCAPE_UNRECOGNIZED })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"n\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('n')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"n\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('n')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"r\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('r')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"0\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"p\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"x\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"u\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"U\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('U')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"d\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('d')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"D\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"s\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"S\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('S')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"w\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('w')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"W\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('W')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('a')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"b\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"B\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordNegate)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordStart)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \">\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordEnd)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"A\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"z\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('z')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::End)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"r\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('r')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"0\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"p\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"x\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"u\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"U\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('U')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"d\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('d')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"D\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"s\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"S\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('S')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"w\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('w')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"W\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('W')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('a')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"b\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert!(result.is_ok());",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"B\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordNegate)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordStart)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \">\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordEnd)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"A\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Start)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"z\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('z')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::End)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"f\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('f')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"0\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('0')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"p\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('p')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"u\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('u')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"x\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('x')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"f\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('f')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"w\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('w')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"A\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('A')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"b\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('b')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"B\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('B')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"<\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('<')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \">\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('>')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"n\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('n')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"r\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('r')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"f\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('f')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"0\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('0')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"p\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('p')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"u\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('u')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"x\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('x')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"f\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('f')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"w\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('w')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"A\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('A')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"b\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('b')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"B\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('B')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"<\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('<')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \">\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('>')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"n\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('n')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    ",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"r\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('r')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"t\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('t')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"t\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('t')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"t\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('t')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser {",
          "    config: Config { nest_limit: 10, flags: Flags::default() },",
          "    pattern: \"t\",",
          "    depth: Cell::new(0),",
          "    pos: Cell::new(0),",
          "    char: Cell::new(Some('t')),",
          "    capture_index: Cell::new(0),",
          "    flags: RefCell::new(Flags::default()),",
          "    capture_names: RefCell::new(vec![]),",
          "    };",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"v\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('v')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    parser.is_done() == false",
          "    parser.char() == 'v'",
          "    parser.char() != '0' && parser.char() != '1' && parser.char() != '2' && parser.char() != '3' && parser.char() != '4' && parser.char() != '5' && parser.char() != '6' && parser.char() != '7' && parser.char() != '8' && parser.char() != '9'",
          "    parser.char() == 'v'",
          "    hir::is_meta_character('v') == false",
          "    hir::is_escapeable_character('v') == false",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"v\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('v')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    parser.is_done() == false",
          "    parser.char() == 'v'",
          "    parser.char() != '0' && parser.char() != '1' && parser.char() != '2' && parser.char() != '3' && parser.char() != '4' && parser.char() != '5' && parser.char() != '6' && parser.char() != '7' && parser.char() != '8' && parser.char() != '9'",
          "    parser.char() == 'v'",
          "    hir::is_meta_character('v') == false",
          "    hir::is_escapeable_character('v') == false",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"b\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('b')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    parser.is_done(); // false",
          "    parser.char(); // Some('b')",
          "    parser.char(); // '0'..='9' // false",
          "    parser.char(); // 'w' // true",
          "    parser.char(); // 'p' // true",
          "    parser.char(); // 'd' // true",
          "    parser.char(); // 'D' // true",
          "    parser.char(); // 'u' // true",
          "    parser.char(); // 'x' // true",
          "    parser.char(); // 'U' // true",
          "    parser.char(); // 's' // true",
          "    parser.char(); // 'P' // true",
          "    parser.char(); // 'S' // true",
          "    parser.char(); // 'W' // true",
          "    parser.char(); // _ // true",
          "    hir::is_meta_character(parser.char()); // false",
          "    hir::is_escapeable_character(parser.char()); // false",
          "    parser.char(); // 'z' // true",
          "    parser.char(); // 'n' // true",
          "    parser.char(); // 'r' // true",
          "    parser.char(); // 'f' // true",
          "    parser.char(); // 't' // true",
          "    parser.char(); // 'v' // true",
          "    parser.char(); // 'b' // true",
          "    parser.char(); // 'a' // true",
          "    parser.char(); // 'B' // true",
          "    parser.char(); // '<' // true",
          "    parser.char(); // '>' // true",
          "    parser.char(); // 'A' // true",
          "    parser.char(); // _ // true",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"b\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('b')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    parser.is_done(); // false",
          "    parser.char(); // Some('b')",
          "    parser.char(); // '0'..='9' // false",
          "    parser.char(); // 'w' // true",
          "    parser.char(); // 'p' // true",
          "    parser.char(); // 'd' // true",
          "    parser.char(); // 'D' // true",
          "    parser.char(); // 'u' // true",
          "    parser.char(); // 'x' // true",
          "    parser.char(); // 'U' // true",
          "    parser.char(); // 's' // true",
          "    parser.char(); // 'P' // true",
          "    parser.char(); // 'S' // true",
          "    parser.char(); // 'W' // true",
          "    parser.char(); // _ // true",
          "    hir::is_meta_character(parser.char()); // false",
          "    hir::is_escapeable_character(parser.char()); // false",
          "    parser.char(); // 'z' // true",
          "    parser.char(); // 'n' // true",
          "    parser.char(); // 'r' // true",
          "    parser.char(); // 'f' // true",
          "    parser.char(); // 't' // true",
          "    parser.char(); // 'v' // true",
          "    parser.char(); // 'b' // true",
          "    parser.char(); // 'a' // true",
          "    parser.char(); // 'B' // true",
          "    parser.char(); // '<' // true",
          "    parser.char(); // '>' // true",
          "    parser.char(); // 'A' // true",
          "    parser.char(); // _ // true",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"a\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('a')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('d')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('U')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('w')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('S')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('W')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::End)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(self.hir_char('\\r')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(self.hir_char('\\x0C')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(self.hir_char('\\t')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(self.hir_char('\\x0B')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Start)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordNegate)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordStart)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordEnd)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('z')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::End)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"a\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('a')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('d')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('U')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('w')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('S')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('W')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::End)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(self.hir_char('\\r')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(self.hir_char('\\x0C')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(self.hir_char('\\t')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(self.hir_char('\\x0B')));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Start)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordNegate)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordStart)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordEnd)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"a\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('z')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::End)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"B\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('B')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"B\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('B')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"<\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('<')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('U')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('W')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('a')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x07')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Word)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\n')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\r')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x0C')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\t')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x0B')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordEnd)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"<\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('<')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('x')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('U')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('s')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('D')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('W')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result.is_ok(), false);",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('a')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x07')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::Word)));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\n')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\r')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x0C')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\t')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(parser.hir_char('\\x0B')));",
          "    ",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]), }; let result = parser.parse_escape(); assert_eq!(result, Ok(Hir::look(hir::Look::WordEnd)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \">\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('>')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(_ , Err(Error { msg }) if msg == ERR_ESCAPE_UNRECOGNIZED));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \">\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('>')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert!(matches!(_ , Err(Error { msg }) if msg == ERR_ESCAPE_UNRECOGNIZED));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"A\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('A')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"0\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"p\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"u\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"A\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Start)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"b\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"B\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordNegate)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"n\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"f\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"t\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"r\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"v\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"z\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('z')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::End)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \">\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordEnd)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordStart)));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"A\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('A')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"0\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('0')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Err(Error::new(ERR_BACKREF_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"p\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('p')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"u\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('u')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(parser.parse_perl_class()));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"A\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('A')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Start)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"b\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('b')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"B\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('B')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordNegate)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"n\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('n')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"f\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('f')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"t\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('t')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"r\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('r')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"v\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('v')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::Word)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"z\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('z')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::End)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \">\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('>')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordEnd)));",
          "    let parser = Parser { config: Config { nest_limit: 10, flags: Flags::default() }, pattern: \"<\", depth: Cell::new(0), pos: Cell::new(0), char: Cell::new(Some('<')), capture_index: Cell::new(0), flags: RefCell::new(Flags::default()), capture_names: RefCell::new(vec![]) }; assert_eq!(parser.parse_escape(), Ok(Hir::look(hir::Look::WordStart)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"z\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('z')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_ESCAPE_UNRECOGNIZED })));",
          "    parser.char.set(Some('0'));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_BACKREF_UNSUPPORTED })));",
          "    parser.char.set(Some('p'));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_UNICODE_CLASS_UNSUPPORTED })));",
          "    parser.char.set(Some('x'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('u'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('U'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('d'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('D'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('s'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('S'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('W'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('b'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('a'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('A'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('f'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('t'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('n'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('r'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('v'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('z'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('<'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('>'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('B'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('c'));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_ESCAPE_UNRECOGNIZED })));",
          "    parser.char.set(Some('@'));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_ESCAPE_UNRECOGNIZED })));"
        ],
        "code": [
          "{",
          "    let parser = Parser {",
          "        config: Config { nest_limit: 10, flags: Flags::default() },",
          "        pattern: \"z\",",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('z')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_ESCAPE_UNRECOGNIZED })));",
          "    parser.char.set(Some('0'));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_BACKREF_UNSUPPORTED })));",
          "    parser.char.set(Some('p'));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_UNICODE_CLASS_UNSUPPORTED })));",
          "    parser.char.set(Some('x'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('u'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('U'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('d'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('D'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('s'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('S'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('W'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('b'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('a'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('A'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('f'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('t'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('n'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('r'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('v'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('z'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('<'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('>'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('B'));",
          "    assert!(parser.parse_escape().is_ok());",
          "    parser.char.set(Some('c'));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_ESCAPE_UNRECOGNIZED })));",
          "    parser.char.set(Some('@'));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { msg: ERR_ESCAPE_UNRECOGNIZED })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]