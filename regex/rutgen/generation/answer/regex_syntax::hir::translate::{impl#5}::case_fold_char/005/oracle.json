[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"A\");",
          "    translator_i.case_fold_char(span, 'A');",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"A\");",
          "    let result = translator_i.case_fold_char(span, 'A');",
          "    assert_eq!(result, Ok(Some(Hir::class(hir::Class::Bytes(cls)))));"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"A\");",
          "    translator_i.case_fold_char(span, 'A');",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"A\");",
          "    let result = translator_i.case_fold_char(span, 'A');",
          "    assert_eq!(result, Ok(Some(Hir::class(hir::Class::Bytes(cls)))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"B\");",
          "    translator_i.case_fold_char(span, 'B');",
          "}"
        ],
        "oracle": [
          "    assert_eq!(translator_i.case_fold_char(span, 'B'), Ok(Some(Hir::class(hir::Class::Bytes(cls)))));",
          "    assert!(translator.flags().case_insensitive().unwrap());",
          "    assert!(!translator.flags().unicode().unwrap());",
          "    assert!(matches!('B', 'A'..='Z' | 'a'..='z'));"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"B\");",
          "    translator_i.case_fold_char(span, 'B');",
          "    assert_eq!(translator_i.case_fold_char(span, 'B'), Ok(Some(Hir::class(hir::Class::Bytes(cls)))));",
          "    assert!(translator.flags().case_insensitive().unwrap());",
          "    assert!(!translator.flags().unicode().unwrap());",
          "    assert!(matches!('B', 'A'..='Z' | 'a'..='z'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"C\");",
          "    translator_i.case_fold_char(span, 'C');",
          "}"
        ],
        "oracle": [
          "    assert_eq!(translator_i.case_fold_char(span, 'C'), Ok(Some(Hir::class(hir::Class::Bytes(cls)))));"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"C\");",
          "    translator_i.case_fold_char(span, 'C');",
          "    assert_eq!(translator_i.case_fold_char(span, 'C'), Ok(Some(Hir::class(hir::Class::Bytes(cls)))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"a\");",
          "    translator_i.case_fold_char(span, 'a');",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"a\");",
          "    let result = translator_i.case_fold_char(span, 'a');",
          "    assert_eq!(result, Ok(Some(Hir::class(hir::Class::Bytes(cls)))));"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"a\");",
          "    translator_i.case_fold_char(span, 'a');",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"a\");",
          "    let result = translator_i.case_fold_char(span, 'a');",
          "    assert_eq!(result, Ok(Some(Hir::class(hir::Class::Bytes(cls)))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"b\");",
          "    translator_i.case_fold_char(span, 'b');",
          "}"
        ],
        "oracle": [
          "    assert_eq!(translator_i.case_fold_char(span, 'b'), Ok(Some(Hir::class(hir::Class::Bytes(cls)))));",
          "    assert_eq!(translator_i.flags().case_insensitive(), true);",
          "    assert_eq!(translator_i.flags().unicode(), false);",
          "    assert!(translator_i.case_fold_char(span, 'B').is_ok());",
          "    assert!(translator_i.case_fold_char(span, 'A').is_ok());",
          "    assert!(translator_i.case_fold_char(span, 'Z').is_ok());",
          "    assert!(translator_i.case_fold_char(span, 'a').is_ok());",
          "    assert!(translator_i.case_fold_char(span, 'z').is_ok());",
          "    assert!(translator_i.case_fold_char(span, '\\xFF').is_ok());"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"b\");",
          "    translator_i.case_fold_char(span, 'b');",
          "    assert_eq!(translator_i.case_fold_char(span, 'b'), Ok(Some(Hir::class(hir::Class::Bytes(cls)))));",
          "    assert_eq!(translator_i.flags().case_insensitive(), true);",
          "    assert_eq!(translator_i.flags().unicode(), false);",
          "    assert!(translator_i.case_fold_char(span, 'B').is_ok());",
          "    assert!(translator_i.case_fold_char(span, 'A').is_ok());",
          "    assert!(translator_i.case_fold_char(span, 'Z').is_ok());",
          "    assert!(translator_i.case_fold_char(span, 'a').is_ok());",
          "    assert!(translator_i.case_fold_char(span, 'z').is_ok());",
          "    assert!(translator_i.case_fold_char(span, '\\xFF').is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"c\");",
          "    translator_i.case_fold_char(span, 'c');",
          "}"
        ],
        "oracle": [
          "    translator_i.flags().case_insensitive() == true",
          "    translator_i.flags().unicode() == false",
          "    'c'.is_ascii() == true",
          "    'c' >= 'A' && 'c' <= 'Z' == false",
          "    'c' >= 'a' && 'c' <= 'z' == true",
          "    let result = translator_i.case_fold_char(span, 'c');",
          "    result == Ok(Some(Hir::class(hir::Class::Bytes(cls))))"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let mut flags = Flags { case_insensitive: Some(true), unicode: Some(false), ..Default::default() };",
          "    let translator = Translator { flags: Cell::new(flags), ..Default::default() };",
          "    let translator_i = TranslatorI::new(&translator, \"c\");",
          "    translator_i.case_fold_char(span, 'c');",
          "    translator_i.flags().case_insensitive() == true",
          "    translator_i.flags().unicode() == false",
          "    'c'.is_ascii() == true",
          "    'c' >= 'A' && 'c' <= 'Z' == false",
          "    'c' >= 'a' && 'c' <= 'z' == true",
          "    let result = translator_i.case_fold_char(span, 'c');",
          "    result == Ok(Some(Hir::class(hir::Class::Bytes(cls))))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]