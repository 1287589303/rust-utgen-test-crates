[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let dfa = DFA::builder()",
          "        .thompson(thompson::Config::new().reverse(true))",
          "        .build(\"foo[0-9]+\").unwrap();",
          "    let mut cache = dfa.create_cache();",
          "    let input = Input::new(\"foo12345\");",
          "    let expected = HalfMatch::must(0, 0);",
          "    let result = dfa.try_search_rev(&mut cache, &input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(Some(expected)));",
          "    assert!(dfa.get_nfa().has_empty() == false);",
          "    assert!(search::find_rev(&dfa, &mut cache, &input).is_ok());",
          "    assert!(search::find_rev(&dfa, &mut cache, &input).is_some());",
          "    assert!(result.unwrap().offset() == expected.offset());",
          "    assert!(utf8empty == false);"
        ],
        "code": [
          "{",
          "    let dfa = DFA::builder()",
          "        .thompson(thompson::Config::new().reverse(true))",
          "        .build(\"foo[0-9]+\").unwrap();",
          "    let mut cache = dfa.create_cache();",
          "    let input = Input::new(\"foo12345\");",
          "    let expected = HalfMatch::must(0, 0);",
          "    let result = dfa.try_search_rev(&mut cache, &input);",
          "    assert_eq!(result, Ok(Some(expected)));",
          "    assert!(dfa.get_nfa().has_empty() == false);",
          "    assert!(search::find_rev(&dfa, &mut cache, &input).is_ok());",
          "    assert!(search::find_rev(&dfa, &mut cache, &input).is_some());",
          "    assert!(result.unwrap().offset() == expected.offset());",
          "    assert!(utf8empty == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let dfa = DFA::builder()",
          "        .thompson(thompson::Config::new().reverse(true))",
          "        .build(\"bar[0-9]+\").unwrap();",
          "    let mut cache = dfa.create_cache();",
          "    let input = Input::new(\"foo12345\");",
          "    let result = dfa.try_search_rev(&mut cache, &input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap().is_none());",
          "    let dfa = DFA::builder()",
          "    .thompson(thompson::Config::new().reverse(true).utf8(false))",
          "    .build(\"foo[0-9]+\").unwrap();",
          "    assert!(dfa.get_nfa().has_empty() == false);",
          "    let input = Input::new(\"foo12345\");",
          "    let result = dfa.try_search_rev(&mut cache, &input);",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap().is_some());",
          "    assert_eq!(result.unwrap().unwrap().pattern(), 0);",
          "    assert!(result.unwrap().unwrap().offset() == 0);"
        ],
        "code": [
          "{",
          "    let dfa = DFA::builder()",
          "        .thompson(thompson::Config::new().reverse(true))",
          "        .build(\"bar[0-9]+\").unwrap();",
          "    let mut cache = dfa.create_cache();",
          "    let input = Input::new(\"foo12345\");",
          "    let result = dfa.try_search_rev(&mut cache, &input);",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap().is_none());",
          "    let dfa = DFA::builder()",
          "    .thompson(thompson::Config::new().reverse(true).utf8(false))",
          "    .build(\"foo[0-9]+\").unwrap();",
          "    assert!(dfa.get_nfa().has_empty() == false);",
          "    let input = Input::new(\"foo12345\");",
          "    let result = dfa.try_search_rev(&mut cache, &input);",
          "    assert!(result.is_ok());",
          "    assert!(result.unwrap().is_some());",
          "    assert_eq!(result.unwrap().unwrap().pattern(), 0);",
          "    assert!(result.unwrap().unwrap().offset() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let dfa = DFA::builder()",
          "        .thompson(thompson::Config::new().reverse(true).utf8(true))",
          "        .build(\"☃\").unwrap();",
          "    let mut cache = dfa.create_cache();",
          "    let input = Input::new(\"☃\");",
          "    let matches: Vec<HalfMatch> = Vec::new();",
          "    ",
          "    loop {",
          "        match dfa.try_search_rev(&mut cache, &input) {",
          "            Err(_) => break,",
          "            Some(hm) => {",
          "                matches.push(hm);",
          "                if hm.offset() == 0 || input.end() == 0 {",
          "                    break;",
          "                } else {",
          "                    input.set_end(hm.offset());",
          "                }",
          "            }",
          "        }",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(dfa.get_nfa().has_empty() == false);",
          "    let result = dfa.try_search_rev(&mut cache, &input);",
          "    assert!(result.is_ok());",
          "    assert!(result.is_some());",
          "    let match_result = result.unwrap();",
          "    assert!(match_result.is_some());",
          "    assert_eq!(match_result.pattern(), 0);",
          "    assert!(hm.offset() > 0);",
          "    assert!(dfa.try_search_rev(&mut cache, &Input::new(\"invalid\"))?.is_none());",
          "    assert!(dfa.get_nfa().is_utf8() == true);",
          "    assert!(utf8empty == true);"
        ],
        "code": [
          "{",
          "    let dfa = DFA::builder()",
          "        .thompson(thompson::Config::new().reverse(true).utf8(true))",
          "        .build(\"☃\").unwrap();",
          "    let mut cache = dfa.create_cache();",
          "    let input = Input::new(\"☃\");",
          "    let matches: Vec<HalfMatch> = Vec::new();",
          "    ",
          "    loop {",
          "        match dfa.try_search_rev(&mut cache, &input) {",
          "            Err(_) => break,",
          "            Some(hm) => {",
          "                matches.push(hm);",
          "                if hm.offset() == 0 || input.end() == 0 {",
          "                    break;",
          "                } else {",
          "                    input.set_end(hm.offset());",
          "                }",
          "            }",
          "        }",
          "    }",
          "    assert!(dfa.get_nfa().has_empty() == false);",
          "    let result = dfa.try_search_rev(&mut cache, &input);",
          "    assert!(result.is_ok());",
          "    assert!(result.is_some());",
          "    let match_result = result.unwrap();",
          "    assert!(match_result.is_some());",
          "    assert_eq!(match_result.pattern(), 0);",
          "    assert!(hm.offset() > 0);",
          "    assert!(dfa.try_search_rev(&mut cache, &Input::new(\"invalid\"))?.is_none());",
          "    assert!(dfa.get_nfa().is_utf8() == true);",
          "    assert!(utf8empty == true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let dfa = DFA::builder()",
          "        .thompson(thompson::Config::new().reverse(true).utf8(false))",
          "        .build(\"☃\").unwrap();",
          "    let mut cache = dfa.create_cache();",
          "    let input = Input::new(\"☃\");",
          "    let matches: Vec<HalfMatch> = Vec::new();",
          "    ",
          "    loop {",
          "        match dfa.try_search_rev(&mut cache, &input) {",
          "            Err(_) => break,",
          "            Some(hm) => {",
          "                matches.push(hm);",
          "                if hm.offset() == 0 || input.end() == 0 {",
          "                    break;",
          "                } else {",
          "                    input.set_end(hm.offset());",
          "                }",
          "            }",
          "        }",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dfa.try_search_rev(&mut cache, &Input::new(\"foo12345\")), Ok(Some(HalfMatch::must(0, 0))));",
          "    ",
          "    let result = dfa.try_search_rev(&mut cache, &Input::new(\"abc\"));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Some(HalfMatch::must(0, 0)));",
          "    ",
          "    assert!(dfa.get_nfa().has_empty() == false);",
          "    ",
          "    let result_none = dfa.try_search_rev(&mut cache, &Input::new(\"no_match\"));",
          "    assert_eq!(result_none, Ok(None));",
          "    ",
          "    let utf8empty = dfa.get_nfa().has_empty() && dfa.get_nfa().is_utf8();",
          "    assert!(utf8empty);",
          "    ",
          "    let search_result = search::find_rev(&dfa, &mut cache, &input);",
          "    assert!(search_result.is_ok());",
          "    ",
          "    let pattern_exists = match search_result {",
          "    Ok(Some(_)) => true,",
          "    _ => false,",
          "    };",
          "    assert!(pattern_exists);"
        ],
        "code": [
          "{",
          "    let dfa = DFA::builder()",
          "        .thompson(thompson::Config::new().reverse(true).utf8(false))",
          "        .build(\"☃\").unwrap();",
          "    let mut cache = dfa.create_cache();",
          "    let input = Input::new(\"☃\");",
          "    let matches: Vec<HalfMatch> = Vec::new();",
          "    ",
          "    loop {",
          "        match dfa.try_search_rev(&mut cache, &input) {",
          "            Err(_) => break,",
          "            Some(hm) => {",
          "                matches.push(hm);",
          "                if hm.offset() == 0 || input.end() == 0 {",
          "                    break;",
          "                } else {",
          "                    input.set_end(hm.offset());",
          "                }",
          "            }",
          "        }",
          "    }",
          "    assert_eq!(dfa.try_search_rev(&mut cache, &Input::new(\"foo12345\")), Ok(Some(HalfMatch::must(0, 0))));",
          "    ",
          "    let result = dfa.try_search_rev(&mut cache, &Input::new(\"abc\"));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Some(HalfMatch::must(0, 0)));",
          "    ",
          "    assert!(dfa.get_nfa().has_empty() == false);",
          "    ",
          "    let result_none = dfa.try_search_rev(&mut cache, &Input::new(\"no_match\"));",
          "    assert_eq!(result_none, Ok(None));",
          "    ",
          "    let utf8empty = dfa.get_nfa().has_empty() && dfa.get_nfa().is_utf8();",
          "    assert!(utf8empty);",
          "    ",
          "    let search_result = search::find_rev(&dfa, &mut cache, &input);",
          "    assert!(search_result.is_ok());",
          "    ",
          "    let pattern_exists = match search_result {",
          "    Ok(Some(_)) => true,",
          "    _ => false,",
          "    };",
          "    assert!(pattern_exists);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]