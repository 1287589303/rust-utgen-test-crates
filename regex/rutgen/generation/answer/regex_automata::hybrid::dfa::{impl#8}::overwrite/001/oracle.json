[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "struct DummyPrefilter;",
      "",
      "impl PrefilterI for DummyPrefilter {}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let default_config = Config::new()",
          "        .match_kind(MatchKind::All)",
          "        .prefilter(Some(Prefilter {",
          "            pre: Arc::new(DummyPrefilter {}),",
          "            is_fast: true,",
          "            max_needle_len: 10,",
          "        }))",
          "        .starts_for_each_pattern(true)",
          "        .byte_classes(true)",
          "        .unicode_word_boundary(true)",
          "        .quit(1, true)",
          "        .specialize_start_states(true)",
          "        .cache_capacity(1024)",
          "        .skip_cache_capacity_check(true)",
          "        .minimum_cache_clear_count(Some(0))",
          "        .minimum_bytes_per_state(Some(0));",
          "        ",
          "    let new_config = Config::new()",
          "        .match_kind(MatchKind::LeftmostFirst)",
          "        .prefilter(Some(Prefilter {",
          "            pre: Arc::new(DummyPrefilter {}),",
          "            is_fast: false,",
          "            max_needle_len: 5,",
          "        }))",
          "        .starts_for_each_pattern(false)",
          "        .byte_classes(false)",
          "        .unicode_word_boundary(false)",
          "        .quit(2, false)",
          "        .specialize_start_states(false)",
          "        .cache_capacity(512)",
          "        .skip_cache_capacity_check(false)",
          "        .minimum_cache_clear_count(Some(1))",
          "        .minimum_bytes_per_state(Some(1));",
          "",
          "    let result = default_config.overwrite(new_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.match_kind, MatchKind::LeftmostFirst);",
          "    assert_eq!(result.pre.as_ref().unwrap().is_fast, false);",
          "    assert_eq!(result.pre.as_ref().unwrap().max_needle_len, 5);",
          "    assert_eq!(result.starts_for_each_pattern, false);",
          "    assert_eq!(result.byte_classes, false);",
          "    assert_eq!(result.unicode_word_boundary, false);",
          "    assert_eq!(result.quitset, None);",
          "    assert_eq!(result.specialize_start_states, false);",
          "    assert_eq!(result.cache_capacity, 512);",
          "    assert_eq!(result.skip_cache_capacity_check, false);",
          "    assert_eq!(result.minimum_cache_clear_count, Some(1));",
          "    assert_eq!(result.minimum_bytes_per_state, Some(1));"
        ],
        "code": [
          "{",
          "    let default_config = Config::new()",
          "        .match_kind(MatchKind::All)",
          "        .prefilter(Some(Prefilter {",
          "            pre: Arc::new(DummyPrefilter {}),",
          "            is_fast: true,",
          "            max_needle_len: 10,",
          "        }))",
          "        .starts_for_each_pattern(true)",
          "        .byte_classes(true)",
          "        .unicode_word_boundary(true)",
          "        .quit(1, true)",
          "        .specialize_start_states(true)",
          "        .cache_capacity(1024)",
          "        .skip_cache_capacity_check(true)",
          "        .minimum_cache_clear_count(Some(0))",
          "        .minimum_bytes_per_state(Some(0));",
          "        ",
          "    let new_config = Config::new()",
          "        .match_kind(MatchKind::LeftmostFirst)",
          "        .prefilter(Some(Prefilter {",
          "            pre: Arc::new(DummyPrefilter {}),",
          "            is_fast: false,",
          "            max_needle_len: 5,",
          "        }))",
          "        .starts_for_each_pattern(false)",
          "        .byte_classes(false)",
          "        .unicode_word_boundary(false)",
          "        .quit(2, false)",
          "        .specialize_start_states(false)",
          "        .cache_capacity(512)",
          "        .skip_cache_capacity_check(false)",
          "        .minimum_cache_clear_count(Some(1))",
          "        .minimum_bytes_per_state(Some(1));",
          "",
          "    let result = default_config.overwrite(new_config);",
          "    assert_eq!(result.match_kind, MatchKind::LeftmostFirst);",
          "    assert_eq!(result.pre.as_ref().unwrap().is_fast, false);",
          "    assert_eq!(result.pre.as_ref().unwrap().max_needle_len, 5);",
          "    assert_eq!(result.starts_for_each_pattern, false);",
          "    assert_eq!(result.byte_classes, false);",
          "    assert_eq!(result.unicode_word_boundary, false);",
          "    assert_eq!(result.quitset, None);",
          "    assert_eq!(result.specialize_start_states, false);",
          "    assert_eq!(result.cache_capacity, 512);",
          "    assert_eq!(result.skip_cache_capacity_check, false);",
          "    assert_eq!(result.minimum_cache_clear_count, Some(1));",
          "    assert_eq!(result.minimum_bytes_per_state, Some(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let default_config = Config::new();",
          "    ",
          "    let new_config = Config::new();",
          "",
          "    let result = default_config.overwrite(new_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.match_kind, default_config.match_kind);",
          "    assert_eq!(result.pre, default_config.pre);",
          "    assert_eq!(result.starts_for_each_pattern, default_config.starts_for_each_pattern);",
          "    assert_eq!(result.byte_classes, default_config.byte_classes);",
          "    assert_eq!(result.unicode_word_boundary, default_config.unicode_word_boundary);",
          "    assert_eq!(result.quitset, default_config.quitset);",
          "    assert_eq!(result.specialize_start_states, default_config.specialize_start_states);",
          "    assert_eq!(result.cache_capacity, default_config.cache_capacity);",
          "    assert_eq!(result.skip_cache_capacity_check, default_config.skip_cache_capacity_check);",
          "    assert_eq!(result.minimum_cache_clear_count, default_config.minimum_cache_clear_count);",
          "    assert_eq!(result.minimum_bytes_per_state, default_config.minimum_bytes_per_state);"
        ],
        "code": [
          "{",
          "    let default_config = Config::new();",
          "    ",
          "    let new_config = Config::new();",
          "",
          "    let result = default_config.overwrite(new_config);",
          "    assert_eq!(result.match_kind, default_config.match_kind);",
          "    assert_eq!(result.pre, default_config.pre);",
          "    assert_eq!(result.starts_for_each_pattern, default_config.starts_for_each_pattern);",
          "    assert_eq!(result.byte_classes, default_config.byte_classes);",
          "    assert_eq!(result.unicode_word_boundary, default_config.unicode_word_boundary);",
          "    assert_eq!(result.quitset, default_config.quitset);",
          "    assert_eq!(result.specialize_start_states, default_config.specialize_start_states);",
          "    assert_eq!(result.cache_capacity, default_config.cache_capacity);",
          "    assert_eq!(result.skip_cache_capacity_check, default_config.skip_cache_capacity_check);",
          "    assert_eq!(result.minimum_cache_clear_count, default_config.minimum_cache_clear_count);",
          "    assert_eq!(result.minimum_bytes_per_state, default_config.minimum_bytes_per_state);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let default_config = Config::new()",
          "        .match_kind(MatchKind::All)",
          "        .prefilter(None)",
          "        .starts_for_each_pattern(true)",
          "        .byte_classes(false)",
          "        .unicode_word_boundary(false);",
          "        ",
          "    let new_config = Config::new()",
          "        .match_kind(MatchKind::LeftmostFirst)",
          "        .prefilter(Some(Prefilter {",
          "            pre: Arc::new(DummyPrefilter {}),",
          "            is_fast: true,",
          "            max_needle_len: 3,",
          "        }))",
          "        .starts_for_each_pattern(false)",
          "        .cache_capacity(256);",
          "",
          "    let result = default_config.overwrite(new_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.match_kind, Some(MatchKind::LeftmostFirst));",
          "    assert_eq!(result.pre, Some(Some(Prefilter {",
          "    pre: Arc::new(DummyPrefilter {}),",
          "    is_fast: true,",
          "    max_needle_len: 3,",
          "    })));",
          "    assert_eq!(result.starts_for_each_pattern, true);",
          "    assert_eq!(result.byte_classes, false);",
          "    assert_eq!(result.unicode_word_boundary, false);",
          "    assert_eq!(result.cache_capacity, Some(256));",
          "    assert_eq!(result.quitset, None);",
          "    assert_eq!(result.specialize_start_states, None);",
          "    assert_eq!(result.skip_cache_capacity_check, None);",
          "    assert_eq!(result.minimum_cache_clear_count, None);",
          "    assert_eq!(result.minimum_bytes_per_state, None);"
        ],
        "code": [
          "{",
          "    let default_config = Config::new()",
          "        .match_kind(MatchKind::All)",
          "        .prefilter(None)",
          "        .starts_for_each_pattern(true)",
          "        .byte_classes(false)",
          "        .unicode_word_boundary(false);",
          "        ",
          "    let new_config = Config::new()",
          "        .match_kind(MatchKind::LeftmostFirst)",
          "        .prefilter(Some(Prefilter {",
          "            pre: Arc::new(DummyPrefilter {}),",
          "            is_fast: true,",
          "            max_needle_len: 3,",
          "        }))",
          "        .starts_for_each_pattern(false)",
          "        .cache_capacity(256);",
          "",
          "    let result = default_config.overwrite(new_config);",
          "    assert_eq!(result.match_kind, Some(MatchKind::LeftmostFirst));",
          "    assert_eq!(result.pre, Some(Some(Prefilter {",
          "    pre: Arc::new(DummyPrefilter {}),",
          "    is_fast: true,",
          "    max_needle_len: 3,",
          "    })));",
          "    assert_eq!(result.starts_for_each_pattern, true);",
          "    assert_eq!(result.byte_classes, false);",
          "    assert_eq!(result.unicode_word_boundary, false);",
          "    assert_eq!(result.cache_capacity, Some(256));",
          "    assert_eq!(result.quitset, None);",
          "    assert_eq!(result.specialize_start_states, None);",
          "    assert_eq!(result.skip_cache_capacity_check, None);",
          "    assert_eq!(result.minimum_cache_clear_count, None);",
          "    assert_eq!(result.minimum_bytes_per_state, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]