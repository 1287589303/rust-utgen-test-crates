[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(0);",
          "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "}"
        ],
        "oracle": [
          "    seq.is_empty() == false",
          "    seq.len() == Some(2)",
          "    seq.literals().unwrap().len() == 2",
          "    seq.literals().unwrap()[0].len() == 3",
          "    seq.literals().unwrap()[1].len() == 3",
          "    seq.literals().unwrap()[0] == b\"abc\"",
          "    seq.literals().unwrap()[1] == b\"def\""
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(0);",
          "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "    seq.is_empty() == false",
          "    seq.len() == Some(2)",
          "    seq.literals().unwrap().len() == 2",
          "    seq.literals().unwrap()[0].len() == 3",
          "    seq.literals().unwrap()[1].len() == 3",
          "    seq.literals().unwrap()[0] == b\"abc\"",
          "    seq.literals().unwrap()[1] == b\"def\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
          "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0], Literal::new(b\"a\"));",
          "    assert_eq!(seq.literals().unwrap()[1], Literal::new(b\"d\"));",
          "    assert!(seq.is_finite());",
          "    assert!(!seq.is_empty());",
          "    assert_eq!(seq.len().unwrap(), 2);",
          "    assert_eq!(seq.min_literal_len().unwrap(), 1);",
          "    assert_eq!(seq.max_literal_len().unwrap(), 1);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
          "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0], Literal::new(b\"a\"));",
          "    assert_eq!(seq.literals().unwrap()[1], Literal::new(b\"d\"));",
          "    assert!(seq.is_finite());",
          "    assert!(!seq.is_empty());",
          "    assert_eq!(seq.len().unwrap(), 2);",
          "    assert_eq!(seq.min_literal_len().unwrap(), 1);",
          "    assert_eq!(seq.max_literal_len().unwrap(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(3);",
          "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert!(seq.literals().unwrap()[0].len() <= 3);",
          "    assert!(seq.literals().unwrap()[1].len() <= 3);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(3);",
          "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert!(seq.literals().unwrap()[0].len() <= 3);",
          "    assert!(seq.literals().unwrap()[1].len() <= 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(2);",
          "    let mut seq = Seq::new(vec![b\"abcdef\", b\"ghijk\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0].len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[1].len(), 2);",
          "    assert!(seq.literals().unwrap()[0] == b\"ab\" || seq.literals().unwrap()[0] == b\"gh\");",
          "    assert!(seq.literals().unwrap()[1] == b\"cd\" || seq.literals().unwrap()[1] == b\"ij\");"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(2);",
          "    let mut seq = Seq::new(vec![b\"abcdef\", b\"ghijk\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0].len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[1].len(), 2);",
          "    assert!(seq.literals().unwrap()[0] == b\"ab\" || seq.literals().unwrap()[0] == b\"gh\");",
          "    assert!(seq.literals().unwrap()[1] == b\"cd\" || seq.literals().unwrap()[1] == b\"ij\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
          "    let mut seq = Seq::new(vec![b\"\", b\"abc\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "}"
        ],
        "oracle": [
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
          "    let mut seq = Seq::new(vec![b\"\", b\"abc\"]);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    extractor.enforce_literal_len(&mut seq);",
          "    assert_eq!(seq.literals().unwrap().len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[0], b\"a\");"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
          "    let mut seq = Seq::new(vec![b\"\", b\"abc\"]);",
          "    extractor.enforce_literal_len(&mut seq);",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
          "    let mut seq = Seq::new(vec![b\"\", b\"abc\"]);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    extractor.enforce_literal_len(&mut seq);",
          "    assert_eq!(seq.literals().unwrap().len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[0], b\"a\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(5);",
          "    let mut seq = Seq::empty();",
          "    extractor.enforce_literal_len(&mut seq);",
          "}"
        ],
        "oracle": [
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix);",
          "    assert_eq!(extractor.limit_literal_len, 5);",
          "    let mut seq = Seq::empty();",
          "    assert!(seq.is_empty());",
          "    extractor.enforce_literal_len(&mut seq);",
          "    assert_eq!(seq.len(), Some(0));",
          "    assert!(seq.is_empty());"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix).limit_literal_len(5);",
          "    let mut seq = Seq::empty();",
          "    extractor.enforce_literal_len(&mut seq);",
          "    let mut extractor = Extractor::new();",
          "    extractor.kind(ExtractKind::Prefix);",
          "    assert_eq!(extractor.limit_literal_len, 5);",
          "    let mut seq = Seq::empty();",
          "    assert!(seq.is_empty());",
          "    extractor.enforce_literal_len(&mut seq);",
          "    assert_eq!(seq.len(), Some(0));",
          "    assert!(seq.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]