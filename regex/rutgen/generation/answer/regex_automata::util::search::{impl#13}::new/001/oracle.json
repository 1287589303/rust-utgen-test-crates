[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = PatternID(0);",
          "    let span = Span { start: 5, end: 5 };",
          "    let m = Match::new(pattern, span);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(m.pattern(), pattern);",
          "    assert_eq!(m.start(), span.start);",
          "    assert_eq!(m.end(), span.end);",
          "    assert!(m.is_empty());",
          "    assert_eq!(m.len(), 0);",
          "    assert_eq!(m.range(), 5..5);",
          "    assert_eq!(m.span(), span);"
        ],
        "code": [
          "{",
          "    let pattern = PatternID(0);",
          "    let span = Span { start: 5, end: 5 };",
          "    let m = Match::new(pattern, span);",
          "    assert_eq!(m.pattern(), pattern);",
          "    assert_eq!(m.start(), span.start);",
          "    assert_eq!(m.end(), span.end);",
          "    assert!(m.is_empty());",
          "    assert_eq!(m.len(), 0);",
          "    assert_eq!(m.range(), 5..5);",
          "    assert_eq!(m.span(), span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = PatternID(1);",
          "    let span = Span { start: 0, end: 0 };",
          "    let m = Match::new(pattern, span);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(m.pattern, pattern);",
          "    assert_eq!(m.span.start, span.start);",
          "    assert_eq!(m.span.end, span.end);",
          "    assert!(m.is_empty());",
          "    assert_eq!(m.len(), 0);",
          "    assert_eq!(m.range(), 0..0);"
        ],
        "code": [
          "{",
          "    let pattern = PatternID(1);",
          "    let span = Span { start: 0, end: 0 };",
          "    let m = Match::new(pattern, span);",
          "    assert_eq!(m.pattern, pattern);",
          "    assert_eq!(m.span.start, span.start);",
          "    assert_eq!(m.span.end, span.end);",
          "    assert!(m.is_empty());",
          "    assert_eq!(m.len(), 0);",
          "    assert_eq!(m.range(), 0..0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = PatternID(2);",
          "    let span = Span { start: 1, end: 10 };",
          "    let m = Match::new(pattern, span);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(m.pattern(), pattern);",
          "    assert_eq!(m.start(), span.start);",
          "    assert_eq!(m.end(), span.end);",
          "    assert!(!m.is_empty());",
          "    assert_eq!(m.len(), span.end - span.start);",
          "    assert_eq!(m.span(), span);",
          "    assert_eq!(m.range(), span.start..span.end);"
        ],
        "code": [
          "{",
          "    let pattern = PatternID(2);",
          "    let span = Span { start: 1, end: 10 };",
          "    let m = Match::new(pattern, span);",
          "    assert_eq!(m.pattern(), pattern);",
          "    assert_eq!(m.start(), span.start);",
          "    assert_eq!(m.end(), span.end);",
          "    assert!(!m.is_empty());",
          "    assert_eq!(m.len(), span.end - span.start);",
          "    assert_eq!(m.span(), span);",
          "    assert_eq!(m.range(), span.start..span.end);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = PatternID(3);",
          "    let span = 3..3;",
          "    let m = Match::new(pattern, span);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(m.pattern, pattern);",
          "    assert_eq!(m.span.start, span.start);",
          "    assert_eq!(m.span.end, span.end);",
          "    assert!(m.is_empty());",
          "    assert_eq!(m.len(), 0);",
          "    assert_eq!(m.range(), 3..3);"
        ],
        "code": [
          "{",
          "    let pattern = PatternID(3);",
          "    let span = 3..3;",
          "    let m = Match::new(pattern, span);",
          "    assert_eq!(m.pattern, pattern);",
          "    assert_eq!(m.span.start, span.start);",
          "    assert_eq!(m.span.end, span.end);",
          "    assert!(m.is_empty());",
          "    assert_eq!(m.len(), 0);",
          "    assert_eq!(m.range(), 3..3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = PatternID(4);",
          "    let span = 0..100;",
          "    let m = Match::new(pattern, span);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(m.pattern(), PatternID(4));",
          "    assert_eq!(m.start(), 0);",
          "    assert_eq!(m.end(), 100);",
          "    assert_eq!(m.range(), 0..100);",
          "    assert_eq!(m.span(), Span { start: 0, end: 100 });",
          "    assert!(!m.is_empty());",
          "    assert_eq!(m.len(), 100);"
        ],
        "code": [
          "{",
          "    let pattern = PatternID(4);",
          "    let span = 0..100;",
          "    let m = Match::new(pattern, span);",
          "    assert_eq!(m.pattern(), PatternID(4));",
          "    assert_eq!(m.start(), 0);",
          "    assert_eq!(m.end(), 100);",
          "    assert_eq!(m.range(), 0..100);",
          "    assert_eq!(m.span(), Span { start: 0, end: 100 });",
          "    assert!(!m.is_empty());",
          "    assert_eq!(m.len(), 100);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]