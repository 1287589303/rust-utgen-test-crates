[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![Literal {",
          "            span: Span::new(0, 1),",
          "            kind: LiteralKind::Exact,",
          "            c: 'a',",
          "        }]),",
          "    };",
          "    let new_literal = Literal {",
          "        span: Span::new(1, 2),",
          "        kind: LiteralKind::Exact,",
          "        c: 'b',",
          "    };",
          "    seq.push(new_literal);",
          "}"
        ],
        "oracle": [
          "    seq.literals().unwrap().len() == 2",
          "    seq.literals().unwrap()[1] == Literal {",
          "    span: Span::new(1, 2),",
          "    kind: LiteralKind::Exact,",
          "    c: 'b'",
          "    }"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![Literal {",
          "            span: Span::new(0, 1),",
          "            kind: LiteralKind::Exact,",
          "            c: 'a',",
          "        }]),",
          "    };",
          "    let new_literal = Literal {",
          "        span: Span::new(1, 2),",
          "        kind: LiteralKind::Exact,",
          "        c: 'b',",
          "    };",
          "    seq.push(new_literal);",
          "    seq.literals().unwrap().len() == 2",
          "    seq.literals().unwrap()[1] == Literal {",
          "    span: Span::new(1, 2),",
          "    kind: LiteralKind::Exact,",
          "    c: 'b'",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 1),",
          "                kind: LiteralKind::Exact,",
          "                c: 'a',",
          "            },",
          "            Literal {",
          "                span: Span::new(1, 2),",
          "                kind: LiteralKind::Exact,",
          "                c: 'b',",
          "            },",
          "        ]),",
          "    };",
          "    let new_literal = Literal {",
          "        span: Span::new(2, 3),",
          "        kind: LiteralKind::Exact,",
          "        c: 'c',",
          "    };",
          "    seq.push(new_literal);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[2].span, Span::new(2, 3));",
          "    assert_eq!(seq.literals().unwrap()[2].kind, LiteralKind::Exact);",
          "    assert_eq!(seq.literals().unwrap()[2].c, 'c');"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 1),",
          "                kind: LiteralKind::Exact,",
          "                c: 'a',",
          "            },",
          "            Literal {",
          "                span: Span::new(1, 2),",
          "                kind: LiteralKind::Exact,",
          "                c: 'b',",
          "            },",
          "        ]),",
          "    };",
          "    let new_literal = Literal {",
          "        span: Span::new(2, 3),",
          "        kind: LiteralKind::Exact,",
          "        c: 'c',",
          "    };",
          "    seq.push(new_literal);",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[2].span, Span::new(2, 3));",
          "    assert_eq!(seq.literals().unwrap()[2].kind, LiteralKind::Exact);",
          "    assert_eq!(seq.literals().unwrap()[2].c, 'c');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![Literal {",
          "            span: Span::new(0, 1),",
          "            kind: LiteralKind::Exact,",
          "            c: 'a',",
          "        }]),",
          "    };",
          "    let new_literal = Literal {",
          "        span: Span::new(1, 2),",
          "        kind: LiteralKind::Exact,",
          "        c: 'b',",
          "    };",
          "    seq.push(new_literal);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0].c, 'a');",
          "    assert_eq!(seq.literals().unwrap()[1].c, 'b');",
          "    assert!(seq.literals().unwrap()[0].span == Span::new(0, 1));",
          "    assert!(seq.literals().unwrap()[1].span == Span::new(1, 2));",
          "    assert!(seq.literals().unwrap()[0].kind == LiteralKind::Exact);",
          "    assert!(seq.literals().unwrap()[1].kind == LiteralKind::Exact);"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![Literal {",
          "            span: Span::new(0, 1),",
          "            kind: LiteralKind::Exact,",
          "            c: 'a',",
          "        }]),",
          "    };",
          "    let new_literal = Literal {",
          "        span: Span::new(1, 2),",
          "        kind: LiteralKind::Exact,",
          "        c: 'b',",
          "    };",
          "    seq.push(new_literal);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0].c, 'a');",
          "    assert_eq!(seq.literals().unwrap()[1].c, 'b');",
          "    assert!(seq.literals().unwrap()[0].span == Span::new(0, 1));",
          "    assert!(seq.literals().unwrap()[1].span == Span::new(1, 2));",
          "    assert!(seq.literals().unwrap()[0].kind == LiteralKind::Exact);",
          "    assert!(seq.literals().unwrap()[1].kind == LiteralKind::Exact);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 1),",
          "                kind: LiteralKind::Exact,",
          "                c: '1',",
          "            },",
          "            Literal {",
          "                span: Span::new(1, 2),",
          "                kind: LiteralKind::Exact,",
          "                c: '2',",
          "            },",
          "        ]),",
          "    };",
          "    let new_literal = Literal {",
          "        span: Span::new(2, 3),",
          "        kind: LiteralKind::Exact,",
          "        c: '3',",
          "    };",
          "    seq.push(new_literal);",
          "}"
        ],
        "oracle": [
          "    seq.literals().unwrap().len() == 3",
          "    ",
          "    seq.literals().unwrap().last().unwrap().c == '3'",
          "    ",
          "    seq.literals().unwrap()[0].c == '1'",
          "    ",
          "    seq.literals().unwrap()[1].c == '2'",
          "    ",
          "    seq.literals().unwrap()[2].c == '3'"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 1),",
          "                kind: LiteralKind::Exact,",
          "                c: '1',",
          "            },",
          "            Literal {",
          "                span: Span::new(1, 2),",
          "                kind: LiteralKind::Exact,",
          "                c: '2',",
          "            },",
          "        ]),",
          "    };",
          "    let new_literal = Literal {",
          "        span: Span::new(2, 3),",
          "        kind: LiteralKind::Exact,",
          "        c: '3',",
          "    };",
          "    seq.push(new_literal);",
          "    seq.literals().unwrap().len() == 3",
          "    ",
          "    seq.literals().unwrap().last().unwrap().c == '3'",
          "    ",
          "    seq.literals().unwrap()[0].c == '1'",
          "    ",
          "    seq.literals().unwrap()[1].c == '2'",
          "    ",
          "    seq.literals().unwrap()[2].c == '3'",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]