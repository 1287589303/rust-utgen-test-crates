[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: Vec::new(),",
          "        cache: StateMap::default(),",
          "        memory_usage_state: 0,",
          "        sparses: SparseSets::default(),",
          "        stack: Vec::new(),",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(runner.builder_states.len(), 0);",
          "    assert_eq!(runner.cache.len(), 0);",
          "    assert_eq!(runner.memory_usage_state, 0);",
          "    assert_eq!(runner.stack.capacity(), 0);",
          "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
          "    assert_eq!(runner.memory_usage(), 0);"
        ],
        "code": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: Vec::new(),",
          "        cache: StateMap::default(),",
          "        memory_usage_state: 0,",
          "        sparses: SparseSets::default(),",
          "        stack: Vec::new(),",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "    assert_eq!(runner.builder_states.len(), 0);",
          "    assert_eq!(runner.cache.len(), 0);",
          "    assert_eq!(runner.memory_usage_state, 0);",
          "    assert_eq!(runner.stack.capacity(), 0);",
          "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
          "    assert_eq!(runner.memory_usage(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let state = State {",
          "        id: StateID(0),",
          "        transitions: &[],",
          "    };",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: vec![state],",
          "        cache: StateMap::default(),",
          "        memory_usage_state: 10,",
          "        sparses: SparseSets::default(),",
          "        stack: Vec::new(),",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(runner.builder_states.len(), 1);",
          "    assert_eq!(core::mem::size_of::<State>(), expected_size_of_state);",
          "    assert_eq!(runner.cache.len(), 0);",
          "    assert_eq!(runner.memory_usage_state, 10);",
          "    assert_eq!(runner.stack.capacity(), 0);",
          "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
          "    assert_eq!(runner.memory_usage(),",
          "    runner.builder_states.len() * core::mem::size_of::<State>() +",
          "    runner.cache.len() * (core::mem::size_of::<State>() + core::mem::size_of::<StateID>()) +",
          "    runner.memory_usage_state +",
          "    runner.stack.capacity() * core::mem::size_of::<StateID>() +",
          "    runner.scratch_state_builder.capacity());"
        ],
        "code": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let state = State {",
          "        id: StateID(0),",
          "        transitions: &[],",
          "    };",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: vec![state],",
          "        cache: StateMap::default(),",
          "        memory_usage_state: 10,",
          "        sparses: SparseSets::default(),",
          "        stack: Vec::new(),",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "    assert_eq!(runner.builder_states.len(), 1);",
          "    assert_eq!(core::mem::size_of::<State>(), expected_size_of_state);",
          "    assert_eq!(runner.cache.len(), 0);",
          "    assert_eq!(runner.memory_usage_state, 10);",
          "    assert_eq!(runner.stack.capacity(), 0);",
          "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
          "    assert_eq!(runner.memory_usage(),",
          "    runner.builder_states.len() * core::mem::size_of::<State>() +",
          "    runner.cache.len() * (core::mem::size_of::<State>() + core::mem::size_of::<StateID>()) +",
          "    runner.memory_usage_state +",
          "    runner.stack.capacity() * core::mem::size_of::<StateID>() +",
          "    runner.scratch_state_builder.capacity());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let states: Vec<State> = (0..10).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: states,",
          "        cache: StateMap::default(),",
          "        memory_usage_state: 50,",
          "        sparses: SparseSets::default(),",
          "        stack: vec![0; 5],",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(runner.builder_states.len(), 10);",
          "    assert_eq!(runner.cache.len(), 0);",
          "    assert_eq!(runner.memory_usage_state, 50);",
          "    assert_eq!(runner.stack.capacity(), 5);",
          "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
          "    let expected_memory_usage = (runner.builder_states.len() * core::mem::size_of::<State>()",
          "    + runner.cache.len() * (core::mem::size_of::<State>() + core::mem::size_of::<StateID>())",
          "    + runner.memory_usage_state",
          "    + runner.stack.capacity() * core::mem::size_of::<StateID>()",
          "    + runner.scratch_state_builder.capacity());",
          "    assert_eq!(runner.memory_usage(), expected_memory_usage);"
        ],
        "code": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let states: Vec<State> = (0..10).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: states,",
          "        cache: StateMap::default(),",
          "        memory_usage_state: 50,",
          "        sparses: SparseSets::default(),",
          "        stack: vec![0; 5],",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "    assert_eq!(runner.builder_states.len(), 10);",
          "    assert_eq!(runner.cache.len(), 0);",
          "    assert_eq!(runner.memory_usage_state, 50);",
          "    assert_eq!(runner.stack.capacity(), 5);",
          "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
          "    let expected_memory_usage = (runner.builder_states.len() * core::mem::size_of::<State>()",
          "    + runner.cache.len() * (core::mem::size_of::<State>() + core::mem::size_of::<StateID>())",
          "    + runner.memory_usage_state",
          "    + runner.stack.capacity() * core::mem::size_of::<StateID>()",
          "    + runner.scratch_state_builder.capacity());",
          "    assert_eq!(runner.memory_usage(), expected_memory_usage);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let states: Vec<State> = (0..1000).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: states,",
          "        cache: StateMap::default(),",
          "        memory_usage_state: 4096,",
          "        sparses: SparseSets::default(),",
          "        stack: vec![0; 100],",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "}"
        ],
        "oracle": [
          "    runner.builder_states.len() * size_of::<State>() == 1000 * size_of::<State>()",
          "    runner.cache.len() * (size_of::<State>() + size_of::<StateID>()) == 0 * (size_of::<State>() + size_of::<StateID>())",
          "    runner.memory_usage_state == 4096",
          "    runner.stack.capacity() * size_of::<StateID>() == 100 * size_of::<StateID>()",
          "    runner.scratch_state_builder.capacity() == 0"
        ],
        "code": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let states: Vec<State> = (0..1000).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: states,",
          "        cache: StateMap::default(),",
          "        memory_usage_state: 4096,",
          "        sparses: SparseSets::default(),",
          "        stack: vec![0; 100],",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "    runner.builder_states.len() * size_of::<State>() == 1000 * size_of::<State>()",
          "    runner.cache.len() * (size_of::<State>() + size_of::<StateID>()) == 0 * (size_of::<State>() + size_of::<StateID>())",
          "    runner.memory_usage_state == 4096",
          "    runner.stack.capacity() * size_of::<StateID>() == 100 * size_of::<StateID>()",
          "    runner.scratch_state_builder.capacity() == 0",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let states: Vec<State> = (0..50).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: states,",
          "        cache: StateMap::from_iter((0..5).map(|i| (State(i), StateID(i)))),",
          "        memory_usage_state: 100,",
          "        sparses: SparseSets::default(),",
          "        stack: vec![0; 20],",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(runner.memory_usage(), 50 * std::mem::size_of::<State>() + 5 * (std::mem::size_of::<State>() + std::mem::size_of::<StateID>()) + 100 + 20 * std::mem::size_of::<StateID>() + runner.scratch_state_builder.capacity());"
        ],
        "code": [
          "{",
          "    let config = Config::default();",
          "    let nfa = Box::new(thompson::NFA::new());",
          "    let mut dfa = dense::OwnedDFA::default();",
          "    let states: Vec<State> = (0..50).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
          "    let runner = Runner {",
          "        config,",
          "        nfa: &nfa,",
          "        dfa: &mut dfa,",
          "        builder_states: states,",
          "        cache: StateMap::from_iter((0..5).map(|i| (State(i), StateID(i)))),",
          "        memory_usage_state: 100,",
          "        sparses: SparseSets::default(),",
          "        stack: vec![0; 20],",
          "        scratch_state_builder: StateBuilderEmpty::new(),",
          "    };",
          "    let _ = runner.memory_usage();",
          "    assert_eq!(runner.memory_usage(), 50 * std::mem::size_of::<State>() + 5 * (std::mem::size_of::<State>() + std::mem::size_of::<StateID>()) + 100 + 20 * std::mem::size_of::<StateID>() + runner.scratch_state_builder.capacity());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]