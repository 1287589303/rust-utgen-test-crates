[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table = vec![StateID::default(), StateID::default(), StateID::default()];",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "",
          "    let _ = start_table.write_to::<Endian>(&mut dst).unwrap();",
          "}"
        ],
        "oracle": [
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table = vec![StateID::default(), StateID::default(), StateID::default()];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    assert!(dst.len() >= nwrite);",
          "    assert!(self.kind.write_to::<E>(dst).is_ok());",
          "    assert!(self.start_map.write_to(dst).is_ok());",
          "    assert!(!self.table().is_empty());",
          "    let sid = self.table().get(0).unwrap();",
          "    assert!(self.table().contains(&sid));"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table = vec![StateID::default(), StateID::default(), StateID::default()];",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "",
          "    let _ = start_table.write_to::<Endian>(&mut dst).unwrap();",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table = vec![StateID::default(), StateID::default(), StateID::default()];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    assert!(dst.len() >= nwrite);",
          "    assert!(self.kind.write_to::<E>(dst).is_ok());",
          "    assert!(self.start_map.write_to(dst).is_ok());",
          "    assert!(!self.table().is_empty());",
          "    let sid = self.table().get(0).unwrap();",
          "    assert!(self.table().contains(&sid));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table: Vec<StateID> = vec![];",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert!(result.is_err());",
          "}"
        ],
        "oracle": [
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(1))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    ",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(2))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert!(result.is_err());",
          "    ",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(2);",
          "    let universal_start_unanchored = Some(StateID(SmallIndex(3)));",
          "    let universal_start_anchored = Some(StateID(SmallIndex(4)));",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(5)), StateID(SmallIndex(6))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    ",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored = Some(StateID(SmallIndex(7)));",
          "    let universal_start_anchored = None;",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(8)), StateID(SmallIndex(9))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert!(result.is_err());",
          "    ",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = Some(StateID(SmallIndex(10)));",
          "    let universal_start_anchored = Some(StateID(SmallIndex(11)));",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(12)), StateID(SmallIndex(13))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table: Vec<StateID> = vec![];",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert!(result.is_err());",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(1))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    ",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(2))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert!(result.is_err());",
          "    ",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(2);",
          "    let universal_start_unanchored = Some(StateID(SmallIndex(3)));",
          "    let universal_start_anchored = Some(StateID(SmallIndex(4)));",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(5)), StateID(SmallIndex(6))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    ",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored = Some(StateID(SmallIndex(7)));",
          "    let universal_start_anchored = None;",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(8)), StateID(SmallIndex(9))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert!(result.is_err());",
          "    ",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 4;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = Some(StateID(SmallIndex(10)));",
          "    let universal_start_anchored = Some(StateID(SmallIndex(11)));",
          "    let table: Vec<StateID> = vec![StateID(SmallIndex(12)), StateID(SmallIndex(13))];",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<Endian>(&mut dst);",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]