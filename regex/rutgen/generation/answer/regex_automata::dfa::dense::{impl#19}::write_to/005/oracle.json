[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let _ = start_table.write_to::<EndianType>(&mut dst);",
          "}"
        ],
        "oracle": [
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "    ",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    ",
          "    let nwrite = start_table.write_to_len();",
          "    assert_eq!(dst.len(), nwrite);",
          "    assert!(start_table.write_to::<EndianType>(&mut dst).is_ok());",
          "    assert!(start_table.start_map.write_to(&mut dst).is_ok());",
          "    assert!(start_table.kind.write_to::<EndianType>(&mut dst).is_ok());",
          "    assert!(start_table.table().is_empty());"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let _ = start_table.write_to::<EndianType>(&mut dst);",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "    ",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    ",
          "    let nwrite = start_table.write_to_len();",
          "    assert_eq!(dst.len(), nwrite);",
          "    assert!(start_table.write_to::<EndianType>(&mut dst).is_ok());",
          "    assert!(start_table.start_map.write_to(&mut dst).is_ok());",
          "    assert!(start_table.kind.write_to::<EndianType>(&mut dst).is_ok());",
          "    assert!(start_table.table().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let _ = start_table.write_to::<EndianType>(&mut dst);",
          "}"
        ],
        "oracle": [
          "    assert!(dst.len() == nwrite);",
          "    assert!(start_table.kind.write_to::<EndianType>(&mut dst).is_ok());",
          "    assert!(start_table.start_map.write_to(&mut dst).is_ok());",
          "    assert!(start_table.table().is_empty());",
          "    assert_eq!(start_table.write_to::<EndianType>(&mut dst), Ok(nwrite));"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let _ = start_table.write_to::<EndianType>(&mut dst);",
          "    assert!(dst.len() == nwrite);",
          "    assert!(start_table.kind.write_to::<EndianType>(&mut dst).is_ok());",
          "    assert!(start_table.start_map.write_to(&mut dst).is_ok());",
          "    assert!(start_table.table().is_empty());",
          "    assert_eq!(start_table.write_to::<EndianType>(&mut dst), Ok(nwrite));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let _ = start_table.write_to::<EndianType>(&mut dst);",
          "}"
        ],
        "oracle": [
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new();",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    assert!(dst.len() == nwrite);",
          "    assert!(kind.write_to::<EndianType>(&mut dst[..]).is_ok());",
          "    assert!(start_map.write_to(&mut dst[..]).is_ok());",
          "    assert!(start_table.table().is_empty());"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let _ = start_table.write_to::<EndianType>(&mut dst);",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new();",
          "    let start_table = StartTable {",
          "    table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    assert!(dst.len() == nwrite);",
          "    assert!(kind.write_to::<EndianType>(&mut dst[..]).is_ok());",
          "    assert!(start_map.write_to(&mut dst[..]).is_ok());",
          "    assert!(start_table.table().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = Some(u32::MAX);",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let _ = start_table.write_to::<EndianType>(&mut dst);",
          "}"
        ],
        "oracle": [
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = Some(u32::MAX);",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new();",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored, universal_start_anchored };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = Some(u32::MAX);",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new(); // Empty table",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let _ = start_table.write_to::<EndianType>(&mut dst);",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher::default());",
          "    let stride = 8;",
          "    let pattern_len = Some(u32::MAX);",
          "    let universal_start_unanchored: Option<StateID> = None;",
          "    let universal_start_anchored: Option<StateID> = None;",
          "    let table: Vec<u32> = Vec::new();",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored, universal_start_anchored };",
          "    let nwrite = start_table.write_to_len();",
          "    let mut dst = vec![0u8; nwrite];",
          "    let result = start_table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]