[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"AB\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "}"
        ],
        "oracle": [
          "    assert_eq!(caps.len(), 3);",
          "    assert_eq!(it.haystack, b\"AB\");",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AB\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"B\"[..]));",
          "    assert_eq!(it.next(), None);",
          "    assert!(it.it.len() > 0);",
          "    assert!(it.it.next().is_some());",
          "    assert_eq!(caps.iter().next().unwrap().map(|m| m.as_bytes()), Some(&b\"AB\"[..]));",
          "    assert_eq!(caps.iter().len(), 3);"
        ],
        "code": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"AB\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "    assert_eq!(caps.len(), 3);",
          "    assert_eq!(it.haystack, b\"AB\");",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AB\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"B\"[..]));",
          "    assert_eq!(it.next(), None);",
          "    assert!(it.it.len() > 0);",
          "    assert!(it.it.next().is_some());",
          "    assert_eq!(caps.iter().next().unwrap().map(|m| m.as_bytes()), Some(&b\"AB\"[..]));",
          "    assert_eq!(caps.iter().len(), 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"A1B\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "}"
        ],
        "oracle": [
          "    assert_eq!(it.haystack, b\"A1B\");",
          "    assert!(it.caps.iter().next().is_some());",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"1\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"B\"[..]));",
          "    assert_eq!(it.next(), None);"
        ],
        "code": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"A1B\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "    assert_eq!(it.haystack, b\"A1B\");",
          "    assert!(it.caps.iter().next().is_some());",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"1\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"B\"[..]));",
          "    assert_eq!(it.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"A\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "}"
        ],
        "oracle": [
          "    assert_eq!(it.haystack, b\"A\");",
          "    assert!(it.next().is_some());",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert!(it.next().is_none());"
        ],
        "code": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"A\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "    assert_eq!(it.haystack, b\"A\");",
          "    assert!(it.next().is_some());",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert!(it.next().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"1\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "}"
        ],
        "oracle": [
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"AZ\").unwrap();",
          "    let mut it = caps.iter();",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AZ\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"Z\"[..]));",
          "    assert_eq!(it.next(), None);"
        ],
        "code": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"1\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"AZ\").unwrap();",
          "    let mut it = caps.iter();",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AZ\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"Z\"[..]));",
          "    assert_eq!(it.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "}"
        ],
        "oracle": [
          "    assert_eq!(it.haystack, b\"\");",
          "    assert_eq!(it.next(), None);",
          "    let caps = re.captures(b\"AB1C\").unwrap();",
          "    let mut it = caps.iter();",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AB1C\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"B\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"1\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"C\"[..]));",
          "    assert_eq!(it.next(), None);",
          "    let caps = re.captures(b\"XYZ\").unwrap();",
          "    let mut it = caps.iter();",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"XYZ\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"X\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"Y\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"Z\"[..]));",
          "    assert_eq!(it.next(), None);"
        ],
        "code": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "    assert_eq!(it.haystack, b\"\");",
          "    assert_eq!(it.next(), None);",
          "    let caps = re.captures(b\"AB1C\").unwrap();",
          "    let mut it = caps.iter();",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AB1C\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"B\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"1\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"C\"[..]));",
          "    assert_eq!(it.next(), None);",
          "    let caps = re.captures(b\"XYZ\").unwrap();",
          "    let mut it = caps.iter();",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"XYZ\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"X\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"Y\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"Z\"[..]));",
          "    assert_eq!(it.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "}"
        ],
        "oracle": [
          "    assert_eq!(caps.len(), 3);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AB\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next(), None);"
        ],
        "code": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "    assert_eq!(caps.len(), 3);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AB\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"1234567890\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "}"
        ],
        "oracle": [
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"AZ\").unwrap();",
          "    let it = caps.iter();",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AZ\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"Z\"[..]));",
          "    assert_eq!(it.next(), None);",
          "    let caps_empty = re.captures(b\"\").unwrap();",
          "    let mut it_empty = caps_empty.iter();",
          "    assert_eq!(it_empty.next(), Some(None));",
          "    assert_eq!(it_empty.next(), None);"
        ],
        "code": [
          "{",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"1234567890\").unwrap();",
          "    let mut it = caps.iter();",
          "    let _ = it.next(); // Ensure the iterator is invoked",
          "    let re = regex::bytes::Regex::new(r\"(\\w)(\\d)?(\\w)\").unwrap();",
          "    let caps = re.captures(b\"AZ\").unwrap();",
          "    let it = caps.iter();",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"AZ\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"A\"[..]));",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), None);",
          "    assert_eq!(it.next().unwrap().map(|m| m.as_bytes()), Some(&b\"Z\"[..]));",
          "    assert_eq!(it.next(), None);",
          "    let caps_empty = re.captures(b\"\").unwrap();",
          "    let mut it_empty = caps_empty.iter();",
          "    assert_eq!(it_empty.next(), Some(None));",
          "    assert_eq!(it_empty.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]