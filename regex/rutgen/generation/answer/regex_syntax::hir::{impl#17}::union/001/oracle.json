[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    let class_bytes_b = ClassBytes::empty();",
          "    class_bytes_a.union(&class_bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes_a.ranges(), &[ClassBytesRange { start: 1, end: 5 }]);"
        ],
        "code": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    let class_bytes_b = ClassBytes::empty();",
          "    class_bytes_a.union(&class_bytes_b);",
          "    assert_eq!(class_bytes_a.ranges(), &[ClassBytesRange { start: 1, end: 5 }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    let class_bytes_b = ClassBytes::new(vec![ClassBytesRange { start: 6, end: 10 }]);",
          "    class_bytes_a.union(&class_bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes_a.ranges(), vec![ClassBytesRange { start: 1, end: 5 }, ClassBytesRange { start: 6, end: 10 }].as_slice());"
        ],
        "code": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    let class_bytes_b = ClassBytes::new(vec![ClassBytesRange { start: 6, end: 10 }]);",
          "    class_bytes_a.union(&class_bytes_b);",
          "    assert_eq!(class_bytes_a.ranges(), vec![ClassBytesRange { start: 1, end: 5 }, ClassBytesRange { start: 6, end: 10 }].as_slice());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    let class_bytes_b = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    class_bytes_a.union(&class_bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes_a.ranges(), &[ClassBytesRange { start: 1, end: 5 }]);",
          "    assert_eq!(class_bytes_a.set.intervals().len(), 1);",
          "    assert!(class_bytes_a.set.folded);"
        ],
        "code": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    let class_bytes_b = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    class_bytes_a.union(&class_bytes_b);",
          "    assert_eq!(class_bytes_a.ranges(), &[ClassBytesRange { start: 1, end: 5 }]);",
          "    assert_eq!(class_bytes_a.set.intervals().len(), 1);",
          "    assert!(class_bytes_a.set.folded);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    let class_bytes_b = ClassBytes::new(vec![ClassBytesRange { start: 4, end: 8 }]);",
          "    class_bytes_a.union(&class_bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes_a.ranges(), &[ClassBytesRange { start: 1, end: 5 }, ClassBytesRange { start: 4, end: 8 }]);",
          "    assert!(class_bytes_a.ranges().len() == 2);",
          "    assert_eq!(class_bytes_a.minimum_len(), Some(1));",
          "    assert_eq!(class_bytes_a.maximum_len(), Some(8));",
          "    assert!(class_bytes_a.is_ascii());"
        ],
        "code": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 5 }]);",
          "    let class_bytes_b = ClassBytes::new(vec![ClassBytesRange { start: 4, end: 8 }]);",
          "    class_bytes_a.union(&class_bytes_b);",
          "    assert_eq!(class_bytes_a.ranges(), &[ClassBytesRange { start: 1, end: 5 }, ClassBytesRange { start: 4, end: 8 }]);",
          "    assert!(class_bytes_a.ranges().len() == 2);",
          "    assert_eq!(class_bytes_a.minimum_len(), Some(1));",
          "    assert_eq!(class_bytes_a.maximum_len(), Some(8));",
          "    assert!(class_bytes_a.is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 3 }, ClassBytesRange { start: 6, end: 8 }]);",
          "    let class_bytes_b = ClassBytes::new(vec![ClassBytesRange { start: 3, end: 6 }]);",
          "    class_bytes_a.union(&class_bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes_a.ranges(), &[ClassBytesRange { start: 1, end: 3 }, ClassBytesRange { start: 3, end: 6 }, ClassBytesRange { start: 6, end: 8 }]);",
          "    assert_eq!(class_bytes_a.set.folding, true);",
          "    assert_eq!(class_bytes_a.set.ranges.len(), 3);",
          "    assert!(class_bytes_a.is_ascii());"
        ],
        "code": [
          "{",
          "    let mut class_bytes_a = ClassBytes::new(vec![ClassBytesRange { start: 1, end: 3 }, ClassBytesRange { start: 6, end: 8 }]);",
          "    let class_bytes_b = ClassBytes::new(vec![ClassBytesRange { start: 3, end: 6 }]);",
          "    class_bytes_a.union(&class_bytes_b);",
          "    assert_eq!(class_bytes_a.ranges(), &[ClassBytesRange { start: 1, end: 3 }, ClassBytesRange { start: 3, end: 6 }, ClassBytesRange { start: 6, end: 8 }]);",
          "    assert_eq!(class_bytes_a.set.folding, true);",
          "    assert_eq!(class_bytes_a.set.ranges.len(), 3);",
          "    assert!(class_bytes_a.is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]