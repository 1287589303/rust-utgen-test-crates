[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = \"abcde\";",
          "    let pattern: &str = \"\"; // empty pattern",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sub_capture_matches.size_hint(), (0, Some(0)));"
        ],
        "code": [
          "{",
          "    let haystack = \"abcde\";",
          "    let pattern: &str = \"\"; // empty pattern",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "    assert_eq!(sub_capture_matches.size_hint(), (0, Some(0)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = \"abcde\";",
          "    let pattern: &str = \"a\"; // single character pattern",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sub_capture_matches.size_hint(), (1, Some(1)));"
        ],
        "code": [
          "{",
          "    let haystack = \"abcde\";",
          "    let pattern: &str = \"a\"; // single character pattern",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "    assert_eq!(sub_capture_matches.size_hint(), (1, Some(1)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = \"abcde\";",
          "    let pattern: &str = \"abc\"; // multi-character pattern",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sub_capture_matches.size_hint(), (3, Some(3)));"
        ],
        "code": [
          "{",
          "    let haystack = \"abcde\";",
          "    let pattern: &str = \"abc\"; // multi-character pattern",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "    assert_eq!(sub_capture_matches.size_hint(), (3, Some(3)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = \"aaaa\";",
          "    let pattern: &str = \"a\"; // single character pattern with multiple captures",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sub_capture_matches.size_hint(), (4, Some(4)));"
        ],
        "code": [
          "{",
          "    let haystack = \"aaaa\";",
          "    let pattern: &str = \"a\"; // single character pattern with multiple captures",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "    assert_eq!(sub_capture_matches.size_hint(), (4, Some(4)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = \"abcabcabc\";",
          "    let pattern: &str = \"abc\"; // multi-character pattern repeated",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sub_capture_matches.size_hint(), (3, Some(3)));"
        ],
        "code": [
          "{",
          "    let haystack = \"abcabcabc\";",
          "    let pattern: &str = \"abc\"; // multi-character pattern repeated",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "    assert_eq!(sub_capture_matches.size_hint(), (3, Some(3)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = \"xyzzyx\";",
          "    let pattern: &str = \"abc\"; // no captures",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sub_capture_matches.size_hint(), (0, Some(0)));"
        ],
        "code": [
          "{",
          "    let haystack = \"xyzzyx\";",
          "    let pattern: &str = \"abc\"; // no captures",
          "    let it = captures::CapturesPatternIter::new(haystack, pattern);",
          "    let sub_capture_matches = SubCaptureMatches { haystack, it };",
          "    sub_capture_matches.size_hint();",
          "    assert_eq!(sub_capture_matches.size_hint(), (0, Some(0)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]