[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty_hir = Hir::empty();",
          "    let capture = Capture {",
          "        index: 0,",
          "        name: None,",
          "        sub: Box::new(empty_hir),",
          "    };",
          "    let hir_with_capture = Hir {",
          "        kind: HirKind::Capture(capture),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(1),",
          "    };",
          "    let _ = hir_with_capture; // Test drop on this value",
          "}"
        ],
        "oracle": [
          "    let empty_hir = Hir::empty();",
          "    let capture = Capture { index: 0, name: None, sub: Box::new(empty_hir), };",
          "    let hir_with_capture = Hir { kind: HirKind::Capture(capture), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: Some(1), };",
          "    assert_eq!(hir_with_capture.kind(), &HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(empty_hir), }));",
          "    assert!(!hir_with_capture.is_start_anchored());",
          "    assert!(!hir_with_capture.is_match_empty());",
          "    assert_eq!(hir_with_capture.static_explicit_captures_len(), Some(1));"
        ],
        "code": [
          "{",
          "    let empty_hir = Hir::empty();",
          "    let capture = Capture {",
          "        index: 0,",
          "        name: None,",
          "        sub: Box::new(empty_hir),",
          "    };",
          "    let hir_with_capture = Hir {",
          "        kind: HirKind::Capture(capture),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(1),",
          "    };",
          "    let _ = hir_with_capture; // Test drop on this value",
          "    let empty_hir = Hir::empty();",
          "    let capture = Capture { index: 0, name: None, sub: Box::new(empty_hir), };",
          "    let hir_with_capture = Hir { kind: HirKind::Capture(capture), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: Some(1), };",
          "    assert_eq!(hir_with_capture.kind(), &HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(empty_hir), }));",
          "    assert!(!hir_with_capture.is_start_anchored());",
          "    assert!(!hir_with_capture.is_match_empty());",
          "    assert_eq!(hir_with_capture.static_explicit_captures_len(), Some(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let non_empty_hir = Hir::empty(); // Assume this would normally be non-empty",
          "    let capture = Capture {",
          "        index: 1,",
          "        name: Some(Box::new(\"test\".into())),",
          "        sub: Box::new(non_empty_hir),",
          "    };",
          "    let hir_with_capture = Hir {",
          "        kind: HirKind::Capture(capture),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(1),",
          "    };",
          "    let _ = hir_with_capture; // Test drop on this value, not hitting return on empty subs",
          "}"
        ],
        "oracle": [
          "    let non_empty_hir = Hir::empty();",
          "    let capture = Capture {",
          "    index: 1,",
          "    name: Some(Box::new(\"test\".into())),",
          "    sub: Box::new(non_empty_hir),",
          "    };",
          "    let hir_with_capture = Hir {",
          "    kind: HirKind::Capture(capture),",
          "    is_start_anchored: false,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: Some(1),",
          "    };",
          "    let _ = hir_with_capture;"
        ],
        "code": [
          "{",
          "    let non_empty_hir = Hir::empty(); // Assume this would normally be non-empty",
          "    let capture = Capture {",
          "        index: 1,",
          "        name: Some(Box::new(\"test\".into())),",
          "        sub: Box::new(non_empty_hir),",
          "    };",
          "    let hir_with_capture = Hir {",
          "        kind: HirKind::Capture(capture),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(1),",
          "    };",
          "    let _ = hir_with_capture; // Test drop on this value, not hitting return on empty subs",
          "    let non_empty_hir = Hir::empty();",
          "    let capture = Capture {",
          "    index: 1,",
          "    name: Some(Box::new(\"test\".into())),",
          "    sub: Box::new(non_empty_hir),",
          "    };",
          "    let hir_with_capture = Hir {",
          "    kind: HirKind::Capture(capture),",
          "    is_start_anchored: false,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: Some(1),",
          "    };",
          "    let _ = hir_with_capture;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]