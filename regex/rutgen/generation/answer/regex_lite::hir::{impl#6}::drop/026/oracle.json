[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_look = Hir::look(Look {});",
          "    let hir_class = Hir::class(Class {});",
          "    ",
          "    let hir_concat = Hir::concat(vec![hir_look.clone(), hir_class.clone()]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat.clone()]);",
          "",
          "    // Underlying effects of the drop method will be invoked here.",
          "    drop(&mut hir_instance);",
          "}"
        ],
        "oracle": [
          "    let hir_look = Hir::look(Look {});",
          "    let hir_class = Hir::class(Class {});",
          "    let hir_concat = Hir::concat(vec![hir_look.clone(), hir_class.clone()]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat.clone()]);",
          "    assert_eq!(hir_instance.kind(), &HirKind::Concat(vec![hir_concat.clone()]));",
          "    assert!(!hir_concat.is_empty());",
          "    assert!(hir_instance.kind().subs().len() > 0);",
          "    drop(&mut hir_instance);",
          "    assert_eq!(hir_instance.kind(), &HirKind::Empty);"
        ],
        "code": [
          "{",
          "    let hir_look = Hir::look(Look {});",
          "    let hir_class = Hir::class(Class {});",
          "    ",
          "    let hir_concat = Hir::concat(vec![hir_look.clone(), hir_class.clone()]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat.clone()]);",
          "",
          "    // Underlying effects of the drop method will be invoked here.",
          "    drop(&mut hir_instance);",
          "    let hir_look = Hir::look(Look {});",
          "    let hir_class = Hir::class(Class {});",
          "    let hir_concat = Hir::concat(vec![hir_look.clone(), hir_class.clone()]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat.clone()]);",
          "    assert_eq!(hir_instance.kind(), &HirKind::Concat(vec![hir_concat.clone()]));",
          "    assert!(!hir_concat.is_empty());",
          "    assert!(hir_instance.kind().subs().len() > 0);",
          "    drop(&mut hir_instance);",
          "    assert_eq!(hir_instance.kind(), &HirKind::Empty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_empty = Hir::empty();",
          "    let hir_class = Hir::class(Class {});",
          "",
          "    let hir_concat = Hir::concat(vec![hir_empty, hir_class]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat]);",
          "",
          "    drop(&mut hir_instance);",
          "}"
        ],
        "oracle": [
          "    HirKind::Concat(ref x) matches expected condition at line 773",
          "    x.is_empty() evaluates to false at line 782",
          "    let Some(mut expr) = stack.pop() evaluates to true at line 788",
          "    expr.kind matches HirKind::Look(_) at line 789",
          "    expr.kind matches HirKind::Class(_) at line 789"
        ],
        "code": [
          "{",
          "    let hir_empty = Hir::empty();",
          "    let hir_class = Hir::class(Class {});",
          "",
          "    let hir_concat = Hir::concat(vec![hir_empty, hir_class]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat]);",
          "",
          "    drop(&mut hir_instance);",
          "    HirKind::Concat(ref x) matches expected condition at line 773",
          "    x.is_empty() evaluates to false at line 782",
          "    let Some(mut expr) = stack.pop() evaluates to true at line 788",
          "    expr.kind matches HirKind::Look(_) at line 789",
          "    expr.kind matches HirKind::Class(_) at line 789",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_char = Hir::char('a');",
          "    let hir_look = Hir::look(Look {});",
          "",
          "    let hir_concat = Hir::concat(vec![hir_char.clone(), hir_look.clone()]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat]);",
          "",
          "    drop(&mut hir_instance);",
          "}"
        ],
        "oracle": [
          "    let hir_char = Hir::char('a');",
          "    let hir_look = Hir::look(Look {});",
          "    let hir_concat = Hir::concat(vec![hir_char.clone(), hir_look.clone()]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat]);",
          "    assert_eq!(hir_instance.kind(), &HirKind::Concat(vec![hir_concat]));",
          "    assert_eq!(hir_instance.static_explicit_captures_len(), Some(0));",
          "    assert!(!hir_instance.is_match_empty());",
          "    drop(&mut hir_instance);",
          "    assert_eq!(hir_instance.kind(), &HirKind::Empty);"
        ],
        "code": [
          "{",
          "    let hir_char = Hir::char('a');",
          "    let hir_look = Hir::look(Look {});",
          "",
          "    let hir_concat = Hir::concat(vec![hir_char.clone(), hir_look.clone()]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat]);",
          "",
          "    drop(&mut hir_instance);",
          "    let hir_char = Hir::char('a');",
          "    let hir_look = Hir::look(Look {});",
          "    let hir_concat = Hir::concat(vec![hir_char.clone(), hir_look.clone()]);",
          "    let mut hir_instance = Hir::concat(vec![hir_concat]);",
          "    assert_eq!(hir_instance.kind(), &HirKind::Concat(vec![hir_concat]));",
          "    assert_eq!(hir_instance.static_explicit_captures_len(), Some(0));",
          "    assert!(!hir_instance.is_match_empty());",
          "    drop(&mut hir_instance);",
          "    assert_eq!(hir_instance.kind(), &HirKind::Empty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]