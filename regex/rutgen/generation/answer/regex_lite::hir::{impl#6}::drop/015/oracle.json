[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let repetition = Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(Hir::char('a')),",
          "    };",
          "    ",
          "    let alternation = HirKind::Alternation(vec![",
          "        Hir::repetition(repetition.clone()),",
          "        Hir::repetition(repetition),",
          "    ]);",
          "",
          "    let hir_instance = Hir {",
          "        kind: alternation,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "",
          "    let _ = hir_instance;  // Calling drop implicitly through the value.",
          "}"
        ],
        "oracle": [
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir::char('a')) };",
          "    let alternation = HirKind::Alternation(vec![Hir::repetition(repetition.clone()), Hir::repetition(repetition)]);",
          "    let hir_instance = Hir { kind: alternation, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _ = hir_instance;  // Triggering drop here",
          "    ",
          "    assert!(hir_instance.kind.is_match_empty() == false);",
          "    assert!(hir_instance.is_start_anchored() == false);",
          "    assert!(hir_instance.static_explicit_captures_len().is_none());",
          "    assert!(matches!(hir_instance.kind(), HirKind::Alternation(_)));",
          "    let subs = if let HirKind::Alternation(ref x) = hir_instance.kind() { x } else { panic!() };",
          "    assert!(subs.len() > 0);",
          "    let mut stack = vec![hir_instance];",
          "    while let Some(expr) = stack.pop() {",
          "    assert!(matches!(expr.kind(), HirKind::Repetition(_)));",
          "    }"
        ],
        "code": [
          "{",
          "    let repetition = Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(Hir::char('a')),",
          "    };",
          "    ",
          "    let alternation = HirKind::Alternation(vec![",
          "        Hir::repetition(repetition.clone()),",
          "        Hir::repetition(repetition),",
          "    ]);",
          "",
          "    let hir_instance = Hir {",
          "        kind: alternation,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "",
          "    let _ = hir_instance;  // Calling drop implicitly through the value.",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir::char('a')) };",
          "    let alternation = HirKind::Alternation(vec![Hir::repetition(repetition.clone()), Hir::repetition(repetition)]);",
          "    let hir_instance = Hir { kind: alternation, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _ = hir_instance;  // Triggering drop here",
          "    ",
          "    assert!(hir_instance.kind.is_match_empty() == false);",
          "    assert!(hir_instance.is_start_anchored() == false);",
          "    assert!(hir_instance.static_explicit_captures_len().is_none());",
          "    assert!(matches!(hir_instance.kind(), HirKind::Alternation(_)));",
          "    let subs = if let HirKind::Alternation(ref x) = hir_instance.kind() { x } else { panic!() };",
          "    assert!(subs.len() > 0);",
          "    let mut stack = vec![hir_instance];",
          "    while let Some(expr) = stack.pop() {",
          "    assert!(matches!(expr.kind(), HirKind::Repetition(_)));",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty_repetition = Repetition {",
          "        min: 0,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir::empty()),  // sub expression is empty",
          "    };",
          "",
          "    let alternation = HirKind::Alternation(vec![",
          "        Hir::repetition(empty_repetition),",
          "        Hir::char('b'),  // includes a non-empty expression",
          "    ]);",
          "",
          "    let hir_instance = Hir {",
          "        kind: alternation,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "",
          "    let _ = hir_instance;  // Calling drop implicitly through the value.",
          "}"
        ],
        "oracle": [
          "    let empty_repetition = Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir::empty()) };",
          "    let alternation = HirKind::Alternation(vec![Hir::repetition(empty_repetition), Hir::char('b')]);",
          "    let hir_instance = Hir { kind: alternation, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _ = hir_instance;  // Check that drop is called correctly.",
          "    assert_eq!(hir_instance.kind(), &HirKind::Alternation(vec![Hir::repetition(empty_repetition), Hir::char('b')]));",
          "    assert!(!matches!(hir_instance.kind(), HirKind::Alternation(subs) if subs.is_empty()));",
          "    assert!(matches!(hir_instance.kind(), HirKind::Alternation(ref subs) if subs.len() == 2));",
          "    assert!(matches!(hir_instance.kind(), HirKind::Alternation(ref subs) if matches!(subs[0].kind, HirKind::Repetition(_))));"
        ],
        "code": [
          "{",
          "    let empty_repetition = Repetition {",
          "        min: 0,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir::empty()),  // sub expression is empty",
          "    };",
          "",
          "    let alternation = HirKind::Alternation(vec![",
          "        Hir::repetition(empty_repetition),",
          "        Hir::char('b'),  // includes a non-empty expression",
          "    ]);",
          "",
          "    let hir_instance = Hir {",
          "        kind: alternation,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "",
          "    let _ = hir_instance;  // Calling drop implicitly through the value.",
          "    let empty_repetition = Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir::empty()) };",
          "    let alternation = HirKind::Alternation(vec![Hir::repetition(empty_repetition), Hir::char('b')]);",
          "    let hir_instance = Hir { kind: alternation, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _ = hir_instance;  // Check that drop is called correctly.",
          "    assert_eq!(hir_instance.kind(), &HirKind::Alternation(vec![Hir::repetition(empty_repetition), Hir::char('b')]));",
          "    assert!(!matches!(hir_instance.kind(), HirKind::Alternation(subs) if subs.is_empty()));",
          "    assert!(matches!(hir_instance.kind(), HirKind::Alternation(ref subs) if subs.len() == 2));",
          "    assert!(matches!(hir_instance.kind(), HirKind::Alternation(ref subs) if matches!(subs[0].kind, HirKind::Repetition(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let repetition_a = Repetition {",
          "        min: 2,",
          "        max: Some(5),",
          "        greedy: true,",
          "        sub: Box::new(Hir::char('c')),",
          "    };",
          "",
          "    let repetition_b = Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(Hir::char('d')),",
          "    };",
          "",
          "    let alternation = HirKind::Alternation(vec![",
          "        Hir::repetition(repetition_a),",
          "        Hir::repetition(repetition_b),",
          "    ]);",
          "",
          "    let hir_instance = Hir {",
          "        kind: alternation,",
          "        is_start_anchored: true,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(1),",
          "    };",
          "",
          "    let _ = hir_instance;  // Calling drop implicitly through the value.",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir_instance.kind(), &HirKind::Alternation(vec![Hir::repetition(repetition_a), Hir::repetition(repetition_b)]));",
          "    assert!(!hir_instance.is_match_empty());",
          "    assert_eq!(hir_instance.static_explicit_captures_len(), Some(1));",
          "    assert!(hir_instance.is_start_anchored());"
        ],
        "code": [
          "{",
          "    let repetition_a = Repetition {",
          "        min: 2,",
          "        max: Some(5),",
          "        greedy: true,",
          "        sub: Box::new(Hir::char('c')),",
          "    };",
          "",
          "    let repetition_b = Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(Hir::char('d')),",
          "    };",
          "",
          "    let alternation = HirKind::Alternation(vec![",
          "        Hir::repetition(repetition_a),",
          "        Hir::repetition(repetition_b),",
          "    ]);",
          "",
          "    let hir_instance = Hir {",
          "        kind: alternation,",
          "        is_start_anchored: true,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(1),",
          "    };",
          "",
          "    let _ = hir_instance;  // Calling drop implicitly through the value.",
          "    assert_eq!(hir_instance.kind(), &HirKind::Alternation(vec![Hir::repetition(repetition_a), Hir::repetition(repetition_b)]));",
          "    assert!(!hir_instance.is_match_empty());",
          "    assert_eq!(hir_instance.static_explicit_captures_len(), Some(1));",
          "    assert!(hir_instance.is_start_anchored());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]