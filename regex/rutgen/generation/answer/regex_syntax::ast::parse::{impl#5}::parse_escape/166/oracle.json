[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: false, kind: ClassPerlKind::Digit, span: Span::new(start_pos, Position { offset: 1, line: 1, column: 2 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: true, kind: ClassPerlKind::Digit, span: Span::new(start_pos, Position { offset: 2, line: 1, column: 3 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: false, kind: ClassPerlKind::Word, span: Span::new(start_pos, Position { offset: 3, line: 1, column: 4 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: true, kind: ClassPerlKind::Word, span: Span::new(start_pos, Position { offset: 4, line: 1, column: 5 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: false, kind: ClassPerlKind::Space, span: Span::new(start_pos, Position { offset: 5, line: 1, column: 6 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: true, kind: ClassPerlKind::Space, span: Span::new(start_pos, Position { offset: 6, line: 1, column: 7 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Unicode(ClassUnicode { negated: false, span: Span::new(start_pos, Position { offset: 7, line: 1, column: 8 }), kind: ClassUnicodeKind::OneLetter('a') }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Unicode(ClassUnicode { negated: true, span: Span::new(start_pos, Position { offset: 8, line: 1, column: 9 }), kind: ClassUnicodeKind::OneLetter('a') }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Literal(ast::Literal { span: Span::new(start_pos, Position { offset: 9, line: 1, column: 10 }), kind: ast::LiteralKind::Meta, c: 'a' }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Assertion(ast::Assertion { span: Span::new(start_pos, Position { offset: 10, line: 1, column: 11 }), kind: AssertionKind::StartText }));"
        ],
        "code": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: false, kind: ClassPerlKind::Digit, span: Span::new(start_pos, Position { offset: 1, line: 1, column: 2 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: true, kind: ClassPerlKind::Digit, span: Span::new(start_pos, Position { offset: 2, line: 1, column: 3 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: false, kind: ClassPerlKind::Word, span: Span::new(start_pos, Position { offset: 3, line: 1, column: 4 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: true, kind: ClassPerlKind::Word, span: Span::new(start_pos, Position { offset: 4, line: 1, column: 5 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: false, kind: ClassPerlKind::Space, span: Span::new(start_pos, Position { offset: 5, line: 1, column: 6 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Perl(ClassPerl { negated: true, kind: ClassPerlKind::Space, span: Span::new(start_pos, Position { offset: 6, line: 1, column: 7 }) }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Unicode(ClassUnicode { negated: false, span: Span::new(start_pos, Position { offset: 7, line: 1, column: 8 }), kind: ClassUnicodeKind::OneLetter('a') }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Unicode(ClassUnicode { negated: true, span: Span::new(start_pos, Position { offset: 8, line: 1, column: 9 }), kind: ClassUnicodeKind::OneLetter('a') }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Literal(ast::Literal { span: Span::new(start_pos, Position { offset: 9, line: 1, column: 10 }), kind: ast::LiteralKind::Meta, c: 'a' }));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Assertion(ast::Assertion { span: Span::new(start_pos, Position { offset: 10, line: 1, column: 11 }), kind: AssertionKind::StartText }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Perl(ast::ClassPerl { kind: ast::ClassPerlKind::Digit, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Perl(ast::ClassPerl { kind: ast::ClassPerlKind::NotDigit, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Unicode(ast::ClassUnicode { negated: true, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Unicode(ast::ClassUnicode { negated: false, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(ast::Literal { kind: ast::LiteralKind::Superfluous, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(ast::Literal { kind: ast::LiteralKind::Meta, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Assertion(ast::Assertion { kind: ast::AssertionKind::WordBoundary, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Assertion(ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Assertion(ast::Assertion { kind: ast::AssertionKind::StartText, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Assertion(ast::Assertion { kind: ast::AssertionKind::EndText, .. })));"
        ],
        "code": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Perl(ast::ClassPerl { kind: ast::ClassPerlKind::Digit, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Perl(ast::ClassPerl { kind: ast::ClassPerlKind::NotDigit, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Unicode(ast::ClassUnicode { negated: true, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Unicode(ast::ClassUnicode { negated: false, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(ast::Literal { kind: ast::LiteralKind::Superfluous, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(ast::Literal { kind: ast::LiteralKind::Meta, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Assertion(ast::Assertion { kind: ast::AssertionKind::WordBoundary, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Assertion(ast::Assertion { kind: ast::AssertionKind::NotWordBoundary, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Assertion(ast::Assertion { kind: ast::AssertionKind::StartText, .. })));",
          "    ",
          "    let parser_i_clone = parser_i.clone();",
          "    let result = parser_i_clone.parse_escape();",
          "    assert!(matches!(result.unwrap(), Primitive::Assertion(ast::Assertion { kind: ast::AssertionKind::EndText, .. })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Literal(ast::Literal {",
          "    span: Span::new(start_pos, parser_i.pos()),",
          "    kind: ast::LiteralKind::Meta,",
          "    c: 'a',",
          "    }));",
          "    assert_eq!(parser_i.pos().offset, start_pos.offset + 1);",
          "    assert_eq!(parser_i.pos().line, start_pos.line);",
          "    assert_eq!(parser_i.pos().column, start_pos.column + 1);",
          "    assert!(parser_i.scratch.borrow().is_empty());",
          "    assert!(parser_i.comments.borrow().is_empty());",
          "    assert!(parser_i.stack_group.borrow().is_empty());",
          "    assert!(parser_i.stack_class.borrow().is_empty());",
          "    assert!(parser_i.capture_names.borrow().is_empty());"
        ],
        "code": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Primitive::Literal(ast::Literal {",
          "    span: Span::new(start_pos, parser_i.pos()),",
          "    kind: ast::LiteralKind::Meta,",
          "    c: 'a',",
          "    }));",
          "    assert_eq!(parser_i.pos().offset, start_pos.offset + 1);",
          "    assert_eq!(parser_i.pos().line, start_pos.line);",
          "    assert_eq!(parser_i.pos().column, start_pos.column + 1);",
          "    assert!(parser_i.scratch.borrow().is_empty());",
          "    assert!(parser_i.comments.borrow().is_empty());",
          "    assert!(parser_i.stack_group.borrow().is_empty());",
          "    assert!(parser_i.stack_class.borrow().is_empty());",
          "    assert!(parser_i.capture_names.borrow().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive.kind, LiteralKind::Meta);",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    assert!(matches!(primitive, Primitive::Unicode(_)));",
          "    assert!(matches!(primitive, Primitive::Assertion(_)));",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    ",
          "    let meta_escaped_chars = ['a', 'b', 'd', 'D', 's', 'S', 'w', 'W', 'p', 'P', 'x', 'u', 'U'];",
          "    for &c in &meta_escaped_chars {",
          "    let test_char = format!(\"\\\\{}\", c);",
          "    let parser_with_test_char = ParserI {",
          "    parser: &parser,",
          "    pattern: test_char.as_str(),",
          "    };",
          "    let result = parser_with_test_char.parse_escape();",
          "    assert!(result.is_ok());",
          "    }",
          "    ",
          "    let illegal_escape_characters = ['8', '9'];",
          "    for &c in &illegal_escape_characters {",
          "    let test_char = format!(\"\\\\{}\", c);",
          "    let parser_with_test_char = ParserI {",
          "    parser: &parser,",
          "    pattern: test_char.as_str(),",
          "    };",
          "    let result = parser_with_test_char.parse_escape();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::UnsupportedBackreference);",
          "    }"
        ],
        "code": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive.kind, LiteralKind::Meta);",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    assert!(matches!(primitive, Primitive::Unicode(_)));",
          "    assert!(matches!(primitive, Primitive::Assertion(_)));",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    ",
          "    let meta_escaped_chars = ['a', 'b', 'd', 'D', 's', 'S', 'w', 'W', 'p', 'P', 'x', 'u', 'U'];",
          "    for &c in &meta_escaped_chars {",
          "    let test_char = format!(\"\\\\{}\", c);",
          "    let parser_with_test_char = ParserI {",
          "    parser: &parser,",
          "    pattern: test_char.as_str(),",
          "    };",
          "    let result = parser_with_test_char.parse_escape();",
          "    assert!(result.is_ok());",
          "    }",
          "    ",
          "    let illegal_escape_characters = ['8', '9'];",
          "    for &c in &illegal_escape_characters {",
          "    let test_char = format!(\"\\\\{}\", c);",
          "    let parser_with_test_char = ParserI {",
          "    parser: &parser,",
          "    pattern: test_char.as_str(),",
          "    };",
          "    let result = parser_with_test_char.parse_escape();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::UnsupportedBackreference);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "    ",
          "    let result = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::Meta);",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    Primitive::Assertion(assertion) => {",
          "    assert_eq!(assertion.kind, AssertionKind::StartText);",
          "    }",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.kind.is_some());",
          "    }",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.kind.is_some());",
          "    }",
          "    }",
          "    assert_eq!(parser_i.pos.get().offset, pattern.len());",
          "    assert!(!parser_i.is_eof());"
        ],
        "code": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "    ",
          "    let result = parser_i.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::Meta);",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    Primitive::Assertion(assertion) => {",
          "    assert_eq!(assertion.kind, AssertionKind::StartText);",
          "    }",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.kind.is_some());",
          "    }",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.kind.is_some());",
          "    }",
          "    }",
          "    assert_eq!(parser_i.pos.get().offset, pattern.len());",
          "    assert!(!parser_i.is_eof());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_) | Primitive::Unicode(_)));",
          "    assert!(primitive.span.start == start_pos);",
          "    assert!(parser_i.pos.get().offset == start_pos.offset + 2);",
          "    assert!(primitive.kind == LiteralKind::Meta);",
          "    assert!(primitive.kind == LiteralKind::Superfluous);",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::Bell));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::FormFeed));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::Tab));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::LineFeed));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::CarriageReturn));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::VerticalTab));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::WordBoundaryStart));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::WordBoundaryEnd));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::WordBoundaryStartHalf));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::WordBoundaryEndHalf));",
          "    assert!(primitive.kind == LiteralKind::Meta);",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::Bell));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::FormFeed));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::Tab));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::LineFeed));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::CarriageReturn));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::VerticalTab));"
        ],
        "code": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_) | Primitive::Unicode(_)));",
          "    assert!(primitive.span.start == start_pos);",
          "    assert!(parser_i.pos.get().offset == start_pos.offset + 2);",
          "    assert!(primitive.kind == LiteralKind::Meta);",
          "    assert!(primitive.kind == LiteralKind::Superfluous);",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::Bell));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::FormFeed));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::Tab));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::LineFeed));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::CarriageReturn));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::VerticalTab));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::WordBoundaryStart));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::WordBoundaryEnd));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::WordBoundaryStartHalf));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::WordBoundaryEndHalf));",
          "    assert!(primitive.kind == LiteralKind::Meta);",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::Bell));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::FormFeed));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::Tab));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::LineFeed));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::CarriageReturn));",
          "    assert!(primitive.kind == LiteralKind::Special(SpecialLiteralKind::VerticalTab));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(class) => {",
          "    assert!(class.kind == ClassPerlKind::Digit || class.kind == ClassPerlKind::NotDigit ||",
          "    class.kind == ClassPerlKind::Space || class.kind == ClassPerlKind::NotSpace ||",
          "    class.kind == ClassPerlKind::Word || class.kind == ClassPerlKind::NotWord);",
          "    assert_eq!(class.negated, c == 'D' || c == 'S' || c == 'W');",
          "    },",
          "    Primitive::Unicode(class) => {",
          "    assert!(class.kind.is_valid());",
          "    assert_eq!(class.negated, c == 'P');",
          "    },",
          "    Primitive::Literal(lit) => {",
          "    assert!(lit.kind == LiteralKind::Meta || lit.kind == LiteralKind::Superfluous);",
          "    assert!(lit.c == 'a' || lit.c == '\\x07' || lit.c == '\\x0C' ||",
          "    lit.c == '\\t' || lit.c == '\\n' || lit.c == '\\r' ||",
          "    lit.c == '\\x0B' || lit.c == ' ' || lit.c == '<' ||",
          "    lit.c == '>' || lit.c == 'b' || lit.c == 'B');",
          "    },",
          "    Primitive::Assertion(assertion) => {",
          "    assert!(matches!(assertion.kind, AssertionKind::StartText | AssertionKind::EndText |",
          "    AssertionKind::WordBoundary | AssertionKind::NotWordBoundary |",
          "    AssertionKind::WordBoundaryStartAngle | AssertionKind::WordBoundaryEndAngle));",
          "    },",
          "    _ => panic!(\"Unexpected primitive type\"),",
          "    }"
        ],
        "code": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let pattern = \"\\\\d\\\\D\\\\w\\\\W\\\\s\\\\S\\\\p\\\\P\\\\x\\\\u\\\\U\\\\a\";",
          "    ",
          "    let parser = Parser {",
          "        ast: ast::parse::Parser {},",
          "        hir: hir::translate::Translator {},",
          "    };",
          "",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern: pattern,",
          "    };",
          "",
          "    parser_i.pos.set(start_pos);",
          "",
          "    let result = parser_i.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(class) => {",
          "    assert!(class.kind == ClassPerlKind::Digit || class.kind == ClassPerlKind::NotDigit ||",
          "    class.kind == ClassPerlKind::Space || class.kind == ClassPerlKind::NotSpace ||",
          "    class.kind == ClassPerlKind::Word || class.kind == ClassPerlKind::NotWord);",
          "    assert_eq!(class.negated, c == 'D' || c == 'S' || c == 'W');",
          "    },",
          "    Primitive::Unicode(class) => {",
          "    assert!(class.kind.is_valid());",
          "    assert_eq!(class.negated, c == 'P');",
          "    },",
          "    Primitive::Literal(lit) => {",
          "    assert!(lit.kind == LiteralKind::Meta || lit.kind == LiteralKind::Superfluous);",
          "    assert!(lit.c == 'a' || lit.c == '\\x07' || lit.c == '\\x0C' ||",
          "    lit.c == '\\t' || lit.c == '\\n' || lit.c == '\\r' ||",
          "    lit.c == '\\x0B' || lit.c == ' ' || lit.c == '<' ||",
          "    lit.c == '>' || lit.c == 'b' || lit.c == 'B');",
          "    },",
          "    Primitive::Assertion(assertion) => {",
          "    assert!(matches!(assertion.kind, AssertionKind::StartText | AssertionKind::EndText |",
          "    AssertionKind::WordBoundary | AssertionKind::NotWordBoundary |",
          "    AssertionKind::WordBoundaryStartAngle | AssertionKind::WordBoundaryEndAngle));",
          "    },",
          "    _ => panic!(\"Unexpected primitive type\"),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]