[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(!parser.bump());",
          "    assert!(!parser.parser().octal);",
          "    assert_eq!(parser.char(), 'd');",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Perl(_))));",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.parser().octal);",
          "    assert!(matches!(parser.char(), 'f'));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(lit))));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(!parser.bump());",
          "    assert!(!parser.parser().octal);",
          "    assert_eq!(parser.char(), 'd');",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Perl(_))));",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.parser().octal);",
          "    assert!(matches!(parser.char(), 'f'));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(lit))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parser.octal, false);",
          "    assert_eq!(parser.pattern, \"\\\\D\");",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    assert!(parser.parse_escape().unwrap().assertion().kind == AssertionKind::NotWordBoundary);",
          "    assert_eq!(parser.parse_escape().unwrap().span.start.offset, 0);",
          "    assert_eq!(parser.parse_escape().unwrap().span.end.offset, 2);",
          "    assert!(is_escapeable_character('D') == false);",
          "    assert!(is_meta_character('D') == false);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.parser.octal, false);",
          "    assert_eq!(parser.pattern, \"\\\\D\");",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    assert!(parser.parse_escape().unwrap().assertion().kind == AssertionKind::NotWordBoundary);",
          "    assert_eq!(parser.parse_escape().unwrap().span.start.offset, 0);",
          "    assert_eq!(parser.parse_escape().unwrap().span.end.offset, 2);",
          "    assert!(is_escapeable_character('D') == false);",
          "    assert!(is_meta_character('D') == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(!matches!(parser.char(), '0'..='7'));",
          "    assert!(!matches!(parser.char(), '8'..='9'));",
          "    assert!(matches!(parser.char(), 'D'));",
          "    assert!(matches!(parser.char(), 'W'));",
          "    assert!(matches!(parser.char(), 'P'));",
          "    assert!(matches!(parser.char(), 'p'));",
          "    assert!(matches!(parser.char(), 'w'));",
          "    assert!(matches!(parser.char(), 'x'));",
          "    assert!(matches!(parser.char(), 's'));",
          "    assert!(matches!(parser.char(), 'S'));",
          "    assert!(matches!(parser.char(), 'd'));",
          "    assert!(matches!(parser.char(), 'U'));",
          "    assert!(matches!(parser.char(), 'u'));",
          "    assert!(matches!(parser.char(), _));",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));",
          "    assert!(matches!(parser.char(), 'f'));",
          "    assert!(matches!(parser.char(), 'f'));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(!matches!(parser.char(), '0'..='7'));",
          "    assert!(!matches!(parser.char(), '8'..='9'));",
          "    assert!(matches!(parser.char(), 'D'));",
          "    assert!(matches!(parser.char(), 'W'));",
          "    assert!(matches!(parser.char(), 'P'));",
          "    assert!(matches!(parser.char(), 'p'));",
          "    assert!(matches!(parser.char(), 'w'));",
          "    assert!(matches!(parser.char(), 'x'));",
          "    assert!(matches!(parser.char(), 's'));",
          "    assert!(matches!(parser.char(), 'S'));",
          "    assert!(matches!(parser.char(), 'd'));",
          "    assert!(matches!(parser.char(), 'U'));",
          "    assert!(matches!(parser.char(), 'u'));",
          "    assert!(matches!(parser.char(), _));",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));",
          "    assert!(matches!(parser.char(), 'f'));",
          "    assert!(matches!(parser.char(), 'f'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap().kind, ast::LiteralKind::Superfluous);",
          "    assert_eq!(parser.parse_escape().unwrap().c, 'S');",
          "    assert_eq!(parser.parse_escape().unwrap().span.start.offset, 0);",
          "    assert_eq!(parser.parse_escape().unwrap().span.end.offset, 2);",
          "    assert!(parser.parser.octal == false);",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.parse_escape().unwrap().kind, ast::LiteralKind::Superfluous);",
          "    assert_eq!(parser.parse_escape().unwrap().c, 'S');",
          "    assert_eq!(parser.parse_escape().unwrap().span.start.offset, 0);",
          "    assert_eq!(parser.parse_escape().unwrap().span.end.offset, 2);",
          "    assert!(parser.parser.octal == false);",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Word, negated: true }));",
          "    ",
          "    let pattern = \"\\\\p{Z}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(...), negated: false, kind: ... }));",
          "    ",
          "    let pattern = \"\\\\P{Z}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(...), negated: true, kind: ... }));",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Digit, negated: false }));",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Space, negated: false }));",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Space, negated: true }));",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Word, negated: false }));",
          "    ",
          "    let pattern = \"\\\\x61\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(...), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\u0061\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(...), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\U00000061\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(...), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\f\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Word, negated: true }));",
          "    ",
          "    let pattern = \"\\\\p{Z}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(...), negated: false, kind: ... }));",
          "    ",
          "    let pattern = \"\\\\P{Z}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(...), negated: true, kind: ... }));",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Digit, negated: false }));",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Space, negated: false }));",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Space, negated: true }));",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Word, negated: false }));",
          "    ",
          "    let pattern = \"\\\\x61\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(...), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\u0061\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(...), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\U00000061\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(...), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\f\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.pos(), expected_position);",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Perl(class)) if class.kind == ClassPerlKind::Word));",
          "    assert_eq!(parser.parser.octal, false);",
          "    assert_eq!(parser.pattern, \"\\\\W\");",
          "    assert!(!parser.is_eof());",
          "    assert_eq!(parser.char(), 'W');",
          "    assert_eq!(parser.pos().offset, expected_offset_after_parsing);",
          "    assert!(!is_meta_character('W'));",
          "    assert!(!is_escapeable_character('W'));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.pos(), expected_position);",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Perl(class)) if class.kind == ClassPerlKind::Word));",
          "    assert_eq!(parser.parser.octal, false);",
          "    assert_eq!(parser.pattern, \"\\\\W\");",
          "    assert!(!parser.is_eof());",
          "    assert_eq!(parser.char(), 'W');",
          "    assert_eq!(parser.pos().offset, expected_offset_after_parsing);",
          "    assert!(!is_meta_character('W'));",
          "    assert!(!is_escapeable_character('W'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Unicode(_)));",
          "    assert_eq!(parser.pos().offset, 4);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 5);",
          "    let span = match result.unwrap() { Primitive::Unicode(cls) => cls.span, _ => unreachable!() };",
          "    assert_eq!(span.start.offset, 0);",
          "    assert_eq!(span.end.offset, 4);",
          "    assert_eq!(cls.negated, false);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Unicode(_)));",
          "    assert_eq!(parser.pos().offset, 4);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 5);",
          "    let span = match result.unwrap() { Primitive::Unicode(cls) => cls.span, _ => unreachable!() };",
          "    assert_eq!(span.start.offset, 0);",
          "    assert_eq!(span.end.offset, 4);",
          "    assert_eq!(cls.negated, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parser().octal, false);",
          "    assert_eq!(parser.char(), 'P');",
          "    assert_eq!(parser.bump(), true);",
          "    assert_eq!(parser.pos(), expected_position);",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Unicode(_)));",
          "    assert_eq!(parser.pos(), expected_end_position);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.parser().octal, false);",
          "    assert_eq!(parser.char(), 'P');",
          "    assert_eq!(parser.bump(), true);",
          "    assert_eq!(parser.pos(), expected_position);",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Unicode(_)));",
          "    assert_eq!(parser.pos(), expected_end_position);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\x7F\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == 'x');",
          "    assert!(parser.char() == '7');",
          "    assert!(parser.char() == 'F');",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(is_meta_character('F') == false);",
          "    assert!(is_escapeable_character('F') == false);",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal {",
          "    span: Span::new(parser.pos(), parser.pos()),",
          "    kind: ast::LiteralKind::HexFixed(HexLiteralKind::X),",
          "    c: '\\x7F',",
          "    }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\x7F\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == 'x');",
          "    assert!(parser.char() == '7');",
          "    assert!(parser.char() == 'F');",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(is_meta_character('F') == false);",
          "    assert!(is_escapeable_character('F') == false);",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal {",
          "    span: Span::new(parser.pos(), parser.pos()),",
          "    kind: ast::LiteralKind::HexFixed(HexLiteralKind::X),",
          "    c: '\\x7F',",
          "    }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\x{7F}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parser.octal, false);",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == 'x');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == '{');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == '7');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == 'F');",
          "    assert!(parser.is_eof());",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert!(parser.parse_escape().unwrap().is_a_kind_of(Primitive::Literal));",
          "    assert!(parser.parse_escape().unwrap().literal().c == '\\x7F');"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\x{7F}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.parser.octal, false);",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == 'x');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == '{');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == '7');",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == 'F');",
          "    assert!(parser.is_eof());",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert!(parser.parse_escape().unwrap().is_a_kind_of(Primitive::Literal));",
          "    assert!(parser.parse_escape().unwrap().literal().c == '\\x7F');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\U0000007F\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.octal, false);",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(parser.bump());",
          "    assert_eq!(parser.char(), 'U');",
          "    assert_eq!(parser.pos().offset, 2);",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    if let Primitive::Literal(lit) = primitive {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeLong));",
          "    assert_eq!(lit.c, '\\u{7F}');",
          "    } else {",
          "    panic!(\"Expected a Literal primitive\");",
          "    }"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\U0000007F\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.octal, false);",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(parser.bump());",
          "    assert_eq!(parser.char(), 'U');",
          "    assert_eq!(parser.pos().offset, 2);",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    if let Primitive::Literal(lit) = primitive {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeLong));",
          "    assert_eq!(lit.c, '\\u{7F}');",
          "    } else {",
          "    panic!(\"Expected a Literal primitive\");",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\u007F\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(parser.parse_escape().is_err());",
          "    assert_eq!(parser.parse_escape().unwrap_err().kind, ast::ErrorKind::UnsupportedBackreference);",
          "    assert!(parser.parser.octal == false);",
          "    assert_eq!(parser.pattern, \"\\\\u007F\");",
          "    assert!(parser.bump());",
          "    assert_eq!(parser.char(), 'u');",
          "    assert!(parser.char() == 'u');",
          "    assert!(is_escapeable_character(parser.char()));",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert!(parser.parse_escape().unwrap().is_a::<Primitive::Literal>());",
          "    assert_eq!(parser.parse_escape().unwrap().to_string(), \"\\\\u007F\");"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\u007F\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert!(parser.parse_escape().is_err());",
          "    assert_eq!(parser.parse_escape().unwrap_err().kind, ast::ErrorKind::UnsupportedBackreference);",
          "    assert!(parser.parser.octal == false);",
          "    assert_eq!(parser.pattern, \"\\\\u007F\");",
          "    assert!(parser.bump());",
          "    assert_eq!(parser.char(), 'u');",
          "    assert!(parser.char() == 'u');",
          "    assert!(is_escapeable_character(parser.char()));",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert!(parser.parse_escape().unwrap().is_a::<Primitive::Literal>());",
          "    assert_eq!(parser.parse_escape().unwrap().to_string(), \"\\\\u007F\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    parser.pattern = \"\\\\d\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\D\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\w\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\W\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\s\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\S\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\p{L}\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\P{L}\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\x41\"; // ASCII for 'A'",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\u0041\"; // Unicode for 'A'",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\U00000041\"; // Unicode for 'A'",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\f\";",
          "    parser.parse_escape().unwrap();"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\d\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\D\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\w\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\W\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\s\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\S\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\p{L}\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\P{L}\";",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\x41\"; // ASCII for 'A'",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\u0041\"; // Unicode for 'A'",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\U00000041\"; // Unicode for 'A'",
          "    parser.parse_escape().unwrap();",
          "    parser.pattern = \"\\\\f\";",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\t\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(expected_start, expected_end), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\t\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(expected_start, expected_end), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\r\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\r\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive, Primitive::Literal(Literal { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } }, kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\r\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    let pattern = \"\\\\r\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive, Primitive::Literal(Literal { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } }, kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\f\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '\\\\');",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(lit) if lit.kind == LiteralKind::Special(SpecialLiteralKind::FormFeed)));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\f\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.char(), '\\\\');",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(lit) if lit.kind == LiteralKind::Special(SpecialLiteralKind::FormFeed)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\v\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(start, end), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\v\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(start, end), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\a\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.pos(), Position { offset: 1, line: 1, column: 2 });",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(lit)) if lit.kind == LiteralKind::Special(SpecialLiteralKind::Bell)));",
          "    assert_eq!(lit.span.start.offset, 0);",
          "    assert_eq!(lit.span.end.offset, 1);",
          "    assert!(parser.stack_class.borrow().is_empty());",
          "    assert!(parser.comments.borrow().is_empty());",
          "    assert_eq!(parser.capture_names.borrow().len(), 0);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\a\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.pos(), Position { offset: 1, line: 1, column: 2 });",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(lit)) if lit.kind == LiteralKind::Special(SpecialLiteralKind::Bell)));",
          "    assert_eq!(lit.span.start.offset, 0);",
          "    assert_eq!(lit.span.end.offset, 1);",
          "    assert!(parser.stack_class.borrow().is_empty());",
          "    assert!(parser.comments.borrow().is_empty());",
          "    assert_eq!(parser.capture_names.borrow().len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"<\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    if let Ok(Primitive::Assertion(assertion)) = result {",
          "    assert_eq!(assertion.kind, ast::AssertionKind::WordBoundaryStart);",
          "    } else {",
          "    panic!(\"Expected Primitive::Assertion\");",
          "    }"
        ],
        "code": [
          "{",
          "    let pattern = \"<\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    let pattern = \"<\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    if let Ok(Primitive::Assertion(assertion)) = result {",
          "    assert_eq!(assertion.kind, ast::AssertionKind::WordBoundaryStart);",
          "    } else {",
          "    panic!(\"Expected Primitive::Assertion\");",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \">\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    let pattern = \">\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(ast::Assertion { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 }), kind: ast::AssertionKind::WordBoundaryEndAngle }));",
          "    ",
          "    let pattern = \"\\\\u0030\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Digit, negated: false }));",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Word, negated: false }));",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Word, negated: true }));",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Space, negated: false }));",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Space, negated: true }));",
          "    ",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    ",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    ",
          "    let pattern = \"\\\\x61\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\U00000061\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\u0061\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 6, line: 1, column: 7 }), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' }));"
        ],
        "code": [
          "{",
          "    let pattern = \">\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    let pattern = \">\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(ast::Assertion { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 }), kind: ast::AssertionKind::WordBoundaryEndAngle }));",
          "    ",
          "    let pattern = \"\\\\u0030\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Digit, negated: false }));",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Word, negated: false }));",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Word, negated: true }));",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Space, negated: false }));",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Space, negated: true }));",
          "    ",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    ",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    ",
          "    let pattern = \"\\\\x61\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\U00000061\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\u0061\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 6, line: 1, column: 7 }), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'a' }));",
          "    ",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(ast::Assertion {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: AssertionKind::WordBoundary,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\B\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(ast::Assertion {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: AssertionKind::NotWordBoundary,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Digit,",
          "    negated: false,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Digit,",
          "    negated: true,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Space,",
          "    negated: false,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Space,",
          "    negated: true,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Word,",
          "    negated: false,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Word,",
          "    negated: true,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\u0031\"; // Unicode code point for '1'",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    ",
          "    let pattern = \"\\\\x41\"; // Unicode code point for 'A'",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    ",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Unicode(_)));",
          "    ",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Unicode(_)));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(ast::Assertion {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: AssertionKind::WordBoundary,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\B\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(ast::Assertion {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: AssertionKind::NotWordBoundary,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Digit,",
          "    negated: false,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Digit,",
          "    negated: true,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Space,",
          "    negated: false,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Space,",
          "    negated: true,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Word,",
          "    negated: false,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ClassPerlKind::Word,",
          "    negated: true,",
          "    }));",
          "    ",
          "    let pattern = \"\\\\u0031\"; // Unicode code point for '1'",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    ",
          "    let pattern = \"\\\\x41\"; // Unicode code point for 'A'",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    ",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Unicode(_)));",
          "    ",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false },",
          "    pattern,",
          "    };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Unicode(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\B\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(!matches!(parser.char(), '0'..='7'));",
          "    assert!(!matches!(parser.char(), '8'..='9'));",
          "    assert!(matches!(parser.char(), 'B'));",
          "    assert!(matches!(parser.char(), 'D'));",
          "    assert!(matches!(parser.char(), 'W'));",
          "    assert!(matches!(parser.char(), 'w'));",
          "    assert!(matches!(parser.char(), 'p'));",
          "    assert!(matches!(parser.char(), 'P'));",
          "    assert!(matches!(parser.char(), 's'));",
          "    assert!(matches!(parser.char(), 'S'));",
          "    assert!(matches!(parser.char(), 'd'));",
          "    assert!(matches!(parser.char(), 'x'));",
          "    assert!(matches!(parser.char(), 'u'));",
          "    assert!(matches!(parser.char(), 'U'));",
          "    assert_eq!(parser.bump(), true);",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));",
          "    assert!(matches!(parser.char(), 'f'));",
          "    assert!(matches!(parser.char(), 'f'));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\B\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false },",
          "        pattern,",
          "    };",
          "    parser.parse_escape().unwrap();",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(!matches!(parser.char(), '0'..='7'));",
          "    assert!(!matches!(parser.char(), '8'..='9'));",
          "    assert!(matches!(parser.char(), 'B'));",
          "    assert!(matches!(parser.char(), 'D'));",
          "    assert!(matches!(parser.char(), 'W'));",
          "    assert!(matches!(parser.char(), 'w'));",
          "    assert!(matches!(parser.char(), 'p'));",
          "    assert!(matches!(parser.char(), 'P'));",
          "    assert!(matches!(parser.char(), 's'));",
          "    assert!(matches!(parser.char(), 'S'));",
          "    assert!(matches!(parser.char(), 'd'));",
          "    assert!(matches!(parser.char(), 'x'));",
          "    assert!(matches!(parser.char(), 'u'));",
          "    assert!(matches!(parser.char(), 'U'));",
          "    assert_eq!(parser.bump(), true);",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));",
          "    assert!(matches!(parser.char(), 'f'));",
          "    assert!(matches!(parser.char(), 'f'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]