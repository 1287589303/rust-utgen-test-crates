[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\p{Unicode}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Ok(Primitive::Unicode(ast::ClassUnicode { span: Span::new(position, parser.pos()), negated: false, kind: ast::ClassUnicodeKind::Named(\"Unicode\".to_string()) })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\p{Unicode}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().unwrap(), Ok(Primitive::Unicode(ast::ClassUnicode { span: Span::new(position, parser.pos()), negated: false, kind: ast::ClassUnicodeKind::Named(\"Unicode\".to_string()) })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\P{Unicode}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(position, parser.pos()), negated: true, kind: ClassUnicodeKind::Named(\"Unicode\".to_string()) })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\P{Unicode}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(position, parser.pos()), negated: true, kind: ClassUnicodeKind::Named(\"Unicode\".to_string()) })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl { span: _, kind: ast::ClassPerlKind::Word, negated: false })));",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl { span: _, kind: ast::ClassPerlKind::Word, negated: true })));",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ast::ClassUnicode { span: _, negated: false, kind: _ })));",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ast::ClassUnicode { span: _, negated: true, kind: _ })));",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion { span: _, kind: ast::AssertionKind::WordBoundary })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl { span: _, kind: ast::ClassPerlKind::Word, negated: false })));",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl { span: _, kind: ast::ClassPerlKind::Word, negated: true })));",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ast::ClassUnicode { span: _, negated: false, kind: _ })));",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ast::ClassUnicode { span: _, negated: true, kind: _ })));",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion { span: _, kind: ast::AssertionKind::WordBoundary })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\s\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion { span: Span::new(position, parser.pos()), kind: ast::AssertionKind::WordBoundary })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\s\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion { span: Span::new(position, parser.pos()), kind: ast::AssertionKind::WordBoundary })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Digit, negated: false })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Space, negated: false })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Word, negated: false })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Digit, negated: true })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Space, negated: true })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Word, negated: true })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span { start: position, end: parser.pos.get() }, negated: false, kind: ClassUnicodeKind::Named(\"name\".to_string()) })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span { start: position, end: parser.pos.get() }, negated: true, kind: ClassUnicodeKind::Named(\"name\".to_string()) })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Digit, negated: false })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Space, negated: false })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Word, negated: false })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Digit, negated: true })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Space, negated: true })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span { start: position, end: parser.pos.get() }, kind: ClassPerlKind::Word, negated: true })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span { start: position, end: parser.pos.get() }, negated: false, kind: ClassUnicodeKind::Named(\"name\".to_string()) })));",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span { start: position, end: parser.pos.get() }, negated: true, kind: ClassUnicodeKind::Named(\"name\".to_string()) })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\x41\"; // Assuming 'A' as valid hex for escape",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\D\"; // Test for a valid Perl escape sequence.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Digit, negated: true })));",
          "    ",
          "    let pattern = \"\\\\W\"; // Test for a valid Perl escape sequence.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Word, negated: true })));",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\"; // Test for Unicode escape sequence.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(...), kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::Equal, name: \"scx\".to_string(), value: \"Katakana\".to_string() }, negated: false })));",
          "    ",
          "    let pattern = \"\\\\P{scx!=Katakana}\"; // Test for negated Unicode escape sequence.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(...), kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::NotEqual, name: \"scx\".to_string(), value: \"Katakana\".to_string() }, negated: true })));",
          "    ",
          "    let pattern = \"\\\\u0041\"; // Test for a valid Unicode escape sequence for 'A'.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeShort), c: 'A' })));",
          "    ",
          "    let pattern = \"\\\\U00000041\"; // Test for a valid long Unicode escape sequence for 'A'.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 'A' })));",
          "    ",
          "    let pattern = \"\\\\b\"; // Test for word boundary assertion escape.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(Assertion { span: Span::new(...), kind: AssertionKind::WordBoundary })));",
          "    ",
          "    let pattern = \"\\\\B\"; // Test for not word boundary assertion escape.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(Assertion { span: Span::new(...), kind: AssertionKind::NotWordBoundary })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\x41\"; // Assuming 'A' as valid hex for escape",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    let pattern = \"\\\\D\"; // Test for a valid Perl escape sequence.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Digit, negated: true })));",
          "    ",
          "    let pattern = \"\\\\W\"; // Test for a valid Perl escape sequence.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(...), kind: ClassPerlKind::Word, negated: true })));",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\"; // Test for Unicode escape sequence.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(...), kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::Equal, name: \"scx\".to_string(), value: \"Katakana\".to_string() }, negated: false })));",
          "    ",
          "    let pattern = \"\\\\P{scx!=Katakana}\"; // Test for negated Unicode escape sequence.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(...), kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::NotEqual, name: \"scx\".to_string(), value: \"Katakana\".to_string() }, negated: true })));",
          "    ",
          "    let pattern = \"\\\\u0041\"; // Test for a valid Unicode escape sequence for 'A'.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeShort), c: 'A' })));",
          "    ",
          "    let pattern = \"\\\\U00000041\"; // Test for a valid long Unicode escape sequence for 'A'.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: Span::new(...), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 'A' })));",
          "    ",
          "    let pattern = \"\\\\b\"; // Test for word boundary assertion escape.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(Assertion { span: Span::new(...), kind: AssertionKind::WordBoundary })));",
          "    ",
          "    let pattern = \"\\\\B\"; // Test for not word boundary assertion escape.",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, ..Default::default() },",
          "    pattern,",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(Assertion { span: Span::new(...), kind: AssertionKind::NotWordBoundary })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\U000041\"; // Assuming 'A' as valid long Unicode escape",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(position, position), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\U000041\"; // Assuming 'A' as valid long Unicode escape",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(position, position), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\u0041\"; // Assuming 'A' as valid short Unicode escape",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion {",
          "    span: Span::new(position, parser.pos()),",
          "    kind: AssertionKind::WordBoundary,",
          "    })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\u0041\"; // Assuming 'A' as valid short Unicode escape",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion {",
          "    span: Span::new(position, parser.pos()),",
          "    kind: AssertionKind::WordBoundary,",
          "    })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\b{start}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion { span: Span::new(position, parser.pos()), kind: ast::AssertionKind::WordBoundary })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\b{start}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion { span: Span::new(position, parser.pos()), kind: ast::AssertionKind::WordBoundary })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\B\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion { span: Span::new(position, parser.pos()), kind: ast::AssertionKind::NotWordBoundary })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\B\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    parser.pos.set(position);",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Assertion(ast::Assertion { span: Span::new(position, parser.pos()), kind: ast::AssertionKind::NotWordBoundary })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]