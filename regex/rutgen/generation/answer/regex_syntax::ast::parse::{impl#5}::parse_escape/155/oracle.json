[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Assertion(assertion) => {",
          "    assert_eq!(assertion.kind, ast::AssertionKind::WordBoundary);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Assertion for \\\\b\"),",
          "    }",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Word);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\w\"),",
          "    }",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Word);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\W\"),",
          "    }",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Digit);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\d\"),",
          "    }",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Digit);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\D\"),",
          "    }",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Space);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\s\"),",
          "    }",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Space);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\S\"),",
          "    }",
          "    let pattern = \"\\\\d{2,}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_err());",
          "    let pattern = \"\\\\x41\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.c, 'A');",
          "    assert_eq!(lit.kind, ast::LiteralKind::HexFixed(ast::HexLiteralKind::X));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for \\\\x41\"),",
          "    }",
          "    let pattern = \"\\\\u03B1\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.c, 'Î±');",
          "    assert_eq!(lit.kind, ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for \\\\u03B1\"),",
          "    }",
          "    let pattern = \"\\\\U0001F600\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.c, 'ğŸ˜€');",
          "    assert_eq!(lit.kind, ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for \\\\U0001F600\"),",
          "    }",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(!cls.negated);",
          "    // Further assertions on `cls` can be made.",
          "    },",
          "    _ => panic!(\"Expected Primitive::Unicode for \\\\p{{L}}\"),",
          "    }",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.negated);",
          "    // Further assertions on `cls` can be made.",
          "    },",
          "    _ => panic!(\"Expected Primitive::Unicode for \\\\P{{L}}\"),",
          "    }",
          "    let pattern = \"\\\\o123\";",
          "    let parser = ParserI { parser: Parser { octal: true, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.c, 'S');",
          "    assert_eq!(lit.kind, ast::LiteralKind::Octal);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for \\\\o123\"),",
          "    }",
          "    let pattern = \"\\\\o128\";",
          "    let parser = ParserI { parser: Parser { octal: true, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Assertion(assertion) => {",
          "    assert_eq!(assertion.kind, ast::AssertionKind::WordBoundary);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Assertion for \\\\b\"),",
          "    }",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Word);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\w\"),",
          "    }",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Word);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\W\"),",
          "    }",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Digit);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\d\"),",
          "    }",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Digit);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\D\"),",
          "    }",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Space);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\s\"),",
          "    }",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Space);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for \\\\S\"),",
          "    }",
          "    let pattern = \"\\\\d{2,}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_err());",
          "    let pattern = \"\\\\x41\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.c, 'A');",
          "    assert_eq!(lit.kind, ast::LiteralKind::HexFixed(ast::HexLiteralKind::X));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for \\\\x41\"),",
          "    }",
          "    let pattern = \"\\\\u03B1\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.c, 'Î±');",
          "    assert_eq!(lit.kind, ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for \\\\u03B1\"),",
          "    }",
          "    let pattern = \"\\\\U0001F600\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.c, 'ğŸ˜€');",
          "    assert_eq!(lit.kind, ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for \\\\U0001F600\"),",
          "    }",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(!cls.negated);",
          "    // Further assertions on `cls` can be made.",
          "    },",
          "    _ => panic!(\"Expected Primitive::Unicode for \\\\p{{L}}\"),",
          "    }",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.negated);",
          "    // Further assertions on `cls` can be made.",
          "    },",
          "    _ => panic!(\"Expected Primitive::Unicode for \\\\P{{L}}\"),",
          "    }",
          "    let pattern = \"\\\\o123\";",
          "    let parser = ParserI { parser: Parser { octal: true, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    match result.unwrap() {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.c, 'S');",
          "    assert_eq!(lit.kind, ast::LiteralKind::Octal);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for \\\\o123\"),",
          "    }",
          "    let pattern = \"\\\\o128\";",
          "    let parser = ParserI { parser: Parser { octal: true, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parser.octal, false);",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(!matches!(parser.char(), '0'..='7'));",
          "    assert!(!matches!(parser.char(), '8'..='9'));",
          "    assert!(matches!(parser.char(), 'd' | 'D' | 's' | 'S' | 'w' | 'W'));",
          "    assert!(matches!(parser.char(), 'P' | 'p'));",
          "    assert!(matches!(parser.char(), 'x' | 'U' | 'u'));",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));",
          "    assert!(matches!(parser.char(), 'b'));",
          "    assert!(matches!(parser.char(), 'b'));",
          "    assert!(!parser.is_eof());",
          "    assert!(!parser.char() == '{');",
          "    assert!(parser.maybe_parse_special_word_boundary(start).is_err());"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(parser.parser.octal, false);",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(!matches!(parser.char(), '0'..='7'));",
          "    assert!(!matches!(parser.char(), '8'..='9'));",
          "    assert!(matches!(parser.char(), 'd' | 'D' | 's' | 'S' | 'w' | 'W'));",
          "    assert!(matches!(parser.char(), 'P' | 'p'));",
          "    assert!(matches!(parser.char(), 'x' | 'U' | 'u'));",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));",
          "    assert!(matches!(parser.char(), 'b'));",
          "    assert!(matches!(parser.char(), 'b'));",
          "    assert!(!parser.is_eof());",
          "    assert!(!parser.char() == '{');",
          "    assert!(parser.maybe_parse_special_word_boundary(start).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let expected_result = Err(Error { kind: ErrorKind::UnsupportedBackreference, ... });",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Digit, negated: false }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\D{start}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Digit, negated: true }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Unicode(ClassUnicode { span: ..., negated: false, kind: ... }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\P{scx=Katakana}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Unicode(ClassUnicode { span: ..., negated: true, kind: ... }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Space, negated: false }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Space, negated: true }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Word, negated: false }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Word, negated: true }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\x61\"; // 'a' in hex",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Literal(Literal { span: ..., kind: LiteralKind::HexFixed(HexLiteralKind::X), c: 'a' }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\u0061\"; // 'a' in Unicode hex",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Literal(Literal { span: ..., kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeShort), c: 'a' }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\U00000061\"; // 'a' in Unicode long",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Literal(Literal { span: ..., kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 'a' }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Assertion(Assertion { span: ..., kind: AssertionKind::WordBoundary }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\B\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Assertion(Assertion { span: ..., kind: AssertionKind::NotWordBoundary }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\<\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Assertion(Assertion { span: ..., kind: AssertionKind::WordBoundaryStartAngle }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\>\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Assertion(Assertion { span: ..., kind: AssertionKind::WordBoundaryEndAngle }));",
          "    assert_eq!(parser.parse_escape(), expected_result);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let expected_result = Err(Error { kind: ErrorKind::UnsupportedBackreference, ... });",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Digit, negated: false }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\D{start}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Digit, negated: true }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Unicode(ClassUnicode { span: ..., negated: false, kind: ... }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\P{scx=Katakana}\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Unicode(ClassUnicode { span: ..., negated: true, kind: ... }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Space, negated: false }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Space, negated: true }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Word, negated: false }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Perl(ClassPerl { span: ..., kind: ClassPerlKind::Word, negated: true }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\x61\"; // 'a' in hex",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Literal(Literal { span: ..., kind: LiteralKind::HexFixed(HexLiteralKind::X), c: 'a' }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\u0061\"; // 'a' in Unicode hex",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Literal(Literal { span: ..., kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeShort), c: 'a' }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\U00000061\"; // 'a' in Unicode long",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Literal(Literal { span: ..., kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 'a' }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Assertion(Assertion { span: ..., kind: AssertionKind::WordBoundary }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\B\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Assertion(Assertion { span: ..., kind: AssertionKind::NotWordBoundary }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\<\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Assertion(Assertion { span: ..., kind: AssertionKind::WordBoundaryStartAngle }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "    ",
          "    let pattern = \"\\\\>\";",
          "    let parser = ParserI {",
          "    parser: Parser { octal: false, ..Default::default() },",
          "    pattern,",
          "    };",
          "    let expected_result = Ok(Primitive::Assertion(Assertion { span: ..., kind: AssertionKind::WordBoundaryEndAngle }));",
          "    assert_eq!(parser.parse_escape(), expected_result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    if let Ok(Primitive::Perl(cls)) = result {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Word);",
          "    assert!(!cls.negated);",
          "    } else {",
          "    panic!(\"Expected Primitive::Perl but received another variant.\");",
          "    }"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    if let Ok(Primitive::Perl(cls)) = result {",
          "    assert_eq!(cls.kind, ast::ClassPerlKind::Word);",
          "    assert!(!cls.negated);",
          "    } else {",
          "    panic!(\"Expected Primitive::Perl but received another variant.\");",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_, Primitive::Perl(ClassPerl { span: _, kind: ClassPerlKind::Word, negated: false }));",
          "    assert!(matches!(_, Err(_)));",
          "    assert_eq!(self.parser().octal, false);",
          "    assert!(matches!(self.char(), '\\\\'));",
          "    assert!(self.bump());",
          "    assert!(self.is_eof());",
          "    assert!(self.char() != '{');",
          "    assert!(matches!(self.maybe_parse_special_word_boundary(start), Err(_)));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(_, Primitive::Perl(ClassPerl { span: _, kind: ClassPerlKind::Word, negated: false }));",
          "    assert!(matches!(_, Err(_)));",
          "    assert_eq!(self.parser().octal, false);",
          "    assert!(matches!(self.char(), '\\\\'));",
          "    assert!(self.bump());",
          "    assert!(self.is_eof());",
          "    assert!(self.char() != '{');",
          "    assert!(matches!(self.maybe_parse_special_word_boundary(start), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }), negated: false, kind: ClassUnicodeKind::Named(\"L\".to_string()) }));",
          "    assert!(parser.parse_escape().is_ok(), \"Expected parse_escape to succeed.\");",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Unicode(_))), \"Expected a Unicode class as the result.\");",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(_))), \"Expected a Literal class as the result if the input is incorrect.\");",
          "    assert!(matches!(parser.parse_escape().err(), Some(ast::ErrorKind::EscapeUnexpectedEof)), \"Expected an error for unexpected EOF.\");",
          "    assert!(matches!(parser.parse_escape().err(), Some(ast::ErrorKind::EscapeUnrecognized)), \"Expected an error for unrecognized escape sequence.\");",
          "    assert!(parser.bump(), \"Expected bump to succeed.\");",
          "    assert_eq!(parser.pos().offset, 1, \"Expected position offset to be updated after bump.\");",
          "    assert!(!parser.is_eof(), \"Expected not to reach EOF after parsing one character.\");"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }), negated: false, kind: ClassUnicodeKind::Named(\"L\".to_string()) }));",
          "    assert!(parser.parse_escape().is_ok(), \"Expected parse_escape to succeed.\");",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Unicode(_))), \"Expected a Unicode class as the result.\");",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(_))), \"Expected a Literal class as the result if the input is incorrect.\");",
          "    assert!(matches!(parser.parse_escape().err(), Some(ast::ErrorKind::EscapeUnexpectedEof)), \"Expected an error for unexpected EOF.\");",
          "    assert!(matches!(parser.parse_escape().err(), Some(ast::ErrorKind::EscapeUnrecognized)), \"Expected an error for unrecognized escape sequence.\");",
          "    assert!(parser.bump(), \"Expected bump to succeed.\");",
          "    assert_eq!(parser.pos().offset, 1, \"Expected position offset to be updated after bump.\");",
          "    assert!(!parser.is_eof(), \"Expected not to reach EOF after parsing one character.\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap_err().kind, ast::ErrorKind::EscapeUnrecognized);",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Unicode(_)));",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\u007B\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\x7B\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\u{007B}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Assertion(_)));",
          "    let pattern = \"\\\\B\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Assertion(_)));",
          "    let pattern = \"\\\\<\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Assertion(_)));",
          "    let pattern = \"\\\\>\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Assertion(_)));",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\t\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\r\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\f\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\v\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\a\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert_eq!(parser.parse_escape().unwrap_err().kind, ast::ErrorKind::EscapeUnrecognized);",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Unicode(_)));",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    let pattern = \"\\\\u007B\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\x7B\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\u{007B}\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\b\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Assertion(_)));",
          "    let pattern = \"\\\\B\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Assertion(_)));",
          "    let pattern = \"\\\\<\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Assertion(_)));",
          "    let pattern = \"\\\\>\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Assertion(_)));",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\t\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\r\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\f\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\v\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "    let pattern = \"\\\\a\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Literal(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\x41\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 3, line: 1, column: 4 }), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\x41\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 3, line: 1, column: 4 }), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\u0041\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\u0041\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(_)));",
          "    assert_eq!(parser.pos().offset, pattern.len());",
          "    assert_eq!(parser.char(), '\\0');"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\u0041\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    let pattern = \"\\\\u0041\";",
          "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(_)));",
          "    assert_eq!(parser.pos().offset, pattern.len());",
          "    assert_eq!(parser.char(), '\\0');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\U00000041\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(lit) if lit.c == 'A'));",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeLong));",
          "    assert_eq!(lit.span.start.offset, expected_start_offset);",
          "    assert_eq!(lit.span.end.offset, expected_end_offset);",
          "    assert_eq!(parser.pos.get().offset, expected_position_after_parsing);",
          "    assert!(parser.parser.ignore_whitespace.get() == false);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\U00000041\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(lit) if lit.c == 'A'));",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeLong));",
          "    assert_eq!(lit.span.start.offset, expected_start_offset);",
          "    assert_eq!(lit.span.end.offset, expected_end_offset);",
          "    assert_eq!(parser.pos.get().offset, expected_position_after_parsing);",
          "    assert!(parser.parser.ignore_whitespace.get() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]