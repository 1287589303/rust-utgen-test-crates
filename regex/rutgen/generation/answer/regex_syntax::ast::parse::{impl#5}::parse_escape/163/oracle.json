[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(ref cls) if cls.kind == ast::ClassPerlKind::Digit && !cls.negated));",
          "    assert_eq!(cls.span.start.offset, 0);",
          "    assert_eq!(cls.span.end.offset, 2);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(ref cls) if cls.kind == ast::ClassPerlKind::Digit && !cls.negated));",
          "    assert_eq!(cls.span.start.offset, 0);",
          "    assert_eq!(cls.span.end.offset, 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\D\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert_eq!(cls.negated, true);",
          "    }",
          "    assert_eq!(parser.pos.offset, 2);",
          "    assert_eq!(parser.pos.line, 1);",
          "    assert_eq!(parser.pos.column, 3);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\D\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert_eq!(cls.negated, true);",
          "    }",
          "    assert_eq!(parser.pos.offset, 2);",
          "    assert_eq!(parser.pos.line, 1);",
          "    assert_eq!(parser.pos.column, 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    assert_eq!(cls.negated, false);",
          "    assert!(cls.span.start == start);",
          "    }",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    assert_eq!(cls.negated, true);",
          "    }",
          "    ",
          "    let pattern = \"\\\\P{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Unicode(_)));",
          "    ",
          "    if let Primitive::Unicode(cls) = primitive {",
          "    assert!(cls.negated);",
          "    }",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Unicode(_)));",
          "    ",
          "    if let Primitive::Unicode(cls) = primitive {",
          "    assert!(!cls.negated);",
          "    }",
          "    ",
          "    let pattern = \"\\\\x61\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    ",
          "    if let Primitive::Literal(lit) = primitive {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::X));",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    ",
          "    let pattern = \"\\\\u0061\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    ",
          "    if let Primitive::Literal(lit) = primitive {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeShort));",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    ",
          "    let pattern = \"\\\\U00000061\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    ",
          "    if let Primitive::Literal(lit) = primitive {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeLong));",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    assert_eq!(cls.negated, false);",
          "    }",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    assert_eq!(cls.negated, true);",
          "    }",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert_eq!(cls.negated, false);",
          "    }",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert_eq!(cls.negated, true);",
          "    }"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    assert_eq!(cls.negated, false);",
          "    assert!(cls.span.start == start);",
          "    }",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    assert_eq!(cls.negated, true);",
          "    }",
          "    ",
          "    let pattern = \"\\\\P{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Unicode(_)));",
          "    ",
          "    if let Primitive::Unicode(cls) = primitive {",
          "    assert!(cls.negated);",
          "    }",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Unicode(_)));",
          "    ",
          "    if let Primitive::Unicode(cls) = primitive {",
          "    assert!(!cls.negated);",
          "    }",
          "    ",
          "    let pattern = \"\\\\x61\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    ",
          "    if let Primitive::Literal(lit) = primitive {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::X));",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    ",
          "    let pattern = \"\\\\u0061\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    ",
          "    if let Primitive::Literal(lit) = primitive {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeShort));",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    ",
          "    let pattern = \"\\\\U00000061\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    ",
          "    if let Primitive::Literal(lit) = primitive {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeLong));",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    assert_eq!(cls.negated, false);",
          "    }",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    assert_eq!(cls.negated, true);",
          "    }",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert_eq!(cls.negated, false);",
          "    }",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    ",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    ",
          "    if let Primitive::Perl(cls) = primitive {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert_eq!(cls.negated, true);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\W\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Perl(_)));",
          "    assert_eq!(parser.pos().offset, 2);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 3);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\W\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Perl(_)));",
          "    assert_eq!(parser.pos().offset, 2);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\s\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    assert_eq!(primitive.span().start, start);",
          "    assert_eq!(primitive.span().end.offset, 2);",
          "    assert_eq!(primitive.kind(), LiteralKind::Meta);",
          "    assert_eq!(primitive.c, 's');",
          "    assert_eq!(primitive.span().is_empty(), false);",
          "    assert_eq!(primitive.span().is_one_line(), true);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\s\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Perl(_)));",
          "    assert_eq!(primitive.span().start, start);",
          "    assert_eq!(primitive.span().end.offset, 2);",
          "    assert_eq!(primitive.kind(), LiteralKind::Meta);",
          "    assert_eq!(primitive.c, 's');",
          "    assert_eq!(primitive.span().is_empty(), false);",
          "    assert_eq!(primitive.span().is_one_line(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\S\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.unwrap(), Ok(Primitive::Perl(ast::ClassPerl { span: Span::new(start, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Space, negated: true })));",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\S\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.unwrap(), Ok(Primitive::Perl(ast::ClassPerl { span: Span::new(start, Position { offset: 2, line: 1, column: 3 }), kind: ast::ClassPerlKind::Space, negated: true })));",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\x20\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    let literal = if let Primitive::Literal(lit) = primitive { lit } else { unreachable!() };",
          "    assert_eq!(literal.kind, LiteralKind::HexFixed(HexLiteralKind::X));",
          "    assert_eq!(literal.c, '\\u{20}');",
          "    assert_eq!(literal.span.start, start);",
          "    assert_eq!(literal.span.end.offset, 3);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\x20\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    let literal = if let Primitive::Literal(lit) = primitive { lit } else { unreachable!() };",
          "    assert_eq!(literal.kind, LiteralKind::HexFixed(HexLiteralKind::X));",
          "    assert_eq!(literal.c, '\\u{20}');",
          "    assert_eq!(literal.span.start, start);",
          "    assert_eq!(literal.span.end.offset, 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\u{007}\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(lit) if lit.kind == LiteralKind::HexFixed(HexLiteralKind::UnicodeShort) && lit.c == '\\x07'));",
          "    assert_eq!(parser.pos().offset, 6);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 7);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\u{007}\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap(), Primitive::Literal(lit) if lit.kind == LiteralKind::HexFixed(HexLiteralKind::UnicodeShort) && lit.c == '\\x07'));",
          "    assert_eq!(parser.pos().offset, 6);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 7);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\a\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    let literal = if let Primitive::Literal(lit) = primitive { lit } else { unreachable!() };",
          "    assert_eq!(literal.c, '\\x07');",
          "    assert_eq!(literal.kind, LiteralKind::Special(SpecialLiteralKind::Bell));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\a\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Literal(_)));",
          "    let literal = if let Primitive::Literal(lit) = primitive { lit } else { unreachable!() };",
          "    assert_eq!(literal.c, '\\x07');",
          "    assert_eq!(literal.kind, LiteralKind::Special(SpecialLiteralKind::Bell));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\f\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive, Primitive::Literal(ast::Literal {",
          "    span: Span::new(start, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "    c: '\\x0C',",
          "    }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\f\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive, Primitive::Literal(ast::Literal {",
          "    span: Span::new(start, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "    c: '\\x0C',",
          "    }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\t\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::UnsupportedBackreference);",
          "    assert_eq!(result.unwrap_err().span.start.offset, 1);",
          "    assert_eq!(result.unwrap_err().span.end.offset, 1);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().span.start.line, 1);",
          "    assert_eq!(result.unwrap_err().span.end.line, 1);",
          "    assert_eq!(result.unwrap_err().span.start.column, 1);",
          "    assert_eq!(result.unwrap_err().span.end.column, 1);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\t\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::UnsupportedBackreference);",
          "    assert_eq!(result.unwrap_err().span.start.offset, 1);",
          "    assert_eq!(result.unwrap_err().span.end.offset, 1);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().span.start.line, 1);",
          "    assert_eq!(result.unwrap_err().span.end.line, 1);",
          "    assert_eq!(result.unwrap_err().span.start.column, 1);",
          "    assert_eq!(result.unwrap_err().span.end.column, 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\r\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::Special(SpecialLiteralKind::CarriageReturn));",
          "    }",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\r'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::Special(SpecialLiteralKind::LineFeed));",
          "    }",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\n'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\u0061\"; // 'a' in Unicode",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeShort));",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\u0061'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(!cls.negated);",
          "    // Further assertions can be added based on class properties",
          "    }",
          "    _ => panic!(\"Expected Primitive::Unicode for '\\\\p{{scx=Katakana}}'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\P{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.negated);",
          "    // Further assertions can be added based on class properties",
          "    }",
          "    _ => panic!(\"Expected Primitive::Unicode for '\\\\P{{scx=Katakana}}'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\s'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\D'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\d'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\w'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\W'\"),",
          "    }"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\r\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::Special(SpecialLiteralKind::CarriageReturn));",
          "    }",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\r'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::Special(SpecialLiteralKind::LineFeed));",
          "    }",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\n'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\u0061\"; // 'a' in Unicode",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeShort));",
          "    assert_eq!(lit.c, 'a');",
          "    }",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\u0061'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(!cls.negated);",
          "    // Further assertions can be added based on class properties",
          "    }",
          "    _ => panic!(\"Expected Primitive::Unicode for '\\\\p{{scx=Katakana}}'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\P{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.negated);",
          "    // Further assertions can be added based on class properties",
          "    }",
          "    _ => panic!(\"Expected Primitive::Unicode for '\\\\P{{scx=Katakana}}'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\s'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\D'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\d'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\w'\"),",
          "    }",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    }",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\W'\"),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\v\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), Primitive::Literal(ast::Literal { span: Span::new(start, Position { offset: 1, line: 1, column: 2 }), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\v\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), Primitive::Literal(ast::Literal { span: Span::new(start, Position { offset: 1, line: 1, column: 2 }), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\b\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Assertion(_)));",
          "    if let Primitive::Assertion(assertion) = primitive {",
          "    assert_eq!(assertion.kind, AssertionKind::WordBoundary);",
          "    }",
          "    assert_eq!(parser.pos().offset, 2);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\b\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert!(matches!(primitive, Primitive::Assertion(_)));",
          "    if let Primitive::Assertion(assertion) = primitive {",
          "    assert_eq!(assertion.kind, AssertionKind::WordBoundary);",
          "    }",
          "    assert_eq!(parser.pos().offset, 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\B\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\\\\B\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(ast::Assertion { span: Span::new(start, parser.pos()), kind: AssertionKind::NotWordBoundary }));",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Digit, negated: false }));",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Word, negated: false }));",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Word, negated: true }));",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Space, negated: false }));",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Space, negated: true }));",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Digit, negated: false }));",
          "    ",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ast::ClassUnicode { span: Span::new(start, parser.pos()), negated: false, kind: ClassUnicodeKind::Named(\"L\".to_string()) }));",
          "    ",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ast::ClassUnicode { span: Span::new(start, parser.pos()), negated: true, kind: ClassUnicodeKind::Named(\"L\".to_string()) }));",
          "    ",
          "    let pattern = \"\\\\u0061\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap().to_literal().unwrap().c, 'a');",
          "    ",
          "    let pattern = \"\\\\x61\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap().to_literal().unwrap().c, 'a');"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\B\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    let pattern = \"\\\\B\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(ast::Assertion { span: Span::new(start, parser.pos()), kind: AssertionKind::NotWordBoundary }));",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Digit, negated: false }));",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Word, negated: false }));",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Word, negated: true }));",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Space, negated: false }));",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Space, negated: true }));",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(start, parser.pos()), kind: ClassPerlKind::Digit, negated: false }));",
          "    ",
          "    let pattern = \"\\\\p{L}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ast::ClassUnicode { span: Span::new(start, parser.pos()), negated: false, kind: ClassUnicodeKind::Named(\"L\".to_string()) }));",
          "    ",
          "    let pattern = \"\\\\P{L}\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ast::ClassUnicode { span: Span::new(start, parser.pos()), negated: true, kind: ClassUnicodeKind::Named(\"L\".to_string()) }));",
          "    ",
          "    let pattern = \"\\\\u0061\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap().to_literal().unwrap().c, 'a');",
          "    ",
          "    let pattern = \"\\\\x61\";",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert_eq!(parser.parse_escape().unwrap().to_literal().unwrap().c, 'a');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\<\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive, Primitive::Assertion(Assertion {",
          "    span: Span { start, end: Position { offset: 1, line: 1, column: 2 }},",
          "    kind: AssertionKind::WordBoundaryStart,",
          "    }));",
          "    assert_eq!(parser.pos(), Position { offset: 1, line: 1, column: 2 });"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\<\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive, Primitive::Assertion(Assertion {",
          "    span: Span { start, end: Position { offset: 1, line: 1, column: 2 }},",
          "    kind: AssertionKind::WordBoundaryStart,",
          "    }));",
          "    assert_eq!(parser.pos(), Position { offset: 1, line: 1, column: 2 });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\>\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive, Primitive::Assertion(Assertion {",
          "    span: Span::new(start, parser.pos()),",
          "    kind: AssertionKind::WordBoundaryEndAngle,",
          "    }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\>\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    assert_eq!(primitive, Primitive::Assertion(Assertion {",
          "    span: Span::new(start, parser.pos()),",
          "    kind: AssertionKind::WordBoundaryEndAngle,",
          "    }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\u{202E}\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeShort));",
          "    assert_eq!(lit.c, '\\u{202E}');",
          "    }",
          "    _ => panic!(\"Expected a Literal but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassUnicodeKind::Named(\"scx\".to_string()));",
          "    }",
          "    _ => panic!(\"Expected a Unicode class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\P{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassUnicodeKind::Named(\"scx\".to_string()));",
          "    }",
          "    _ => panic!(\"Expected a Unicode class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\x10\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::X));",
          "    assert_eq!(lit.c, '\\x10');",
          "    }",
          "    _ => panic!(\"Expected a Literal but got {:?}\", primitive),",
          "    }"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\u{202E}\";",
          "    let start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser { octal: true }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::UnicodeShort));",
          "    assert_eq!(lit.c, '\\u{202E}');",
          "    }",
          "    _ => panic!(\"Expected a Literal but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\p{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassUnicodeKind::Named(\"scx\".to_string()));",
          "    }",
          "    _ => panic!(\"Expected a Unicode class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\P{scx=Katakana}\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassUnicodeKind::Named(\"scx\".to_string()));",
          "    }",
          "    _ => panic!(\"Expected a Unicode class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\d\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\D\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\w\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\W\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\s\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(!cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\S\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Perl(cls) => {",
          "    assert!(cls.negated);",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    }",
          "    _ => panic!(\"Expected a Perl class but got {:?}\", primitive),",
          "    }",
          "    ",
          "    let pattern = \"\\\\x10\";",
          "    let parser = ParserI { parser: Parser { octal: false }, pattern };",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    let primitive = result.unwrap();",
          "    match primitive {",
          "    Primitive::Literal(lit) => {",
          "    assert_eq!(lit.kind, LiteralKind::HexFixed(HexLiteralKind::X));",
          "    assert_eq!(lit.c, '\\x10');",
          "    }",
          "    _ => panic!(\"Expected a Literal but got {:?}\", primitive),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]