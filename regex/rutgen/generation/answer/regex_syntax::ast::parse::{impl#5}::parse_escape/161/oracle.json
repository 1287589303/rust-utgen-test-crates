[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, .. },",
          "        pattern: \"\\\\d\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    parser.parser().octal = false;",
          "    ",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\d'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\D\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\D'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\w\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\w'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\W\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\W'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\s\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\s'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\S\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\S'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\p{scx=Katakana}\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(!cls.negated);",
          "    // Additional checks on the kind of class can be added here as needed.",
          "    },",
          "    _ => panic!(\"Expected Primitive::Unicode for '\\\\p'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\P{scx=Katakana}\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.negated);",
          "    // Additional checks on the kind of class can be added here as needed.",
          "    },",
          "    _ => panic!(\"Expected Primitive::Unicode for '\\\\P'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\x61\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Literal(literal) => {",
          "    assert_eq!(literal.c, 'a');",
          "    assert_eq!(literal.kind, LiteralKind::HexFixed(ast::HexLiteralKind::X));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\x61'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\u0061\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Literal(literal) => {",
          "    assert_eq!(literal.c, 'a');",
          "    assert_eq!(literal.kind, LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\u0061'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\U00000061\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Literal(literal) => {",
          "    assert_eq!(literal.c, 'a');",
          "    assert_eq!(literal.kind, LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\U00000061'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\v\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Literal(literal) => {",
          "    assert_eq!(literal.kind, LiteralKind::Special(SpecialLiteralKind::VerticalTab));",
          "    assert_eq!(literal.c, '\\x0B');",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\v'\"),",
          "    }"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, .. },",
          "        pattern: \"\\\\d\",",
          "    };",
          "    parser.parse_escape();",
          "    parser.pos.set(Position { offset: 0, line: 1, column: 1 });",
          "    parser.parser().octal = false;",
          "    ",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\d'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\D\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Digit);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\D'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\w\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\w'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\W\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Word);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\W'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\s\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    assert!(!cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\s'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\S\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Perl(cls) => {",
          "    assert_eq!(cls.kind, ClassPerlKind::Space);",
          "    assert!(cls.negated);",
          "    },",
          "    _ => panic!(\"Expected Primitive::Perl for '\\\\S'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\p{scx=Katakana}\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(!cls.negated);",
          "    // Additional checks on the kind of class can be added here as needed.",
          "    },",
          "    _ => panic!(\"Expected Primitive::Unicode for '\\\\p'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\P{scx=Katakana}\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Unicode(cls) => {",
          "    assert!(cls.negated);",
          "    // Additional checks on the kind of class can be added here as needed.",
          "    },",
          "    _ => panic!(\"Expected Primitive::Unicode for '\\\\P'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\x61\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Literal(literal) => {",
          "    assert_eq!(literal.c, 'a');",
          "    assert_eq!(literal.kind, LiteralKind::HexFixed(ast::HexLiteralKind::X));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\x61'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\u0061\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Literal(literal) => {",
          "    assert_eq!(literal.c, 'a');",
          "    assert_eq!(literal.kind, LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\u0061'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\U00000061\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Literal(literal) => {",
          "    assert_eq!(literal.c, 'a');",
          "    assert_eq!(literal.kind, LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong));",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\U00000061'\"),",
          "    }",
          "    ",
          "    parser.pattern = \"\\\\v\";",
          "    let result = parser.parse_escape();",
          "    assert!(result.is_ok());",
          "    ",
          "    match result.unwrap() {",
          "    Primitive::Literal(literal) => {",
          "    assert_eq!(literal.kind, LiteralKind::Special(SpecialLiteralKind::VerticalTab));",
          "    assert_eq!(literal.c, '\\x0B');",
          "    },",
          "    _ => panic!(\"Expected Primitive::Literal for '\\\\v'\"),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, .. },",
          "        pattern: \"\\\\8\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    parser.parse_escape(); // Expect Err(ErrorKind::UnsupportedBackreference) due to '8' invalid escape with octal disabled.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: true, .. }, pattern: \"\\\\4\" };",
          "    parser.parse_escape(); // Expect Ok(Literal) due to valid octal escape '4'.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: true, .. }, pattern: \"\\\\x61\" };",
          "    parser.parse_escape(); // Expect Ok(Literal) for valid hex escape 'a'.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\u0061\" };",
          "    parser.parse_escape(); // Expect Ok(Literal) for valid unicode escape 'a'.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\p{L}\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Unicode) for valid unicode class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\P{L}\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Unicode) for valid negated unicode class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\d\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid perl class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\D\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid negated perl class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\s\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid whitespace class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\S\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid negated whitespace class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\w\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid word class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\W\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid negated word class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\v\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid vertical tab escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\a\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid bell escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\f\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid form feed escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\t\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid tab escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\n\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid line feed escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\r\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid carriage return escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\B\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Assertion) for valid not-word-boundary assertion.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\b\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Assertion) for valid word-boundary assertion.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\<\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Assertion) for valid start-word-boundary.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\>\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Assertion) for valid end-word-boundary.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\a\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid bell escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\c\" };",
          "    parser.parse_escape(); // Expect Err(ErrorKind::EscapeUnrecognized) for unrecognized escape."
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, .. },",
          "        pattern: \"\\\\8\",",
          "    };",
          "    parser.parse_escape();",
          "    parser.parse_escape(); // Expect Err(ErrorKind::UnsupportedBackreference) due to '8' invalid escape with octal disabled.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: true, .. }, pattern: \"\\\\4\" };",
          "    parser.parse_escape(); // Expect Ok(Literal) due to valid octal escape '4'.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: true, .. }, pattern: \"\\\\x61\" };",
          "    parser.parse_escape(); // Expect Ok(Literal) for valid hex escape 'a'.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\u0061\" };",
          "    parser.parse_escape(); // Expect Ok(Literal) for valid unicode escape 'a'.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\p{L}\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Unicode) for valid unicode class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\P{L}\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Unicode) for valid negated unicode class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\d\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid perl class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\D\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid negated perl class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\s\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid whitespace class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\S\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid negated whitespace class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\w\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid word class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\W\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Perl) for valid negated word class.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\v\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid vertical tab escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\a\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid bell escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\f\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid form feed escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\t\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid tab escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\n\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid line feed escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\r\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid carriage return escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\B\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Assertion) for valid not-word-boundary assertion.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\b\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Assertion) for valid word-boundary assertion.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\<\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Assertion) for valid start-word-boundary.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\>\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Assertion) for valid end-word-boundary.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\a\" };",
          "    parser.parse_escape(); // Expect Ok(Primitive::Literal) for valid bell escape.",
          "    ",
          "    let parser = ParserI { parser: Parser { octal: false, .. }, pattern: \"\\\\c\" };",
          "    parser.parse_escape(); // Expect Err(ErrorKind::EscapeUnrecognized) for unrecognized escape.",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\D\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\W\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Word, negated: true }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\p{scx=Katakana}\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 15, line: 1, column: 16}), negated: false, kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::Equal, name: \"scx\".to_string(), value: \"Katakana\".to_string() }}));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\P{scx=Katakana}\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 15, line: 1, column: 16}), negated: true, kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::Equal, name: \"scx\".to_string(), value: \"Katakana\".to_string() }}));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\w\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Word, negated: false }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\s\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Space, negated: false }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\D\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\U0073\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 6, line: 1, column: 7}), kind: ast::LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 's' }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\v\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' }));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\D\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\W\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Word, negated: true }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\p{scx=Katakana}\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 15, line: 1, column: 16}), negated: false, kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::Equal, name: \"scx\".to_string(), value: \"Katakana\".to_string() }}));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\P{scx=Katakana}\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 15, line: 1, column: 16}), negated: true, kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::Equal, name: \"scx\".to_string(), value: \"Katakana\".to_string() }}));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\w\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Word, negated: false }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\s\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Space, negated: false }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\D\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ClassPerlKind::Digit, negated: true }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\U0073\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 6, line: 1, column: 7}), kind: ast::LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 's' }));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\v\",",
          "    };",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span::new(Position {offset: 0, line: 1, column: 1}, Position {offset: 2, line: 1, column: 3}), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\W\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Word, negated: true })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\d\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Digit, negated: false })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\D\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Digit, negated: true })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\s\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: false })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\S\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: true })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\p{letter}\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }), negated: false, kind: ClassUnicodeKind::Named(\"letter\".to_string()) })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\P{letter}\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }), negated: true, kind: ClassUnicodeKind::Named(\"letter\".to_string()) })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\x41\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }), kind: LiteralKind::HexFixed(HexLiteralKind::X), c: 'A' })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\u0041\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 6, line: 1, column: 7 }), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeShort), c: 'A' })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\U00000041\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 'A' })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: r\"\\v\";",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' })));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\W\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Word, negated: true })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\d\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Digit, negated: false })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\D\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Digit, negated: true })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\s\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: false })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\S\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: true })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\p{letter}\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }), negated: false, kind: ClassUnicodeKind::Named(\"letter\".to_string()) })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\P{letter}\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }), negated: true, kind: ClassUnicodeKind::Named(\"letter\".to_string()) })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\x41\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }), kind: LiteralKind::HexFixed(HexLiteralKind::X), c: 'A' })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\u0041\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 6, line: 1, column: 7 }), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeShort), c: 'A' })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\U00000041\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 'A' })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: r\"\\v\";",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\P{scx=Katakana}\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ast::ClassUnicode {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 20, line: 1, column: 21 }),",
          "    negated: true,",
          "    kind: ast::ClassUnicodeKind::Named(\"scx\".to_string()),",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\p{scx=Katakana}\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ast::ClassUnicode {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 20, line: 1, column: 21 }),",
          "    negated: false,",
          "    kind: ast::ClassUnicodeKind::Named(\"scx\".to_string()),",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\d\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Digit,",
          "    negated: false,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\D\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Digit,",
          "    negated: true,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\w\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Word,",
          "    negated: false,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\W\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Word,",
          "    negated: true,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\s\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Space,",
          "    negated: false,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\S\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Space,",
          "    negated: true,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\x41\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "    c: 'A',",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\u0041\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 6, line: 1, column: 7 }),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "    c: 'A',",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\U00000041\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "    c: 'A',",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\v\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "    c: '\\x0B',",
          "    })));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\P{scx=Katakana}\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ast::ClassUnicode {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 20, line: 1, column: 21 }),",
          "    negated: true,",
          "    kind: ast::ClassUnicodeKind::Named(\"scx\".to_string()),",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\p{scx=Katakana}\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Unicode(ast::ClassUnicode {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 20, line: 1, column: 21 }),",
          "    negated: false,",
          "    kind: ast::ClassUnicodeKind::Named(\"scx\".to_string()),",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\d\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Digit,",
          "    negated: false,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\D\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Digit,",
          "    negated: true,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\w\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Word,",
          "    negated: false,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\W\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Word,",
          "    negated: true,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\s\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Space,",
          "    negated: false,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\S\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Perl(ast::ClassPerl {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::ClassPerlKind::Space,",
          "    negated: true,",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\x41\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "    c: 'A',",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\u0041\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 6, line: 1, column: 7 }),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "    c: 'A',",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\U00000041\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 10, line: 1, column: 11 }),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "    c: 'A',",
          "    })));",
          "    ",
          "    let parser = ParserI {",
          "    parser: Parser { octal: true, .. },",
          "    pattern: \"\\\\v\",",
          "    };",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "    c: '\\x0B',",
          "    })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\p{scx=Katakana}\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 18, line: 1, column: 19 } }, negated: false, kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::Equal, name: String::from(\"scx\"), value: String::from(\"Katakana\") } }));",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Unicode(_))));",
          "    assert!(parser.parser.octal);",
          "    assert_eq!(parser.pattern, \"\\\\p{scx=Katakana}\");",
          "    assert!(is_escapeable_character('p'));",
          "    assert!(!is_meta_character('p'));",
          "    assert!(!is_escapeable_character(' '));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\p{scx=Katakana}\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Unicode(ClassUnicode { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 18, line: 1, column: 19 } }, negated: false, kind: ClassUnicodeKind::NamedValue { op: ClassUnicodeOpKind::Equal, name: String::from(\"scx\"), value: String::from(\"Katakana\") } }));",
          "    assert!(parser.parse_escape().is_ok());",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Unicode(_))));",
          "    assert!(parser.parser.octal);",
          "    assert_eq!(parser.pattern, \"\\\\p{scx=Katakana}\");",
          "    assert!(is_escapeable_character('p'));",
          "    assert!(!is_meta_character('p'));",
          "    assert!(!is_escapeable_character(' '));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\w\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 1, line: 1, column: 2 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Word, negated: false }));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\w\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 1, line: 1, column: 2 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Word, negated: false }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\s\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: false }));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { kind: ErrorKind::UnsupportedBackreference, .. })));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { kind: ErrorKind::EscapeUnrecognized, .. })));",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(Assertion { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: AssertionKind::WordBoundary }));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { kind: ErrorKind::EscapeUnexpectedEof, .. })));",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' }));",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: LiteralKind::Meta, c: 'v' }));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: _, negated: false, kind: _ }))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: _, kind: _, c: 'u' } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: _, kind: _, c: 'x' } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: _, kind: _, c: 'W' } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Assertion(Assertion { span: _, kind: AssertionKind::EndText } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: _, negated: false, kind: ClassPerlKind::Word } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Assertion(Assertion { span: _, kind: AssertionKind::NotWordBoundary } ))));",
          "    assert!(parser.bump().is_true());"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\s\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: false }));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { kind: ErrorKind::UnsupportedBackreference, .. })));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { kind: ErrorKind::EscapeUnrecognized, .. })));",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(Assertion { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: AssertionKind::WordBoundary }));",
          "    assert!(matches!(parser.parse_escape(), Err(Error { kind: ErrorKind::EscapeUnexpectedEof, .. })));",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' }));",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: LiteralKind::Meta, c: 'v' }));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Unicode(ClassUnicode { span: _, negated: false, kind: _ }))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: _, kind: _, c: 'u' } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: _, kind: _, c: 'x' } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(Literal { span: _, kind: _, c: 'W' } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Assertion(Assertion { span: _, kind: AssertionKind::EndText } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Perl(ClassPerl { span: _, negated: false, kind: ClassPerlKind::Word } ))));",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Assertion(Assertion { span: _, kind: AssertionKind::NotWordBoundary } ))));",
          "    assert!(parser.bump().is_true());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\S\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().is_ok(), true);",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(cls) if cls.kind == ClassPerlKind::Space && cls.negated == true));",
          "    assert_eq!(parser.parse_escape().unwrap().span.start.offset, 0);",
          "    assert_eq!(parser.parse_escape().unwrap().span.end.offset, 2);",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(cls) if cls.span.start.offset > 0));",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == 'S');",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\S\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().is_ok(), true);",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(_)));",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(cls) if cls.kind == ClassPerlKind::Space && cls.negated == true));",
          "    assert_eq!(parser.parse_escape().unwrap().span.start.offset, 0);",
          "    assert_eq!(parser.parse_escape().unwrap().span.end.offset, 2);",
          "    assert!(matches!(parser.parse_escape().unwrap(), Primitive::Perl(cls) if cls.span.start.offset > 0));",
          "    assert!(parser.bump());",
          "    assert!(parser.char() == 'S');",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\d\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Digit, negated: false }));",
          "    parser.parser.octal = false;",
          "    assert!(parser.parse_escape().is_err());",
          "    parser.pattern = \"\\\\D\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Digit, negated: true }));",
          "    parser.pattern = \"\\\\w\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Word, negated: false }));",
          "    parser.pattern = \"\\\\W\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Word, negated: true }));",
          "    parser.pattern = \"\\\\s\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: false }));",
          "    parser.pattern = \"\\\\S\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: true }));",
          "    parser.pattern = \"\\\\p{Letter}\";",
          "    assert!(parser.parse_escape().is_err());",
          "    parser.pattern = \"\\\\P{Letter}\";",
          "    assert!(parser.parse_escape().is_err());",
          "    parser.pattern = \"\\\\x61\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }), kind: LiteralKind::HexFixed(HexLiteralKind::X), c: 'a' }));",
          "    parser.pattern = \"\\\\u0061\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 6, line: 1, column: 7 }), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeShort), c: 'a' }));",
          "    parser.pattern = \"\\\\U00000061\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 8, line: 1, column: 9 }), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 'a' }));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\d\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Digit, negated: false }));",
          "    parser.parser.octal = false;",
          "    assert!(parser.parse_escape().is_err());",
          "    parser.pattern = \"\\\\D\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Digit, negated: true }));",
          "    parser.pattern = \"\\\\w\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Word, negated: false }));",
          "    parser.pattern = \"\\\\W\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Word, negated: true }));",
          "    parser.pattern = \"\\\\s\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: false }));",
          "    parser.pattern = \"\\\\S\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Perl(ClassPerl { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ClassPerlKind::Space, negated: true }));",
          "    parser.pattern = \"\\\\p{Letter}\";",
          "    assert!(parser.parse_escape().is_err());",
          "    parser.pattern = \"\\\\P{Letter}\";",
          "    assert!(parser.parse_escape().is_err());",
          "    parser.pattern = \"\\\\x61\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 4, line: 1, column: 5 }), kind: LiteralKind::HexFixed(HexLiteralKind::X), c: 'a' }));",
          "    parser.pattern = \"\\\\u0061\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 6, line: 1, column: 7 }), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeShort), c: 'a' }));",
          "    parser.pattern = \"\\\\U00000061\";",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 8, line: 1, column: 9 }), kind: LiteralKind::HexFixed(HexLiteralKind::UnicodeLong), c: 'a' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\U0001F600\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 10, line: 1, column: 11 } }, kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '😀' })));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\U0001F600\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 10, line: 1, column: 11 } }, kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '😀' })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\u1234\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(!('0'..='7').contains(&parser.char()));",
          "    assert!(!('8'..='9').contains(&parser.char()));",
          "    assert!(parser.char() == 'D' || parser.char() == 'W' || parser.char() == 'P' || parser.char() == 'p' || parser.char() == 'w' || parser.char() == 'x' || parser.char() == 's' || parser.char() == 'S' || parser.char() == 'd' || parser.char() == 'U' || parser.char() == 'u');",
          "    assert!(parser.char() == 'v');",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\u1234\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.char(), '\\\\');",
          "    assert!(parser.bump());",
          "    assert!(!('0'..='7').contains(&parser.char()));",
          "    assert!(!('8'..='9').contains(&parser.char()));",
          "    assert!(parser.char() == 'D' || parser.char() == 'W' || parser.char() == 'P' || parser.char() == 'p' || parser.char() == 'w' || parser.char() == 'x' || parser.char() == 's' || parser.char() == 'S' || parser.char() == 'd' || parser.char() == 'U' || parser.char() == 'u');",
          "    assert!(parser.char() == 'v');",
          "    assert!(!is_meta_character(parser.char()));",
          "    assert!(!is_escapeable_character(parser.char()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\x61\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().is_ok(), true);",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(lit)) if lit.kind == LiteralKind::HexFixed(HexLiteralKind::X) && lit.c == 'a'));",
          "    assert!(parser.parser.octal);",
          "    assert_eq!(parser.pattern, \"\\\\x61\");",
          "    assert!(parser.pos().offset > 0);"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\x61\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().is_ok(), true);",
          "    assert!(matches!(parser.parse_escape(), Ok(Primitive::Literal(lit)) if lit.kind == LiteralKind::HexFixed(HexLiteralKind::X) && lit.c == 'a'));",
          "    assert!(parser.parser.octal);",
          "    assert_eq!(parser.pattern, \"\\\\x61\");",
          "    assert!(parser.pos().offset > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\v\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
          "    c: '\\x0B',",
          "    })));"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\v\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
          "    c: '\\x0B',",
          "    })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\b{start}\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().is_ok(), true);",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(Assertion { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 8, line: 1, column: 9 }), kind: AssertionKind::WordBoundary }));",
          "    assert_eq!(parser.parser.octal, true);",
          "    assert_eq!(parser.pattern, \"\\\\b{start}\");",
          "    assert!(parser.bump());"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\b{start}\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().is_ok(), true);",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Assertion(Assertion { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 8, line: 1, column: 9 }), kind: AssertionKind::WordBoundary }));",
          "    assert_eq!(parser.parser.octal, true);",
          "    assert_eq!(parser.pattern, \"\\\\b{start}\");",
          "    assert!(parser.bump());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\a\",",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_escape().is_ok(), true);",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span { start: start_pos, end: end_pos }, kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' }));",
          "    assert_eq!(parser.pos(), expected_pos);",
          "    assert_eq!(parser.parser().octal, true);",
          "    assert_eq!(parser.char(), 'a');",
          "    assert_eq!(parser.bump(), true);",
          "    assert_eq!(parser.maybe_parse_special_word_boundary(start_pos).is_none(), true);",
          "    assert_eq!(parser.parser().scratch.borrow().is_empty(), true);"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { octal: true, .. },",
          "        pattern: \"\\\\a\",",
          "    };",
          "    parser.parse_escape();",
          "    assert_eq!(parser.parse_escape().is_ok(), true);",
          "    assert_eq!(parser.parse_escape().unwrap(), Primitive::Literal(ast::Literal { span: Span { start: start_pos, end: end_pos }, kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' }));",
          "    assert_eq!(parser.pos(), expected_pos);",
          "    assert_eq!(parser.parser().octal, true);",
          "    assert_eq!(parser.char(), 'a');",
          "    assert_eq!(parser.bump(), true);",
          "    assert_eq!(parser.maybe_parse_special_word_boundary(start_pos).is_none(), true);",
          "    assert_eq!(parser.parser().scratch.borrow().is_empty(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]