[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\a\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    parser_i.bump();",
          "    let c = 'a';",
          "    let result = parser_i.parse_escape();",
          "    let expected = Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c,",
          "    }));",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\a\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "    parser_i.bump();",
          "    let c = 'a';",
          "    let result = parser_i.parse_escape();",
          "    let expected = Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c,",
          "    }));",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\f\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_unwrap_result.unwrap(), Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c: '\\x0C',",
          "    }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\f\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "    assert_eq!(_unwrap_result.unwrap(), Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c: '\\x0C',",
          "    }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\t\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_?.is_ok(), true);",
          "    assert_eq!(_?.unwrap(), Primitive::Literal(ast::Literal { span: _, kind: LiteralKind::Superfluous, c: '\\t' }));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\t\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "    assert_eq!(_?.is_ok(), true);",
          "    assert_eq!(_?.unwrap(), Primitive::Literal(ast::Literal { span: _, kind: LiteralKind::Superfluous, c: '\\t' }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\n\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser_i.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c: '\\n',",
          "    })));"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\n\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "    assert_eq!(parser_i.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c: '\\n',",
          "    })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\r\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.bump(), true);",
          "    assert_eq!(self.char(), 'd');",
          "    assert_eq!(self.char(), 'D');",
          "    assert_eq!(self.char(), 'p');",
          "    assert_eq!(self.char(), 'P');",
          "    assert_eq!(self.char(), 'w');",
          "    assert_eq!(self.char(), 'W');",
          "    assert_eq!(self.char(), 'x');",
          "    assert_eq!(self.char(), 's');",
          "    assert_eq!(self.char(), 'S');",
          "    assert_eq!(self.char(), 'u');",
          "    assert_eq!(self.char(), 'U');",
          "    assert_eq!(is_meta_character(c), false);",
          "    assert_eq!(is_escapeable_character(c), true);",
          "    let result = parser_i.parse_escape();",
          "    let expected = Ok(Primitive::Literal(ast::Literal {",
          "    span: some_span_value,",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c: 'r',",
          "    }));",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\r\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "    assert_eq!(self.bump(), true);",
          "    assert_eq!(self.char(), 'd');",
          "    assert_eq!(self.char(), 'D');",
          "    assert_eq!(self.char(), 'p');",
          "    assert_eq!(self.char(), 'P');",
          "    assert_eq!(self.char(), 'w');",
          "    assert_eq!(self.char(), 'W');",
          "    assert_eq!(self.char(), 'x');",
          "    assert_eq!(self.char(), 's');",
          "    assert_eq!(self.char(), 'S');",
          "    assert_eq!(self.char(), 'u');",
          "    assert_eq!(self.char(), 'U');",
          "    assert_eq!(is_meta_character(c), false);",
          "    assert_eq!(is_escapeable_character(c), true);",
          "    let result = parser_i.parse_escape();",
          "    let expected = Ok(Primitive::Literal(ast::Literal {",
          "    span: some_span_value,",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c: 'r',",
          "    }));",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\v\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_,",
          "    Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(",
          "    Position { offset: 0, line: 1, column: 1 },",
          "    Position { offset: 2, line: 1, column: 3 },",
          "    ),",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c: '\\x0B',",
          "    }))",
          "    );"
        ],
        "code": [
          "{",
          "    let pattern = \"\\\\v\";",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 0,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        empty_min_range: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let parser_i = ParserI {",
          "        parser: &parser,",
          "        pattern,",
          "    };",
          "    let _ = parser_i.parse_escape();",
          "    assert_eq!(_,",
          "    Ok(Primitive::Literal(ast::Literal {",
          "    span: Span::new(",
          "    Position { offset: 0, line: 1, column: 1 },",
          "    Position { offset: 2, line: 1, column: 3 },",
          "    ),",
          "    kind: ast::LiteralKind::Superfluous,",
          "    c: '\\x0B',",
          "    }))",
          "    );",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]