[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let states = vec![State::Char { target: 0, ch: 'a' }];",
          "    let nfa = NFA {",
          "        pattern: String::from(\"a\"),",
          "        states,",
          "        start: 0,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![None],",
          "        memory_extra: 0,",
          "    };",
          "    let _state = nfa.state(0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_state, &State::Char { target: 0, ch: 'a' });",
          "    assert_eq!(nfa.state(0).as_usize(), 0);",
          "    assert!(std::panic::catch_unwind(|| nfa.state(1)).is_err());"
        ],
        "code": [
          "{",
          "    let states = vec![State::Char { target: 0, ch: 'a' }];",
          "    let nfa = NFA {",
          "        pattern: String::from(\"a\"),",
          "        states,",
          "        start: 0,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![None],",
          "        memory_extra: 0,",
          "    };",
          "    let _state = nfa.state(0);",
          "    assert_eq!(_state, &State::Char { target: 0, ch: 'a' });",
          "    assert_eq!(nfa.state(0).as_usize(), 0);",
          "    assert!(std::panic::catch_unwind(|| nfa.state(1)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let states = vec![",
          "        State::Char { target: 1, ch: 'a' },",
          "        State::Match,",
          "    ];",
          "    let nfa = NFA {",
          "        pattern: String::from(\"a\"),",
          "        states,",
          "        start: 0,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![None],",
          "        memory_extra: 0,",
          "    };",
          "    let _state = nfa.state(1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_state, &State::Match);",
          "    assert_eq!(nfa.state(0), &State::Char { target: 1, ch: 'a' });",
          "    assert_panics!(nfa.state(2));",
          "    assert_eq!(nfa.state(nfa.start()), &State::Char { target: 1, ch: 'a' });",
          "    assert!(std::panic::catch_unwind(|| { nfa.state(999); }).is_err());"
        ],
        "code": [
          "{",
          "    let states = vec![",
          "        State::Char { target: 1, ch: 'a' },",
          "        State::Match,",
          "    ];",
          "    let nfa = NFA {",
          "        pattern: String::from(\"a\"),",
          "        states,",
          "        start: 0,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![None],",
          "        memory_extra: 0,",
          "    };",
          "    let _state = nfa.state(1);",
          "    assert_eq!(_state, &State::Match);",
          "    assert_eq!(nfa.state(0), &State::Char { target: 1, ch: 'a' });",
          "    assert_panics!(nfa.state(2));",
          "    assert_eq!(nfa.state(nfa.start()), &State::Char { target: 1, ch: 'a' });",
          "    assert!(std::panic::catch_unwind(|| { nfa.state(999); }).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let states = vec![State::Char { target: 0, ch: 'a' }];",
          "    let nfa = NFA {",
          "        pattern: String::from(\"a\"),",
          "        states,",
          "        start: 0,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![None],",
          "        memory_extra: 0,",
          "    };",
          "    let _state = nfa.state(!0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nfa.state(0), &State::Char { target: 0, ch: 'a' });",
          "    assert!(std::panic::catch_unwind(|| nfa.state(1)).is_err());",
          "    assert!(std::panic::catch_unwind(|| nfa.state(!0)).is_err());"
        ],
        "code": [
          "{",
          "    let states = vec![State::Char { target: 0, ch: 'a' }];",
          "    let nfa = NFA {",
          "        pattern: String::from(\"a\"),",
          "        states,",
          "        start: 0,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![None],",
          "        memory_extra: 0,",
          "    };",
          "    let _state = nfa.state(!0);",
          "    assert_eq!(nfa.state(0), &State::Char { target: 0, ch: 'a' });",
          "    assert!(std::panic::catch_unwind(|| nfa.state(1)).is_err());",
          "    assert!(std::panic::catch_unwind(|| nfa.state(!0)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let states = vec![State::Char { target: 0, ch: 'a' }];",
          "    let nfa = NFA {",
          "        pattern: String::from(\"a\"),",
          "        states,",
          "        start: 0,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![None],",
          "        memory_extra: 0,",
          "    };",
          "    let _state = nfa.state(1);",
          "}"
        ],
        "oracle": [
          "    let nfa = NFA::new(config, String::from(\"a\"), &hir).unwrap();",
          "    let state = nfa.state(0);",
          "    let state = nfa.state(0xffff_ffff);",
          "    let state = nfa.state(2);",
          "    let states = vec![State::Capture { target: 1, slot: 0 }];",
          "    let nfa = NFA { states: states.clone(), ..nfa };",
          "    let _state = nfa.state(0);",
          "    let _state = nfa.state(1);",
          "    let _state = nfa.state(2);",
          "    let _state = nfa.state(10);"
        ],
        "code": [
          "{",
          "    let states = vec![State::Char { target: 0, ch: 'a' }];",
          "    let nfa = NFA {",
          "        pattern: String::from(\"a\"),",
          "        states,",
          "        start: 0,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![None],",
          "        memory_extra: 0,",
          "    };",
          "    let _state = nfa.state(1);",
          "    let nfa = NFA::new(config, String::from(\"a\"), &hir).unwrap();",
          "    let state = nfa.state(0);",
          "    let state = nfa.state(0xffff_ffff);",
          "    let state = nfa.state(2);",
          "    let states = vec![State::Capture { target: 1, slot: 0 }];",
          "    let nfa = NFA { states: states.clone(), ..nfa };",
          "    let _state = nfa.state(0);",
          "    let _state = nfa.state(1);",
          "    let _state = nfa.state(2);",
          "    let _state = nfa.state(10);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]