[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let o = Utf8Range { start: 5, end: 5 };",
          "    let n = Utf8Range { start: 5, end: 8 };",
          "    let result = Split::new(o, n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(5..=5), SplitRange::New(6..=8)));"
        ],
        "code": [
          "{",
          "    let o = Utf8Range { start: 5, end: 5 };",
          "    let n = Utf8Range { start: 5, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(5..=5), SplitRange::New(6..=8)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let o = Utf8Range { start: 8, end: 8 };",
          "    let n = Utf8Range { start: 5, end: 8 };",
          "    let result = Split::new(o, n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(8..=8), SplitRange::New(9..=8)));",
          "    assert_eq!(result.as_ref().unwrap().len, 2);",
          "    assert_eq!(result.as_ref().unwrap().partitions[0], SplitRange::Both(8..=8));",
          "    assert_eq!(result.as_ref().unwrap().partitions[1], SplitRange::New(9..=8));"
        ],
        "code": [
          "{",
          "    let o = Utf8Range { start: 8, end: 8 };",
          "    let n = Utf8Range { start: 5, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(8..=8), SplitRange::New(9..=8)));",
          "    assert_eq!(result.as_ref().unwrap().len, 2);",
          "    assert_eq!(result.as_ref().unwrap().partitions[0], SplitRange::Both(8..=8));",
          "    assert_eq!(result.as_ref().unwrap().partitions[1], SplitRange::New(9..=8));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let o = Utf8Range { start: 5, end: 5 };",
          "    let n = Utf8Range { start: 8, end: 8 };",
          "    let result = Split::new(o, n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);  // Precondition: b < x is false (b == 5, x == 8)",
          "    ",
          "    let o = Utf8Range { start: 10, end: 10 };",
          "    let n = Utf8Range { start: 10, end: 15 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts1(SplitRange::Both(10..=10))));  // Precondition: a == x, b == y",
          "    ",
          "    let o = Utf8Range { start: 10, end: 15 };",
          "    let n = Utf8Range { start: 10, end: 15 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts1(SplitRange::Both(10..=15))));  // Precondition: a == x, b == y",
          "    ",
          "    let o = Utf8Range { start: 5, end: 10 };",
          "    let n = Utf8Range { start: 10, end: 15 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(10..=10), SplitRange::New(11..=15))));  // Precondition: b == y",
          "    ",
          "    let o = Utf8Range { start: 7, end: 12 };",
          "    let n = Utf8Range { start: 10, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::New(8..=8), SplitRange::Both(10..=12))));  // Precondition: x == a",
          "    ",
          "    let o = Utf8Range { start: 5, end: 10 };",
          "    let n = Utf8Range { start: 6, end: 15 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(6..=6), SplitRange::Both(7..=10), SplitRange::New(11..=15))));  // Precondition: a > x",
          "    ",
          "    let o = Utf8Range { start: 5, end: 15 };",
          "    let n = Utf8Range { start: 7, end: 10 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=5), SplitRange::Both(6..=10), SplitRange::Old(11..=15))));  // Precondition: x > a",
          "    ",
          "    let o = Utf8Range { start: 5, end: 10 };",
          "    let n = Utf8Range { start: 10, end: 11 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=9), SplitRange::Both(10..=10), SplitRange::New(11..=11))));  // Precondition: b > x",
          "    ",
          "    let o = Utf8Range { start: 5, end: 10 };",
          "    let n = Utf8Range { start: 6, end: 9 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(5..=5), SplitRange::Both(6..=9), SplitRange::Old(10..=10))));  // Precondition: y < b"
        ],
        "code": [
          "{",
          "    let o = Utf8Range { start: 5, end: 5 };",
          "    let n = Utf8Range { start: 8, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, None);  // Precondition: b < x is false (b == 5, x == 8)",
          "    ",
          "    let o = Utf8Range { start: 10, end: 10 };",
          "    let n = Utf8Range { start: 10, end: 15 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts1(SplitRange::Both(10..=10))));  // Precondition: a == x, b == y",
          "    ",
          "    let o = Utf8Range { start: 10, end: 15 };",
          "    let n = Utf8Range { start: 10, end: 15 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts1(SplitRange::Both(10..=15))));  // Precondition: a == x, b == y",
          "    ",
          "    let o = Utf8Range { start: 5, end: 10 };",
          "    let n = Utf8Range { start: 10, end: 15 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(10..=10), SplitRange::New(11..=15))));  // Precondition: b == y",
          "    ",
          "    let o = Utf8Range { start: 7, end: 12 };",
          "    let n = Utf8Range { start: 10, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::New(8..=8), SplitRange::Both(10..=12))));  // Precondition: x == a",
          "    ",
          "    let o = Utf8Range { start: 5, end: 10 };",
          "    let n = Utf8Range { start: 6, end: 15 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(6..=6), SplitRange::Both(7..=10), SplitRange::New(11..=15))));  // Precondition: a > x",
          "    ",
          "    let o = Utf8Range { start: 5, end: 15 };",
          "    let n = Utf8Range { start: 7, end: 10 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=5), SplitRange::Both(6..=10), SplitRange::Old(11..=15))));  // Precondition: x > a",
          "    ",
          "    let o = Utf8Range { start: 5, end: 10 };",
          "    let n = Utf8Range { start: 10, end: 11 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=9), SplitRange::Both(10..=10), SplitRange::New(11..=11))));  // Precondition: b > x",
          "    ",
          "    let o = Utf8Range { start: 5, end: 10 };",
          "    let n = Utf8Range { start: 6, end: 9 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(5..=5), SplitRange::Both(6..=9), SplitRange::Old(10..=10))));  // Precondition: y < b",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let o = Utf8Range { start: 5, end: 7 };",
          "    let n = Utf8Range { start: 8, end: 8 };",
          "    let result = Split::new(o, n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let o = Utf8Range { start: 5, end: 7 };",
          "    let n = Utf8Range { start: 8, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let o = Utf8Range { start: 5, end: 7 };",
          "    let n = Utf8Range { start: 7, end: 8 };",
          "    let result = Split::new(o, n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);  // b < x is false, with bound b == x",
          "    assert_eq!(result, None);  // y < a is false, with bound y == a",
          "    assert_eq!(result, Some(Split::parts1(SplitRange::Both(5..=7))));  // a == x is true",
          "    assert_eq!(result, None);  // b == y is false",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(5..=7), SplitRange::New(8..=8))));  // a == x is true, b < y is false, with bound b == y",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::New(7..=7), SplitRange::Both(5..=7))));  // b == y is true, a > x is false, with bound a == x",
          "    assert_eq!(result, None);  // x == a is true",
          "    assert_eq!(result, None);  // y < b is false, with bound y == b",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(5..=7), SplitRange::New(8..=8))));  // y == b is true, x > a is false, with bound x == a",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(5..=6), SplitRange::Both(7..=7), SplitRange::New(8..=8))));  // a > x is true, b < y is false, with bound b == y",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=6), SplitRange::Both(7..=7), SplitRange::Old(8..=8))));  // x > a is true, y < b is false, with bound y == b",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=7), SplitRange::Both(7..=7), SplitRange::New(8..=8))));  // b == x is true, a < y is false, with bound a == y",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(7..=7), SplitRange::Both(7..=7), SplitRange::Old(8..=8))));  // y == a is true, x < b is false, with bound x == b",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=6), SplitRange::Both(7..=7), SplitRange::New(8..=8))));  // b > x is true, b < y is false, with bound b == y",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(7..=7), SplitRange::Both(7..=7), SplitRange::Old(8..=8))));  // y > a is true, y < b is false, with bound y == b"
        ],
        "code": [
          "{",
          "    let o = Utf8Range { start: 5, end: 7 };",
          "    let n = Utf8Range { start: 7, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, None);  // b < x is false, with bound b == x",
          "    assert_eq!(result, None);  // y < a is false, with bound y == a",
          "    assert_eq!(result, Some(Split::parts1(SplitRange::Both(5..=7))));  // a == x is true",
          "    assert_eq!(result, None);  // b == y is false",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(5..=7), SplitRange::New(8..=8))));  // a == x is true, b < y is false, with bound b == y",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::New(7..=7), SplitRange::Both(5..=7))));  // b == y is true, a > x is false, with bound a == x",
          "    assert_eq!(result, None);  // x == a is true",
          "    assert_eq!(result, None);  // y < b is false, with bound y == b",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(5..=7), SplitRange::New(8..=8))));  // y == b is true, x > a is false, with bound x == a",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(5..=6), SplitRange::Both(7..=7), SplitRange::New(8..=8))));  // a > x is true, b < y is false, with bound b == y",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=6), SplitRange::Both(7..=7), SplitRange::Old(8..=8))));  // x > a is true, y < b is false, with bound y == b",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=7), SplitRange::Both(7..=7), SplitRange::New(8..=8))));  // b == x is true, a < y is false, with bound a == y",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(7..=7), SplitRange::Both(7..=7), SplitRange::Old(8..=8))));  // y == a is true, x < b is false, with bound x == b",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::Old(5..=6), SplitRange::Both(7..=7), SplitRange::New(8..=8))));  // b > x is true, b < y is false, with bound b == y",
          "    assert_eq!(result, Some(Split::parts3(SplitRange::New(7..=7), SplitRange::Both(7..=7), SplitRange::Old(8..=8))));  // y > a is true, y < b is false, with bound y == b",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let o = Utf8Range { start: 5, end: 8 };",
          "    let n = Utf8Range { start: 8, end: 8 };",
          "    let result = Split::new(o, n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let o = Utf8Range { start: 5, end: 8 };",
          "    let n = Utf8Range { start: 8, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let o = Utf8Range { start: 8, end: 8 };",
          "    let n = Utf8Range { start: 5, end: 8 };",
          "    let result = Split::new(o, n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(8..=8), SplitRange::New(9..=8)));",
          "    assert_eq!(result.as_ref().unwrap().len, 2);",
          "    assert_eq!(result.as_ref().unwrap().partitions[0], SplitRange::Both(8..=8));",
          "    assert_eq!(result.as_ref().unwrap().partitions[1], SplitRange::New(9..=8));",
          "    assert!(result.is_some());",
          "    assert!(result.unwrap().partitions.iter().all(|r| matches!(r, SplitRange::Both(_) | SplitRange::New(_))));"
        ],
        "code": [
          "{",
          "    let o = Utf8Range { start: 8, end: 8 };",
          "    let n = Utf8Range { start: 5, end: 8 };",
          "    let result = Split::new(o, n);",
          "    assert_eq!(result, Some(Split::parts2(SplitRange::Both(8..=8), SplitRange::New(9..=8)));",
          "    assert_eq!(result.as_ref().unwrap().len, 2);",
          "    assert_eq!(result.as_ref().unwrap().partitions[0], SplitRange::Both(8..=8));",
          "    assert_eq!(result.as_ref().unwrap().partitions[1], SplitRange::New(9..=8));",
          "    assert!(result.is_some());",
          "    assert!(result.unwrap().partitions.iter().all(|r| matches!(r, SplitRange::Both(_) | SplitRange::New(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]