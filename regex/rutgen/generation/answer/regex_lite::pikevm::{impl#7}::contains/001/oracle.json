[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    let id = StateID::new(1); // Assume StateID can be created this way.",
          "    sparse_set.insert(id.clone());",
          "    assert!(sparse_set.contains(id));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.len(), 1);",
          "    assert!(!sparse_set.is_empty());",
          "    assert!(sparse_set.contains(id));",
          "    assert!(sparse_set.contains(StateID::new(1)));",
          "    assert!(!sparse_set.contains(StateID::new(2)));"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    let id = StateID::new(1); // Assume StateID can be created this way.",
          "    sparse_set.insert(id.clone());",
          "    assert!(sparse_set.contains(id));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    assert!(!sparse_set.is_empty());",
          "    assert!(sparse_set.contains(id));",
          "    assert!(sparse_set.contains(StateID::new(1)));",
          "    assert!(!sparse_set.contains(StateID::new(2)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(3);",
          "    let id = StateID::new(2); // This should be within the valid range.",
          "    sparse_set.insert(id.clone());",
          "    assert!(sparse_set.contains(id));",
          "}"
        ],
        "oracle": [
          "    assert!(sparse_set.len() > 0);",
          "    assert!(sparse_set.sparse[id.as_usize()] < sparse_set.len());",
          "    assert_eq!(sparse_set.dense[sparse_set.sparse[id.as_usize()].as_usize()], id);",
          "    assert!(sparse_set.contains(id));"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(3);",
          "    let id = StateID::new(2); // This should be within the valid range.",
          "    sparse_set.insert(id.clone());",
          "    assert!(sparse_set.contains(id));",
          "    assert!(sparse_set.len() > 0);",
          "    assert!(sparse_set.sparse[id.as_usize()] < sparse_set.len());",
          "    assert_eq!(sparse_set.dense[sparse_set.sparse[id.as_usize()].as_usize()], id);",
          "    assert!(sparse_set.contains(id));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse_set = SparseSet::new(0);",
          "    let id = StateID::new(0);",
          "    assert!(!sparse_set.contains(id)); // Should return false since set is empty.",
          "}"
        ],
        "oracle": [
          "    assert!(sparse_set.len() == 0); // Ensure length is 0 for an empty set.",
          "    assert!(!sparse_set.contains(StateID::new(0))); // Verify contains returns false for non-existent id."
        ],
        "code": [
          "{",
          "    let sparse_set = SparseSet::new(0);",
          "    let id = StateID::new(0);",
          "    assert!(!sparse_set.contains(id)); // Should return false since set is empty.",
          "    assert!(sparse_set.len() == 0); // Ensure length is 0 for an empty set.",
          "    assert!(!sparse_set.contains(StateID::new(0))); // Verify contains returns false for non-existent id.",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    let id1 = StateID::new(1);",
          "    let id2 = StateID::new(3);",
          "    sparse_set.insert(id1.clone());",
          "    sparse_set.insert(id2.clone());",
          "    assert!(sparse_set.contains(id1));",
          "    assert!(sparse_set.contains(id2));",
          "}"
        ],
        "oracle": [
          "    assert!(sparse_set.contains(StateID::new(1)));",
          "    assert!(sparse_set.contains(StateID::new(3)));",
          "    assert_eq!(sparse_set.len(), 2);",
          "    assert!(!sparse_set.is_empty());",
          "    sparse_set.clear();",
          "    assert!(sparse_set.is_empty());",
          "    sparse_set.insert(StateID::new(0));",
          "    assert!(sparse_set.contains(StateID::new(0)));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    sparse_set.resize(10);",
          "    assert_eq!(sparse_set.capacity(), 10);"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    let id1 = StateID::new(1);",
          "    let id2 = StateID::new(3);",
          "    sparse_set.insert(id1.clone());",
          "    sparse_set.insert(id2.clone());",
          "    assert!(sparse_set.contains(id1));",
          "    assert!(sparse_set.contains(id2));",
          "    assert!(sparse_set.contains(StateID::new(1)));",
          "    assert!(sparse_set.contains(StateID::new(3)));",
          "    assert_eq!(sparse_set.len(), 2);",
          "    assert!(!sparse_set.is_empty());",
          "    sparse_set.clear();",
          "    assert!(sparse_set.is_empty());",
          "    sparse_set.insert(StateID::new(0));",
          "    assert!(sparse_set.contains(StateID::new(0)));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    sparse_set.resize(10);",
          "    assert_eq!(sparse_set.capacity(), 10);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    let id1 = StateID::new(1);",
          "    let id2 = StateID::new(4); // id that will not be inserted",
          "    sparse_set.insert(id1.clone());",
          "    assert!(!sparse_set.contains(id2)); // Should return false for non-existent ID.",
          "}"
        ],
        "oracle": [
          "    assert!(sparse_set.contains(id1)); // Should return true for existing ID.",
          "    assert_eq!(sparse_set.len(), 1); // Length should be 1 after insertion.",
          "    assert!(!sparse_set.is_empty()); // Set should not be empty after insertion.",
          "    sparse_set.insert(StateID::new(2)); // Insert another ID.",
          "    assert!(sparse_set.contains(StateID::new(2))); // Should return true for newly inserted ID.",
          "    assert_eq!(sparse_set.len(), 2); // Length should be 2 after second insertion."
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    let id1 = StateID::new(1);",
          "    let id2 = StateID::new(4); // id that will not be inserted",
          "    sparse_set.insert(id1.clone());",
          "    assert!(!sparse_set.contains(id2)); // Should return false for non-existent ID.",
          "    assert!(sparse_set.contains(id1)); // Should return true for existing ID.",
          "    assert_eq!(sparse_set.len(), 1); // Length should be 1 after insertion.",
          "    assert!(!sparse_set.is_empty()); // Set should not be empty after insertion.",
          "    sparse_set.insert(StateID::new(2)); // Insert another ID.",
          "    assert!(sparse_set.contains(StateID::new(2))); // Should return true for newly inserted ID.",
          "    assert_eq!(sparse_set.len(), 2); // Length should be 2 after second insertion.",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]