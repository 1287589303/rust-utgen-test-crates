[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        is_start_anchored: false,",
          "        is_match_empty: true,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: true, static_explicit_captures_len: None }, 1), Ok(()));"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        is_start_anchored: false,",
          "        is_match_empty: true,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: true, static_explicit_captures_len: None }, 1), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, 1), Ok(()));"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, 1), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Class(vec!['a', 'b']),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Capture(Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Class(vec!['c']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Class(vec!['c']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Look(hir::Look::Positive(Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }))), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 0); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Capture(Box::new(Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Capture(Box::new(Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec![]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    let hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec!['a']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 0); assert_eq!(result, Err(Error::new(ERR_TOO_MUCH_NESTING)));"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Class(vec!['a', 'b']),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "    let hir = Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Capture(Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Class(vec!['c']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Class(vec!['c']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Look(hir::Look::Positive(Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }))), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 0); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Capture(Box::new(Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None })), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Capture(Box::new(Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec!['a', 'b']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Ok(()));",
          "    let hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec![]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 1); assert_eq!(result, Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    let hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(Hir { kind: HirKind::Class(vec!['a']), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; let result = check_hir_nesting(&hir, 0); assert_eq!(result, Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Look(vec![Hir::new(HirKind::Char('a'))]), // Assuming a dummy method to create Hir",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "}"
        ],
        "oracle": [
          "    assert!(check_hir_nesting(&hir, 1).is_ok());",
          "    assert_eq!(check_hir_nesting(&hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&hir, 2), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Repetition(Box::new(hir.clone())), ..hir }, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Concat(vec![hir.clone(), hir.clone()]), ..hir }, 5), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Capture(Box::new(hir.clone())), ..hir }, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Alternation(vec![hir.clone(), hir.clone()]), ..hir }, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Empty, ..hir }, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Char('a'), ..hir }, 1), Ok(()));"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Look(vec![Hir::new(HirKind::Char('a'))]), // Assuming a dummy method to create Hir",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "    assert!(check_hir_nesting(&hir, 1).is_ok());",
          "    assert_eq!(check_hir_nesting(&hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&hir, 2), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Repetition(Box::new(hir.clone())), ..hir }, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Concat(vec![hir.clone(), hir.clone()]), ..hir }, 5), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Capture(Box::new(hir.clone())), ..hir }, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Alternation(vec![hir.clone(), hir.clone()]), ..hir }, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Empty, ..hir }, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Char('a'), ..hir }, 1), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(hir::Repetition { sub: Box::new(sub_hir), min: 1, max: None }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_hir_nesting(&hir, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&hir, 2), Ok(()));",
          "    let deep_hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir.clone()), min: 2, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(check_hir_nesting(&deep_hir, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    let empty_hir = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(check_hir_nesting(&empty_hir, 1), Ok(()));"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(hir::Repetition { sub: Box::new(sub_hir), min: 1, max: None }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "    assert_eq!(check_hir_nesting(&hir, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&hir, 2), Ok(()));",
          "    let deep_hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir.clone()), min: 2, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(check_hir_nesting(&deep_hir, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    let empty_hir = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(check_hir_nesting(&empty_hir, 1), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Capture(hir::Capture { name: None, sub: Box::new(sub_hir) }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_hir_nesting(&hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&hir, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&hir, 2), Ok(()));",
          "    assert_eq!(check_hir_nesting(&hir, u32::MAX), Ok(()));",
          "    let deep_hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir.clone()), ..Default::default() }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(check_hir_nesting(&deep_hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&deep_hir, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&deep_hir, 2), Ok(()));"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Capture(hir::Capture { name: None, sub: Box::new(sub_hir) }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "    assert_eq!(check_hir_nesting(&hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&hir, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&hir, 2), Ok(()));",
          "    assert_eq!(check_hir_nesting(&hir, u32::MAX), Ok(()));",
          "    let deep_hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir.clone()), ..Default::default() }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(check_hir_nesting(&deep_hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&deep_hir, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&deep_hir, 2), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir1 = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let sub_hir2 = Hir {",
          "        kind: HirKind::Char('b'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Concat(vec![Box::new(sub_hir1), Box::new(sub_hir2)]),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_hir_nesting(&hir, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&hir, 2), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir), .. }), .. }, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Capture(hir::Capture { sub: Box::new(hir), .. }), .. }, 2), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Empty, .. }, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Class(vec![Box::new(sub_hir1)]), .. }, 1), Ok(()));"
        ],
        "code": [
          "{",
          "    let sub_hir1 = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let sub_hir2 = Hir {",
          "        kind: HirKind::Char('b'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Concat(vec![Box::new(sub_hir1), Box::new(sub_hir2)]),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "    assert_eq!(check_hir_nesting(&hir, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&hir, 2), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir), .. }), .. }, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Capture(hir::Capture { sub: Box::new(hir), .. }), .. }, 2), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Empty, .. }, 1), Ok(()));",
          "    assert_eq!(check_hir_nesting(&Hir { kind: HirKind::Class(vec![Box::new(sub_hir1)]), .. }, 1), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir1 = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let sub_hir2 = Hir {",
          "        kind: HirKind::Char('b'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![Box::new(sub_hir1), Box::new(sub_hir2)]),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "}"
        ],
        "oracle": [
          "    check_hir_nesting(&hir, 1).is_ok();",
          "    assert_eq!(check_hir_nesting(&hir, 0).unwrap_err().msg, ERR_TOO_MUCH_NESTING);",
          "    let nested_hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(check_hir_nesting(&nested_hir, 1).unwrap_err().msg, ERR_TOO_MUCH_NESTING);",
          "    let deep_hir = Hir { kind: HirKind::Concat(vec![Box::new(nested_hir.clone()), Box::new(nested_hir.clone())]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    check_hir_nesting(&deep_hir, 2).is_ok();",
          "    assert_eq!(check_hir_nesting(&deep_hir, 1).unwrap_err().msg, ERR_TOO_MUCH_NESTING);",
          "    let empty_hir = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    check_hir_nesting(&empty_hir, 1).is_ok();"
        ],
        "code": [
          "{",
          "    let sub_hir1 = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let sub_hir2 = Hir {",
          "        kind: HirKind::Char('b'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![Box::new(sub_hir1), Box::new(sub_hir2)]),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 1);",
          "    check_hir_nesting(&hir, 1).is_ok();",
          "    assert_eq!(check_hir_nesting(&hir, 0).unwrap_err().msg, ERR_TOO_MUCH_NESTING);",
          "    let nested_hir = Hir { kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir), min: 1, max: None }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(check_hir_nesting(&nested_hir, 1).unwrap_err().msg, ERR_TOO_MUCH_NESTING);",
          "    let deep_hir = Hir { kind: HirKind::Concat(vec![Box::new(nested_hir.clone()), Box::new(nested_hir.clone())]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    check_hir_nesting(&deep_hir, 2).is_ok();",
          "    assert_eq!(check_hir_nesting(&deep_hir, 1).unwrap_err().msg, ERR_TOO_MUCH_NESTING);",
          "    let empty_hir = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    check_hir_nesting(&empty_hir, 1).is_ok();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_hir = Hir {",
          "        kind: HirKind::Repetition(hir::Repetition { sub: Box::new(HirKind::Empty.into()), min: 1, max: None }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Capture(hir::Capture { name: None, sub: Box::new(sub_hir) }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_hir_nesting(&hir, 0), Ok(()));",
          "    let mut depth_limit = 0;",
          "    assert_eq!(check_hir_nesting(&hir, depth_limit), Ok(()));",
          "    depth_limit = 1;",
          "    assert_eq!(check_hir_nesting(&hir, depth_limit), Ok(()));",
          "    depth_limit = 2;",
          "    assert_eq!(check_hir_nesting(&hir, depth_limit), Ok(()));",
          "    let deep_hir = Hir {",
          "    kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir), min: 1, max: None }),",
          "    is_start_anchored: false,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: None,",
          "    };",
          "    assert_eq!(check_hir_nesting(&deep_hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&deep_hir, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));"
        ],
        "code": [
          "{",
          "    let sub_hir = Hir {",
          "        kind: HirKind::Repetition(hir::Repetition { sub: Box::new(HirKind::Empty.into()), min: 1, max: None }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Capture(hir::Capture { name: None, sub: Box::new(sub_hir) }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = check_hir_nesting(&hir, 0);",
          "    assert_eq!(check_hir_nesting(&hir, 0), Ok(()));",
          "    let mut depth_limit = 0;",
          "    assert_eq!(check_hir_nesting(&hir, depth_limit), Ok(()));",
          "    depth_limit = 1;",
          "    assert_eq!(check_hir_nesting(&hir, depth_limit), Ok(()));",
          "    depth_limit = 2;",
          "    assert_eq!(check_hir_nesting(&hir, depth_limit), Ok(()));",
          "    let deep_hir = Hir {",
          "    kind: HirKind::Repetition(hir::Repetition { sub: Box::new(hir), min: 1, max: None }),",
          "    is_start_anchored: false,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: None,",
          "    };",
          "    assert_eq!(check_hir_nesting(&deep_hir, 0), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "    assert_eq!(check_hir_nesting(&deep_hir, 1), Err(Error::new(ERR_TOO_MUCH_NESTING)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]