[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    let accel = Accel::new();",
          "    accels.add(accel);",
          "}"
        ],
        "oracle": [
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    let accel = Accel::new();",
          "    assert_eq!(accels.len(), 0);",
          "    accels.add(accel);",
          "    assert_eq!(accels.len(), 1);",
          "    assert!(accels.accels.len() <= ACCEL_CAP);",
          "    assert!(accels.accels.len() < AccelTy::MAX as usize);"
        ],
        "code": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    let accel = Accel::new();",
          "    accels.add(accel);",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    let accel = Accel::new();",
          "    assert_eq!(accels.len(), 0);",
          "    accels.add(accel);",
          "    assert_eq!(accels.len(), 1);",
          "    assert!(accels.accels.len() <= ACCEL_CAP);",
          "    assert!(accels.accels.len() < AccelTy::MAX as usize);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    let mut accel = Accel::new();",
          "    for i in 0..ACCEL_CAP {",
          "        accel.bytes[i] = 0;",
          "    }",
          "    accels.add(accel);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(accels.len(), 1);",
          "    assert!(!accels.is_empty());",
          "    assert_eq!(accels.accels.len(), 4);",
          "    let expected_accel_tys = [0, 0];",
          "    assert_eq!(accels.accels.as_slice()[0..2], expected_accel_tys);",
          "    assert!(std::panic::catch_unwind(|| { accels.add(accel); }).is_err());",
          "    assert_eq!(accels.len(), 1);"
        ],
        "code": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    let mut accel = Accel::new();",
          "    for i in 0..ACCEL_CAP {",
          "        accel.bytes[i] = 0;",
          "    }",
          "    accels.add(accel);",
          "    assert_eq!(accels.len(), 1);",
          "    assert!(!accels.is_empty());",
          "    assert_eq!(accels.accels.len(), 4);",
          "    let expected_accel_tys = [0, 0];",
          "    assert_eq!(accels.accels.as_slice()[0..2], expected_accel_tys);",
          "    assert!(std::panic::catch_unwind(|| { accels.add(accel); }).is_err());",
          "    assert_eq!(accels.len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    let mut accel = Accel::new();",
          "    for i in 0..ACCEL_CAP {",
          "        accel.bytes[i] = u8::MAX;",
          "    }",
          "    accels.add(accel);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(accels.len(), 1);",
          "    assert!(accels.accels.len() <= ACCEL_CAP);",
          "    assert_eq!(accels.accels[0], AccelTy::from_ne_bytes([u8::MAX, u8::MAX, u8::MAX, u8::MAX]));",
          "    assert!(accels.accels[0] <= AccelTy::MAX);",
          "    assert!(accel.is_empty() == false);",
          "    assert_eq!(accel.len(), ACCEL_CAP);",
          "    assert!(accel.contains(u8::MAX));",
          "    assert!(!accel.contains(0));"
        ],
        "code": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    let mut accel = Accel::new();",
          "    for i in 0..ACCEL_CAP {",
          "        accel.bytes[i] = u8::MAX;",
          "    }",
          "    accels.add(accel);",
          "    assert_eq!(accels.len(), 1);",
          "    assert!(accels.accels.len() <= ACCEL_CAP);",
          "    assert_eq!(accels.accels[0], AccelTy::from_ne_bytes([u8::MAX, u8::MAX, u8::MAX, u8::MAX]));",
          "    assert!(accels.accels[0] <= AccelTy::MAX);",
          "    assert!(accel.is_empty() == false);",
          "    assert_eq!(accel.len(), ACCEL_CAP);",
          "    assert!(accel.contains(u8::MAX));",
          "    assert!(!accel.contains(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    for i in 0..5 {",
          "        let mut accel = Accel::new();",
          "        for j in 0..ACCEL_CAP {",
          "            accel.bytes[j] = (i * 10 + j) as u8; // Different byte values for variety",
          "        }",
          "        accels.add(accel);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(accels.len(), 5);",
          "    assert_eq!(accels.accels.len(), 5 * 2);",
          "    assert_eq!(accels.accels[0], (0 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[1], (0 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[2], (0 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[3], (0 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[4], (0 * 10 + 4) as AccelTy);",
          "    assert_eq!(accels.accels[5], (1 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[6], (1 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[7], (1 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[8], (1 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[9], (1 * 10 + 4) as AccelTy);",
          "    assert_eq!(accels.accels[10], (2 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[11], (2 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[12], (2 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[13], (2 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[14], (2 * 10 + 4) as AccelTy);",
          "    assert_eq!(accels.accels[15], (3 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[16], (3 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[17], (3 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[18], (3 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[19], (3 * 10 + 4) as AccelTy);",
          "    assert_eq!(accels.accels[20], (4 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[21], (4 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[22], (4 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[23], (4 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[24], (4 * 10 + 4) as AccelTy);"
        ],
        "code": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    for i in 0..5 {",
          "        let mut accel = Accel::new();",
          "        for j in 0..ACCEL_CAP {",
          "            accel.bytes[j] = (i * 10 + j) as u8; // Different byte values for variety",
          "        }",
          "        accels.add(accel);",
          "    }",
          "    assert_eq!(accels.len(), 5);",
          "    assert_eq!(accels.accels.len(), 5 * 2);",
          "    assert_eq!(accels.accels[0], (0 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[1], (0 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[2], (0 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[3], (0 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[4], (0 * 10 + 4) as AccelTy);",
          "    assert_eq!(accels.accels[5], (1 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[6], (1 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[7], (1 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[8], (1 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[9], (1 * 10 + 4) as AccelTy);",
          "    assert_eq!(accels.accels[10], (2 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[11], (2 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[12], (2 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[13], (2 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[14], (2 * 10 + 4) as AccelTy);",
          "    assert_eq!(accels.accels[15], (3 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[16], (3 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[17], (3 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[18], (3 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[19], (3 * 10 + 4) as AccelTy);",
          "    assert_eq!(accels.accels[20], (4 * 10 + 0) as AccelTy);",
          "    assert_eq!(accels.accels[21], (4 * 10 + 1) as AccelTy);",
          "    assert_eq!(accels.accels[22], (4 * 10 + 2) as AccelTy);",
          "    assert_eq!(accels.accels[23], (4 * 10 + 3) as AccelTy);",
          "    assert_eq!(accels.accels[24], (4 * 10 + 4) as AccelTy);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    for _ in 0..(AccelTy::MAX as usize) {",
          "        let accel = Accel::new();",
          "        accels.add(accel);",
          "    }",
          "    let overflow_accel = Accel::new();",
          "    accels.add(overflow_accel); // This should panic",
          "}"
        ],
        "oracle": [
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    for _ in 0..(AccelTy::MAX as usize) {",
          "    let accel = Accel::new();",
          "    accels.add(accel);",
          "    }",
          "    let overflow_accel = Accel::new();",
          "    accels.add(overflow_accel); // This should panic"
        ],
        "code": [
          "{",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    for _ in 0..(AccelTy::MAX as usize) {",
          "        let accel = Accel::new();",
          "        accels.add(accel);",
          "    }",
          "    let overflow_accel = Accel::new();",
          "    accels.add(overflow_accel); // This should panic",
          "    let mut accels = Accels::<Vec<AccelTy>>::empty();",
          "    for _ in 0..(AccelTy::MAX as usize) {",
          "    let accel = Accel::new();",
          "    accels.add(accel);",
          "    }",
          "    let overflow_accel = Accel::new();",
          "    accels.add(overflow_accel); // This should panic",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]