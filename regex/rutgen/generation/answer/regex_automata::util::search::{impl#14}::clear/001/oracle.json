[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut pattern_set = PatternSet {",
          "        len: 2,",
          "        which: alloc::vec![true, false].into_boxed_slice(),",
          "    };",
          "    ",
          "    pattern_set.clear();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(pattern_set.len(), 0);",
          "    assert_eq!(pattern_set.which[0], false);",
          "    assert_eq!(pattern_set.which[1], false);",
          "    assert!(pattern_set.is_empty());",
          "    assert!(!pattern_set.is_full());"
        ],
        "code": [
          "{",
          "    let mut pattern_set = PatternSet {",
          "        len: 2,",
          "        which: alloc::vec![true, false].into_boxed_slice(),",
          "    };",
          "    ",
          "    pattern_set.clear();",
          "    assert_eq!(pattern_set.len(), 0);",
          "    assert_eq!(pattern_set.which[0], false);",
          "    assert_eq!(pattern_set.which[1], false);",
          "    assert!(pattern_set.is_empty());",
          "    assert!(!pattern_set.is_full());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut pattern_set = PatternSet {",
          "        len: 1,",
          "        which: alloc::vec![true, false].into_boxed_slice(),",
          "    };",
          "    ",
          "    pattern_set.clear();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(pattern_set.len, 0);",
          "    assert_eq!(pattern_set.which[0], false);",
          "    assert_eq!(pattern_set.which[1], false);",
          "    ",
          "    let mut pattern_set_full = PatternSet {",
          "    len: 2,",
          "    which: alloc::vec![true, true].into_boxed_slice(),",
          "    };",
          "    ",
          "    pattern_set_full.clear();",
          "    assert_eq!(pattern_set_full.len, 0);",
          "    assert_eq!(pattern_set_full.which[0], false);",
          "    assert_eq!(pattern_set_full.which[1], false);"
        ],
        "code": [
          "{",
          "    let mut pattern_set = PatternSet {",
          "        len: 1,",
          "        which: alloc::vec![true, false].into_boxed_slice(),",
          "    };",
          "    ",
          "    pattern_set.clear();",
          "    assert_eq!(pattern_set.len, 0);",
          "    assert_eq!(pattern_set.which[0], false);",
          "    assert_eq!(pattern_set.which[1], false);",
          "    ",
          "    let mut pattern_set_full = PatternSet {",
          "    len: 2,",
          "    which: alloc::vec![true, true].into_boxed_slice(),",
          "    };",
          "    ",
          "    pattern_set_full.clear();",
          "    assert_eq!(pattern_set_full.len, 0);",
          "    assert_eq!(pattern_set_full.which[0], false);",
          "    assert_eq!(pattern_set_full.which[1], false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut pattern_set = PatternSet {",
          "        len: 3,",
          "        which: alloc::vec![true, true, false].into_boxed_slice(),",
          "    };",
          "    ",
          "    pattern_set.clear();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(pattern_set.len(), 0);",
          "    assert_eq!(pattern_set.which.as_ref(), &[false, false, false]);",
          "    assert!(pattern_set.is_empty());",
          "    assert!(!pattern_set.is_full());",
          "    assert_eq!(pattern_set.capacity(), 3);"
        ],
        "code": [
          "{",
          "    let mut pattern_set = PatternSet {",
          "        len: 3,",
          "        which: alloc::vec![true, true, false].into_boxed_slice(),",
          "    };",
          "    ",
          "    pattern_set.clear();",
          "    assert_eq!(pattern_set.len(), 0);",
          "    assert_eq!(pattern_set.which.as_ref(), &[false, false, false]);",
          "    assert!(pattern_set.is_empty());",
          "    assert!(!pattern_set.is_full());",
          "    assert_eq!(pattern_set.capacity(), 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut pattern_set = PatternSet {",
          "        len: 1,",
          "        which: alloc::vec![false, false].into_boxed_slice(),",
          "    };",
          "",
          "    pattern_set.clear();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(pattern_set.len, 0);",
          "    assert!(pattern_set.which.iter().all(|&matched| !matched));"
        ],
        "code": [
          "{",
          "    let mut pattern_set = PatternSet {",
          "        len: 1,",
          "        which: alloc::vec![false, false].into_boxed_slice(),",
          "    };",
          "",
          "    pattern_set.clear();",
          "    assert_eq!(pattern_set.len, 0);",
          "    assert!(pattern_set.which.iter().all(|&matched| !matched));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]