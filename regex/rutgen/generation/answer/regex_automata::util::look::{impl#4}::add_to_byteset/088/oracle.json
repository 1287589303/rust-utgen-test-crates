[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::StartLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert!(set.0.contains(b'\\n'));",
          "    assert_eq!(set.0.size(), 1);",
          "    assert!(!set.0.contains(b'\\r'));",
          "    assert!(!set.0.contains(b'a'));",
          "    assert!(!set.0.contains(b'z'));"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::StartLF, &mut set);",
          "    assert!(set.0.contains(b'\\n'));",
          "    assert_eq!(set.0.size(), 1);",
          "    assert!(!set.0.contains(b'\\r'));",
          "    assert!(!set.0.contains(b'a'));",
          "    assert!(!set.0.contains(b'z'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::EndLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "    matcher.add_to_byteset(Look::EndLF, &mut set);",
          "    assert_eq!(set.range_contains(b'\\n'), true);",
          "    assert_eq!(set.range_contains(b'\\r'), false);",
          "    matcher.add_to_byteset(Look::StartLF, &mut set);",
          "    assert_eq!(set.range_contains(b'\\n'), true);",
          "    assert_eq!(set.range_contains(b'\\r'), false);"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::EndLF, &mut set);",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "    matcher.add_to_byteset(Look::EndLF, &mut set);",
          "    assert_eq!(set.range_contains(b'\\n'), true);",
          "    assert_eq!(set.range_contains(b'\\r'), false);",
          "    matcher.add_to_byteset(Look::StartLF, &mut set);",
          "    assert_eq!(set.range_contains(b'\\n'), true);",
          "    assert_eq!(set.range_contains(b'\\r'), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::StartCRLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set, expected_set);",
          "    assert!(set.contains(b'\\r'));",
          "    assert!(set.contains(b'\\n'));",
          "    assert!(!set.contains(b'a'));",
          "    assert!(!set.contains(b'A'));",
          "    assert!(!set.contains(b'1'));",
          "    assert!(!set.contains(b'\\0'));",
          "    assert!(set.is_empty() == false);"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::StartCRLF, &mut set);",
          "    assert_eq!(set, expected_set);",
          "    assert!(set.contains(b'\\r'));",
          "    assert!(set.contains(b'\\n'));",
          "    assert!(!set.contains(b'a'));",
          "    assert!(!set.contains(b'A'));",
          "    assert!(!set.contains(b'1'));",
          "    assert!(!set.contains(b'\\0'));",
          "    assert!(set.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::EndCRLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.0.get_range(), vec![(b'\\r', b'\\r'), (b'\\n', b'\\n')]);",
          "    assert!(set.0.contains(b'\\r'));",
          "    assert!(set.0.contains(b'\\n'));",
          "    assert!(!set.0.contains(b'a'));"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::EndCRLF, &mut set);",
          "    assert_eq!(set.0.get_range(), vec![(b'\\r', b'\\r'), (b'\\n', b'\\n')]);",
          "    assert!(set.0.contains(b'\\r'));",
          "    assert!(set.0.contains(b'\\n'));",
          "    assert!(!set.0.contains(b'a'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::StartLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.0.byte_classes(), /* expected byte classes for Look::StartLF */);",
          "    assert!(set.0.contains(b'\\n'), \"Expected set to contain '\\\\n' for Look::StartLF\");",
          "    assert_eq!(set.0.range_count(), 1, \"Expected exactly one range in the byte class set\");",
          "    assert_eq!(set.0.range(0), (b'\\n', b'\\n'), \"Expected range for Look::StartLF to be (\\\\n, \\\\n)\");"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::StartLF, &mut set);",
          "    assert_eq!(set.0.byte_classes(), /* expected byte classes for Look::StartLF */);",
          "    assert!(set.0.contains(b'\\n'), \"Expected set to contain '\\\\n' for Look::StartLF\");",
          "    assert_eq!(set.0.range_count(), 1, \"Expected exactly one range in the byte class set\");",
          "    assert_eq!(set.0.range(0), (b'\\n', b'\\n'), \"Expected range for Look::StartLF to be (\\\\n, \\\\n)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::EndLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    set.set_range(b'\\n', b'\\n');"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::ByteClassSet::empty();",
          "    let lineterm = DebugByte(b'\\n');",
          "    let mut matcher = LookMatcher { lineterm };",
          "",
          "    matcher.add_to_byteset(Look::EndLF, &mut set);",
          "    set.set_range(b'\\n', b'\\n');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]