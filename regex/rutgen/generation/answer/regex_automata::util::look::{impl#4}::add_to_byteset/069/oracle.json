[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "",
          "    let look = Look::WordUnicode;",
          "    let mut set = ByteClassSet::empty();",
          "",
          "    matcher.add_to_byteset(look, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(matcher.get_line_terminator(), b'\\n');",
          "    assert!(matcher.matches(Look::WordUnicode, &[], 0));",
          "    let set_size_before = set.byte_classes().len();",
          "    matcher.add_to_byteset(Look::WordUnicode, &mut set);",
          "    let set_size_after = set.byte_classes().len();",
          "    assert!(set_size_after > set_size_before);",
          "    assert!(set.byte_classes().contains(b'\\r'));",
          "    assert!(set.byte_classes().contains(b'\\n'));",
          "    assert!(set.byte_classes().contains(asu8(255)));",
          "    assert!(set.byte_classes().contains(asu8(254)));"
        ],
        "code": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "",
          "    let look = Look::WordUnicode;",
          "    let mut set = ByteClassSet::empty();",
          "",
          "    matcher.add_to_byteset(look, &mut set);",
          "    assert_eq!(matcher.get_line_terminator(), b'\\n');",
          "    assert!(matcher.matches(Look::WordUnicode, &[], 0));",
          "    let set_size_before = set.byte_classes().len();",
          "    matcher.add_to_byteset(Look::WordUnicode, &mut set);",
          "    let set_size_after = set.byte_classes().len();",
          "    assert!(set_size_after > set_size_before);",
          "    assert!(set.byte_classes().contains(b'\\r'));",
          "    assert!(set.byte_classes().contains(b'\\n'));",
          "    assert!(set.byte_classes().contains(asu8(255)));",
          "    assert!(set.byte_classes().contains(asu8(254)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "",
          "    let look = Look::WordUnicode;",
          "    let mut set = ByteClassSet::empty();",
          "",
          "    matcher.add_to_byteset(look, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(matcher.get_line_terminator(), b'\\n');",
          "    assert_eq!(set.byte_classes().len(), expected_length);",
          "    assert!(set.contains_byte(b'\\r'));",
          "    assert!(set.contains_byte(b'\\n'));",
          "    assert!(set.contains_range(expected_start, expected_end));",
          "    assert_eq!(b1, 255);",
          "    assert!(b2 > 255);",
          "    assert!(set.check_invariants());"
        ],
        "code": [
          "{",
          "    let mut matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "",
          "    let look = Look::WordUnicode;",
          "    let mut set = ByteClassSet::empty();",
          "",
          "    matcher.add_to_byteset(look, &mut set);",
          "    assert_eq!(matcher.get_line_terminator(), b'\\n');",
          "    assert_eq!(set.byte_classes().len(), expected_length);",
          "    assert!(set.contains_byte(b'\\r'));",
          "    assert!(set.contains_byte(b'\\n'));",
          "    assert!(set.contains_range(expected_start, expected_end));",
          "    assert_eq!(b1, 255);",
          "    assert!(b2 > 255);",
          "    assert!(set.check_invariants());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]