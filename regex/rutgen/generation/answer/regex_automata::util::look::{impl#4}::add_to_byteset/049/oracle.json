[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let look = Look::WordEndAscii;",
          "    let lineterm = DebugByte(10);",
          "    let matcher = LookMatcher {",
          "        lineterm,",
          "    };",
          "    let haystack: &[u8] = b\"Some valid ASCII text.\";",
          "    let at = 24;",
          "    matcher.add_to_byteset(look, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set, expected_set);",
          "    assert!(b1 > 255);",
          "    assert!(matcher.is_end(haystack, at));",
          "    assert!(matcher.is_word_end_ascii(haystack, at));",
          "    assert_eq!(matcher.get_line_terminator(), 10);",
          "    assert!(matcher.matches(look, haystack, at));"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let look = Look::WordEndAscii;",
          "    let lineterm = DebugByte(10);",
          "    let matcher = LookMatcher {",
          "        lineterm,",
          "    };",
          "    let haystack: &[u8] = b\"Some valid ASCII text.\";",
          "    let at = 24;",
          "    matcher.add_to_byteset(look, &mut set);",
          "    assert_eq!(set, expected_set);",
          "    assert!(b1 > 255);",
          "    assert!(matcher.is_end(haystack, at));",
          "    assert!(matcher.is_word_end_ascii(haystack, at));",
          "    assert_eq!(matcher.get_line_terminator(), 10);",
          "    assert!(matcher.matches(look, haystack, at));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let look = Look::WordEndAscii;",
          "    let lineterm = DebugByte(10);",
          "    let matcher = LookMatcher {",
          "        lineterm,",
          "    };",
          "    let haystack: &[u8] = b\"Another ASCII text!\";",
          "    let at = 20;",
          "    matcher.add_to_byteset(look, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert!(set.0.is_some());",
          "    assert_eq!(set.0.first_byte(), Some(b'!'));",
          "    assert_eq!(set.0.last_byte(), Some(b'!'));",
          "    assert!(set.0.contains(b'!'));",
          "    assert!(!set.0.contains(b'A'));",
          "    assert_eq!(matcher.lineterm, DebugByte(10));",
          "    assert!(set.byte_classes().len() > 0);"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let look = Look::WordEndAscii;",
          "    let lineterm = DebugByte(10);",
          "    let matcher = LookMatcher {",
          "        lineterm,",
          "    };",
          "    let haystack: &[u8] = b\"Another ASCII text!\";",
          "    let at = 20;",
          "    matcher.add_to_byteset(look, &mut set);",
          "    assert!(set.0.is_some());",
          "    assert_eq!(set.0.first_byte(), Some(b'!'));",
          "    assert_eq!(set.0.last_byte(), Some(b'!'));",
          "    assert!(set.0.contains(b'!'));",
          "    assert!(!set.0.contains(b'A'));",
          "    assert_eq!(matcher.lineterm, DebugByte(10));",
          "    assert!(set.byte_classes().len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]