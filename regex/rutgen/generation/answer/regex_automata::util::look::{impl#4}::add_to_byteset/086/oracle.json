[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "    matcher.add_to_byteset(Look::StartCRLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "    assert_eq!(set.byte_classes(), expected_classes_for_start_crlf());",
          "    matcher.add_to_byteset(Look::StartCRLF, &mut set);",
          "    assert!(set.contains(b'\\r'));",
          "    assert!(set.contains(b'\\n'));",
          "    assert_eq!(set.byte_classes(), expected_classes_after_start_crlf());",
          "    matcher.add_to_byteset(Look::EndCRLF, &mut set);",
          "    assert!(set.contains(b'\\r'));",
          "    assert!(set.contains(b'\\n'));",
          "    assert_eq!(set.byte_classes(), expected_classes_after_end_crlf());"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "    matcher.add_to_byteset(Look::StartCRLF, &mut set);",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "    assert_eq!(set.byte_classes(), expected_classes_for_start_crlf());",
          "    matcher.add_to_byteset(Look::StartCRLF, &mut set);",
          "    assert!(set.contains(b'\\r'));",
          "    assert!(set.contains(b'\\n'));",
          "    assert_eq!(set.byte_classes(), expected_classes_after_start_crlf());",
          "    matcher.add_to_byteset(Look::EndCRLF, &mut set);",
          "    assert!(set.contains(b'\\r'));",
          "    assert!(set.contains(b'\\n'));",
          "    assert_eq!(set.byte_classes(), expected_classes_after_end_crlf());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "    matcher.add_to_byteset(Look::EndCRLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.byte_classes().len(), expected_length_for_end_crlf);",
          "    assert!(set.contains(b'\\r'));",
          "    assert!(set.contains(b'\\n'));",
          "    assert!(!set.contains(b'a'));",
          "    assert!(!set.contains(b'0'));",
          "    assert_eq!(matcher.get_line_terminator(), b'\\n');"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(b'\\n');",
          "    matcher.add_to_byteset(Look::EndCRLF, &mut set);",
          "    assert_eq!(set.byte_classes().len(), expected_length_for_end_crlf);",
          "    assert!(set.contains(b'\\r'));",
          "    assert!(set.contains(b'\\n'));",
          "    assert!(!set.contains(b'a'));",
          "    assert!(!set.contains(b'0'));",
          "    assert_eq!(matcher.get_line_terminator(), b'\\n');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(0);",
          "    matcher.add_to_byteset(Look::StartCRLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.0.contains(b'\\r'), true);",
          "    assert_eq!(set.0.contains(b'\\n'), true);",
          "    assert_eq!(set.0.contains(0), false);",
          "    assert_eq!(set.0.contains(1), false);",
          "    assert_eq!(set.0.contains(2), false);",
          "    assert_eq!(set.0.contains(255), false);",
          "    assert_eq!(set.0.contains(128), false);",
          "    assert_eq!(set.0.contains(127), false);",
          "    assert_eq!(set.0.contains(254), false);",
          "    assert_eq!(set.0.contains(5), false);",
          "    set.set_range(0, 0);",
          "    set.set_range(1, 1);",
          "    set.set_range(2, 2);",
          "    set.set_range(3, 3);",
          "    set.set_range(4, 4);",
          "    set.set_range(0, 255);",
          "    assert_eq!(set.0.contains(0), false);"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(0);",
          "    matcher.add_to_byteset(Look::StartCRLF, &mut set);",
          "    assert_eq!(set.0.contains(b'\\r'), true);",
          "    assert_eq!(set.0.contains(b'\\n'), true);",
          "    assert_eq!(set.0.contains(0), false);",
          "    assert_eq!(set.0.contains(1), false);",
          "    assert_eq!(set.0.contains(2), false);",
          "    assert_eq!(set.0.contains(255), false);",
          "    assert_eq!(set.0.contains(128), false);",
          "    assert_eq!(set.0.contains(127), false);",
          "    assert_eq!(set.0.contains(254), false);",
          "    assert_eq!(set.0.contains(5), false);",
          "    set.set_range(0, 0);",
          "    set.set_range(1, 1);",
          "    set.set_range(2, 2);",
          "    set.set_range(3, 3);",
          "    set.set_range(4, 4);",
          "    set.set_range(0, 255);",
          "    assert_eq!(set.0.contains(0), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(255);",
          "    matcher.add_to_byteset(Look::EndCRLF, &mut set);",
          "}"
        ],
        "oracle": [
          "    set.set_range(b'\\r', b'\\r');",
          "    set.set_range(b'\\n', b'\\n');"
        ],
        "code": [
          "{",
          "    let mut set = crate::util::alphabet::ByteClassSet::empty();",
          "    let matcher = LookMatcher::new();",
          "    matcher.set_line_terminator(255);",
          "    matcher.add_to_byteset(Look::EndCRLF, &mut set);",
          "    set.set_range(b'\\r', b'\\r');",
          "    set.set_range(b'\\n', b'\\n');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]