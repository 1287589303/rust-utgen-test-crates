{
  "name": "regex::regex::bytes::{impl#7}::capture_names",
  "mod_info": {
    "name": "regex::bytes",
    "loc": "src/regex/mod.rs:1:1:1:22"
  },
  "visible": true,
  "loc": "src/regex/bytes.rs:1326:5:1328:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: CaptureNames(self.meta.group_info().pattern_names(PatternID::ZERO))\n"
      ],
      "input_infer": "Valid regex patterns including named and unnamed capture groups, empty regex pattern, and patterns with no matches and invalid captures; ensure to cover cases like single capturing groups, multiple named/unnamed groups, and non-capturing groups.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    names.next();",
                "    names.next();",
                "    names.next();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"a\")));",
                "    assert_eq!(names.next(), Some(Some(\"b\")));",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"c\")));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re_empty = Regex::new(r\"\").unwrap();",
                "    let mut names_empty = re_empty.capture_names();",
                "    assert_eq!(names_empty.next(), Some(None));",
                "    assert_eq!(names_empty.next(), None);",
                "    ",
                "    let re_no_capture = Regex::new(r\"[a&&b]\").unwrap();",
                "    let mut names_no_capture = re_no_capture.capture_names();",
                "    assert_eq!(names_no_capture.next(), Some(None));",
                "    assert_eq!(names_no_capture.next(), None);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    names.next();",
                "    names.next();",
                "    names.next();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"a\")));",
                "    assert_eq!(names.next(), Some(Some(\"b\")));",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"c\")));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re_empty = Regex::new(r\"\").unwrap();",
                "    let mut names_empty = re_empty.capture_names();",
                "    assert_eq!(names_empty.next(), Some(None));",
                "    assert_eq!(names_empty.next(), None);",
                "    ",
                "    let re_no_capture = Regex::new(r\"[a&&b]\").unwrap();",
                "    let mut names_no_capture = re_no_capture.capture_names();",
                "    assert_eq!(names_no_capture.next(), Some(None));",
                "    assert_eq!(names_no_capture.next(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re = Regex::new(r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"a\")));",
                "    assert_eq!(names.next(), Some(Some(\"b\")));",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"c\")));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re = Regex::new(r\"[a&&b]\").unwrap();",
                "    let mut names = re.capture_names();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re = Regex::new(r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"a\")));",
                "    assert_eq!(names.next(), Some(Some(\"b\")));",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"c\")));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re = Regex::new(r\"[a&&b]\").unwrap();",
                "    let mut names = re.capture_names();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"[a&&b]\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"[a&&b]\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"(?<name>abc)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"name\")));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re = Regex::new(r\"\").unwrap();",
                "    let mut names = re.capture_names();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re = Regex::new(r\"[a&&b]\").unwrap();",
                "    let mut names = re.capture_names();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"(?<name>abc)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"name\")));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re = Regex::new(r\"\").unwrap();",
                "    let mut names = re.capture_names();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);",
                "    ",
                "    let re = Regex::new(r\"[a&&b]\").unwrap();",
                "    let mut names = re.capture_names();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"(?<first>foo)(?<second>bar)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    names.next();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"first\")));",
                "    assert_eq!(names.next(), Some(Some(\"second\")));",
                "    assert_eq!(names.next(), None);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"(?<first>foo)(?<second>bar)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    names.next();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"first\")));",
                "    assert_eq!(names.next(), Some(Some(\"second\")));",
                "    assert_eq!(names.next(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"(abc)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"abc\")));"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"(abc)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"abc\")));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"(?:abc)(def)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"1\")));",
                "    assert_eq!(names.next(), None);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"(?:abc)(def)\").unwrap();",
                "    let mut names = re.capture_names();",
                "    names.next();",
                "    names.next();",
                "    assert_eq!(names.next(), Some(None));",
                "    assert_eq!(names.next(), Some(Some(\"1\")));",
                "    assert_eq!(names.next(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}