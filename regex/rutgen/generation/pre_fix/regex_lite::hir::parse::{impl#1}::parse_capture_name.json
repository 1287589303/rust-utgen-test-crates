{
  "name": "regex_lite::hir::parse::{impl#1}::parse_capture_name",
  "mod_info": {
    "name": "hir::parse",
    "loc": "regex-lite/src/hir/mod.rs:5:1:5:11"
  },
  "visible": false,
  "loc": "regex-lite/src/hir/parse.rs:861:5:889:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.is_done() at line 862 is true\n",
        "expected return value/type: Err(Error::new(ERR_MISSING_GROUP_NAME))\n"
      ],
      "input_infer": "self.is_done() is true, self.pos() = 0, pattern = \"\";\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 1,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern: \"\",",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(0),",
                "        char: Cell::new(None),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let result = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, \"expected capture group name, but got end of pattern\");"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 1,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern: \"\",",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(0),",
                "        char: Cell::new(None),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, \"expected capture group name, but got end of pattern\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 1,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern: \"\",",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(0),",
                "        char: Cell::new(None),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let result = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, ERR_MISSING_GROUP_NAME);"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 1,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern: \"\",",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(0),",
                "        char: Cell::new(None),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, ERR_MISSING_GROUP_NAME);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "precondition: self.is_done() at line 862 is false\n",
        "precondition: self.char() == '>' at line 867 is false\n",
        "precondition: self.is_done() at line 878 is false\n",
        "precondition: (*left_val == *right_val) at line 40 is false\n"
      ],
      "input_infer": "self.is_done() = false, self.char() != '>', pattern has valid capture name characters, capture name not empty, current pos within valid range 0 to pattern length, depth < nest_limit, valid capture group context\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<valid_capture_name>\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('v')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_capture_name\"));",
                "    assert!(parser.capture_names.borrow().contains(&\"valid_capture_name\".to_string()));",
                "    assert_eq!(parser.pos.get(), 19);",
                "    assert!(parser.capture_names.borrow().len() == 1);",
                "    assert!(parser.is_done() == false);",
                "    assert!(parser.char.get().is_some());",
                "    assert!(parser.char.get().unwrap() == '>');"
              ],
              "code": [
                "{",
                "    let pattern = \"<valid_capture_name>\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('v')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_capture_name\"));",
                "    assert!(parser.capture_names.borrow().contains(&\"valid_capture_name\".to_string()));",
                "    assert_eq!(parser.pos.get(), 19);",
                "    assert!(parser.capture_names.borrow().len() == 1);",
                "    assert!(parser.is_done() == false);",
                "    assert!(parser.char.get().is_some());",
                "    assert!(parser.char.get().unwrap() == '>');",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<invalid@name>\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('i')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_err, Error::new(ERR_INVALID_GROUP_NAME));",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.pos.get(), 1);",
                "    assert_eq!(parser.char.get(), Some('i'));",
                "    assert_eq!(parser.is_done(), false);",
                "    parser.pos.set(0);",
                "    assert!(parser.parse_capture_name().is_err());",
                "    parser.char.set(Some('>'));",
                "    parser.pos.set(2);",
                "    assert!(parser.parse_capture_name().is_ok());",
                "    assert!(parser.capture_names.borrow().contains(&String::from(\"invalid@name\")));",
                "    parser.pos.set(1);",
                "    parser.char.set(None);",
                "    assert_eq!(parser.parse_capture_name().err().unwrap().msg, ERR_EMPTY_GROUP_NAME);",
                "    parser.char.set(Some('>'));",
                "    assert!(parser.parse_capture_name().is_err());"
              ],
              "code": [
                "{",
                "    let pattern = \"<invalid@name>\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('i')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(_err, Error::new(ERR_INVALID_GROUP_NAME));",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.pos.get(), 1);",
                "    assert_eq!(parser.char.get(), Some('i'));",
                "    assert_eq!(parser.is_done(), false);",
                "    parser.pos.set(0);",
                "    assert!(parser.parse_capture_name().is_err());",
                "    parser.char.set(Some('>'));",
                "    parser.pos.set(2);",
                "    assert!(parser.parse_capture_name().is_ok());",
                "    assert!(parser.capture_names.borrow().contains(&String::from(\"invalid@name\")));",
                "    parser.pos.set(1);",
                "    parser.char.set(None);",
                "    assert_eq!(parser.parse_capture_name().err().unwrap().msg, ERR_EMPTY_GROUP_NAME);",
                "    parser.char.set(Some('>'));",
                "    assert!(parser.parse_capture_name().is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<duplicate_name><duplicate_name>\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('d')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"duplicate_name\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*parser.parse_capture_name().unwrap(), \"duplicate_name\");",
                "    assert!(parser.capture_names.borrow().len() > 1);",
                "    assert_eq!(parser.capture_names.borrow()[0], \"duplicate_name\");",
                "    assert_eq!(parser.pos.get(), 17);",
                "    assert!(parser.is_done());",
                "    assert!(parser.char.get().is_none());",
                "    assert_eq!(parser.capture_index.get(), 1);"
              ],
              "code": [
                "{",
                "    let pattern = \"<duplicate_name><duplicate_name>\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('d')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"duplicate_name\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(*parser.parse_capture_name().unwrap(), \"duplicate_name\");",
                "    assert!(parser.capture_names.borrow().len() > 1);",
                "    assert_eq!(parser.capture_names.borrow()[0], \"duplicate_name\");",
                "    assert_eq!(parser.pos.get(), 17);",
                "    assert!(parser.is_done());",
                "    assert!(parser.char.get().is_none());",
                "    assert_eq!(parser.capture_index.get(), 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<>\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.pos.get(), 1);",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert!(parser.char.get().is_some());",
                "    assert!(parser.char.get().unwrap() == '>');",
                "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_EMPTY_GROUP_NAME)));"
              ],
              "code": [
                "{",
                "    let pattern = \"<>\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.pos.get(), 1);",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert!(parser.char.get().is_some());",
                "    assert!(parser.char.get().unwrap() == '>');",
                "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_EMPTY_GROUP_NAME)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<valid_capture_name\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('v')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_capture_name\"));",
                "    assert!(parser.is_done());",
                "    assert_eq!(parser.pos.get(), 20);",
                "    assert!(parser.capture_names.borrow().contains(&\"valid_capture_name\".to_string()));",
                "    assert!(parser.capture_index.get() > 0);",
                "    assert!(parser.char.get().is_none());",
                "    assert_eq!(parser.pattern, \"<valid_capture_name\");"
              ],
              "code": [
                "{",
                "    let pattern = \"<valid_capture_name\";",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('v')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_capture_name\"));",
                "    assert!(parser.is_done());",
                "    assert_eq!(parser.pos.get(), 20);",
                "    assert!(parser.capture_names.borrow().contains(&\"valid_capture_name\".to_string()));",
                "    assert!(parser.capture_index.get() > 0);",
                "    assert!(parser.char.get().is_none());",
                "    assert_eq!(parser.pattern, \"<valid_capture_name\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "precondition: self.is_done() at line 862 is false\n",
        "precondition: self.char() == '>' at line 867 is true\n",
        "precondition: is_capture_char(self.char(), self.pos() == start) at line 870 is true\n",
        "precondition: self.bump() at line 873 is true\n",
        "precondition: self.char() == '>' at line 867 is false\n",
        "precondition: self.is_done() at line 878 is false\n",
        "precondition: (*left_val == *right_val) at line 40 is false\n"
      ],
      "input_infer": "self.pattern must start with a '<', followed by valid capture characters (letters, digits, '_', '.', '[', ']'), ending with a '>', and ensuring there are no nested capture names or characters outside of allowed capture chars, with at least one character between '<' and '>'.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<capture>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('c')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.parse_capture_name(), Ok(\"capture\"));",
                "    assert!(parser.capture_names.borrow().contains(&String::from(\"capture\")));",
                "    assert_eq!(parser.pos.get(), 9);",
                "    assert_eq!(parser.char.get(), None);",
                "    assert!(parser.is_done());"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<capture>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('c')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"capture\"));",
                "    assert!(parser.capture_names.borrow().contains(&String::from(\"capture\")));",
                "    assert_eq!(parser.pos.get(), 9);",
                "    assert_eq!(parser.char.get(), None);",
                "    assert!(parser.is_done());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<ca#pture>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('c')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, ERR_INVALID_GROUP_NAME);",
                "    ",
                "    parser.pos.set(1);",
                "    parser.char.set(Some('>'));",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.ok().unwrap(), \"capture\");",
                "    ",
                "    parser.pos.set(1);",
                "    parser.char.set(Some('c'));",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.ok().unwrap(), \"ca\");",
                "    ",
                "    parser.pos.set(1);",
                "    parser.char.set(Some('.'));",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, ERR_INVALID_GROUP_NAME);",
                "    ",
                "    parser.pos.set(1);",
                "    parser.char.set(Some('c'));",
                "    parser.bump();",
                "    parser.char.set(Some('>'));",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, ERR_EMPTY_GROUP_NAME);"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<ca#pture>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('c')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, ERR_INVALID_GROUP_NAME);",
                "    ",
                "    parser.pos.set(1);",
                "    parser.char.set(Some('>'));",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.ok().unwrap(), \"capture\");",
                "    ",
                "    parser.pos.set(1);",
                "    parser.char.set(Some('c'));",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.ok().unwrap(), \"ca\");",
                "    ",
                "    parser.pos.set(1);",
                "    parser.char.set(Some('.'));",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, ERR_INVALID_GROUP_NAME);",
                "    ",
                "    parser.pos.set(1);",
                "    parser.char.set(Some('c'));",
                "    parser.bump();",
                "    parser.char.set(Some('>'));",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().msg, ERR_EMPTY_GROUP_NAME);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.pos.get(), 2);",
                "    assert!(parser.is_done());",
                "    assert_eq!(parser.char.get(), None);",
                "    assert_eq!(parser.capture_index.get(), 0);"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.pos.get(), 2);",
                "    assert!(parser.is_done());",
                "    assert_eq!(parser.char.get(), None);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<capture\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('c')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), Some('c'));",
                "    assert!(is_capture_char(parser.char().unwrap(), parser.pos().get() == 1));",
                "    assert!(parser.bump());",
                "    assert_eq!(parser.char(), Some('>'));",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.pattern(), \"<capture\");",
                "    assert!(parser.add_capture_name(\"<capture\").is_ok());",
                "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_UNCLOSED_GROUP_NAME)));"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<capture\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('c')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), Some('c'));",
                "    assert!(is_capture_char(parser.char().unwrap(), parser.pos().get() == 1));",
                "    assert!(parser.bump());",
                "    assert_eq!(parser.char(), Some('>'));",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.pattern(), \"<capture\");",
                "    assert!(parser.add_capture_name(\"<capture\").is_ok());",
                "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_UNCLOSED_GROUP_NAME)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<capture_1>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('c')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.pos.get(), 16);",
                "    assert_eq!(parser.capture_names.borrow().len(), 1);",
                "    assert_eq!(parser.capture_names.borrow()[0], \"capture_1\");",
                "    assert_eq!(parser.is_done(), false);"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<capture_1>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('c')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.pos.get(), 16);",
                "    assert_eq!(parser.capture_names.borrow().len(), 1);",
                "    assert_eq!(parser.capture_names.borrow()[0], \"capture_1\");",
                "    assert_eq!(parser.is_done(), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "precondition: self.is_done() at line 862 is false\n",
        "precondition: self.char() == '>' at line 867 is true\n",
        "precondition: is_capture_char(self.char(), self.pos() == start) at line 870 is true\n",
        "precondition: self.bump() at line 873 is false\n",
        "precondition: self.is_done() at line 878 is true\n",
        "expected return value/type: Err(Error::new(ERR_UNCLOSED_GROUP_NAME))\n"
      ],
      "input_infer": "self.pattern = \"<validName>\", self.pos() = 0, self.char() = '>' at second call to self.char(), is_done() true after processing, self.bump() does not advance position\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<validName>\";",
                "",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(0),",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(flags),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), Some('>'));",
                "    assert_eq!(is_capture_char(parser.char().unwrap(), parser.pos() == 0), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), true);",
                "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_UNCLOSED_GROUP_NAME)));"
              ],
              "code": [
                "{",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<validName>\";",
                "",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(0),",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(flags),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), Some('>'));",
                "    assert_eq!(is_capture_char(parser.char().unwrap(), parser.pos() == 0), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), true);",
                "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_UNCLOSED_GROUP_NAME)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<>\";",
                "",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(0),",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(flags),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(parser.parse_capture_name(), Err(Error { msg: ERR_UNCLOSED_GROUP_NAME })));"
              ],
              "code": [
                "{",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<>\";",
                "",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(0),",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(flags),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "",
                "    let _ = parser.parse_capture_name();",
                "    assert!(matches!(parser.parse_capture_name(), Err(Error { msg: ERR_UNCLOSED_GROUP_NAME })));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 13,
      "prompt_conds": [
        "precondition: self.is_done() at line 862 is false\n",
        "precondition: self.char() == '>' at line 867 is true\n",
        "precondition: is_capture_char(self.char(), self.pos() == start) at line 870 is true\n",
        "precondition: self.bump() at line 873 is false\n",
        "precondition: self.is_done() at line 878 is false\n",
        "precondition: (*left_val == *right_val) at line 40 is true\n",
        "precondition: name.is_empty() at line 884 is true\n",
        "expected return value/type: Err(Error::new(ERR_EMPTY_GROUP_NAME))\n"
      ],
      "input_infer": "self.is_done() is false, self.char() is '>', is_capture_char(self.char(), self.pos() == start) is true, self.bump() is false, self.is_done() is false, name is empty строка inside a capture group, pattern includes only '<' and '>' with no valid characters in between.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Position after '<'",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "",
                "    let _result = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(Error::new(ERR_EMPTY_GROUP_NAME)));"
              ],
              "code": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Position after '<'",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "",
                "    let _result = parser.parse_capture_name();",
                "    assert_eq!(_result, Err(Error::new(ERR_EMPTY_GROUP_NAME)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let pattern = \"<   >\"; // Spaces represent invalid capture characters",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Position after '<'",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "",
                "    let _result = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(Error::new(ERR_EMPTY_GROUP_NAME)));"
              ],
              "code": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let pattern = \"<   >\"; // Spaces represent invalid capture characters",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Position after '<'",
                "        char: Cell::new(Some('>')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "",
                "    let _result = parser.parse_capture_name();",
                "    assert_eq!(_result, Err(Error::new(ERR_EMPTY_GROUP_NAME)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 14,
      "prompt_conds": [
        "precondition: self.is_done() at line 862 is false\n",
        "precondition: self.char() == '>' at line 867 is true\n",
        "precondition: is_capture_char(self.char(), self.pos() == start) at line 870 is true\n",
        "precondition: self.bump() at line 873 is false\n",
        "precondition: self.is_done() at line 878 is false\n",
        "precondition: (*left_val == *right_val) at line 40 is true\n",
        "precondition: name.is_empty() at line 884 is false\n",
        "precondition: self.add_capture_name(name)? at line 887 is Err/None\n"
      ],
      "input_infer": "self.is_done() is false, self.char() == '>' is true, is_capture_char(self.char(), self.pos() == start) is true, self.bump() is false, self.is_done() is false, name is non-empty, self.add_capture_name(name) returns Ok\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<valid_name>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Positioned at the first character after '<'",
                "        char: Cell::new(Some('v')), // 'v' is a valid capture char",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    ",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    result = parser.parse_capture_name();",
                "    assert_eq!(result.is_ok(), true);",
                "    assert_eq!(result.unwrap(), \"valid_name\");",
                "    assert_eq!(parser.pos.get(), pattern.len());",
                "    assert_eq!(parser.capture_names.borrow().len(), 1);",
                "    assert_eq!(parser.capture_names.borrow().get(0), Some(&String::from(\"valid_name\")));"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<valid_name>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Positioned at the first character after '<'",
                "        char: Cell::new(Some('v')), // 'v' is a valid capture char",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    ",
                "    let _ = parser.parse_capture_name();",
                "    result = parser.parse_capture_name();",
                "    assert_eq!(result.is_ok(), true);",
                "    assert_eq!(result.unwrap(), \"valid_name\");",
                "    assert_eq!(parser.pos.get(), pattern.len());",
                "    assert_eq!(parser.capture_names.borrow().len(), 1);",
                "    assert_eq!(parser.capture_names.borrow().get(0), Some(&String::from(\"valid_name\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Positioned at the first character after '<'",
                "        char: Cell::new(Some('>')), // '>' means we should check for empty name",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    ",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), Some('>'));",
                "    assert_eq!(is_capture_char(parser.char().unwrap(), parser.pos() == 1), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(name.is_empty(), false);",
                "    assert_eq!(parser.add_capture_name(name), Err(Error::new(ERR_EMPTY_GROUP_NAME)));"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Positioned at the first character after '<'",
                "        char: Cell::new(Some('>')), // '>' means we should check for empty name",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    ",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), Some('>'));",
                "    assert_eq!(is_capture_char(parser.char().unwrap(), parser.pos() == 1), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(name.is_empty(), false);",
                "    assert_eq!(parser.add_capture_name(name), Err(Error::new(ERR_EMPTY_GROUP_NAME)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<invalid_name$>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Positioned at the first character after '<'",
                "        char: Cell::new(Some('i')), // 'i' is valid",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    ",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), '>');",
                "    assert_eq!(is_capture_char(parser.char(), parser.pos() == 1), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(name.is_empty(), false);",
                "    assert!(parser.add_capture_name(name).is_err());"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<invalid_name$>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Positioned at the first character after '<'",
                "        char: Cell::new(Some('i')), // 'i' is valid",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    ",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), '>');",
                "    assert_eq!(is_capture_char(parser.char(), parser.pos() == 1), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(name.is_empty(), false);",
                "    assert!(parser.add_capture_name(name).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<valid_name\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Positioned at the first character after '<'",
                "        char: Cell::new(Some('v')), // 'v' is valid",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    ",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.unwrap_err().msg, ERR_UNCLOSED_GROUP_NAME)",
                "    assert_eq!(parser.pos.get(), 1)",
                "    assert_eq!(parser.capture_names.borrow().len(), 0)",
                "    assert_eq!(parser.char.get(), Some('v'))",
                "    assert_eq!(parser.depth.get(), 0)",
                "    assert!(parser.is_done() == false)",
                "    assert!(name.is_empty() == false)"
              ],
              "code": [
                "{",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let pattern = \"<valid_name\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Positioned at the first character after '<'",
                "        char: Cell::new(Some('v')), // 'v' is valid",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    ",
                "    let result = parser.parse_capture_name();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().msg, ERR_UNCLOSED_GROUP_NAME)",
                "    assert_eq!(parser.pos.get(), 1)",
                "    assert_eq!(parser.capture_names.borrow().len(), 0)",
                "    assert_eq!(parser.char.get(), Some('v'))",
                "    assert_eq!(parser.depth.get(), 0)",
                "    assert!(parser.is_done() == false)",
                "    assert!(name.is_empty() == false)",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 15,
      "prompt_conds": [
        "precondition: self.is_done() at line 862 is false\n",
        "precondition: self.char() == '>' at line 867 is true\n",
        "precondition: is_capture_char(self.char(), self.pos() == start) at line 870 is true\n",
        "precondition: self.bump() at line 873 is false\n",
        "precondition: self.is_done() at line 878 is false\n",
        "precondition: (*left_val == *right_val) at line 40 is true\n",
        "precondition: name.is_empty() at line 884 is false\n",
        "precondition: self.add_capture_name(name)? at line 887 is Ok/Some\n",
        "expected return value/type: Ok(name)\n"
      ],
      "input_infer": "valid capture group names starting with a letter or underscore followed by alphanumeric characters, not ending with '>', not empty, and self.add_capture_name(name) returning Ok/Some\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<valid_name>\";",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('v')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"valid_name\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), Some('v'));",
                "    assert_eq!(is_capture_char('v', true), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(name.is_empty(), false);",
                "    assert!(parser.add_capture_name(\"valid_name\").is_ok());",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_name\"));"
              ],
              "code": [
                "{",
                "    let pattern = \"<valid_name>\";",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('v')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"valid_name\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), Some('v'));",
                "    assert_eq!(is_capture_char('v', true), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(name.is_empty(), false);",
                "    assert!(parser.add_capture_name(\"valid_name\").is_ok());",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_name\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<_validName123>\";",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('_')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"validName123\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), '>');",
                "    assert_eq!(is_capture_char(parser.char(), parser.pos() == 1), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(name.is_empty(), false);",
                "    assert_eq!(parser.add_capture_name(name), Ok(()));",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"_validName123\"));"
              ],
              "code": [
                "{",
                "    let pattern = \"<_validName123>\";",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('_')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"validName123\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(parser.char(), '>');",
                "    assert_eq!(is_capture_char(parser.char(), parser.pos() == 1), true);",
                "    assert_eq!(parser.bump(), false);",
                "    assert_eq!(parser.is_done(), false);",
                "    assert_eq!(name.is_empty(), false);",
                "    assert_eq!(parser.add_capture_name(name), Ok(()));",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"_validName123\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<_alpha_123>\";",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('_')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"alpha_123\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert!(!parser.is_done());",
                "    assert_eq!(parser.char(), Some('>'));",
                "    assert!(is_capture_char(parser.char().unwrap(), parser.pos() == 1));",
                "    assert!(!parser.bump());",
                "    assert!(!parser.is_done());",
                "    assert!(!name.is_empty());",
                "    assert!(parser.add_capture_name(name).is_ok());",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"_alpha_123\"));"
              ],
              "code": [
                "{",
                "    let pattern = \"<_alpha_123>\";",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('_')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"alpha_123\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert!(!parser.is_done());",
                "    assert_eq!(parser.char(), Some('>'));",
                "    assert!(is_capture_char(parser.char().unwrap(), parser.pos() == 1));",
                "    assert!(!parser.bump());",
                "    assert!(!parser.is_done());",
                "    assert!(!name.is_empty());",
                "    assert!(parser.add_capture_name(name).is_ok());",
                "    assert_eq!(parser.parse_capture_name(), Ok(\"_alpha_123\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"<name123>\";",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('n')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"name123\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    assert!(parser.is_done() == false);",
                "    assert!(parser.char() == '>');",
                "    assert!(is_capture_char(parser.char(), parser.pos() == 1) == true);",
                "    assert!(parser.bump() == false);",
                "    assert!(parser.is_done() == false);",
                "    assert!(name.is_empty() == false);",
                "    assert!(parser.add_capture_name(name).is_ok());",
                "    assert!(parser.parse_capture_name().unwrap() == \"name123\");"
              ],
              "code": [
                "{",
                "    let pattern = \"<name123>\";",
                "    let config = Config {",
                "        nest_limit: 10,",
                "        flags: Flags::default(),",
                "    };",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1),",
                "        char: Cell::new(Some('n')),",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(Flags::default()),",
                "        capture_names: RefCell::new(vec![\"name123\".to_string()]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    assert!(parser.is_done() == false);",
                "    assert!(parser.char() == '>');",
                "    assert!(is_capture_char(parser.char(), parser.pos() == 1) == true);",
                "    assert!(parser.bump() == false);",
                "    assert!(parser.is_done() == false);",
                "    assert!(name.is_empty() == false);",
                "    assert!(parser.add_capture_name(name).is_ok());",
                "    assert!(parser.parse_capture_name().unwrap() == \"name123\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 17,
      "prompt_conds": [
        "precondition: self.is_done() at line 862 is false\n",
        "precondition: self.char() == '>' at line 867 is true\n",
        "precondition: is_capture_char(self.char(), self.pos() == start) at line 870 is false\n",
        "expected return value/type: Err(Error::new(ERR_INVALID_GROUP_NAME))\n"
      ],
      "input_infer": "self.is_done() == false, self.char() == '>', is_capture_char(self.char(), self.pos() == start) == false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Position right after '<'",
                "        char: Cell::new(Some('>')), // Current character is '>'",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(flags),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    let result = parser.parse_capture_name(); assert_eq!(result, Err(Error::new(ERR_INVALID_GROUP_NAME)));"
              ],
              "code": [
                "{",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Position right after '<'",
                "        char: Cell::new(Some('>')), // Current character is '>'",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(flags),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    let result = parser.parse_capture_name(); assert_eq!(result, Err(Error::new(ERR_INVALID_GROUP_NAME)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Position right after '<'",
                "        char: Cell::new(Some('>')), // Current character is '>'",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(flags),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "}"
              ],
              "oracle": [
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "    config,",
                "    pattern,",
                "    depth: Cell::new(0),",
                "    pos: Cell::new(1), // Position right after '<'",
                "    char: Cell::new(Some('>')), // Current character is '>'",
                "    capture_index: Cell::new(0),",
                "    flags: RefCell::new(flags),",
                "    capture_names: RefCell::new(vec![]),",
                "    };",
                "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_INVALID_GROUP_NAME)));"
              ],
              "code": [
                "{",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "        config,",
                "        pattern,",
                "        depth: Cell::new(0),",
                "        pos: Cell::new(1), // Position right after '<'",
                "        char: Cell::new(Some('>')), // Current character is '>'",
                "        capture_index: Cell::new(0),",
                "        flags: RefCell::new(flags),",
                "        capture_names: RefCell::new(vec![]),",
                "    };",
                "    let _ = parser.parse_capture_name();",
                "    let flags = Flags::default();",
                "    let config = Config { nest_limit: 10, flags };",
                "    let pattern = \"<>\";",
                "    let parser = Parser {",
                "    config,",
                "    pattern,",
                "    depth: Cell::new(0),",
                "    pos: Cell::new(1), // Position right after '<'",
                "    char: Cell::new(Some('>')), // Current character is '>'",
                "    capture_index: Cell::new(0),",
                "    flags: RefCell::new(flags),",
                "    capture_names: RefCell::new(vec![]),",
                "    };",
                "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_INVALID_GROUP_NAME)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}