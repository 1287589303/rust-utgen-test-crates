{
  "name": "regex_syntax::hir::literal::{impl#0}::enforce_literal_len",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:42:1:42:17"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/literal.rs:620:5:626:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.kind matches ExtractKind::Suffix at line 622 is true\n"
      ],
      "input_infer": "self.kind is ExtractKind::Suffix; seq must contain at least one literal with length greater than self.limit_literal_len, self.limit_literal_len >= 0, and self.limit_literal_len < maximum possible literal length in seq\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(5);",
                "    let mut seq = Seq::new(vec![b\"short\".to_vec(), b\"thisisalongliteral\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    assert!(seq.literals().is_some());",
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    assert_eq!(seq.literals().unwrap()[0].max_literal_len(), Some(5));",
                "    assert_eq!(seq.literals().unwrap()[1].max_literal_len(), Some(5));",
                "    assert_eq!(seq.literals().unwrap()[0].len(), Some(5));",
                "    assert_eq!(seq.literals().unwrap()[1].len(), Some(5));"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(5);",
                "    let mut seq = Seq::new(vec![b\"short\".to_vec(), b\"thisisalongliteral\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert!(seq.literals().is_some());",
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    assert_eq!(seq.literals().unwrap()[0].max_literal_len(), Some(5));",
                "    assert_eq!(seq.literals().unwrap()[1].max_literal_len(), Some(5));",
                "    assert_eq!(seq.literals().unwrap()[0].len(), Some(5));",
                "    assert_eq!(seq.literals().unwrap()[1].len(), Some(5));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(3);",
                "    let mut seq = Seq::new(vec![b\"one\".to_vec(), b\"two\".to_vec(), b\"threeletters\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    seq.literals().unwrap().iter().map(|lit| lit.len()).all(|length| length <= 3);",
                "    seq.literals().unwrap().contains(&b\"one\".to_vec());",
                "    seq.literals().unwrap().contains(&b\"two\".to_vec());",
                "    seq.literals().unwrap().contains(&b\"threeletters\".to_vec());",
                "    seq.literals().unwrap().len() == 3;"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(3);",
                "    let mut seq = Seq::new(vec![b\"one\".to_vec(), b\"two\".to_vec(), b\"threeletters\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    seq.literals().unwrap().iter().map(|lit| lit.len()).all(|length| length <= 3);",
                "    seq.literals().unwrap().contains(&b\"one\".to_vec());",
                "    seq.literals().unwrap().contains(&b\"two\".to_vec());",
                "    seq.literals().unwrap().contains(&b\"threeletters\".to_vec());",
                "    seq.literals().unwrap().len() == 3;",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(7);",
                "    let mut seq = Seq::new(vec![b\"1234567\".to_vec(), b\"abcdefg\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    seq.literals().unwrap().len() == 2",
                "    seq.literals().unwrap()[0].len() == 7",
                "    seq.literals().unwrap()[1].len() == 7",
                "    seq.literals().unwrap()[0] == b\"1234567\"",
                "    seq.literals().unwrap()[1] == b\"abcdefg\""
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(7);",
                "    let mut seq = Seq::new(vec![b\"1234567\".to_vec(), b\"abcdefg\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    seq.literals().unwrap().len() == 2",
                "    seq.literals().unwrap()[0].len() == 7",
                "    seq.literals().unwrap()[1].len() == 7",
                "    seq.literals().unwrap()[0] == b\"1234567\"",
                "    seq.literals().unwrap()[1] == b\"abcdefg\"",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(0);",
                "    let mut seq = Seq::new(vec![b\"longliteral\".to_vec(), b\"anotherlongliteral\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(0);",
                "    let mut seq = Seq::new(vec![b\"longliteral\".to_vec(), b\"anotherlongliteral\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.len(), Some(2));",
                "    assert_eq!(seq.literals().unwrap()[0].len(), b\"longliteral\".len());",
                "    assert_eq!(seq.literals().unwrap()[1].len(), b\"anotherlongliteral\".len());",
                "    assert!(seq.is_finite());",
                "    assert!(!seq.is_empty());",
                "    assert!(!seq.is_exact());",
                "    assert!(seq.is_inexact());"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(0);",
                "    let mut seq = Seq::new(vec![b\"longliteral\".to_vec(), b\"anotherlongliteral\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(0);",
                "    let mut seq = Seq::new(vec![b\"longliteral\".to_vec(), b\"anotherlongliteral\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.len(), Some(2));",
                "    assert_eq!(seq.literals().unwrap()[0].len(), b\"longliteral\".len());",
                "    assert_eq!(seq.literals().unwrap()[1].len(), b\"anotherlongliteral\".len());",
                "    assert!(seq.is_finite());",
                "    assert!(!seq.is_empty());",
                "    assert!(!seq.is_exact());",
                "    assert!(seq.is_inexact());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(10);",
                "    let mut seq = Seq::new(vec![b\"short\".to_vec(), b\"tiny\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(seq.literals().map(|l| l.len()), Some(2));",
                "    assert!(seq.literals().unwrap()[0].len() <= 10);",
                "    assert!(seq.literals().unwrap()[1].len() <= 10);",
                "    assert!(seq.is_empty() == false);",
                "    assert!(seq.is_finite() == true);",
                "    assert_eq!(seq.len(), Some(2));",
                "    assert!(seq.max_literal_len().unwrap() <= 10);",
                "    assert!(seq.min_literal_len().unwrap() <= 10);"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_literal_len(10);",
                "    let mut seq = Seq::new(vec![b\"short\".to_vec(), b\"tiny\".to_vec()]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.literals().map(|l| l.len()), Some(2));",
                "    assert!(seq.literals().unwrap()[0].len() <= 10);",
                "    assert!(seq.literals().unwrap()[1].len() <= 10);",
                "    assert!(seq.is_empty() == false);",
                "    assert!(seq.is_finite() == true);",
                "    assert_eq!(seq.len(), Some(2));",
                "    assert!(seq.max_literal_len().unwrap() <= 10);",
                "    assert!(seq.min_literal_len().unwrap() <= 10);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.kind matches ExtractKind::Prefix at line 622 is true\n",
        "precondition: self.kind matches ExtractKind::Prefix at line 622 is true\n"
      ],
      "input_infer": "limit_literal_len: 0 to N, where N is maximum possible size of literals; seq contains literals of length 0 to N or None.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(0);",
                "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    seq.is_empty() == false",
                "    seq.len() == Some(2)",
                "    seq.literals().unwrap().len() == 2",
                "    seq.literals().unwrap()[0].len() == 3",
                "    seq.literals().unwrap()[1].len() == 3",
                "    seq.literals().unwrap()[0] == b\"abc\"",
                "    seq.literals().unwrap()[1] == b\"def\""
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(0);",
                "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    seq.is_empty() == false",
                "    seq.len() == Some(2)",
                "    seq.literals().unwrap().len() == 2",
                "    seq.literals().unwrap()[0].len() == 3",
                "    seq.literals().unwrap()[1].len() == 3",
                "    seq.literals().unwrap()[0] == b\"abc\"",
                "    seq.literals().unwrap()[1] == b\"def\"",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
                "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    assert_eq!(seq.literals().unwrap()[0], Literal::new(b\"a\"));",
                "    assert_eq!(seq.literals().unwrap()[1], Literal::new(b\"d\"));",
                "    assert!(seq.is_finite());",
                "    assert!(!seq.is_empty());",
                "    assert_eq!(seq.len().unwrap(), 2);",
                "    assert_eq!(seq.min_literal_len().unwrap(), 1);",
                "    assert_eq!(seq.max_literal_len().unwrap(), 1);"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
                "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    assert_eq!(seq.literals().unwrap()[0], Literal::new(b\"a\"));",
                "    assert_eq!(seq.literals().unwrap()[1], Literal::new(b\"d\"));",
                "    assert!(seq.is_finite());",
                "    assert!(!seq.is_empty());",
                "    assert_eq!(seq.len().unwrap(), 2);",
                "    assert_eq!(seq.min_literal_len().unwrap(), 1);",
                "    assert_eq!(seq.max_literal_len().unwrap(), 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(3);",
                "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    assert!(seq.literals().unwrap()[0].len() <= 3);",
                "    assert!(seq.literals().unwrap()[1].len() <= 3);"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(3);",
                "    let mut seq = Seq::new(vec![b\"abc\", b\"def\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    assert!(seq.literals().unwrap()[0].len() <= 3);",
                "    assert!(seq.literals().unwrap()[1].len() <= 3);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(2);",
                "    let mut seq = Seq::new(vec![b\"abcdef\", b\"ghijk\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    assert_eq!(seq.literals().unwrap()[0].len(), 2);",
                "    assert_eq!(seq.literals().unwrap()[1].len(), 2);",
                "    assert!(seq.literals().unwrap()[0] == b\"ab\" || seq.literals().unwrap()[0] == b\"gh\");",
                "    assert!(seq.literals().unwrap()[1] == b\"cd\" || seq.literals().unwrap()[1] == b\"ij\");"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(2);",
                "    let mut seq = Seq::new(vec![b\"abcdef\", b\"ghijk\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    assert_eq!(seq.literals().unwrap()[0].len(), 2);",
                "    assert_eq!(seq.literals().unwrap()[1].len(), 2);",
                "    assert!(seq.literals().unwrap()[0] == b\"ab\" || seq.literals().unwrap()[0] == b\"gh\");",
                "    assert!(seq.literals().unwrap()[1] == b\"cd\" || seq.literals().unwrap()[1] == b\"ij\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
                "    let mut seq = Seq::new(vec![b\"\", b\"abc\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
                "    let mut seq = Seq::new(vec![b\"\", b\"abc\"]);",
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.literals().unwrap().len(), 1);",
                "    assert_eq!(seq.literals().unwrap()[0], b\"a\");"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
                "    let mut seq = Seq::new(vec![b\"\", b\"abc\"]);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(1);",
                "    let mut seq = Seq::new(vec![b\"\", b\"abc\"]);",
                "    assert_eq!(seq.literals().unwrap().len(), 2);",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.literals().unwrap().len(), 1);",
                "    assert_eq!(seq.literals().unwrap()[0], b\"a\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(5);",
                "    let mut seq = Seq::empty();",
                "    extractor.enforce_literal_len(&mut seq);",
                "}"
              ],
              "oracle": [
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix);",
                "    assert_eq!(extractor.limit_literal_len, 5);",
                "    let mut seq = Seq::empty();",
                "    assert!(seq.is_empty());",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.len(), Some(0));",
                "    assert!(seq.is_empty());"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(5);",
                "    let mut seq = Seq::empty();",
                "    extractor.enforce_literal_len(&mut seq);",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix);",
                "    assert_eq!(extractor.limit_literal_len, 5);",
                "    let mut seq = Seq::empty();",
                "    assert!(seq.is_empty());",
                "    extractor.enforce_literal_len(&mut seq);",
                "    assert_eq!(seq.len(), Some(0));",
                "    assert!(seq.is_empty());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}