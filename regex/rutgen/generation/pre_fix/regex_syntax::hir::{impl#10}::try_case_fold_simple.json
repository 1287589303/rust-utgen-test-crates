{
  "name": "regex_syntax::hir::{impl#10}::try_case_fold_simple",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:190:1:190:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:874:5:882:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: *self matches Class::Bytes(ref mut x) at line 877 is true\n",
        "expected return value/type: Ok(())\n"
      ],
      "input_infer": "self must be an instance of Class::Bytes containing ASCII ranges, the unicode-case feature must be disabled, and try_case_fold_simple should be called with a mutable reference.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0x41, 0x5A), // A-Z",
                "        ClassBytesRange::new(0x61, 0x7A), // a-z",
                "    ]));",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class_bytes.is_ascii(), true);",
                "    assert_eq!(class_bytes.ranges().len(), 2);",
                "    assert!(class_bytes.ranges().contains(&ClassBytesRange::new(0x41, 0x5A));",
                "    assert!(class_bytes.ranges().contains(&ClassBytesRange::new(0x61, 0x7A));",
                "    assert!(class_bytes.literal().is_none());",
                "    assert_eq!(class_bytes.minimum_len(), Some(1));",
                "    assert_eq!(class_bytes.maximum_len(), Some(2));"
              ],
              "code": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0x41, 0x5A), // A-Z",
                "        ClassBytesRange::new(0x61, 0x7A), // a-z",
                "    ]));",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "    assert_eq!(class_bytes.is_ascii(), true);",
                "    assert_eq!(class_bytes.ranges().len(), 2);",
                "    assert!(class_bytes.ranges().contains(&ClassBytesRange::new(0x41, 0x5A));",
                "    assert!(class_bytes.ranges().contains(&ClassBytesRange::new(0x61, 0x7A));",
                "    assert!(class_bytes.literal().is_none());",
                "    assert_eq!(class_bytes.minimum_len(), Some(1));",
                "    assert_eq!(class_bytes.maximum_len(), Some(2));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::empty());",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class_bytes.is_empty(), true);",
                "    assert!(class_bytes.maximum_len().is_none());",
                "    assert!(class_bytes.minimum_len().is_none());",
                "    assert!(class_bytes.literal().is_none());"
              ],
              "code": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::empty());",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "    assert_eq!(class_bytes.is_empty(), true);",
                "    assert!(class_bytes.maximum_len().is_none());",
                "    assert!(class_bytes.minimum_len().is_none());",
                "    assert!(class_bytes.literal().is_none());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0x41, 0x41), // A",
                "    ]));",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "}"
              ],
              "oracle": [
                "    class_bytes.try_case_fold_simple().unwrap();"
              ],
              "code": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0x41, 0x41), // A",
                "    ]));",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0x20, 0x7E), // Space to ~",
                "    ]));",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class_bytes.try_case_fold_simple(), Ok(()));"
              ],
              "code": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0x20, 0x7E), // Space to ~",
                "    ]));",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "    assert_eq!(class_bytes.try_case_fold_simple(), Ok(()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0xFF, 0xFF), // Non-ASCII",
                "    ]));",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class_bytes, Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(0xFF, 0xFF)])));",
                "    assert!(class_bytes.try_case_fold_simple().is_ok());",
                "    class_bytes = Class::Bytes(ClassBytes::empty());",
                "    assert!(class_bytes.try_case_fold_simple().is_ok());",
                "    class_bytes = Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(0x41, 0x5A), ClassBytesRange::new(0x61, 0x7A)]));",
                "    assert!(class_bytes.try_case_fold_simple().is_ok());"
              ],
              "code": [
                "{",
                "    let mut class_bytes = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0xFF, 0xFF), // Non-ASCII",
                "    ]));",
                "    class_bytes.try_case_fold_simple().unwrap();",
                "    assert_eq!(class_bytes, Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(0xFF, 0xFF)])));",
                "    assert!(class_bytes.try_case_fold_simple().is_ok());",
                "    class_bytes = Class::Bytes(ClassBytes::empty());",
                "    assert!(class_bytes.try_case_fold_simple().is_ok());",
                "    class_bytes = Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(0x41, 0x5A), ClassBytesRange::new(0x61, 0x7A)]));",
                "    assert!(class_bytes.try_case_fold_simple().is_ok());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: *self matches Class::Unicode(ref mut x) at line 877 is true\n",
        "precondition: *self matches Class::Unicode(ref mut x) at line 877 is true\n",
        "precondition: x.try_case_fold_simple()? at line 878 is Err/None\n"
      ],
      "input_infer": "Class::Unicode with valid ranges that require case mapping data and the `unicode-case` feature not enabled, specifically cases that are expected to trigger a CaseFoldError upon attempting case folding.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges = vec![ClassUnicodeRange::new('A', 'Z'), ClassUnicodeRange::new('a', 'z')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "",
                "    let result = unicode_class.try_case_fold_simple();",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().0, ());"
              ],
              "code": [
                "{",
                "    let ranges = vec![ClassUnicodeRange::new('A', 'Z'), ClassUnicodeRange::new('a', 'z')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().0, ());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let empty_unicode_class = Class::Unicode(ClassUnicode::empty());",
                "",
                "    let result = empty_unicode_class.try_case_fold_simple();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.is_err(), true);",
                "    assert_eq!(result.unwrap_err().is_none(), true);"
              ],
              "code": [
                "{",
                "    let empty_unicode_class = Class::Unicode(ClassUnicode::empty());",
                "",
                "    let result = empty_unicode_class.try_case_fold_simple();",
                "    assert_eq!(result.is_err(), true);",
                "    assert_eq!(result.unwrap_err().is_none(), true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges = vec![ClassUnicodeRange::new('A', 'A')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "",
                "    let result = unicode_class.try_case_fold_simple();",
                "}"
              ],
              "oracle": [
                "    let ranges = vec![ClassUnicodeRange::new('A', 'A')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(CaseFoldError(())));"
              ],
              "code": [
                "{",
                "    let ranges = vec![ClassUnicodeRange::new('A', 'A')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "",
                "    let result = unicode_class.try_case_fold_simple();",
                "    let ranges = vec![ClassUnicodeRange::new('A', 'A')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(CaseFoldError(())));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges = vec![ClassUnicodeRange::new('é', 'é')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "",
                "    let result = unicode_class.try_case_fold_simple();",
                "}"
              ],
              "oracle": [
                "    let ranges = vec![ClassUnicodeRange::new('é', 'é')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(CaseFoldError(())));"
              ],
              "code": [
                "{",
                "    let ranges = vec![ClassUnicodeRange::new('é', 'é')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "",
                "    let result = unicode_class.try_case_fold_simple();",
                "    let ranges = vec![ClassUnicodeRange::new('é', 'é')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(CaseFoldError(())));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: *self matches Class::Unicode(ref mut x) at line 877 is true\n",
        "precondition: *self matches Class::Unicode(ref mut x) at line 877 is true\n",
        "precondition: x.try_case_fold_simple()? at line 878 is Ok/Some\n",
        "expected return value/type: Ok(())\n"
      ],
      "input_infer": "Class::Unicode with valid ranges covering all required characters for simple case folding, and the `unicode-case` feature enabled.\n",
      "answers": [
        {
          "uses": [
            "use crate::hir::Class;",
            "use crate::hir::ClassUnicode;",
            "use crate::hir::ClassUnicodeKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::hir::{Class, ClassUnicode, ClassUnicodeKind};",
                "    ",
                "    let ranges = vec![",
                "        ClassUnicodeRange::new('A'..='Z'), // valid uppercase range",
                "        ClassUnicodeRange::new('a'..='z'), // valid lowercase range",
                "    ];",
                "    ",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    ",
                "    let result = unicode_class.try_case_fold_simple();",
                "    let _ = result.unwrap(); // expect Ok(())",
                "}"
              ],
              "oracle": [
                "    let ranges = vec![ClassUnicodeRange::new('A'..='Z'), ClassUnicodeRange::new('a'..='z')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    assert_eq!(unicode_class.try_case_fold_simple(), Ok(()));",
                "    assert!(matches!(unicode_class, Class::Unicode(_)));",
                "    assert!(unicode_class.is_ascii());"
              ],
              "code": [
                "{",
                "    use crate::hir::{Class, ClassUnicode, ClassUnicodeKind};",
                "    ",
                "    let ranges = vec![",
                "        ClassUnicodeRange::new('A'..='Z'), // valid uppercase range",
                "        ClassUnicodeRange::new('a'..='z'), // valid lowercase range",
                "    ];",
                "    ",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    ",
                "    let result = unicode_class.try_case_fold_simple();",
                "    let _ = result.unwrap(); // expect Ok(())",
                "    let ranges = vec![ClassUnicodeRange::new('A'..='Z'), ClassUnicodeRange::new('a'..='z')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    assert_eq!(unicode_class.try_case_fold_simple(), Ok(()));",
                "    assert!(matches!(unicode_class, Class::Unicode(_)));",
                "    assert!(unicode_class.is_ascii());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::hir::{Class, ClassUnicode};",
                "    ",
                "    let unicode_class = Class::Unicode(ClassUnicode::empty());",
                "    ",
                "    let result = unicode_class.try_case_fold_simple();",
                "    let _ = result.unwrap(); // expect Ok(())",
                "}"
              ],
              "oracle": [
                "    let unicode_class = Class::Unicode(ClassUnicode::empty());",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert_eq!(result, Ok(()));"
              ],
              "code": [
                "{",
                "    use crate::hir::{Class, ClassUnicode};",
                "    ",
                "    let unicode_class = Class::Unicode(ClassUnicode::empty());",
                "    ",
                "    let result = unicode_class.try_case_fold_simple();",
                "    let _ = result.unwrap(); // expect Ok(())",
                "    let unicode_class = Class::Unicode(ClassUnicode::empty());",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert_eq!(result, Ok(()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::hir::{Class, ClassUnicode};",
                "    ",
                "    let ranges = vec![",
                "        ClassUnicodeRange::new('é'..='è'), // valid range including accented letters",
                "    ];",
                "    ",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    ",
                "    let result = unicode_class.try_case_fold_simple();",
                "    let _ = result.unwrap(); // expect Ok(())",
                "}"
              ],
              "oracle": [
                "    let ranges = vec![ClassUnicodeRange::new('é'..='è')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert_eq!(result, Ok(()));"
              ],
              "code": [
                "{",
                "    use crate::hir::{Class, ClassUnicode};",
                "    ",
                "    let ranges = vec![",
                "        ClassUnicodeRange::new('é'..='è'), // valid range including accented letters",
                "    ];",
                "    ",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    ",
                "    let result = unicode_class.try_case_fold_simple();",
                "    let _ = result.unwrap(); // expect Ok(())",
                "    let ranges = vec![ClassUnicodeRange::new('é'..='è')];",
                "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
                "    let result = unicode_class.try_case_fold_simple();",
                "    assert_eq!(result, Ok(()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}