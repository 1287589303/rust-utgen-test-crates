{
  "name": "regex_syntax::hir::{impl#17}::to_unicode_class",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:190:1:190:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:1484:5:1497:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.is_ascii() at line 1485 is true\n",
        "expected return value/type: Some(ClassUnicode::new(self.ranges().iter().map(|r| {\n            // Since we are guaranteed that our byte range is ASCII, the\n            // 'char::from' calls below are correct and will not erroneously\n            // convert a raw byte value into its corresponding codepoint.\n            ClassUnicodeRange {\n                start: char::from(r.start),\n                end: char::from(r.end),\n            }\n        })))\n"
      ],
      "input_infer": "ClassBytes with ranges only consisting of ASCII values, where each ClassBytesRange has start and end between 0x00 and 0x7F, with at least one valid range.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range = ClassBytesRange { start: 0x41, end: 0x41 }; // 'A'",
                "    let class_bytes = ClassBytes::new(vec![range]);",
                "    let _result = class_bytes.to_unicode_class();",
                "}"
              ],
              "oracle": [
                "    assert!(_result.is_some());",
                "    let class_unicode = _result.unwrap();",
                "    assert_eq!(class_unicode.ranges().len(), 1);",
                "    assert_eq!(class_unicode.ranges()[0].start, char::from(0x41));",
                "    assert_eq!(class_unicode.ranges()[0].end, char::from(0x41));",
                "    assert!(class_bytes.is_ascii());"
              ],
              "code": [
                "{",
                "    let range = ClassBytesRange { start: 0x41, end: 0x41 }; // 'A'",
                "    let class_bytes = ClassBytes::new(vec![range]);",
                "    let _result = class_bytes.to_unicode_class();",
                "    assert!(_result.is_some());",
                "    let class_unicode = _result.unwrap();",
                "    assert_eq!(class_unicode.ranges().len(), 1);",
                "    assert_eq!(class_unicode.ranges()[0].start, char::from(0x41));",
                "    assert_eq!(class_unicode.ranges()[0].end, char::from(0x41));",
                "    assert!(class_bytes.is_ascii());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges = vec![",
                "        ClassBytesRange { start: 0x30, end: 0x39 }, // '0'-'9'",
                "        ClassBytesRange { start: 0x41, end: 0x5A }, // 'A'-'Z'",
                "        ClassBytesRange { start: 0x61, end: 0x7A }, // 'a'-'z'",
                "    ];",
                "    let class_bytes = ClassBytes::new(ranges);",
                "    let _result = class_bytes.to_unicode_class();",
                "}"
              ],
              "oracle": [
                "    let ranges = vec![ClassBytesRange { start: 0x30, end: 0x39 }, ClassBytesRange { start: 0x41, end: 0x5A }, ClassBytesRange { start: 0x61, end: 0x7A }];",
                "    let class_bytes = ClassBytes::new(ranges);",
                "    let result = class_bytes.to_unicode_class();",
                "    assert!(result.is_some());",
                "    let unicode_class = result.unwrap();",
                "    assert_eq!(unicode_class.ranges().len(), 3);",
                "    assert_eq!(unicode_class.ranges()[0], ClassUnicodeRange { start: '0', end: '9' });",
                "    assert_eq!(unicode_class.ranges()[1], ClassUnicodeRange { start: 'A', end: 'Z' });",
                "    assert_eq!(unicode_class.ranges()[2], ClassUnicodeRange { start: 'a', end: 'z' });"
              ],
              "code": [
                "{",
                "    let ranges = vec![",
                "        ClassBytesRange { start: 0x30, end: 0x39 }, // '0'-'9'",
                "        ClassBytesRange { start: 0x41, end: 0x5A }, // 'A'-'Z'",
                "        ClassBytesRange { start: 0x61, end: 0x7A }, // 'a'-'z'",
                "    ];",
                "    let class_bytes = ClassBytes::new(ranges);",
                "    let _result = class_bytes.to_unicode_class();",
                "    let ranges = vec![ClassBytesRange { start: 0x30, end: 0x39 }, ClassBytesRange { start: 0x41, end: 0x5A }, ClassBytesRange { start: 0x61, end: 0x7A }];",
                "    let class_bytes = ClassBytes::new(ranges);",
                "    let result = class_bytes.to_unicode_class();",
                "    assert!(result.is_some());",
                "    let unicode_class = result.unwrap();",
                "    assert_eq!(unicode_class.ranges().len(), 3);",
                "    assert_eq!(unicode_class.ranges()[0], ClassUnicodeRange { start: '0', end: '9' });",
                "    assert_eq!(unicode_class.ranges()[1], ClassUnicodeRange { start: 'A', end: 'Z' });",
                "    assert_eq!(unicode_class.ranges()[2], ClassUnicodeRange { start: 'a', end: 'z' });",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range = ClassBytesRange { start: 0x00, end: 0x7F }; // Full ASCII range",
                "    let class_bytes = ClassBytes::new(vec![range]);",
                "    let _result = class_bytes.to_unicode_class();",
                "}"
              ],
              "oracle": [
                "    _result.unwrap().set.ranges.iter().map(|r| r.start).collect::<Vec<_>>() == vec![0x00]",
                "    _result.unwrap().set.ranges.iter().map(|r| r.end).collect::<Vec<_>>() == vec![0x7F]",
                "    _result.unwrap().set.is_ascii() == true",
                "    _result.is_some() == true"
              ],
              "code": [
                "{",
                "    let range = ClassBytesRange { start: 0x00, end: 0x7F }; // Full ASCII range",
                "    let class_bytes = ClassBytes::new(vec![range]);",
                "    let _result = class_bytes.to_unicode_class();",
                "    _result.unwrap().set.ranges.iter().map(|r| r.start).collect::<Vec<_>>() == vec![0x00]",
                "    _result.unwrap().set.ranges.iter().map(|r| r.end).collect::<Vec<_>>() == vec![0x7F]",
                "    _result.unwrap().set.is_ascii() == true",
                "    _result.is_some() == true",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges = vec![",
                "        ClassBytesRange { start: 0x20, end: 0x20 }, // Space",
                "        ClassBytesRange { start: 0x21, end: 0x21 }, // '!'",
                "        ClassBytesRange { start: 0x7E, end: 0x7E }, // '~'",
                "    ];",
                "    let class_bytes = ClassBytes::new(ranges);",
                "    let _result = class_bytes.to_unicode_class();",
                "}"
              ],
              "oracle": [
                "    assert!(_result.is_some());",
                "    let unicode_class = _result.unwrap();",
                "    let expected_ranges = vec![",
                "    ClassUnicodeRange { start: char::from(0x20), end: char::from(0x20) },",
                "    ClassUnicodeRange { start: char::from(0x21), end: char::from(0x21) },",
                "    ClassUnicodeRange { start: char::from(0x7E), end: char::from(0x7E) },",
                "    ];",
                "    assert_eq!(unicode_class.ranges(), expected_ranges.as_slice());"
              ],
              "code": [
                "{",
                "    let ranges = vec![",
                "        ClassBytesRange { start: 0x20, end: 0x20 }, // Space",
                "        ClassBytesRange { start: 0x21, end: 0x21 }, // '!'",
                "        ClassBytesRange { start: 0x7E, end: 0x7E }, // '~'",
                "    ];",
                "    let class_bytes = ClassBytes::new(ranges);",
                "    let _result = class_bytes.to_unicode_class();",
                "    assert!(_result.is_some());",
                "    let unicode_class = _result.unwrap();",
                "    let expected_ranges = vec![",
                "    ClassUnicodeRange { start: char::from(0x20), end: char::from(0x20) },",
                "    ClassUnicodeRange { start: char::from(0x21), end: char::from(0x21) },",
                "    ClassUnicodeRange { start: char::from(0x7E), end: char::from(0x7E) },",
                "    ];",
                "    assert_eq!(unicode_class.ranges(), expected_ranges.as_slice());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.is_ascii() at line 1485 is false\n",
        "expected return value/type: None\n"
      ],
      "input_infer": "ClassBytes with ranges that include non-ASCII values (e.g., ClassBytesRange { start: 128, end: 255 })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range = ClassBytesRange { start: 128, end: 255 };",
                "    let class_bytes = ClassBytes::new(vec![range]);",
                "    let result = class_bytes.to_unicode_class();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let range = ClassBytesRange { start: 128, end: 255 };",
                "    let class_bytes = ClassBytes::new(vec![range]);",
                "    let result = class_bytes.to_unicode_class();",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range = ClassBytesRange { start: 100, end: 200 };",
                "    let class_bytes = ClassBytes::new(vec![range]);",
                "    let result = class_bytes.to_unicode_class();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let range = ClassBytesRange { start: 100, end: 200 };",
                "    let class_bytes = ClassBytes::new(vec![range]);",
                "    let result = class_bytes.to_unicode_class();",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range1 = ClassBytesRange { start: 128, end: 200 };",
                "    let range2 = ClassBytesRange { start: 201, end: 255 };",
                "    let class_bytes = ClassBytes::new(vec![range1, range2]);",
                "    let result = class_bytes.to_unicode_class();",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_none());"
              ],
              "code": [
                "{",
                "    let range1 = ClassBytesRange { start: 128, end: 200 };",
                "    let range2 = ClassBytesRange { start: 201, end: 255 };",
                "    let class_bytes = ClassBytes::new(vec![range1, range2]);",
                "    let result = class_bytes.to_unicode_class();",
                "    assert!(result.is_none());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_bytes = ClassBytes::empty();",
                "    let result = class_bytes.to_unicode_class();",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_none());"
              ],
              "code": [
                "{",
                "    let class_bytes = ClassBytes::empty();",
                "    let result = class_bytes.to_unicode_class();",
                "    assert!(result.is_none());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}