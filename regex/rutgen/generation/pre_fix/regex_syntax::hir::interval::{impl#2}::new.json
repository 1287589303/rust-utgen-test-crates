{
  "name": "regex_syntax::hir::interval::{impl#2}::new",
  "mod_info": {
    "name": "hir::interval",
    "loc": "regex-syntax/src/hir/mod.rs:41:1:41:14"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/interval.rs:73:5:80:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: set\n"
      ],
      "input_infer": "non-empty intervals with overlapping ranges, non-empty intervals without overlapping ranges, empty intervals, intervals with same lower and upper bounds, intervals with upper bound less than lower bound (to check boundary cases)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]",
            "struct TestBound(u32);",
            "",
            "impl core::cmp::PartialEq for TestBound {",
            "    fn eq(&self, other: &Self) -> bool {",
            "        self.0 == other.0",
            "    }",
            "}",
            "",
            "impl core::cmp::Eq for TestBound {}",
            "",
            "impl core::cmp::Ord for TestBound {",
            "    fn cmp(&self, other: &Self) -> core::cmp::Ordering {",
            "        self.0.cmp(&other.0)",
            "    }",
            "}",
            "",
            "impl core::cmp::PartialOrd for TestBound {",
            "    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {",
            "        Some(self.cmp(other))",
            "    }",
            "}",
            "",
            "trait Bound {",
            "    fn increment(&self) -> Self;",
            "    fn decrement(&self) -> Self;",
            "}",
            "",
            "impl Bound for TestBound {",
            "    fn increment(&self) -> Self {",
            "        TestBound(self.0 + 1)",
            "    }",
            "",
            "    fn decrement(&self) -> Self {",
            "        TestBound(self.0 - 1)",
            "    }",
            "}",
            "",
            "#[derive(Clone, Debug, Default, PartialEq)]",
            "struct TestInterval {",
            "    lower: TestBound,",
            "    upper: TestBound,",
            "}",
            "",
            "impl Interval for TestInterval {",
            "    type Bound = TestBound;",
            "",
            "    fn lower(&self) -> Self::Bound {",
            "        self.lower",
            "    }",
            "",
            "    fn upper(&self) -> Self::Bound {",
            "        self.upper",
            "    }",
            "",
            "    fn set_lower(&mut self, bound: Self::Bound) {",
            "        self.lower = bound;",
            "    }",
            "",
            "    fn set_upper(&mut self, bound: Self::Bound) {",
            "        self.upper = bound;",
            "    }",
            "",
            "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) -> Result<(), unicode::CaseFoldError> {",
            "        Ok(())",
            "    }",
            "",
            "    fn is_contiguous(&self, other: &Self) -> bool {",
            "        self.upper >= other.lower && self.lower <= other.upper",
            "    }",
            "",
            "    fn is_intersection_empty(&self, other: &Self) -> bool {",
            "        self.upper < other.lower || self.lower > other.upper",
            "    }",
            "",
            "    fn is_subset(&self, other: &Self) -> bool {",
            "        self.lower >= other.lower && self.upper <= other.upper",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let intervals = vec![",
                "        TestInterval { lower: TestBound(1), upper: TestBound(5) },",
                "        TestInterval { lower: TestBound(3), upper: TestBound(7) },",
                "    ];",
                "    let set = IntervalSet::new(intervals);",
                "}"
              ],
              "oracle": [
                "    let intervals_empty: Vec<TestInterval> = vec![];",
                "    let set_empty = IntervalSet::new(intervals_empty);",
                "    assert_eq!(set_empty.ranges.len(), 0);",
                "    assert!(set_empty.folded);",
                "    ",
                "    let intervals_single: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(3) }",
                "    ];",
                "    let set_single = IntervalSet::new(intervals_single);",
                "    assert_eq!(set_single.ranges.len(), 1);",
                "    assert_eq!(set_single.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_single.ranges[0].upper(), TestBound(3));",
                "    ",
                "    let intervals_non_overlapping: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
                "    TestInterval { lower: TestBound(3), upper: TestBound(4) },",
                "    ];",
                "    let set_non_overlapping = IntervalSet::new(intervals_non_overlapping);",
                "    assert_eq!(set_non_overlapping.ranges.len(), 2);",
                "    assert_eq!(set_non_overlapping.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_non_overlapping.ranges[0].upper(), TestBound(2));",
                "    assert_eq!(set_non_overlapping.ranges[1].lower(), TestBound(3));",
                "    assert_eq!(set_non_overlapping.ranges[1].upper(), TestBound(4));",
                "    ",
                "    let intervals_overlapping: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(5) },",
                "    TestInterval { lower: TestBound(2), upper: TestBound(3) },",
                "    ];",
                "    let set_overlapping = IntervalSet::new(intervals_overlapping);",
                "    assert_eq!(set_overlapping.ranges.len(), 1);",
                "    assert_eq!(set_overlapping.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_overlapping.ranges[0].upper(), TestBound(5));",
                "    ",
                "    let intervals_reverse_order: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(5), upper: TestBound(10) },",
                "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
                "    ];",
                "    let set_reverse_order = IntervalSet::new(intervals_reverse_order);",
                "    assert_eq!(set_reverse_order.ranges.len(), 2);",
                "    assert_eq!(set_reverse_order.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_reverse_order.ranges[0].upper(), TestBound(3));",
                "    assert_eq!(set_reverse_order.ranges[1].lower(), TestBound(5));",
                "    assert_eq!(set_reverse_order.ranges[1].upper(), TestBound(10));"
              ],
              "code": [
                "{",
                "    let intervals = vec![",
                "        TestInterval { lower: TestBound(1), upper: TestBound(5) },",
                "        TestInterval { lower: TestBound(3), upper: TestBound(7) },",
                "    ];",
                "    let set = IntervalSet::new(intervals);",
                "    let intervals_empty: Vec<TestInterval> = vec![];",
                "    let set_empty = IntervalSet::new(intervals_empty);",
                "    assert_eq!(set_empty.ranges.len(), 0);",
                "    assert!(set_empty.folded);",
                "    ",
                "    let intervals_single: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(3) }",
                "    ];",
                "    let set_single = IntervalSet::new(intervals_single);",
                "    assert_eq!(set_single.ranges.len(), 1);",
                "    assert_eq!(set_single.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_single.ranges[0].upper(), TestBound(3));",
                "    ",
                "    let intervals_non_overlapping: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
                "    TestInterval { lower: TestBound(3), upper: TestBound(4) },",
                "    ];",
                "    let set_non_overlapping = IntervalSet::new(intervals_non_overlapping);",
                "    assert_eq!(set_non_overlapping.ranges.len(), 2);",
                "    assert_eq!(set_non_overlapping.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_non_overlapping.ranges[0].upper(), TestBound(2));",
                "    assert_eq!(set_non_overlapping.ranges[1].lower(), TestBound(3));",
                "    assert_eq!(set_non_overlapping.ranges[1].upper(), TestBound(4));",
                "    ",
                "    let intervals_overlapping: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(5) },",
                "    TestInterval { lower: TestBound(2), upper: TestBound(3) },",
                "    ];",
                "    let set_overlapping = IntervalSet::new(intervals_overlapping);",
                "    assert_eq!(set_overlapping.ranges.len(), 1);",
                "    assert_eq!(set_overlapping.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_overlapping.ranges[0].upper(), TestBound(5));",
                "    ",
                "    let intervals_reverse_order: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(5), upper: TestBound(10) },",
                "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
                "    ];",
                "    let set_reverse_order = IntervalSet::new(intervals_reverse_order);",
                "    assert_eq!(set_reverse_order.ranges.len(), 2);",
                "    assert_eq!(set_reverse_order.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_reverse_order.ranges[0].upper(), TestBound(3));",
                "    assert_eq!(set_reverse_order.ranges[1].lower(), TestBound(5));",
                "    assert_eq!(set_reverse_order.ranges[1].upper(), TestBound(10));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let intervals = vec![",
                "        TestInterval { lower: TestBound(1), upper: TestBound(2) },",
                "        TestInterval { lower: TestBound(3), upper: TestBound(4) },",
                "    ];",
                "    let set = IntervalSet::new(intervals);",
                "}"
              ],
              "oracle": [
                "    let intervals = vec![TestInterval { lower: TestBound(1), upper: TestBound(2) }, TestInterval { lower: TestBound(3), upper: TestBound(4) }];",
                "    assert_eq!(set.ranges.len(), 2);",
                "    assert_eq!(set.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set.ranges[0].upper(), TestBound(2));",
                "    assert_eq!(set.ranges[1].lower(), TestBound(3));",
                "    assert_eq!(set.ranges[1].upper(), TestBound(4));",
                "    assert!(set.folded);"
              ],
              "code": [
                "{",
                "    let intervals = vec![",
                "        TestInterval { lower: TestBound(1), upper: TestBound(2) },",
                "        TestInterval { lower: TestBound(3), upper: TestBound(4) },",
                "    ];",
                "    let set = IntervalSet::new(intervals);",
                "    let intervals = vec![TestInterval { lower: TestBound(1), upper: TestBound(2) }, TestInterval { lower: TestBound(3), upper: TestBound(4) }];",
                "    assert_eq!(set.ranges.len(), 2);",
                "    assert_eq!(set.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set.ranges[0].upper(), TestBound(2));",
                "    assert_eq!(set.ranges[1].lower(), TestBound(3));",
                "    assert_eq!(set.ranges[1].upper(), TestBound(4));",
                "    assert!(set.folded);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let intervals: Vec<TestInterval> = Vec::new();",
                "    let set = IntervalSet::new(intervals);",
                "}"
              ],
              "oracle": [
                "    let intervals: Vec<TestInterval> = Vec::new(); assert_eq!(set.ranges.len(), 0); assert!(set.folded);",
                "    let intervals: Vec<TestInterval> = vec![TestInterval { lower: TestBound(1), upper: TestBound(3) }]; let set = IntervalSet::new(intervals); assert_eq!(set.ranges.len(), 1); assert_eq!(set.ranges[0].lower(), TestBound(1)); assert_eq!(set.ranges[0].upper(), TestBound(3));",
                "    let intervals: Vec<TestInterval> = vec![TestInterval { lower: TestBound(2), upper: TestBound(5) }, TestInterval { lower: TestBound(1), upper: TestBound(3) }]; let set = IntervalSet::new(intervals); assert_eq!(set.ranges.len(), 1); assert_eq!(set.ranges[0].lower(), TestBound(1)); assert_eq!(set.ranges[0].upper(), TestBound(5));",
                "    let intervals: Vec<TestInterval> = vec![TestInterval { lower: TestBound(4), upper: TestBound(6) }, TestInterval { lower: TestBound(1), upper: TestBound(3) }]; let set = IntervalSet::new(intervals); assert_eq!(set.ranges.len(), 2); assert_eq!(set.ranges[0].lower(), TestBound(1)); assert_eq!(set.ranges[0].upper(), TestBound(3)); assert_eq!(set.ranges[1].lower(), TestBound(4)); assert_eq!(set.ranges[1].upper(), TestBound(6));",
                "    let intervals: Vec<TestInterval> = vec![TestInterval { lower: TestBound(5), upper: TestBound(7) }, TestInterval { lower: TestBound(1), upper: TestBound(4) }]; let set = IntervalSet::new(intervals); assert_eq!(set.ranges.len(), 2); assert_eq!(set.ranges[0].lower(), TestBound(1)); assert_eq!(set.ranges[0].upper(), TestBound(4)); assert_eq!(set.ranges[1].lower(), TestBound(5)); assert_eq!(set.ranges[1].upper(), TestBound(7));"
              ],
              "code": [
                "{",
                "    let intervals: Vec<TestInterval> = Vec::new();",
                "    let set = IntervalSet::new(intervals);",
                "    let intervals: Vec<TestInterval> = Vec::new(); assert_eq!(set.ranges.len(), 0); assert!(set.folded);",
                "    let intervals: Vec<TestInterval> = vec![TestInterval { lower: TestBound(1), upper: TestBound(3) }]; let set = IntervalSet::new(intervals); assert_eq!(set.ranges.len(), 1); assert_eq!(set.ranges[0].lower(), TestBound(1)); assert_eq!(set.ranges[0].upper(), TestBound(3));",
                "    let intervals: Vec<TestInterval> = vec![TestInterval { lower: TestBound(2), upper: TestBound(5) }, TestInterval { lower: TestBound(1), upper: TestBound(3) }]; let set = IntervalSet::new(intervals); assert_eq!(set.ranges.len(), 1); assert_eq!(set.ranges[0].lower(), TestBound(1)); assert_eq!(set.ranges[0].upper(), TestBound(5));",
                "    let intervals: Vec<TestInterval> = vec![TestInterval { lower: TestBound(4), upper: TestBound(6) }, TestInterval { lower: TestBound(1), upper: TestBound(3) }]; let set = IntervalSet::new(intervals); assert_eq!(set.ranges.len(), 2); assert_eq!(set.ranges[0].lower(), TestBound(1)); assert_eq!(set.ranges[0].upper(), TestBound(3)); assert_eq!(set.ranges[1].lower(), TestBound(4)); assert_eq!(set.ranges[1].upper(), TestBound(6));",
                "    let intervals: Vec<TestInterval> = vec![TestInterval { lower: TestBound(5), upper: TestBound(7) }, TestInterval { lower: TestBound(1), upper: TestBound(4) }]; let set = IntervalSet::new(intervals); assert_eq!(set.ranges.len(), 2); assert_eq!(set.ranges[0].lower(), TestBound(1)); assert_eq!(set.ranges[0].upper(), TestBound(4)); assert_eq!(set.ranges[1].lower(), TestBound(5)); assert_eq!(set.ranges[1].upper(), TestBound(7));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let intervals = vec![",
                "        TestInterval { lower: TestBound(1), upper: TestBound(1) },",
                "        TestInterval { lower: TestBound(2), upper: TestBound(2) },",
                "    ];",
                "    let set = IntervalSet::new(intervals);",
                "}"
              ],
              "oracle": [
                "    let intervals_empty: Vec<TestInterval> = vec![];",
                "    let set_empty = IntervalSet::new(intervals_empty);",
                "    assert_eq!(set_empty.ranges.len(), 0);",
                "    assert!(set_empty.folded);",
                "    ",
                "    let intervals_single: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(1) },",
                "    ];",
                "    let set_single = IntervalSet::new(intervals_single);",
                "    assert_eq!(set_single.ranges.len(), 1);",
                "    assert_eq!(set_single.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_single.ranges[0].upper(), TestBound(1));",
                "    assert!(set_single.folded);",
                "    ",
                "    let intervals_overlapping: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
                "    TestInterval { lower: TestBound(2), upper: TestBound(4) },",
                "    ];",
                "    let set_overlapping = IntervalSet::new(intervals_overlapping);",
                "    assert_eq!(set_overlapping.ranges.len(), 1);",
                "    assert_eq!(set_overlapping.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_overlapping.ranges[0].upper(), TestBound(4));",
                "    assert!(!set_overlapping.folded);",
                "    ",
                "    let intervals_non_overlapping: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(1) },",
                "    TestInterval { lower: TestBound(3), upper: TestBound(3) },",
                "    ];",
                "    let set_non_overlapping = IntervalSet::new(intervals_non_overlapping);",
                "    assert_eq!(set_non_overlapping.ranges.len(), 2);",
                "    assert_eq!(set_non_overlapping.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_non_overlapping.ranges[0].upper(), TestBound(1));",
                "    assert_eq!(set_non_overlapping.ranges[1].lower(), TestBound(3));",
                "    assert_eq!(set_non_overlapping.ranges[1].upper(), TestBound(3));",
                "    assert!(set_non_overlapping.folded);",
                "    ",
                "    let intervals_mixed: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
                "    TestInterval { lower: TestBound(3), upper: TestBound(5) },",
                "    TestInterval { lower: TestBound(2), upper: TestBound(4) },",
                "    ];",
                "    let set_mixed = IntervalSet::new(intervals_mixed);",
                "    assert_eq!(set_mixed.ranges.len(), 1);",
                "    assert_eq!(set_mixed.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_mixed.ranges[0].upper(), TestBound(5));",
                "    assert!(!set_mixed.folded);"
              ],
              "code": [
                "{",
                "    let intervals = vec![",
                "        TestInterval { lower: TestBound(1), upper: TestBound(1) },",
                "        TestInterval { lower: TestBound(2), upper: TestBound(2) },",
                "    ];",
                "    let set = IntervalSet::new(intervals);",
                "    let intervals_empty: Vec<TestInterval> = vec![];",
                "    let set_empty = IntervalSet::new(intervals_empty);",
                "    assert_eq!(set_empty.ranges.len(), 0);",
                "    assert!(set_empty.folded);",
                "    ",
                "    let intervals_single: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(1) },",
                "    ];",
                "    let set_single = IntervalSet::new(intervals_single);",
                "    assert_eq!(set_single.ranges.len(), 1);",
                "    assert_eq!(set_single.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_single.ranges[0].upper(), TestBound(1));",
                "    assert!(set_single.folded);",
                "    ",
                "    let intervals_overlapping: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
                "    TestInterval { lower: TestBound(2), upper: TestBound(4) },",
                "    ];",
                "    let set_overlapping = IntervalSet::new(intervals_overlapping);",
                "    assert_eq!(set_overlapping.ranges.len(), 1);",
                "    assert_eq!(set_overlapping.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_overlapping.ranges[0].upper(), TestBound(4));",
                "    assert!(!set_overlapping.folded);",
                "    ",
                "    let intervals_non_overlapping: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(1) },",
                "    TestInterval { lower: TestBound(3), upper: TestBound(3) },",
                "    ];",
                "    let set_non_overlapping = IntervalSet::new(intervals_non_overlapping);",
                "    assert_eq!(set_non_overlapping.ranges.len(), 2);",
                "    assert_eq!(set_non_overlapping.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_non_overlapping.ranges[0].upper(), TestBound(1));",
                "    assert_eq!(set_non_overlapping.ranges[1].lower(), TestBound(3));",
                "    assert_eq!(set_non_overlapping.ranges[1].upper(), TestBound(3));",
                "    assert!(set_non_overlapping.folded);",
                "    ",
                "    let intervals_mixed: Vec<TestInterval> = vec![",
                "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
                "    TestInterval { lower: TestBound(3), upper: TestBound(5) },",
                "    TestInterval { lower: TestBound(2), upper: TestBound(4) },",
                "    ];",
                "    let set_mixed = IntervalSet::new(intervals_mixed);",
                "    assert_eq!(set_mixed.ranges.len(), 1);",
                "    assert_eq!(set_mixed.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set_mixed.ranges[0].upper(), TestBound(5));",
                "    assert!(!set_mixed.folded);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let intervals = vec![",
                "        TestInterval { lower: TestBound(2), upper: TestBound(1) },",
                "        TestInterval { lower: TestBound(4), upper: TestBound(3) },",
                "    ];",
                "    let set = IntervalSet::new(intervals);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.ranges.len(), 2);",
                "    assert_eq!(set.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set.ranges[0].upper(), TestBound(2));",
                "    assert_eq!(set.ranges[1].lower(), TestBound(3));",
                "    assert_eq!(set.ranges[1].upper(), TestBound(4));",
                "    assert!(set.folded);",
                "    assert!(set.is_canonical());"
              ],
              "code": [
                "{",
                "    let intervals = vec![",
                "        TestInterval { lower: TestBound(2), upper: TestBound(1) },",
                "        TestInterval { lower: TestBound(4), upper: TestBound(3) },",
                "    ];",
                "    let set = IntervalSet::new(intervals);",
                "    assert_eq!(set.ranges.len(), 2);",
                "    assert_eq!(set.ranges[0].lower(), TestBound(1));",
                "    assert_eq!(set.ranges[0].upper(), TestBound(2));",
                "    assert_eq!(set.ranges[1].lower(), TestBound(3));",
                "    assert_eq!(set.ranges[1].upper(), TestBound(4));",
                "    assert!(set.folded);",
                "    assert!(set.is_canonical());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}