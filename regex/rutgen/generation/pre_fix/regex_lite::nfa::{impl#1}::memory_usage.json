{
  "name": "regex_lite::nfa::{impl#1}::memory_usage",
  "mod_info": {
    "name": "nfa",
    "loc": "regex-lite/src/lib.rs:880:1:880:9"
  },
  "visible": false,
  "loc": "regex-lite/src/nfa.rs:127:5:131:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: (self.states.len() * size_of::<State>())\n            + (self.cap_index_to_name.len() * size_of::<Option<Arc<str>>>())\n            + self.memory_extra\n"
      ],
      "input_infer": "Valid ranges for states vector length: 0 to 1000; valid lengths for cap_index_to_name vector: 0 to 100; valid memory_extra values: 0 to 4096.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let states: Vec<State> = Vec::new();",
                "    let cap_index_to_name: Vec<Option<Arc<str>>> = Vec::new();",
                "    let memory_extra: usize = 0;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"\"),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.states.len(), 0);",
                "    assert_eq!(nfa.cap_index_to_name.len(), 0);",
                "    assert_eq!(nfa.memory_extra, 0);",
                "    assert_eq!(nfa.memory_usage(), 0);"
              ],
              "code": [
                "{",
                "    let states: Vec<State> = Vec::new();",
                "    let cap_index_to_name: Vec<Option<Arc<str>>> = Vec::new();",
                "    let memory_extra: usize = 0;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"\"),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "    assert_eq!(nfa.states.len(), 0);",
                "    assert_eq!(nfa.cap_index_to_name.len(), 0);",
                "    assert_eq!(nfa.memory_extra, 0);",
                "    assert_eq!(nfa.memory_usage(), 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let states = vec![State::Char { target: 1, ch: 'a' }];",
                "    let cap_index_to_name: Vec<Option<Arc<str>>> = Vec::new();",
                "    let memory_extra: usize = 0;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"a\"),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.states.len() * size_of::<State>(), expected_memory_usage);",
                "    assert_eq!(nfa.cap_index_to_name.len() * size_of::<Option<Arc<str>>>(), expected_memory_usage);",
                "    assert_eq!(nfa.memory_extra, expected_memory_usage);",
                "    assert_eq!(nfa.memory_usage(), (nfa.states.len() * size_of::<State>()) + (nfa.cap_index_to_name.len() * size_of::<Option<Arc<str>>>()) + nfa.memory_extra);"
              ],
              "code": [
                "{",
                "    let states = vec![State::Char { target: 1, ch: 'a' }];",
                "    let cap_index_to_name: Vec<Option<Arc<str>>> = Vec::new();",
                "    let memory_extra: usize = 0;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"a\"),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "    assert_eq!(nfa.states.len() * size_of::<State>(), expected_memory_usage);",
                "    assert_eq!(nfa.cap_index_to_name.len() * size_of::<Option<Arc<str>>>(), expected_memory_usage);",
                "    assert_eq!(nfa.memory_extra, expected_memory_usage);",
                "    assert_eq!(nfa.memory_usage(), (nfa.states.len() * size_of::<State>()) + (nfa.cap_index_to_name.len() * size_of::<Option<Arc<str>>>()) + nfa.memory_extra);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let states = vec![",
                "        State::Char { target: 1, ch: 'a' },",
                "        State::Char { target: 2, ch: 'b' },",
                "    ];",
                "    let cap_index_to_name: Vec<Option<Arc<str>>> = Vec::new();",
                "    let memory_extra: usize = 0;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"ab\"),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "}"
              ],
              "oracle": [
                "    let states = vec![State::Char { target: 1, ch: 'a' }, State::Char { target: 2, ch: 'b' }];",
                "    let cap_index_to_name: Vec<Option<Arc<str>>> = Vec::new();",
                "    let memory_extra: usize = 0;",
                "    let expected_usage = (states.len() * size_of::<State>()) + (cap_index_to_name.len() * size_of::<Option<Arc<str>>>()) + memory_extra;",
                "    assert_eq!(nfa.memory_usage(), expected_usage);"
              ],
              "code": [
                "{",
                "    let states = vec![",
                "        State::Char { target: 1, ch: 'a' },",
                "        State::Char { target: 2, ch: 'b' },",
                "    ];",
                "    let cap_index_to_name: Vec<Option<Arc<str>>> = Vec::new();",
                "    let memory_extra: usize = 0;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"ab\"),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "    let states = vec![State::Char { target: 1, ch: 'a' }, State::Char { target: 2, ch: 'b' }];",
                "    let cap_index_to_name: Vec<Option<Arc<str>>> = Vec::new();",
                "    let memory_extra: usize = 0;",
                "    let expected_usage = (states.len() * size_of::<State>()) + (cap_index_to_name.len() * size_of::<Option<Arc<str>>>()) + memory_extra;",
                "    assert_eq!(nfa.memory_usage(), expected_usage);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let states = vec![State::Capture { target: 1, slot: 0 }];",
                "    let cap_index_to_name = vec![Some(Arc::new(String::from(\"group1\")))]; ",
                "    let memory_extra: usize = 16;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"(group1)\"),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "}"
              ],
              "oracle": [
                "    let expected_memory_usage = (1 * size_of::<State>()) + (1 * size_of::<Option<Arc<str>>>()) + 16;",
                "    assert_eq!(_usage, expected_memory_usage);"
              ],
              "code": [
                "{",
                "    let states = vec![State::Capture { target: 1, slot: 0 }];",
                "    let cap_index_to_name = vec![Some(Arc::new(String::from(\"group1\")))]; ",
                "    let memory_extra: usize = 16;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"(group1)\"),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "    let expected_memory_usage = (1 * size_of::<State>()) + (1 * size_of::<Option<Arc<str>>>()) + 16;",
                "    assert_eq!(_usage, expected_memory_usage);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let states = (0..1000).map(|i| State::Char { target: i as StateID, ch: 'a' }).collect::<Vec<State>>();",
                "    let cap_index_to_name = (0..100).map(|i| Some(Arc::new(format!(\"group{}\", i)))).collect::<Vec<Option<Arc<str>>>>();",
                "    let memory_extra: usize = 4096;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"a\".repeat(1000)),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.states.len(), 1000);",
                "    assert_eq!(nfa.cap_index_to_name.len(), 100);",
                "    assert_eq!(nfa.memory_extra, 4096);",
                "    assert_eq!(nfa.memory_usage(), (nfa.states.len() * size_of::<State>()) + (nfa.cap_index_to_name.len() * size_of::<Option<Arc<str>>>()) + nfa.memory_extra);"
              ],
              "code": [
                "{",
                "    let states = (0..1000).map(|i| State::Char { target: i as StateID, ch: 'a' }).collect::<Vec<State>>();",
                "    let cap_index_to_name = (0..100).map(|i| Some(Arc::new(format!(\"group{}\", i)))).collect::<Vec<Option<Arc<str>>>>();",
                "    let memory_extra: usize = 4096;",
                "",
                "    let nfa = NFA {",
                "        pattern: String::from(\"a\".repeat(1000)),",
                "        states,",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name,",
                "        memory_extra,",
                "    };",
                "",
                "    let _usage = nfa.memory_usage();",
                "    assert_eq!(nfa.states.len(), 1000);",
                "    assert_eq!(nfa.cap_index_to_name.len(), 100);",
                "    assert_eq!(nfa.memory_extra, 4096);",
                "    assert_eq!(nfa.memory_usage(), (nfa.states.len() * size_of::<State>()) + (nfa.cap_index_to_name.len() * size_of::<Option<Arc<str>>>()) + nfa.memory_extra);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}