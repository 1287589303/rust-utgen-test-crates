{
  "name": "regex_syntax::unicode::canonical_script",
  "mod_info": {
    "name": "unicode",
    "loc": "regex-syntax/src/lib.rs:193:1:193:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/unicode.rs:515:1:520:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: property_values(\"Script\")? at line 518 is Err/None\n"
      ],
      "input_infer": "normalized_value as any string, including empty string and strings matching valid and invalid script values, ensuring to check error conditions from property_values function return of Err or None\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"some_script_value\";",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(Error::PropertyValueNotFound));"
              ],
              "code": [
                "{",
                "    let normalized_value = \"some_script_value\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(Error::PropertyValueNotFound));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"\";",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err() || result.is_none());"
              ],
              "code": [
                "{",
                "    let normalized_value = \"\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_err() || result.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"invalid_script\";",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Err(Error::PropertyValueNotFound));",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(Error::PropertyValueNotFound)));",
                "    assert!(result.is_none());",
                "    assert!(result.unwrap_err() == Error::PropertyValueNotFound);"
              ],
              "code": [
                "{",
                "    let normalized_value = \"invalid_script\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Err(Error::PropertyValueNotFound));",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(Error::PropertyValueNotFound)));",
                "    assert!(result.is_none());",
                "    assert!(result.unwrap_err() == Error::PropertyValueNotFound);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"totally_not_a_script\";",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(Error::PropertyNotFound));",
                "    assert!(result.is_ok() == false);",
                "    assert!(result.unwrap_err() == Error::PropertyNotFound);",
                "    assert!(result == Err(Error::PropertyValueNotFound));",
                "    assert!(result.is_none());"
              ],
              "code": [
                "{",
                "    let normalized_value = \"totally_not_a_script\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(Error::PropertyNotFound));",
                "    assert!(result.is_ok() == false);",
                "    assert!(result.unwrap_err() == Error::PropertyNotFound);",
                "    assert!(result == Err(Error::PropertyValueNotFound));",
                "    assert!(result.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: property_values(\"Script\")? at line 518 is Ok/Some\n",
        "expected return value/type: Ok(canonical_value(scripts, normalized_value))\n"
      ],
      "input_infer": "normalized_value input should be a valid string representing a known Unicode script, including boundary cases such as empty strings and special characters, while ensuring it can be matched against the entries in PROPERTY_VALUES corresponding to \"Script\" when property_values(\"Script\") returns Ok/Some.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"Latin\";",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    let expected = Some(\"Latn\");",
                "    assert_eq!(result.unwrap(), expected);"
              ],
              "code": [
                "{",
                "    let normalized_value = \"Latin\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    let expected = Some(\"Latn\");",
                "    assert_eq!(result.unwrap(), expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"\";",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    let normalized_value = \"Latin\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Latn\")));",
                "    ",
                "    let normalized_value = \"Cyrillic\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Cyrl\")));",
                "    ",
                "    let normalized_value = \"Greek\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Grek\")));",
                "    ",
                "    let normalized_value = \"Arab\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Arab\")));",
                "    ",
                "    let normalized_value = \"Hebrew\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Hebr\")));"
              ],
              "code": [
                "{",
                "    let normalized_value = \"\";",
                "    let result = canonical_script(normalized_value);",
                "    let normalized_value = \"Latin\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Latn\")));",
                "    ",
                "    let normalized_value = \"Cyrillic\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Cyrl\")));",
                "    ",
                "    let normalized_value = \"Greek\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Grek\")));",
                "    ",
                "    let normalized_value = \"Arab\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Arab\")));",
                "    ",
                "    let normalized_value = \"Hebrew\";",
                "    let result = canonical_script(normalized_value);",
                "    assert_eq!(result, Ok(Some(\"Hebr\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"汉\"; // Chinese character",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    let normalized_value = \"汉\"; // Chinese character",
                "    let expected_value = Ok(Some(\"Han\")); // Expecting \"Han\" script for the Chinese character",
                "    assert_eq!(result, expected_value);"
              ],
              "code": [
                "{",
                "    let normalized_value = \"汉\"; // Chinese character",
                "    let result = canonical_script(normalized_value);",
                "    let normalized_value = \"汉\"; // Chinese character",
                "    let expected_value = Ok(Some(\"Han\")); // Expecting \"Han\" script for the Chinese character",
                "    assert_eq!(result, expected_value);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"NonExistentScript\";",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    let normalized_value = \"NonExistentScript\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert!(result.unwrap().is_none());",
                "    let normalized_value = \"Latin\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Latn\"));",
                "    let normalized_value = \"Cyrillic\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Cyrl\"));"
              ],
              "code": [
                "{",
                "    let normalized_value = \"NonExistentScript\";",
                "    let result = canonical_script(normalized_value);",
                "    let normalized_value = \"NonExistentScript\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert!(result.unwrap().is_none());",
                "    let normalized_value = \"Latin\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Latn\"));",
                "    let normalized_value = \"Cyrillic\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Cyrl\"));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let normalized_value = \"123\";",
                "    let result = canonical_script(normalized_value);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Latin\"));  // Assuming the expected value for \"123\" is \"Latin\"",
                "    ",
                "    let normalized_value = \"abc\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Latin\"));  // Assuming the expected value for \"abc\" is \"Latin\"",
                "    ",
                "    let normalized_value = \"你好\"; // Test with a different script",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Han\"));  // Assuming the expected value for \"你好\" is \"Han\"",
                "    ",
                "    let normalized_value = \"α\"; // Greek character",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Greek\"));  // Assuming the expected value for \"α\" is \"Greek\""
              ],
              "code": [
                "{",
                "    let normalized_value = \"123\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Latin\"));  // Assuming the expected value for \"123\" is \"Latin\"",
                "    ",
                "    let normalized_value = \"abc\";",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Latin\"));  // Assuming the expected value for \"abc\" is \"Latin\"",
                "    ",
                "    let normalized_value = \"你好\"; // Test with a different script",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Han\"));  // Assuming the expected value for \"你好\" is \"Han\"",
                "    ",
                "    let normalized_value = \"α\"; // Greek character",
                "    let result = canonical_script(normalized_value);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Some(\"Greek\"));  // Assuming the expected value for \"α\" is \"Greek\"",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}