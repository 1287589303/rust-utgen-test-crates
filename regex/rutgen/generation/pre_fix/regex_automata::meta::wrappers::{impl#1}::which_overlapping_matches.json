{
  "name": "regex_automata::meta::wrappers::{impl#1}::which_overlapping_matches",
  "mod_info": {
    "name": "meta::wrappers",
    "loc": "regex-automata/src/meta/mod.rs:62:1:62:14"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/wrappers.rs:110:5:121:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "PikeVMCache (Valid/Invalid, Option::Some/None), Input (haystack length 0 to max, span length 0 to max, anchored true/false, earliest true/false), PatternSet (len 0 to max, which array length 0 to max, booleans true/false)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input {",
                "        haystack: &[],",
                "        span: Span::new(0, 0),",
                "        anchored: Anchored::False,",
                "        earliest: false,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 0,",
                "        which: alloc::boxed::Box::new([]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "}"
              ],
              "oracle": [
                "    assert!(cache.0.is_some());",
                "    assert_eq!(input.haystack.len(), 0);",
                "    assert_eq!(patset.len, 0);",
                "    assert!(patset.which.is_empty());",
                "    assert!(pike_vm.0.0.is_some());"
              ],
              "code": [
                "{",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input {",
                "        haystack: &[],",
                "        span: Span::new(0, 0),",
                "        anchored: Anchored::False,",
                "        earliest: false,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 0,",
                "        which: alloc::boxed::Box::new([]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "    assert!(cache.0.is_some());",
                "    assert_eq!(input.haystack.len(), 0);",
                "    assert_eq!(patset.len, 0);",
                "    assert!(patset.which.is_empty());",
                "    assert!(pike_vm.0.0.is_some());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input {",
                "        haystack: &[1, 2, 3, 4],",
                "        span: Span::new(0, 4),",
                "        anchored: Anchored::True,",
                "        earliest: true,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 1,",
                "        which: alloc::boxed::Box::new([true]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "}"
              ],
              "oracle": [
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input { haystack: &[1, 2, 3, 4], span: Span::new(0, 4), anchored: Anchored::True, earliest: true };",
                "    let mut patset = PatternSet { len: 1, which: alloc::boxed::Box::new([true]) };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);"
              ],
              "code": [
                "{",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input {",
                "        haystack: &[1, 2, 3, 4],",
                "        span: Span::new(0, 4),",
                "        anchored: Anchored::True,",
                "        earliest: true,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 1,",
                "        which: alloc::boxed::Box::new([true]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input { haystack: &[1, 2, 3, 4], span: Span::new(0, 4), anchored: Anchored::True, earliest: true };",
                "    let mut patset = PatternSet { len: 1, which: alloc::boxed::Box::new([true]) };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut cache = PikeVMCache(None);",
                "    let input = Input {",
                "        haystack: &[1, 2, 3, 4],",
                "        span: Span::new(0, 4),",
                "        anchored: Anchored::False,",
                "        earliest: false,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 1,",
                "        which: alloc::boxed::Box::new([false]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "}"
              ],
              "oracle": [
                "    assert!(cache.0.is_none());",
                "    assert_eq!(patset.len, 1);",
                "    assert!(patset.which[0] == false);"
              ],
              "code": [
                "{",
                "    let mut cache = PikeVMCache(None);",
                "    let input = Input {",
                "        haystack: &[1, 2, 3, 4],",
                "        span: Span::new(0, 4),",
                "        anchored: Anchored::False,",
                "        earliest: false,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 1,",
                "        which: alloc::boxed::Box::new([false]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "    assert!(cache.0.is_none());",
                "    assert_eq!(patset.len, 1);",
                "    assert!(patset.which[0] == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input {",
                "        haystack: &[5, 6, 7],",
                "        span: Span::new(0, 3),",
                "        anchored: Anchored::True,",
                "        earliest: true,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 0,",
                "        which: alloc::boxed::Box::new([]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "}"
              ],
              "oracle": [
                "    assert!(cache.0.is_some());",
                "    assert_eq!(input.haystack, &[5, 6, 7]);",
                "    assert_eq!(input.span.start, 0);",
                "    assert_eq!(input.span.end, 3);",
                "    assert!(input.anchored == Anchored::True);",
                "    assert!(input.earliest);",
                "    assert_eq!(patset.len, 0);",
                "    assert!(patset.which.is_empty());",
                "    assert!(pike_vm.0.0.is_match(&mut cache, &input));"
              ],
              "code": [
                "{",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input {",
                "        haystack: &[5, 6, 7],",
                "        span: Span::new(0, 3),",
                "        anchored: Anchored::True,",
                "        earliest: true,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 0,",
                "        which: alloc::boxed::Box::new([]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "    assert!(cache.0.is_some());",
                "    assert_eq!(input.haystack, &[5, 6, 7]);",
                "    assert_eq!(input.span.start, 0);",
                "    assert_eq!(input.span.end, 3);",
                "    assert!(input.anchored == Anchored::True);",
                "    assert!(input.earliest);",
                "    assert_eq!(patset.len, 0);",
                "    assert!(patset.which.is_empty());",
                "    assert!(pike_vm.0.0.is_match(&mut cache, &input));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input {",
                "        haystack: &[8, 9, 10, 11],",
                "        span: Span::new(0, 4),",
                "        anchored: Anchored::False,",
                "        earliest: false,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 2,",
                "        which: alloc::boxed::Box::new([true, false]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "}"
              ],
              "oracle": [
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input { haystack: &[8, 9, 10, 11], span: Span::new(0, 4), anchored: Anchored::False, earliest: false };",
                "    let mut patset = PatternSet { len: 2, which: alloc::boxed::Box::new([true, false]) };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);"
              ],
              "code": [
                "{",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input {",
                "        haystack: &[8, 9, 10, 11],",
                "        span: Span::new(0, 4),",
                "        anchored: Anchored::False,",
                "        earliest: false,",
                "    };",
                "    let mut patset = PatternSet {",
                "        len: 2,",
                "        which: alloc::boxed::Box::new([true, false]),",
                "    };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "    let mut cache = PikeVMCache(Some(pikevm::Cache {}));",
                "    let input = Input { haystack: &[8, 9, 10, 11], span: Span::new(0, 4), anchored: Anchored::False, earliest: false };",
                "    let mut patset = PatternSet { len: 2, which: alloc::boxed::Box::new([true, false]) };",
                "    let pike_vm = PikeVM(PikeVMEngine(pikevm::PikeVM {}));",
                "    pike_vm.which_overlapping_matches(&mut cache, &input, &mut patset);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}