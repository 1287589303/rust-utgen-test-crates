{
  "name": "regex_automata::nfa::thompson::pikevm::{impl#1}::build_from_nfa",
  "mod_info": {
    "name": "nfa::thompson::pikevm",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:68:1:68:16"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/pikevm.rs:279:5:282:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: nfa.look_set_any().available().map_err(BuildError::word)? at line 280 is Err/None\n"
      ],
      "input_infer": "nfa input should trigger available() error handling by containing a word in look_set_any(), covering edge cases with both valid and invalid NFA instances and varying look sets.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let result = builder.build_from_nfa(nfa);",
                "}"
              ],
              "oracle": [
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert!(result.is_ok());",
                "    let nfa_invalid = NFA::never_match();",
                "    let result_invalid = builder.build_from_nfa(nfa_invalid);",
                "    assert!(result_invalid.is_err());",
                "    assert!(matches!(result_invalid.unwrap_err().kind, BuildErrorKind::Word));",
                "    let empty_nfa = NFA::new(\"\");",
                "    let result_empty = builder.build_from_nfa(empty_nfa.unwrap());",
                "    assert!(result_empty.is_err());",
                "    assert!(matches!(result_empty.unwrap_err().kind, BuildErrorKind::Word));"
              ],
              "code": [
                "{",
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let result = builder.build_from_nfa(nfa);",
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert!(result.is_ok());",
                "    let nfa_invalid = NFA::never_match();",
                "    let result_invalid = builder.build_from_nfa(nfa_invalid);",
                "    assert!(result_invalid.is_err());",
                "    assert!(matches!(result_invalid.unwrap_err().kind, BuildErrorKind::Word));",
                "    let empty_nfa = NFA::new(\"\");",
                "    let result_empty = builder.build_from_nfa(empty_nfa.unwrap());",
                "    assert!(result_empty.is_err());",
                "    assert!(matches!(result_empty.unwrap_err().kind, BuildErrorKind::Word));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let builder = Builder::new();",
                "    let mut nfa = NFA::always_match();",
                "    let look_set = LookSet::singleton(Look::Word);",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "}"
              ],
              "oracle": [
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let look_set = LookSet::singleton(Look::Word);",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Word);"
              ],
              "code": [
                "{",
                "    let builder = Builder::new();",
                "    let mut nfa = NFA::always_match();",
                "    let look_set = LookSet::singleton(Look::Word);",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let look_set = LookSet::singleton(Look::Word);",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Word);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let builder = Builder::new();",
                "    let mut nfa = NFA::always_match();",
                "    let look_set = LookSet::full();",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "}"
              ],
              "oracle": [
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let look_set = LookSet::empty();",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(BuildError::word(_))));"
              ],
              "code": [
                "{",
                "    let builder = Builder::new();",
                "    let mut nfa = NFA::always_match();",
                "    let look_set = LookSet::full();",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let look_set = LookSet::empty();",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(BuildError::word(_))));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let builder = Builder::new();",
                "    let mut nfa = NFA::always_match();",
                "    let look_set = LookSet::empty();",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Word);"
              ],
              "code": [
                "{",
                "    let builder = Builder::new();",
                "    let mut nfa = NFA::always_match();",
                "    let look_set = LookSet::empty();",
                "    nfa.0.look_set_any = look_set;",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::Word);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: nfa.look_set_any().available().map_err(BuildError::word)? at line 280 is Ok/Some\n",
        "expected return value/type: Ok(PikeVM { config: self.config.clone(), nfa })\n"
      ],
      "input_infer": "Valid test input conditions or ranges: NFA instances with LookSet containing no unicode word boundaries, and valid configurations including any valid NFA structure with states and transitions.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let result = builder.build_from_nfa(nfa);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    let pikevm = result.unwrap();",
                "    assert_eq!(pikevm.nfa, nfa);",
                "    assert_eq!(pikevm.config, builder.config);"
              ],
              "code": [
                "{",
                "    let builder = Builder::new();",
                "    let nfa = NFA::always_match();",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert!(result.is_ok());",
                "    let pikevm = result.unwrap();",
                "    assert_eq!(pikevm.nfa, nfa);",
                "    assert_eq!(pikevm.config, builder.config);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let builder = Builder::new();",
                "    let nfa = NFA::never_match();",
                "    let result = builder.build_from_nfa(nfa);",
                "}"
              ],
              "oracle": [
                "    result.is_ok();",
                "    result.unwrap().nfa == NFA::never_match();",
                "    result.unwrap().config == builder.config;"
              ],
              "code": [
                "{",
                "    let builder = Builder::new();",
                "    let nfa = NFA::never_match();",
                "    let result = builder.build_from_nfa(nfa);",
                "    result.is_ok();",
                "    result.unwrap().nfa == NFA::never_match();",
                "    result.unwrap().config == builder.config;",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let builder = Builder::new();",
                "    let mut nfa = NFA::always_match();",
                "    // Add a custom state and transitions to the NFA",
                "    // (Filling the NFA with valid configurations as needed for the test)",
                "    let result = builder.build_from_nfa(nfa);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Ok(PikeVM { config: builder.config.clone(), nfa }));",
                "    assert!(nfa.look_set_any().available().is_ok());",
                "    assert!(nfa.pattern_len() > 0);",
                "    assert!(builder.config.match_kind.is_none());",
                "    assert_eq!(builder.config.starts_for_each_pattern, None);",
                "    assert!(!builder.config.byte_classes.unwrap_or(false));",
                "    assert!(nfa.has_empty());",
                "    assert!(nfa.is_utf8());",
                "    assert!(!nfa.is_reverse());",
                "    assert!(nfa.is_always_start_anchored());",
                "    assert!(builder.build_from_nfa(nfa.clone()).is_ok());"
              ],
              "code": [
                "{",
                "    let builder = Builder::new();",
                "    let mut nfa = NFA::always_match();",
                "    // Add a custom state and transitions to the NFA",
                "    // (Filling the NFA with valid configurations as needed for the test)",
                "    let result = builder.build_from_nfa(nfa);",
                "    assert_eq!(result, Ok(PikeVM { config: builder.config.clone(), nfa }));",
                "    assert!(nfa.look_set_any().available().is_ok());",
                "    assert!(nfa.pattern_len() > 0);",
                "    assert!(builder.config.match_kind.is_none());",
                "    assert_eq!(builder.config.starts_for_each_pattern, None);",
                "    assert!(!builder.config.byte_classes.unwrap_or(false));",
                "    assert!(nfa.has_empty());",
                "    assert!(nfa.is_utf8());",
                "    assert!(!nfa.is_reverse());",
                "    assert!(nfa.is_always_start_anchored());",
                "    assert!(builder.build_from_nfa(nfa.clone()).is_ok());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}