{
  "name": "regex_syntax::hir::literal::{impl#11}::fmt",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:42:1:42:17"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/literal.rs:2176:5:2181:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.exact at line 2177 is true\n"
      ],
      "input_infer": "self.exact = true; bytes = empty Vec<u8>, bytes = single element Vec<u8> (e.g., Vec<u8>::from([0x01])), bytes = multiple elements Vec<u8> (e.g., Vec<u8>::from([0x01, 0x02, 0x03]))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal::exact(Vec::new());",
                "    let _ = core::fmt::format(format_args!(\"{:?}\", lit));",
                "}"
              ],
              "oracle": [
                "    let lit = Literal::exact(Vec::new());",
                "    let result = core::fmt::format(format_args!(\"{:?}\", lit));",
                "    assert_eq!(result, \"E([])\");"
              ],
              "code": [
                "{",
                "    let lit = Literal::exact(Vec::new());",
                "    let _ = core::fmt::format(format_args!(\"{:?}\", lit));",
                "    let lit = Literal::exact(Vec::new());",
                "    let result = core::fmt::format(format_args!(\"{:?}\", lit));",
                "    assert_eq!(result, \"E([])\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal::exact(Vec::from([0x01]));",
                "    let _ = core::fmt::format(format_args!(\"{:?}\", lit));",
                "}"
              ],
              "oracle": [
                "    let lit = Literal::exact(Vec::from([0x01]));",
                "    assert_eq!(lit.is_exact(), true);",
                "    assert_eq!(lit.as_bytes(), &[0x01]);",
                "    assert_eq!(core::fmt::format(format_args!(\"{:?}\", lit)), \"E(01)\");"
              ],
              "code": [
                "{",
                "    let lit = Literal::exact(Vec::from([0x01]));",
                "    let _ = core::fmt::format(format_args!(\"{:?}\", lit));",
                "    let lit = Literal::exact(Vec::from([0x01]));",
                "    assert_eq!(lit.is_exact(), true);",
                "    assert_eq!(lit.as_bytes(), &[0x01]);",
                "    assert_eq!(core::fmt::format(format_args!(\"{:?}\", lit)), \"E(01)\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal::exact(Vec::from([0x01, 0x02, 0x03]));",
                "    let _ = core::fmt::format(format_args!(\"{:?}\", lit));",
                "}"
              ],
              "oracle": [
                "    let lit = Literal::exact(Vec::from([0x01, 0x02, 0x03]));",
                "    assert_eq!(lit.is_exact(), true);",
                "    assert_eq!(lit.as_bytes(), &[0x01, 0x02, 0x03]);",
                "    let formatted = core::fmt::format(format_args!(\"{:?}\", lit));",
                "    assert!(formatted.contains(\"E\"));",
                "    assert!(!formatted.contains(\"I\"));"
              ],
              "code": [
                "{",
                "    let lit = Literal::exact(Vec::from([0x01, 0x02, 0x03]));",
                "    let _ = core::fmt::format(format_args!(\"{:?}\", lit));",
                "    let lit = Literal::exact(Vec::from([0x01, 0x02, 0x03]));",
                "    assert_eq!(lit.is_exact(), true);",
                "    assert_eq!(lit.as_bytes(), &[0x01, 0x02, 0x03]);",
                "    let formatted = core::fmt::format(format_args!(\"{:?}\", lit));",
                "    assert!(formatted.contains(\"E\"));",
                "    assert!(!formatted.contains(\"I\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.exact at line 2177 is false\n"
      ],
      "input_infer": "self.exact is false with bytes as an empty Vec<u8>, bytes with a single element, bytes with multiple elements, and bytes containing special characters.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = Literal::inexact(vec![]);",
                "    let mut formatter = core::fmt::Formatter::new();",
                "    let _ = literal.fmt(&mut formatter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(literal.is_exact(), false);",
                "    assert_eq!(formatter.to_string(), \"I\");",
                "    assert_eq!(literal.as_bytes().len(), 0);",
                "    assert!(literal.is_empty());",
                "    assert!(formatter.write_str(\"I\").is_ok());"
              ],
              "code": [
                "{",
                "    let literal = Literal::inexact(vec![]);",
                "    let mut formatter = core::fmt::Formatter::new();",
                "    let _ = literal.fmt(&mut formatter);",
                "    assert_eq!(literal.is_exact(), false);",
                "    assert_eq!(formatter.to_string(), \"I\");",
                "    assert_eq!(literal.as_bytes().len(), 0);",
                "    assert!(literal.is_empty());",
                "    assert!(formatter.write_str(\"I\").is_ok());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = Literal::inexact(vec![42]);",
                "    let mut formatter = core::fmt::Formatter::new();",
                "    let _ = literal.fmt(&mut formatter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(literal.as_bytes(), &[42]);",
                "    assert_eq!(literal.is_exact(), false);",
                "    assert!(formatter.output().contains(\"I\"));"
              ],
              "code": [
                "{",
                "    let literal = Literal::inexact(vec![42]);",
                "    let mut formatter = core::fmt::Formatter::new();",
                "    let _ = literal.fmt(&mut formatter);",
                "    assert_eq!(literal.as_bytes(), &[42]);",
                "    assert_eq!(literal.is_exact(), false);",
                "    assert!(formatter.output().contains(\"I\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = Literal::inexact(vec![1, 2, 3, 4, 5]);",
                "    let mut formatter = core::fmt::Formatter::new();",
                "    let _ = literal.fmt(&mut formatter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(literal.is_exact(), false);",
                "    assert_eq!(formatter.debug_tuple(\"I\").field(&crate::debug::Bytes(literal.as_bytes())).finish(), Ok(()));",
                "    assert_eq!(formatter.debug_tuple(\"I\").field(&crate::debug::Bytes(literal.as_bytes())).finish().is_ok(), true);",
                "    assert_eq!(literal.as_bytes(), &[1, 2, 3, 4, 5]);",
                "    assert_eq!(literal.len(), 5);",
                "    assert_eq!(literal.is_empty(), false);"
              ],
              "code": [
                "{",
                "    let literal = Literal::inexact(vec![1, 2, 3, 4, 5]);",
                "    let mut formatter = core::fmt::Formatter::new();",
                "    let _ = literal.fmt(&mut formatter);",
                "    assert_eq!(literal.is_exact(), false);",
                "    assert_eq!(formatter.debug_tuple(\"I\").field(&crate::debug::Bytes(literal.as_bytes())).finish(), Ok(()));",
                "    assert_eq!(formatter.debug_tuple(\"I\").field(&crate::debug::Bytes(literal.as_bytes())).finish().is_ok(), true);",
                "    assert_eq!(literal.as_bytes(), &[1, 2, 3, 4, 5]);",
                "    assert_eq!(literal.len(), 5);",
                "    assert_eq!(literal.is_empty(), false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = Literal::inexact(vec![b'!', b'@', b'#', b'$']);",
                "    let mut formatter = core::fmt::Formatter::new();",
                "    let _ = literal.fmt(&mut formatter);",
                "}"
              ],
              "oracle": [
                "    let literal = Literal::inexact(vec![b'!', b'@', b'#', b'$']);",
                "    let result = literal.fmt(&mut formatter);",
                "    assert_eq!(result.is_ok(), true);",
                "    assert_eq!(formatter.output(), \"I\");"
              ],
              "code": [
                "{",
                "    let literal = Literal::inexact(vec![b'!', b'@', b'#', b'$']);",
                "    let mut formatter = core::fmt::Formatter::new();",
                "    let _ = literal.fmt(&mut formatter);",
                "    let literal = Literal::inexact(vec![b'!', b'@', b'#', b'$']);",
                "    let result = literal.fmt(&mut formatter);",
                "    assert_eq!(result.is_ok(), true);",
                "    assert_eq!(formatter.output(), \"I\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}