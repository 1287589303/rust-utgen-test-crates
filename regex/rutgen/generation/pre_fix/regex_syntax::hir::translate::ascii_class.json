{
  "name": "regex_syntax::hir::translate::ascii_class",
  "mod_info": {
    "name": "hir::translate",
    "loc": "regex-syntax/src/hir/mod.rs:44:1:44:19"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/translate.rs:1323:1:1350:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: *kind matches Xdigit at line 1326 is true\n"
      ],
      "input_infer": "kind = ast::ClassAsciiKind::Xdigit\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let iterator = ascii_class(&kind);",
                "    let result: Vec<(u8, u8)> = iterator.collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let iterator = ascii_class(&kind);",
                "    let result: Vec<(u8, u8)> = iterator.collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let iterator = ascii_class(&kind);",
                "    let result: Vec<(u8, u8)> = iterator.collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let iterator = ascii_class(&kind);",
                "    let result: Vec<(u8, u8)> = iterator.collect();",
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: *kind matches Word at line 1326 is true\n",
        "precondition: *kind matches Word at line 1326 is true\n"
      ],
      "input_infer": "kind values should be limited to the variant enum ClassAsciiKind::Word only\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let _result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result: Vec<(u8, u8)> = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
                "    assert_eq!(_result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let _result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result: Vec<(u8, u8)> = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
                "    assert_eq!(_result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let _result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let _result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(_result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: *kind matches Upper at line 1326 is true\n",
        "precondition: *kind matches Upper at line 1326 is true\n"
      ],
      "input_infer": "kind must be ClassAsciiKind::Upper\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    result == vec![(b'A', b'Z')]"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    result == vec![(b'A', b'Z')]",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "precondition: *kind matches Space at line 1326 is true\n",
        "precondition: *kind matches Space at line 1326 is true\n"
      ],
      "input_infer": "The test input conditions or ranges are: Space, which includes tab (b'\\t', b'\\t'), newline (b'\\n', b'\\n'), vertical tab (b'\\x0B', b'\\x0B'), form feed (b'\\x0C', b'\\x0C'), carriage return (b'\\r', b'\\r'), and space (b' ', b' ').\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    // Call result here for testing purposes",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    // Call result here for testing purposes",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    // Call result here for testing purposes",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    // Call result here for testing purposes",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "precondition: *kind matches Punct at line 1326 is true\n",
        "precondition: *kind matches Punct at line 1326 is true\n"
      ],
      "input_infer": "Input conditions: kind must be ClassAsciiKind::Punct\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result_alnum = vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result_alnum);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_alpha = vec![(b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result_alpha);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_ascii = vec![(b'\\x00', b'\\x7F')];",
                "    assert_eq!(result, expected_result_ascii);",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_blank = vec![(b'\\t', b'\\t'), (b' ', b' ')];",
                "    assert_eq!(result, expected_result_blank);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_cntrl = vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')];",
                "    assert_eq!(result, expected_result_cntrl);",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_digit = vec![(b'0', b'9')];",
                "    assert_eq!(result, expected_result_digit);",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_graph = vec![(b'!', b'~')];",
                "    assert_eq!(result, expected_result_graph);",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_lower = vec![(b'a', b'z')];",
                "    assert_eq!(result, expected_result_lower);",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_print = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result_print);",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_punct = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
                "    assert_eq!(result, expected_result_punct);",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_space = vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')];",
                "    assert_eq!(result, expected_result_space);",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_upper = vec![(b'A', b'Z')];",
                "    assert_eq!(result, expected_result_upper);",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_word = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result_word);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_xdigit = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
                "    assert_eq!(result, expected_result_xdigit);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_alnum = vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result_alnum);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_alpha = vec![(b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result_alpha);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_ascii = vec![(b'\\x00', b'\\x7F')];",
                "    assert_eq!(result, expected_result_ascii);",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_blank = vec![(b'\\t', b'\\t'), (b' ', b' ')];",
                "    assert_eq!(result, expected_result_blank);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_cntrl = vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')];",
                "    assert_eq!(result, expected_result_cntrl);",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_digit = vec![(b'0', b'9')];",
                "    assert_eq!(result, expected_result_digit);",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_graph = vec![(b'!', b'~')];",
                "    assert_eq!(result, expected_result_graph);",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_lower = vec![(b'a', b'z')];",
                "    assert_eq!(result, expected_result_lower);",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_print = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result_print);",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_punct = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
                "    assert_eq!(result, expected_result_punct);",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_space = vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')];",
                "    assert_eq!(result, expected_result_space);",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_upper = vec![(b'A', b'Z')];",
                "    assert_eq!(result, expected_result_upper);",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_word = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result_word);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_xdigit = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
                "    assert_eq!(result, expected_result_xdigit);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert!(result.len() > 0);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert!(result.len() > 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Punct;",
                "    let expected = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct;",
                "    let expected = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result.len(), 4);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.iter().all(|&(start, end)| start <= end));",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'!', b'/')));",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b':', b'@')));",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'[', b'`')));",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'{', b'~')));"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result.len(), 4);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.iter().all(|&(start, end)| start <= end));",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'!', b'/')));",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b':', b'@')));",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'[', b'`')));",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'{', b'~')));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Alnum;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Alnum;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected = vec![",
                "    (b'\\t', b'\\t'),",
                "    (b'\\n', b'\\n'),",
                "    (b'\\x0B', b'\\x0B'),",
                "    (b'\\x0C', b'\\x0C'),",
                "    (b'\\r', b'\\r'),",
                "    (b' ', b' ')",
                "    ];",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected = vec![",
                "    (b'\\t', b'\\t'),",
                "    (b'\\n', b'\\n'),",
                "    (b'\\x0B', b'\\x0B'),",
                "    (b'\\x0C', b'\\x0C'),",
                "    (b'\\r', b'\\r'),",
                "    (b' ', b' ')",
                "    ];",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "precondition: *kind matches Print at line 1326 is true\n",
        "precondition: *kind matches Print at line 1326 is true\n"
      ],
      "input_infer": "*kind must be of type &ast::ClassAsciiKind with a value of ClassAsciiKind::Print to return the range (b' ', b'~')\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b' ', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum;",
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let expected_result = vec![(b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let expected_result = vec![(b'\\x00', b'\\x7F')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    let expected_result = vec![(b'\\t', b'\\t'), (b' ', b' ')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let expected_result = vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    let expected_result = vec![(b'0', b'9')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    let expected_result = vec![(b'!', b'~')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    let expected_result = vec![(b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    let expected_result = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    let expected_result = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    let expected_result = vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    let expected_result = vec![(b'A', b'Z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let expected_result = vec![(b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let expected_result = vec![(b'\\x00', b'\\x7F')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    let expected_result = vec![(b'\\t', b'\\t'), (b' ', b' ')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let expected_result = vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    let expected_result = vec![(b'0', b'9')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    let expected_result = vec![(b'!', b'~')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    let expected_result = vec![(b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    let expected_result = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    let expected_result = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    let expected_result = vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    let expected_result = vec![(b'A', b'Z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Ascii;",
                "    let expected_result: Vec<(u8, u8)> = vec![(b'\\x00', b'\\x7F')];",
                "    assert_eq!(result, expected_result);",
                "    let kind = ClassAsciiKind::Print;",
                "    let expected_result: Vec<(u8, u8)> = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let expected_result: Vec<(u8, u8)> = vec![(b'\\x00', b'\\x7F')];",
                "    assert_eq!(result, expected_result);",
                "    let kind = ClassAsciiKind::Print;",
                "    let expected_result: Vec<(u8, u8)> = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(0x00, 0x1F), (0x7F, 0x7F)]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0x00, 0x1F), (0x7F, 0x7F)]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Print;",
                "    let expected = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Print;",
                "    let expected = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    result.assert_eq(vec![(b'!', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    result.assert_eq(vec![(b'!', b'~')]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    result[0] == (b'a', b'z')",
                "    result.len() == 1"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    result[0] == (b'a', b'z')",
                "    result.len() == 1",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result_upper: Vec<(u8, u8)> = vec![(b'A', b'Z')];",
                "    assert_eq!(result, expected_result_upper);",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_print: Vec<(u8, u8)> = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result_print);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_upper: Vec<(u8, u8)> = vec![(b'A', b'Z')];",
                "    assert_eq!(result, expected_result_upper);",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_print: Vec<(u8, u8)> = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result_print);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Word;",
                "    let expected_result: Vec<(u8, u8)> = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Word;",
                "    let expected_result: Vec<(u8, u8)> = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')])",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')])"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')])",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')])",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "precondition: *kind matches Lower at line 1326 is true\n",
        "precondition: *kind matches Lower at line 1326 is true\n"
      ],
      "input_infer": "*kind must be one of the variants from ClassAsciiKind enum: Alnum, Alpha, Ascii, Blank, Cntrl, Digit, Graph, Lower, Print, Punct, Space, Upper, Word, Xdigit.\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result == vec![(b'A', b'Z'), (b'a', b'z')]",
                "    let kind = ClassAsciiKind::Ascii;",
                "    result == vec![(b'\\x00', b'\\x7F')]",
                "    let kind = ClassAsciiKind::Blank;",
                "    result == vec![(b'\\t', b'\\t'), (b' ', b' ')]",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result == vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]",
                "    let kind = ClassAsciiKind::Digit;",
                "    result == vec![(b'0', b'9')]",
                "    let kind = ClassAsciiKind::Graph;",
                "    result == vec![(b'!', b'~')]",
                "    let kind = ClassAsciiKind::Lower;",
                "    result == vec![(b'a', b'z')]",
                "    let kind = ClassAsciiKind::Print;",
                "    result == vec![(b' ', b'~')]",
                "    let kind = ClassAsciiKind::Punct;",
                "    result == vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]",
                "    let kind = ClassAsciiKind::Space;",
                "    result == vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]",
                "    let kind = ClassAsciiKind::Upper;",
                "    result == vec![(b'A', b'Z')]",
                "    let kind = ClassAsciiKind::Word;",
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result == vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result == vec![(b'A', b'Z'), (b'a', b'z')]",
                "    let kind = ClassAsciiKind::Ascii;",
                "    result == vec![(b'\\x00', b'\\x7F')]",
                "    let kind = ClassAsciiKind::Blank;",
                "    result == vec![(b'\\t', b'\\t'), (b' ', b' ')]",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result == vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]",
                "    let kind = ClassAsciiKind::Digit;",
                "    result == vec![(b'0', b'9')]",
                "    let kind = ClassAsciiKind::Graph;",
                "    result == vec![(b'!', b'~')]",
                "    let kind = ClassAsciiKind::Lower;",
                "    result == vec![(b'a', b'z')]",
                "    let kind = ClassAsciiKind::Print;",
                "    result == vec![(b' ', b'~')]",
                "    let kind = ClassAsciiKind::Punct;",
                "    result == vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]",
                "    let kind = ClassAsciiKind::Space;",
                "    result == vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]",
                "    let kind = ClassAsciiKind::Upper;",
                "    result == vec![(b'A', b'Z')]",
                "    let kind = ClassAsciiKind::Word;",
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result == vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(0, 31), (127, 127)]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0, 31), (127, 127)]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(0, 127)]);",
                "    ",
                "    let kind = ClassAsciiKind::Alnum;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(48, 57), (65, 90), (97, 122)]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(65, 90), (97, 122)]);",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(9, 9), (32, 32)]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0, 31), (127, 127)]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(48, 57)]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(33, 126)]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(97, 122)]);",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(32, 126)]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(33, 47), (58, 64), (91, 96), (123, 126)]);",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (32, 32)]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(65, 90)]);",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(48, 57), (65, 90), (95, 95), (97, 122)]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(48, 57), (65, 70), (97, 102)]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0, 127)]);",
                "    ",
                "    let kind = ClassAsciiKind::Alnum;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(48, 57), (65, 90), (97, 122)]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(65, 90), (97, 122)]);",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(9, 9), (32, 32)]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0, 31), (127, 127)]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(48, 57)]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(33, 126)]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(97, 122)]);",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(32, 126)]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(33, 47), (58, 64), (91, 96), (123, 126)]);",
                "    ",
                "    let kind = ClassAsciiKind::Space;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (32, 32)]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(65, 90)]);",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(48, 57), (65, 90), (95, 95), (97, 122)]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(48, 57), (65, 70), (97, 102)]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "precondition: *kind matches Graph at line 1326 is true\n",
        "precondition: *kind matches Graph at line 1326 is true\n"
      ],
      "input_infer": "*kind = Graph\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result: Vec<(u8, u8)> = vec![(b'!', b'~')];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result: Vec<(u8, u8)> = vec![(b'!', b'~')];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "precondition: *kind matches Digit at line 1326 is true\n",
        "precondition: *kind matches Digit at line 1326 is true\n"
      ],
      "input_infer": "kind must be one of the valid variants from the ClassAsciiKind enum, specifically Digit\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ast::ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ast::ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    let kind = ast::ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    result assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    result assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Digit;",
                "    let expected = vec![(b'0', b'9')];",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Digit;",
                "    let expected = vec![(b'0', b'9')];",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "precondition: *kind matches Cntrl at line 1326 is true\n",
        "precondition: *kind matches Cntrl at line 1326 is true\n"
      ],
      "input_infer": "Test input conditions or ranges: kind should equal ast::ClassAsciiKind::Cntrl.\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result: Vec<(u8, u8)> = vec![(0, 31), (127, 127)];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result: Vec<(u8, u8)> = vec![(0, 31), (127, 127)];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(0x00, 0x1F), (0x7F, 0x7F)]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0x00, 0x1F), (0x7F, 0x7F)]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "precondition: *kind matches Blank at line 1326 is true\n",
        "precondition: *kind matches Blank at line 1326 is true\n"
      ],
      "input_infer": "ClassAsciiKind::Blank\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(0, 127)]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0, 31), (127, 127)]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0, 127)]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(0, 31), (127, 127)]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    result == vec![(b'a', b'z')]",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'A', b'Z')]",
                "    ",
                "    let kind = ClassAsciiKind::Alnum;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9')]",
                "    ",
                "    let kind = ClassAsciiKind::Ascii;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'\\x00', b'\\x7F')]",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'!', b'~')]",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'\\t', b'\\t'), (b' ', b' ')]",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b' ', b'~')]",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    result == vec![(b'a', b'z')]",
                "    ",
                "    let kind = ClassAsciiKind::Upper;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'A', b'Z')]",
                "    ",
                "    let kind = ClassAsciiKind::Alnum;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]",
                "    ",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9')]",
                "    ",
                "    let kind = ClassAsciiKind::Ascii;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'\\x00', b'\\x7F')]",
                "    ",
                "    let kind = ClassAsciiKind::Graph;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'!', b'~')]",
                "    ",
                "    let kind = ClassAsciiKind::Blank;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'\\t', b'\\t'), (b' ', b' ')]",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]",
                "    ",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]",
                "    ",
                "    let kind = ClassAsciiKind::Print;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b' ', b'~')]",
                "    ",
                "    let kind = ClassAsciiKind::Word;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<_>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    result == vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    result == vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "precondition: *kind matches Ascii at line 1326 is true\n",
        "precondition: *kind matches Ascii at line 1326 is true\n"
      ],
      "input_infer": "kind can be any variant of ast::ClassAsciiKind: Alnum, Alpha, Ascii, Blank, Cntrl, Digit, Graph, Lower, Print, Punct, Space, Upper, Word, Xdigit\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Alnum;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    let kind = ast::ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ast::ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ast::ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ast::ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    let kind = ast::ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ast::ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    let kind = ast::ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Alnum;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    let kind = ast::ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ast::ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ast::ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ast::ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    let kind = ast::ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ast::ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    let kind = ast::ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Alpha;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    let kind = ast::ClassAsciiKind::Ascii;",
                "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Alpha;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    let kind = ast::ClassAsciiKind::Ascii;",
                "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Ascii;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    let kind = ast::ClassAsciiKind::Ascii;",
                "    let expected = vec![(b'\\x00', b'\\x7F')];",
                "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Ascii;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    let kind = ast::ClassAsciiKind::Ascii;",
                "    let expected = vec![(b'\\x00', b'\\x7F')];",
                "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Blank;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Blank;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Cntrl;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Cntrl;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Digit;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Digit;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Graph;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Graph;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Lower;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Lower;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Print;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Print;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Punct;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Punct;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Space;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Space;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Upper;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Upper;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Word;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    let kind = ast::ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ast::ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ast::ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ast::ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    let kind = ast::ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ast::ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    let kind = ast::ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Word;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    let kind = ast::ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ast::ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ast::ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ast::ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    let kind = ast::ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ast::ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ast::ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    let kind = ast::ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ast::ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = ast::ClassAsciiKind::Xdigit;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    let kind = ast::ClassAsciiKind::Xdigit;",
                "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 13,
      "prompt_conds": [
        "precondition: *kind matches Alpha at line 1326 is true\n",
        "precondition: *kind matches Alpha at line 1326 is true\n"
      ],
      "input_infer": "kind = Alpha\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    result == vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result = vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')];",
                "    assert_eq!(result, expected_result);",
                "    let kind_alpha = ClassAsciiKind::Alpha;",
                "    let result_alpha: Vec<(u8, u8)> = ascii_class(&kind_alpha).collect();",
                "    let expected_result_alpha = vec![(b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result_alpha, expected_result_alpha);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result = vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')];",
                "    assert_eq!(result, expected_result);",
                "    let kind_alpha = ClassAsciiKind::Alpha;",
                "    let result_alpha: Vec<(u8, u8)> = ascii_class(&kind_alpha).collect();",
                "    let expected_result_alpha = vec![(b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result_alpha, expected_result_alpha);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected = vec![(b'0', b'9')];",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected = vec![(b'0', b'9')];",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Graph;",
                "    let expected_result = vec![(b'!', b'~')];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Graph;",
                "    let expected_result = vec![(b'!', b'~')];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected_result_lower: Vec<(u8, u8)> = vec![(b'a', b'z')];",
                "    assert_eq!(result, expected_result_lower);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected_result_lower: Vec<(u8, u8)> = vec![(b'a', b'z')];",
                "    assert_eq!(result, expected_result_lower);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b' ', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Print;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected = vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')];",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Space;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected = vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')];",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Word;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let expected = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
                "    let expected = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 14,
      "prompt_conds": [
        "precondition: *kind matches Alnum at line 1326 is true\n",
        "precondition: *kind matches Alnum at line 1326 is true\n"
      ],
      "input_infer": "kind must be one of the enum variants from ClassAsciiKind: Alnum, Alpha, Ascii, Blank, Cntrl, Digit, Graph, Lower, Print, Punct, Space, Upper, Word, Xdigit\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    let expected_result = vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')];",
                "    assert_eq!(result, expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(0, 127)]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(0, 127)]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Digit;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'!', b'~')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Graph;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Lower;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Print;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    let expected = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Print;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    let expected = vec![(b' ', b'~')];",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Blank; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Print; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Space; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Word; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Punct;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    let kind = ClassAsciiKind::Alnum; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Blank; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'0', b'9')]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'!', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Print; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b' ', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Space; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'A', b'Z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Word; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit; let result = ascii_class(&kind).collect::<Vec<_>>(); assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Space;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Alnum;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Space;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Alnum;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'~')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b' ', b'~')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'A', b'Z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Upper;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'A', b'Z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let result = ascii_class(&kind).collect::<Vec<_>>();",
                "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}