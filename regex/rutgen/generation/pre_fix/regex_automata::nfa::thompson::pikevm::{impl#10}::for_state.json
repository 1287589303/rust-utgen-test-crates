{
  "name": "regex_automata::nfa::thompson::pikevm::{impl#10}::for_state",
  "mod_info": {
    "name": "nfa::thompson::pikevm",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:68:1:68:16"
  },
  "visible": false,
  "loc": "regex-automata/src/nfa/thompson/pikevm.rs:2147:5:2150:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: &mut self.table[i..i + self.slots_for_captures]\n"
      ],
      "input_infer": "sid: StateID with value in the range [0, (self.table.len() / self.slots_per_state) - 1], self.slots_per_state > 0, self.slots_for_captures in the range [1, self.slots_per_state]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slots_per_state = 2;",
                "    let slots_for_captures = 1;",
                "    let mut slot_table = SlotTable {",
                "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 6],",
                "        slots_per_state,",
                "        slots_for_captures,",
                "    };",
                "    let state_id = StateID(SmallIndex::new(1));",
                "    let result = slot_table.for_state(state_id);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.len(), slots_for_captures);",
                "    assert_eq!(result[0], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
                "    assert_eq!(result.as_ptr(), &slot_table.table[slots_per_state * state_id.0.as_usize()] as *const _);",
                "    assert!(result.iter().all(|&slot| slot.is_some()));",
                "    let empty_state_id = StateID(SmallIndex::new(3));",
                "    let result_empty = slot_table.for_state(empty_state_id);",
                "    assert_eq!(result_empty.len(), slots_for_captures);",
                "    assert!(result_empty.iter().all(|&slot| slot.is_none()));"
              ],
              "code": [
                "{",
                "    let slots_per_state = 2;",
                "    let slots_for_captures = 1;",
                "    let mut slot_table = SlotTable {",
                "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 6],",
                "        slots_per_state,",
                "        slots_for_captures,",
                "    };",
                "    let state_id = StateID(SmallIndex::new(1));",
                "    let result = slot_table.for_state(state_id);",
                "    assert_eq!(result.len(), slots_for_captures);",
                "    assert_eq!(result[0], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
                "    assert_eq!(result.as_ptr(), &slot_table.table[slots_per_state * state_id.0.as_usize()] as *const _);",
                "    assert!(result.iter().all(|&slot| slot.is_some()));",
                "    let empty_state_id = StateID(SmallIndex::new(3));",
                "    let result_empty = slot_table.for_state(empty_state_id);",
                "    assert_eq!(result_empty.len(), slots_for_captures);",
                "    assert!(result_empty.iter().all(|&slot| slot.is_none()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slots_per_state = 3;",
                "    let slots_for_captures = 2;",
                "    let mut slot_table = SlotTable {",
                "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 9],",
                "        slots_per_state,",
                "        slots_for_captures,",
                "    };",
                "    let state_id = StateID(SmallIndex::new(0));",
                "    let result = slot_table.for_state(state_id);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.len(), slots_for_captures);",
                "    assert_eq!(result[0], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
                "    assert_eq!(result[1], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
                "    assert_eq!(result.as_ptr() as usize % std::mem::size_of::<Option<NonMaxUsize>>() == 0, true);",
                "    assert!(std::ptr::eq(result, &mut slot_table.table[0..slots_for_captures]));",
                "    assert_eq!(slot_table.for_state(StateID(SmallIndex::new(1))).len(), slots_for_captures);",
                "    assert!(slot_table.for_state(StateID(SmallIndex::new(2))).is_empty());"
              ],
              "code": [
                "{",
                "    let slots_per_state = 3;",
                "    let slots_for_captures = 2;",
                "    let mut slot_table = SlotTable {",
                "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 9],",
                "        slots_per_state,",
                "        slots_for_captures,",
                "    };",
                "    let state_id = StateID(SmallIndex::new(0));",
                "    let result = slot_table.for_state(state_id);",
                "    assert_eq!(result.len(), slots_for_captures);",
                "    assert_eq!(result[0], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
                "    assert_eq!(result[1], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
                "    assert_eq!(result.as_ptr() as usize % std::mem::size_of::<Option<NonMaxUsize>>() == 0, true);",
                "    assert!(std::ptr::eq(result, &mut slot_table.table[0..slots_for_captures]));",
                "    assert_eq!(slot_table.for_state(StateID(SmallIndex::new(1))).len(), slots_for_captures);",
                "    assert!(slot_table.for_state(StateID(SmallIndex::new(2))).is_empty());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slots_per_state = 4;",
                "    let slots_for_captures = 3;",
                "    let mut slot_table = SlotTable {",
                "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 16],",
                "        slots_per_state,",
                "        slots_for_captures,",
                "    };",
                "    let state_id = StateID(SmallIndex::new(3));",
                "    let result = slot_table.for_state(state_id);",
                "}"
              ],
              "oracle": [
                "    let slots_per_state = 4;",
                "    let slots_for_captures = 3;",
                "    let mut slot_table = SlotTable { table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 16], slots_per_state, slots_for_captures };",
                "    let state_id = StateID(SmallIndex::new(3));",
                "    let expected_length = slots_for_captures;",
                "    assert_eq!(result.len(), expected_length);",
                "    let expected_slice = &mut slot_table.table[state_id.as_usize() * slots_per_state..state_id.as_usize() * slots_per_state + slots_for_captures];",
                "    assert_eq!(result.as_mut_ptr(), expected_slice.as_mut_ptr());",
                "    assert_eq!(result, expected_slice);"
              ],
              "code": [
                "{",
                "    let slots_per_state = 4;",
                "    let slots_for_captures = 3;",
                "    let mut slot_table = SlotTable {",
                "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 16],",
                "        slots_per_state,",
                "        slots_for_captures,",
                "    };",
                "    let state_id = StateID(SmallIndex::new(3));",
                "    let result = slot_table.for_state(state_id);",
                "    let slots_per_state = 4;",
                "    let slots_for_captures = 3;",
                "    let mut slot_table = SlotTable { table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 16], slots_per_state, slots_for_captures };",
                "    let state_id = StateID(SmallIndex::new(3));",
                "    let expected_length = slots_for_captures;",
                "    assert_eq!(result.len(), expected_length);",
                "    let expected_slice = &mut slot_table.table[state_id.as_usize() * slots_per_state..state_id.as_usize() * slots_per_state + slots_for_captures];",
                "    assert_eq!(result.as_mut_ptr(), expected_slice.as_mut_ptr());",
                "    assert_eq!(result, expected_slice);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slots_per_state = 2;",
                "    let slots_for_captures = 1;",
                "    let mut slot_table = SlotTable {",
                "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 6],",
                "        slots_per_state,",
                "        slots_for_captures,",
                "    };",
                "    let state_id = StateID(SmallIndex::new(2)); // Out of range",
                "    let result = slot_table.for_state(state_id);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.len(), slots_for_captures);",
                "    assert!(result.iter().all(|&slot| slot.is_some()));",
                "    slot_table.for_state(StateID(SmallIndex::new(0)));",
                "    assert!(slot_table.for_state(StateID(SmallIndex::new(0))).len() == slots_for_captures);",
                "    slot_table.for_state(StateID(SmallIndex::new(1)));",
                "    assert!(slot_table.for_state(StateID(SmallIndex::new(1))).len() == slots_for_captures);",
                "    slot_table.for_state(StateID(SmallIndex::new(2)));",
                "    assert!(slot_table.for_state(StateID(SmallIndex::new(2))).len() == slots_for_captures);",
                "    slot_table.table[4] = Some(NonMaxUsize(NonZeroUsize::new(2).unwrap()));",
                "    assert_eq!(slot_table.for_state(StateID(SmallIndex::new(2)))[0], Some(NonMaxUsize(NonZeroUsize::new(2).unwrap())));"
              ],
              "code": [
                "{",
                "    let slots_per_state = 2;",
                "    let slots_for_captures = 1;",
                "    let mut slot_table = SlotTable {",
                "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 6],",
                "        slots_per_state,",
                "        slots_for_captures,",
                "    };",
                "    let state_id = StateID(SmallIndex::new(2)); // Out of range",
                "    let result = slot_table.for_state(state_id);",
                "    assert_eq!(result.len(), slots_for_captures);",
                "    assert!(result.iter().all(|&slot| slot.is_some()));",
                "    slot_table.for_state(StateID(SmallIndex::new(0)));",
                "    assert!(slot_table.for_state(StateID(SmallIndex::new(0))).len() == slots_for_captures);",
                "    slot_table.for_state(StateID(SmallIndex::new(1)));",
                "    assert!(slot_table.for_state(StateID(SmallIndex::new(1))).len() == slots_for_captures);",
                "    slot_table.for_state(StateID(SmallIndex::new(2)));",
                "    assert!(slot_table.for_state(StateID(SmallIndex::new(2))).len() == slots_for_captures);",
                "    slot_table.table[4] = Some(NonMaxUsize(NonZeroUsize::new(2).unwrap()));",
                "    assert_eq!(slot_table.for_state(StateID(SmallIndex::new(2)))[0], Some(NonMaxUsize(NonZeroUsize::new(2).unwrap())));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}