{
  "name": "regex_automata::nfa::thompson::builder::{impl#1}::add_sparse",
  "mod_info": {
    "name": "nfa::thompson::builder",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:58:1:58:13"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/builder.rs:793:5:798:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "PatternID must be set in Builder, transitions must be non-overlapping and in ascending order, and size_limit must not be exceeded; valid Transition ranges are [0-255] with distinct start and end values.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions: Vec<Transition> = Vec::new();",
                "    builder.add_sparse(transitions).unwrap();",
                "}"
              ],
              "oracle": [
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    assert_eq!(builder.memory_usage(), 0);",
                "    assert!(builder.get_utf8() == false);",
                "    assert!(builder.get_reverse() == false);",
                "    ",
                "    let transitions: Vec<Transition> = Vec::new();",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), StateID::default());",
                "    assert_eq!(builder.states.len(), 1);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions: Vec<Transition> = Vec::new();",
                "    builder.add_sparse(transitions).unwrap();",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    assert_eq!(builder.memory_usage(), 0);",
                "    assert!(builder.get_utf8() == false);",
                "    assert!(builder.get_reverse() == false);",
                "    ",
                "    let transitions: Vec<Transition> = Vec::new();",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), StateID::default());",
                "    assert_eq!(builder.states.len(), 1);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) }];",
                "    builder.add_sparse(transitions).unwrap();",
                "}"
              ],
              "oracle": [
                "    builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) }];",
                "    assert!(builder.add_sparse(transitions).is_ok());",
                "    assert_eq!(builder.states.len(), 1);",
                "    assert!(builder.states[0].is_sparse());",
                "    assert_eq!(builder.states[0].transitions.len(), 1);",
                "    assert_eq!(builder.states[0].transitions[0].start, 0);",
                "    assert_eq!(builder.states[0].transitions[0].end, 1);",
                "    assert_eq!(builder.states[0].transitions[0].next, StateID(SmallIndex::new(1).unwrap()));"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) }];",
                "    builder.add_sparse(transitions).unwrap();",
                "    builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) }];",
                "    assert!(builder.add_sparse(transitions).is_ok());",
                "    assert_eq!(builder.states.len(), 1);",
                "    assert!(builder.states[0].is_sparse());",
                "    assert_eq!(builder.states[0].transitions.len(), 1);",
                "    assert_eq!(builder.states[0].transitions[0].start, 0);",
                "    assert_eq!(builder.states[0].transitions[0].end, 1);",
                "    assert_eq!(builder.states[0].transitions[0].next, StateID(SmallIndex::new(1).unwrap()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "        Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "        Transition { start: 2, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "        Transition { start: 4, end: 5, next: StateID(SmallIndex::new(3).unwrap()) }",
                "    ];",
                "    builder.add_sparse(transitions).unwrap();",
                "}"
              ],
              "oracle": [
                "    builder.start_pattern().unwrap() == PatternID(SmallIndex::new(0).unwrap())",
                "    builder.finish_pattern(StateID::default()).unwrap() == PatternID(SmallIndex::new(0).unwrap())",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 2, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    Transition { start: 4, end: 5, next: StateID(SmallIndex::new(3).unwrap()) }",
                "    ]).unwrap() == StateID(SmallIndex::new(0).unwrap())",
                "    builder.states.len() == 1",
                "    builder.states[0] == State::Sparse { transitions: vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 2, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    Transition { start: 4, end: 5, next: StateID(SmallIndex::new(3).unwrap()) }",
                "    ]}"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "        Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "        Transition { start: 2, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "        Transition { start: 4, end: 5, next: StateID(SmallIndex::new(3).unwrap()) }",
                "    ];",
                "    builder.add_sparse(transitions).unwrap();",
                "    builder.start_pattern().unwrap() == PatternID(SmallIndex::new(0).unwrap())",
                "    builder.finish_pattern(StateID::default()).unwrap() == PatternID(SmallIndex::new(0).unwrap())",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 2, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    Transition { start: 4, end: 5, next: StateID(SmallIndex::new(3).unwrap()) }",
                "    ]).unwrap() == StateID(SmallIndex::new(0).unwrap())",
                "    builder.states.len() == 1",
                "    builder.states[0] == State::Sparse { transitions: vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 2, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    Transition { start: 4, end: 5, next: StateID(SmallIndex::new(3).unwrap()) }",
                "    ]}",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "        Transition { start: 0, end: 2, next: StateID(SmallIndex::new(1).unwrap()) },",
                "        Transition { start: 1, end: 3, next: StateID(SmallIndex::new(2).unwrap()) }",
                "    ];",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    builder.add_sparse(vec![]).unwrap(); // Add a sparse state with no transitions, expect success (equivalent to a fail state).",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 2, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Add a non-overlapping sparse state with valid transitions, expect success.",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 1, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Add overlapping transitions, expect panic.",
                "    builder.add_sparse(vec![",
                "    Transition { start: 3, end: 5, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 2, end: 4, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Add overlapping transitions in ascending order, expect panic.",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 2, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Add transitions with same start, expect panic.",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 3, end: 4, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Valid sparse state with non-overlapping transitions, expect success."
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "        Transition { start: 0, end: 2, next: StateID(SmallIndex::new(1).unwrap()) },",
                "        Transition { start: 1, end: 3, next: StateID(SmallIndex::new(2).unwrap()) }",
                "    ];",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_err());",
                "    builder.add_sparse(vec![]).unwrap(); // Add a sparse state with no transitions, expect success (equivalent to a fail state).",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 2, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Add a non-overlapping sparse state with valid transitions, expect success.",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 1, end: 3, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Add overlapping transitions, expect panic.",
                "    builder.add_sparse(vec![",
                "    Transition { start: 3, end: 5, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 2, end: 4, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Add overlapping transitions in ascending order, expect panic.",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 2, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Add transitions with same start, expect panic.",
                "    builder.add_sparse(vec![",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 3, end: 4, next: StateID(SmallIndex::new(2).unwrap()) },",
                "    ]).unwrap(); // Valid sparse state with non-overlapping transitions, expect success.",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "        Transition { start: 1, end: 2, next: StateID(SmallIndex::new(1).unwrap()) },",
                "        Transition { start: 0, end: 1, next: StateID(SmallIndex::new(2).unwrap()) }",
                "    ];",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "    Transition { start: 1, end: 2, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(2).unwrap()) }",
                "    ];",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_err());"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "        Transition { start: 1, end: 2, next: StateID(SmallIndex::new(1).unwrap()) },",
                "        Transition { start: 0, end: 1, next: StateID(SmallIndex::new(2).unwrap()) }",
                "    ];",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_err());",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "    Transition { start: 1, end: 2, next: StateID(SmallIndex::new(1).unwrap()) },",
                "    Transition { start: 0, end: 1, next: StateID(SmallIndex::new(2).unwrap()) }",
                "    ];",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    builder.set_size_limit(Some(10)).unwrap();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "        Transition { start: 0, end: 255, next: StateID(SmallIndex::new(1).unwrap()) }",
                "    ];",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(builder.states.len(), 1);",
                "    assert!(builder.memory_states <= 10);",
                "    assert_eq!(builder.current_pattern_id(), pattern_id);",
                "    assert_eq!(builder.pattern_len(), 1);",
                "    assert!(builder.get_size_limit().is_some());",
                "    assert_eq!(builder.get_size_limit(), Some(10));",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::StateLimitExceeded);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    builder.set_size_limit(Some(10)).unwrap();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.finish_pattern(StateID::default()).unwrap();",
                "    let transitions = vec![",
                "        Transition { start: 0, end: 255, next: StateID(SmallIndex::new(1).unwrap()) }",
                "    ];",
                "    let result = builder.add_sparse(transitions);",
                "    assert!(result.is_err());",
                "    assert_eq!(builder.states.len(), 1);",
                "    assert!(builder.memory_states <= 10);",
                "    assert_eq!(builder.current_pattern_id(), pattern_id);",
                "    assert_eq!(builder.pattern_len(), 1);",
                "    assert!(builder.get_size_limit().is_some());",
                "    assert_eq!(builder.get_size_limit(), Some(10));",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::StateLimitExceeded);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}