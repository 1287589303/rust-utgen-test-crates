{
  "name": "regex_automata::util::sparse_set::{impl#0}::swap",
  "mod_info": {
    "name": "util::sparse_set",
    "loc": "regex-automata/src/util/mod.rs:55:1:55:27"
  },
  "visible": true,
  "loc": "regex-automata/src/util/sparse_set.rs:70:5:72:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "SparseSets should have two initialized SparseSet instances before testing the swap function, with varying lengths (from 0 to a maximum allowable value based on StateID) and different contents; test cases should include initial empty SparseSets, SparseSets with one element, and SparseSets fully populated to capacity.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
                "    sparse_sets.set2 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
                "    sparse_sets.swap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(sparse_sets.set1.len, 0);",
                "    assert_eq!(sparse_sets.set2.len, 0);",
                "    assert!(sparse_sets.set1.dense.is_empty());",
                "    assert!(sparse_sets.set2.dense.is_empty());",
                "    assert!(sparse_sets.set1.sparse.is_empty());",
                "    assert!(sparse_sets.set2.sparse.is_empty());",
                "    let set1_ptr = &sparse_sets.set1 as *const SparseSet;",
                "    let set2_ptr = &sparse_sets.set2 as *const SparseSet;",
                "    sparse_sets.swap();",
                "    assert_eq!(set1_ptr, &sparse_sets.set2 as *const SparseSet);",
                "    assert_eq!(set2_ptr, &sparse_sets.set1 as *const SparseSet);"
              ],
              "code": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
                "    sparse_sets.set2 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
                "    sparse_sets.swap();",
                "    assert_eq!(sparse_sets.set1.len, 0);",
                "    assert_eq!(sparse_sets.set2.len, 0);",
                "    assert!(sparse_sets.set1.dense.is_empty());",
                "    assert!(sparse_sets.set2.dense.is_empty());",
                "    assert!(sparse_sets.set1.sparse.is_empty());",
                "    assert!(sparse_sets.set2.sparse.is_empty());",
                "    let set1_ptr = &sparse_sets.set1 as *const SparseSet;",
                "    let set2_ptr = &sparse_sets.set2 as *const SparseSet;",
                "    sparse_sets.swap();",
                "    assert_eq!(set1_ptr, &sparse_sets.set2 as *const SparseSet);",
                "    assert_eq!(set2_ptr, &sparse_sets.set1 as *const SparseSet);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 1, dense: vec![1], sparse: vec![0] };",
                "    sparse_sets.set2 = SparseSet { len: 1, dense: vec![2], sparse: vec![0] };",
                "    sparse_sets.swap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(sparse_sets.set1.len, 1);",
                "    assert_eq!(sparse_sets.set1.dense, vec![2]);",
                "    assert_eq!(sparse_sets.set1.sparse, vec![0]);",
                "    assert_eq!(sparse_sets.set2.len, 1);",
                "    assert_eq!(sparse_sets.set2.dense, vec![1]);",
                "    assert_eq!(sparse_sets.set2.sparse, vec![0]);"
              ],
              "code": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 1, dense: vec![1], sparse: vec![0] };",
                "    sparse_sets.set2 = SparseSet { len: 1, dense: vec![2], sparse: vec![0] };",
                "    sparse_sets.swap();",
                "    assert_eq!(sparse_sets.set1.len, 1);",
                "    assert_eq!(sparse_sets.set1.dense, vec![2]);",
                "    assert_eq!(sparse_sets.set1.sparse, vec![0]);",
                "    assert_eq!(sparse_sets.set2.len, 1);",
                "    assert_eq!(sparse_sets.set2.dense, vec![1]);",
                "    assert_eq!(sparse_sets.set2.sparse, vec![0]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 10, dense: (0..10).map(|x| x as StateID).collect(), sparse: (0..10).map(|x| x as StateID).collect() };",
                "    sparse_sets.set2 = SparseSet { len: 10, dense: (10..20).map(|x| x as StateID).collect(), sparse: (0..10).map(|x| (x + 10) as StateID).collect() };",
                "    sparse_sets.swap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(sparse_sets.set1.len, 10);",
                "    assert_eq!(sparse_sets.set1.dense, (10..20).map(|x| x as StateID).collect::<Vec<StateID>>());",
                "    assert_eq!(sparse_sets.set1.sparse, (0..10).map(|x| (x + 10) as StateID).collect::<Vec<StateID>>());",
                "    assert_eq!(sparse_sets.set2.len, 10);",
                "    assert_eq!(sparse_sets.set2.dense, (0..10).map(|x| x as StateID).collect::<Vec<StateID>>());",
                "    assert_eq!(sparse_sets.set2.sparse, (0..10).map(|x| x as StateID).collect::<Vec<StateID>>());"
              ],
              "code": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 10, dense: (0..10).map(|x| x as StateID).collect(), sparse: (0..10).map(|x| x as StateID).collect() };",
                "    sparse_sets.set2 = SparseSet { len: 10, dense: (10..20).map(|x| x as StateID).collect(), sparse: (0..10).map(|x| (x + 10) as StateID).collect() };",
                "    sparse_sets.swap();",
                "    assert_eq!(sparse_sets.set1.len, 10);",
                "    assert_eq!(sparse_sets.set1.dense, (10..20).map(|x| x as StateID).collect::<Vec<StateID>>());",
                "    assert_eq!(sparse_sets.set1.sparse, (0..10).map(|x| (x + 10) as StateID).collect::<Vec<StateID>>());",
                "    assert_eq!(sparse_sets.set2.len, 10);",
                "    assert_eq!(sparse_sets.set2.dense, (0..10).map(|x| x as StateID).collect::<Vec<StateID>>());",
                "    assert_eq!(sparse_sets.set2.sparse, (0..10).map(|x| x as StateID).collect::<Vec<StateID>>());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 5, dense: vec![0, 1, 2, 3, 4], sparse: vec![0, 1, 2, 3, 4] };",
                "    sparse_sets.set2 = SparseSet { len: 3, dense: vec![5, 6, 7], sparse: vec![0, 1, 2] };",
                "    sparse_sets.swap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(sparse_sets.set1.len, 3);",
                "    assert_eq!(sparse_sets.set1.dense, vec![5, 6, 7]);",
                "    assert_eq!(sparse_sets.set1.sparse, vec![0, 1, 2]);",
                "    assert_eq!(sparse_sets.set2.len, 5);",
                "    assert_eq!(sparse_sets.set2.dense, vec![0, 1, 2, 3, 4]);",
                "    assert_eq!(sparse_sets.set2.sparse, vec![0, 1, 2, 3, 4]);"
              ],
              "code": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 5, dense: vec![0, 1, 2, 3, 4], sparse: vec![0, 1, 2, 3, 4] };",
                "    sparse_sets.set2 = SparseSet { len: 3, dense: vec![5, 6, 7], sparse: vec![0, 1, 2] };",
                "    sparse_sets.swap();",
                "    assert_eq!(sparse_sets.set1.len, 3);",
                "    assert_eq!(sparse_sets.set1.dense, vec![5, 6, 7]);",
                "    assert_eq!(sparse_sets.set1.sparse, vec![0, 1, 2]);",
                "    assert_eq!(sparse_sets.set2.len, 5);",
                "    assert_eq!(sparse_sets.set2.dense, vec![0, 1, 2, 3, 4]);",
                "    assert_eq!(sparse_sets.set2.sparse, vec![0, 1, 2, 3, 4]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
                "    sparse_sets.set2 = SparseSet { len: 6, dense: vec![0, 1, 2, 3, 4, 5], sparse: vec![0, 1, 2, 3, 4, 5] };",
                "    sparse_sets.swap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(sparse_sets.set1.len, 0);",
                "    assert_eq!(sparse_sets.set2.len, 6);",
                "    assert_eq!(sparse_sets.set1.dense, vec![]);",
                "    assert_eq!(sparse_sets.set2.dense, vec![0, 1, 2, 3, 4, 5]);",
                "    assert_eq!(sparse_sets.set1.sparse, vec![]);",
                "    assert_eq!(sparse_sets.set2.sparse, vec![0, 1, 2, 3, 4, 5]);"
              ],
              "code": [
                "{",
                "    let mut sparse_sets = SparseSets::new(10);",
                "    sparse_sets.set1 = SparseSet { len: 0, dense: Vec::new(), sparse: Vec::new() };",
                "    sparse_sets.set2 = SparseSet { len: 6, dense: vec![0, 1, 2, 3, 4, 5], sparse: vec![0, 1, 2, 3, 4, 5] };",
                "    sparse_sets.swap();",
                "    assert_eq!(sparse_sets.set1.len, 0);",
                "    assert_eq!(sparse_sets.set2.len, 6);",
                "    assert_eq!(sparse_sets.set1.dense, vec![]);",
                "    assert_eq!(sparse_sets.set2.dense, vec![0, 1, 2, 3, 4, 5]);",
                "    assert_eq!(sparse_sets.set1.sparse, vec![]);",
                "    assert_eq!(sparse_sets.set2.sparse, vec![0, 1, 2, 3, 4, 5]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}