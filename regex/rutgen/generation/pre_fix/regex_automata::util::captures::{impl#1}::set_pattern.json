{
  "name": "regex_automata::util::captures::{impl#1}::set_pattern",
  "mod_info": {
    "name": "util::captures",
    "loc": "regex-automata/src/util/mod.rs:32:1:32:18"
  },
  "visible": true,
  "loc": "regex-automata/src/util/captures.rs:1134:5:1136:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "pid: Option<PatternID> = Some(PatternID(0)), None; Expected return: is_match() true/false, pattern() Some/None, slots() vector with None or NonMaxUsize values up to maximum slots capacity.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut captures = Captures {",
                "        group_info: GroupInfo::default(),",
                "        pid: None,",
                "        slots: vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6],",
                "    };",
                "    ",
                "    captures.set_pattern(Some(PatternID(SmallIndex::new(0))));",
                "    let is_match = captures.pid.is_some();",
                "    let pattern_id = captures.pid;",
                "    let slots: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
                "}"
              ],
              "oracle": [
                "    assert!(is_match);",
                "    assert!(pattern_id.is_some());",
                "    assert_eq!(slots, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);",
                "    ",
                "    captures.set_pattern(None);",
                "    let is_match_after_none = captures.pid.is_some();",
                "    let pattern_id_after_none = captures.pid;",
                "    let slots_after_none: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
                "    ",
                "    assert!(!is_match_after_none);",
                "    assert!(pattern_id_after_none.is_none());",
                "    assert_eq!(slots_after_none, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);"
              ],
              "code": [
                "{",
                "    let mut captures = Captures {",
                "        group_info: GroupInfo::default(),",
                "        pid: None,",
                "        slots: vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6],",
                "    };",
                "    ",
                "    captures.set_pattern(Some(PatternID(SmallIndex::new(0))));",
                "    let is_match = captures.pid.is_some();",
                "    let pattern_id = captures.pid;",
                "    let slots: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
                "    assert!(is_match);",
                "    assert!(pattern_id.is_some());",
                "    assert_eq!(slots, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);",
                "    ",
                "    captures.set_pattern(None);",
                "    let is_match_after_none = captures.pid.is_some();",
                "    let pattern_id_after_none = captures.pid;",
                "    let slots_after_none: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
                "    ",
                "    assert!(!is_match_after_none);",
                "    assert!(pattern_id_after_none.is_none());",
                "    assert_eq!(slots_after_none, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut captures = Captures {",
                "        group_info: GroupInfo::default(),",
                "        pid: Some(PatternID(SmallIndex::new(0))),",
                "        slots: vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6],",
                "    };",
                "",
                "    captures.set_pattern(None);",
                "    let is_match = captures.pid.is_none();",
                "    let pattern_id = captures.pid;",
                "    let slots: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
                "}"
              ],
              "oracle": [
                "    assert!(is_match);",
                "    assert!(pattern_id.is_none());",
                "    assert_eq!(slots, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);"
              ],
              "code": [
                "{",
                "    let mut captures = Captures {",
                "        group_info: GroupInfo::default(),",
                "        pid: Some(PatternID(SmallIndex::new(0))),",
                "        slots: vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6],",
                "    };",
                "",
                "    captures.set_pattern(None);",
                "    let is_match = captures.pid.is_none();",
                "    let pattern_id = captures.pid;",
                "    let slots: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
                "    assert!(is_match);",
                "    assert!(pattern_id.is_none());",
                "    assert_eq!(slots, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}