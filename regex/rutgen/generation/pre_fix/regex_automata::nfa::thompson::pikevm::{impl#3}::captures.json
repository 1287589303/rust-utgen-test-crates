{
  "name": "regex_automata::nfa::thompson::pikevm::{impl#3}::captures",
  "mod_info": {
    "name": "nfa::thompson::pikevm",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:68:1:68:16"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/pikevm.rs:859:5:866:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "valid inputs: strings matching regex pattern like \"YYYY-MM-DD\"; caps must have enough slots for capturing groups; valid Cache object; ranges for date components must be within acceptable limits (e.g., 0000-12-31)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = PikeVM::new(r\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\").unwrap();",
                "    let (mut cache, mut caps) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache, \"2022-08-15\", &mut caps);",
                "}"
              ],
              "oracle": [
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    re.captures(&mut cache, \"2022-08-15\", &mut caps);",
                "    assert!(!caps.is_match());",
                "    re.captures(&mut cache, \"not-a-date\", &mut caps);",
                "    assert!(!caps.is_match());",
                "    re.captures(&mut cache, \"\", &mut caps);"
              ],
              "code": [
                "{",
                "    let re = PikeVM::new(r\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\").unwrap();",
                "    let (mut cache, mut caps) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache, \"2022-08-15\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    re.captures(&mut cache, \"2022-08-15\", &mut caps);",
                "    assert!(!caps.is_match());",
                "    re.captures(&mut cache, \"not-a-date\", &mut caps);",
                "    assert!(!caps.is_match());",
                "    re.captures(&mut cache, \"\", &mut caps);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = PikeVM::new(r\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\").unwrap();",
                "    let (mut cache, mut caps) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache, \"2020-02-29\", &mut caps);",
                "}"
              ],
              "oracle": [
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    ",
                "    let (mut cache2, mut caps2) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache2, \"2020-02-29\", &mut caps2);",
                "    assert!(caps2.is_match());",
                "    ",
                "    let (mut cache3, mut caps3) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache3, \"2019-12-31\", &mut caps3);",
                "    assert!(caps3.is_match());",
                "    ",
                "    let (mut cache4, mut caps4) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache4, \"non-date-string\", &mut caps4);",
                "    assert!(!caps4.is_match());"
              ],
              "code": [
                "{",
                "    let re = PikeVM::new(r\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\").unwrap();",
                "    let (mut cache, mut caps) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache, \"2020-02-29\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    ",
                "    let (mut cache2, mut caps2) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache2, \"2020-02-29\", &mut caps2);",
                "    assert!(caps2.is_match());",
                "    ",
                "    let (mut cache3, mut caps3) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache3, \"2019-12-31\", &mut caps3);",
                "    assert!(caps3.is_match());",
                "    ",
                "    let (mut cache4, mut caps4) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache4, \"non-date-string\", &mut caps4);",
                "    assert!(!caps4.is_match());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = PikeVM::new(r\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\").unwrap();",
                "    let (mut cache, mut caps) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache, \"0000-01-01\", &mut caps);",
                "    re.captures(&mut cache, \"9999-12-31\", &mut caps);",
                "}"
              ],
              "oracle": [
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    assert!(!caps.is_match());"
              ],
              "code": [
                "{",
                "    let re = PikeVM::new(r\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\").unwrap();",
                "    let (mut cache, mut caps) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache, \"0000-01-01\", &mut caps);",
                "    re.captures(&mut cache, \"9999-12-31\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    assert!(!caps.is_match());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = PikeVM::new(r\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\").unwrap();",
                "    let (mut cache, mut caps) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache, \"2022-13-01\", &mut caps);",
                "    re.captures(&mut cache, \"2022-00-15\", &mut caps);",
                "    re.captures(&mut cache, \"2022-02-30\", &mut caps);",
                "    re.captures(&mut cache, \"2022-07-32\", &mut caps);",
                "}"
              ],
              "oracle": [
                "    assert!(!caps.is_match());",
                "    assert!(!caps.get_group(1).is_some());",
                "    assert!(!caps.get_group(2).is_some());",
                "    assert!(!caps.get_group(3).is_some());",
                "    caps.clear();",
                "    re.captures(&mut cache, \"2022-01-01\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    caps.clear();",
                "    re.captures(&mut cache, \"2022-12-31\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    caps.clear();",
                "    re.captures(&mut cache, \"2023-01-01\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));"
              ],
              "code": [
                "{",
                "    let re = PikeVM::new(r\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\").unwrap();",
                "    let (mut cache, mut caps) = (re.create_cache(), re.create_captures());",
                "    re.captures(&mut cache, \"2022-13-01\", &mut caps);",
                "    re.captures(&mut cache, \"2022-00-15\", &mut caps);",
                "    re.captures(&mut cache, \"2022-02-30\", &mut caps);",
                "    re.captures(&mut cache, \"2022-07-32\", &mut caps);",
                "    assert!(!caps.is_match());",
                "    assert!(!caps.get_group(1).is_some());",
                "    assert!(!caps.get_group(2).is_some());",
                "    assert!(!caps.get_group(3).is_some());",
                "    caps.clear();",
                "    re.captures(&mut cache, \"2022-01-01\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    caps.clear();",
                "    re.captures(&mut cache, \"2022-12-31\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "    caps.clear();",
                "    re.captures(&mut cache, \"2023-01-01\", &mut caps);",
                "    assert!(caps.is_match());",
                "    assert_eq!(Some(Span::from(0..4)), caps.get_group(1));",
                "    assert_eq!(Some(Span::from(5..7)), caps.get_group(2));",
                "    assert_eq!(Some(Span::from(8..10)), caps.get_group(3));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}