{
  "name": "regex_automata::hybrid::dfa::{impl#0}::get_config",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:407:5:409:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: &self.config\n"
      ],
      "input_infer": "self.config must be a valid instance of Config with various optional fields including match_kind, utf8_empty, autopre, pre, which_captures, nfa_size_limit (set to Some or None), onepass_size_limit (set to Some or None), hybrid_cache_capacity (set to Some or None), hybrid (set to Some or None), dfa (set to Some or None), dfa_size_limit (set to Some or None), dfa_state_limit (set to Some or None), onepass (set to Some or None), backtrack (set to Some or None), byte_classes (set to Some or None), line_terminator (set to any value between 0 to 255).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config {",
                "            match_kind: Some(MatchKind::Anchored),",
                "            utf8_empty: None,",
                "            autopre: None,",
                "            pre: None,",
                "            which_captures: None,",
                "            nfa_size_limit: None,",
                "            onepass_size_limit: None,",
                "            hybrid_cache_capacity: None,",
                "            hybrid: None,",
                "            dfa: None,",
                "            dfa_size_limit: None,",
                "            dfa_state_limit: None,",
                "            onepass: None,",
                "            backtrack: None,",
                "            byte_classes: None,",
                "            line_terminator: Some(10),",
                "        },",
                "        nfa: thompson::NFA::default(),",
                "        stride2: 0,",
                "        start_map: StartByteMap { map: [Start::default(); 256] },",
                "        classes: ByteClasses([0; 256]),",
                "        quitset: ByteSet::default(),",
                "        cache_capacity: 0,",
                "    };",
                "    dfa.get_config();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.get_config().match_kind, Some(MatchKind::Anchored));",
                "    assert_eq!(dfa.get_config().utf8_empty, None);",
                "    assert_eq!(dfa.get_config().autopre, None);",
                "    assert_eq!(dfa.get_config().pre, None);",
                "    assert_eq!(dfa.get_config().which_captures, None);",
                "    assert_eq!(dfa.get_config().nfa_size_limit, None);",
                "    assert_eq!(dfa.get_config().onepass_size_limit, None);",
                "    assert_eq!(dfa.get_config().hybrid_cache_capacity, None);",
                "    assert_eq!(dfa.get_config().hybrid, None);",
                "    assert_eq!(dfa.get_config().dfa, None);",
                "    assert_eq!(dfa.get_config().dfa_size_limit, None);",
                "    assert_eq!(dfa.get_config().dfa_state_limit, None);",
                "    assert_eq!(dfa.get_config().onepass, None);",
                "    assert_eq!(dfa.get_config().backtrack, None);",
                "    assert_eq!(dfa.get_config().byte_classes, None);",
                "    assert_eq!(dfa.get_config().line_terminator, Some(10));"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config {",
                "            match_kind: Some(MatchKind::Anchored),",
                "            utf8_empty: None,",
                "            autopre: None,",
                "            pre: None,",
                "            which_captures: None,",
                "            nfa_size_limit: None,",
                "            onepass_size_limit: None,",
                "            hybrid_cache_capacity: None,",
                "            hybrid: None,",
                "            dfa: None,",
                "            dfa_size_limit: None,",
                "            dfa_state_limit: None,",
                "            onepass: None,",
                "            backtrack: None,",
                "            byte_classes: None,",
                "            line_terminator: Some(10),",
                "        },",
                "        nfa: thompson::NFA::default(),",
                "        stride2: 0,",
                "        start_map: StartByteMap { map: [Start::default(); 256] },",
                "        classes: ByteClasses([0; 256]),",
                "        quitset: ByteSet::default(),",
                "        cache_capacity: 0,",
                "    };",
                "    dfa.get_config();",
                "    assert_eq!(dfa.get_config().match_kind, Some(MatchKind::Anchored));",
                "    assert_eq!(dfa.get_config().utf8_empty, None);",
                "    assert_eq!(dfa.get_config().autopre, None);",
                "    assert_eq!(dfa.get_config().pre, None);",
                "    assert_eq!(dfa.get_config().which_captures, None);",
                "    assert_eq!(dfa.get_config().nfa_size_limit, None);",
                "    assert_eq!(dfa.get_config().onepass_size_limit, None);",
                "    assert_eq!(dfa.get_config().hybrid_cache_capacity, None);",
                "    assert_eq!(dfa.get_config().hybrid, None);",
                "    assert_eq!(dfa.get_config().dfa, None);",
                "    assert_eq!(dfa.get_config().dfa_size_limit, None);",
                "    assert_eq!(dfa.get_config().dfa_state_limit, None);",
                "    assert_eq!(dfa.get_config().onepass, None);",
                "    assert_eq!(dfa.get_config().backtrack, None);",
                "    assert_eq!(dfa.get_config().byte_classes, None);",
                "    assert_eq!(dfa.get_config().line_terminator, Some(10));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config {",
                "            match_kind: None,",
                "            utf8_empty: Some(true),",
                "            autopre: None,",
                "            pre: None,",
                "            which_captures: None,",
                "            nfa_size_limit: None,",
                "            onepass_size_limit: None,",
                "            hybrid_cache_capacity: None,",
                "            hybrid: None,",
                "            dfa: None,",
                "            dfa_size_limit: None,",
                "            dfa_state_limit: None,",
                "            onepass: None,",
                "            backtrack: None,",
                "            byte_classes: None,",
                "            line_terminator: Some(255),",
                "        },",
                "        nfa: thompson::NFA::default(),",
                "        stride2: 0,",
                "        start_map: StartByteMap { map: [Start::default(); 256] },",
                "        classes: ByteClasses([0; 256]),",
                "        quitset: ByteSet::default(),",
                "        cache_capacity: 0,",
                "    };",
                "    dfa.get_config();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.get_config().match_kind, None);",
                "    assert_eq!(dfa.get_config().utf8_empty, Some(true));",
                "    assert_eq!(dfa.get_config().autopre, None);",
                "    assert_eq!(dfa.get_config().pre, None);",
                "    assert_eq!(dfa.get_config().which_captures, None);",
                "    assert_eq!(dfa.get_config().nfa_size_limit, None);",
                "    assert_eq!(dfa.get_config().onepass_size_limit, None);",
                "    assert_eq!(dfa.get_config().hybrid_cache_capacity, None);",
                "    assert_eq!(dfa.get_config().hybrid, None);",
                "    assert_eq!(dfa.get_config().dfa, None);",
                "    assert_eq!(dfa.get_config().dfa_size_limit, None);",
                "    assert_eq!(dfa.get_config().dfa_state_limit, None);",
                "    assert_eq!(dfa.get_config().onepass, None);",
                "    assert_eq!(dfa.get_config().backtrack, None);",
                "    assert_eq!(dfa.get_config().byte_classes, None);",
                "    assert_eq!(dfa.get_config().line_terminator, Some(255));"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config {",
                "            match_kind: None,",
                "            utf8_empty: Some(true),",
                "            autopre: None,",
                "            pre: None,",
                "            which_captures: None,",
                "            nfa_size_limit: None,",
                "            onepass_size_limit: None,",
                "            hybrid_cache_capacity: None,",
                "            hybrid: None,",
                "            dfa: None,",
                "            dfa_size_limit: None,",
                "            dfa_state_limit: None,",
                "            onepass: None,",
                "            backtrack: None,",
                "            byte_classes: None,",
                "            line_terminator: Some(255),",
                "        },",
                "        nfa: thompson::NFA::default(),",
                "        stride2: 0,",
                "        start_map: StartByteMap { map: [Start::default(); 256] },",
                "        classes: ByteClasses([0; 256]),",
                "        quitset: ByteSet::default(),",
                "        cache_capacity: 0,",
                "    };",
                "    dfa.get_config();",
                "    assert_eq!(dfa.get_config().match_kind, None);",
                "    assert_eq!(dfa.get_config().utf8_empty, Some(true));",
                "    assert_eq!(dfa.get_config().autopre, None);",
                "    assert_eq!(dfa.get_config().pre, None);",
                "    assert_eq!(dfa.get_config().which_captures, None);",
                "    assert_eq!(dfa.get_config().nfa_size_limit, None);",
                "    assert_eq!(dfa.get_config().onepass_size_limit, None);",
                "    assert_eq!(dfa.get_config().hybrid_cache_capacity, None);",
                "    assert_eq!(dfa.get_config().hybrid, None);",
                "    assert_eq!(dfa.get_config().dfa, None);",
                "    assert_eq!(dfa.get_config().dfa_size_limit, None);",
                "    assert_eq!(dfa.get_config().dfa_state_limit, None);",
                "    assert_eq!(dfa.get_config().onepass, None);",
                "    assert_eq!(dfa.get_config().backtrack, None);",
                "    assert_eq!(dfa.get_config().byte_classes, None);",
                "    assert_eq!(dfa.get_config().line_terminator, Some(255));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config {",
                "            match_kind: None,",
                "            utf8_empty: None,",
                "            autopre: None,",
                "            pre: None,",
                "            which_captures: None,",
                "            nfa_size_limit: Some(Some(100)),",
                "            onepass_size_limit: Some(Some(200)),",
                "            hybrid_cache_capacity: Some(300),",
                "            hybrid: None,",
                "            dfa: Some(true),",
                "            dfa_size_limit: Some(Some(400)),",
                "            dfa_state_limit: Some(Some(500)),",
                "            onepass: None,",
                "            backtrack: Some(true),",
                "            byte_classes: Some(false),",
                "            line_terminator: Some(0),",
                "        },",
                "        nfa: thompson::NFA::default(),",
                "        stride2: 0,",
                "        start_map: StartByteMap { map: [Start::default(); 256] },",
                "        classes: ByteClasses([0; 256]),",
                "        quitset: ByteSet::default(),",
                "        cache_capacity: 0,",
                "    };",
                "    dfa.get_config();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.get_config().match_kind, None);",
                "    assert_eq!(dfa.get_config().utf8_empty, None);",
                "    assert_eq!(dfa.get_config().autopre, None);",
                "    assert_eq!(dfa.get_config().pre, None);",
                "    assert_eq!(dfa.get_config().which_captures, None);",
                "    assert_eq!(dfa.get_config().nfa_size_limit, Some(Some(100)));",
                "    assert_eq!(dfa.get_config().onepass_size_limit, Some(Some(200)));",
                "    assert_eq!(dfa.get_config().hybrid_cache_capacity, Some(300));",
                "    assert_eq!(dfa.get_config().hybrid, None);",
                "    assert_eq!(dfa.get_config().dfa, Some(true));",
                "    assert_eq!(dfa.get_config().dfa_size_limit, Some(Some(400)));",
                "    assert_eq!(dfa.get_config().dfa_state_limit, Some(Some(500)));",
                "    assert_eq!(dfa.get_config().onepass, None);",
                "    assert_eq!(dfa.get_config().backtrack, Some(true));",
                "    assert_eq!(dfa.get_config().byte_classes, Some(false));",
                "    assert_eq!(dfa.get_config().line_terminator, Some(0));"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config {",
                "            match_kind: None,",
                "            utf8_empty: None,",
                "            autopre: None,",
                "            pre: None,",
                "            which_captures: None,",
                "            nfa_size_limit: Some(Some(100)),",
                "            onepass_size_limit: Some(Some(200)),",
                "            hybrid_cache_capacity: Some(300),",
                "            hybrid: None,",
                "            dfa: Some(true),",
                "            dfa_size_limit: Some(Some(400)),",
                "            dfa_state_limit: Some(Some(500)),",
                "            onepass: None,",
                "            backtrack: Some(true),",
                "            byte_classes: Some(false),",
                "            line_terminator: Some(0),",
                "        },",
                "        nfa: thompson::NFA::default(),",
                "        stride2: 0,",
                "        start_map: StartByteMap { map: [Start::default(); 256] },",
                "        classes: ByteClasses([0; 256]),",
                "        quitset: ByteSet::default(),",
                "        cache_capacity: 0,",
                "    };",
                "    dfa.get_config();",
                "    assert_eq!(dfa.get_config().match_kind, None);",
                "    assert_eq!(dfa.get_config().utf8_empty, None);",
                "    assert_eq!(dfa.get_config().autopre, None);",
                "    assert_eq!(dfa.get_config().pre, None);",
                "    assert_eq!(dfa.get_config().which_captures, None);",
                "    assert_eq!(dfa.get_config().nfa_size_limit, Some(Some(100)));",
                "    assert_eq!(dfa.get_config().onepass_size_limit, Some(Some(200)));",
                "    assert_eq!(dfa.get_config().hybrid_cache_capacity, Some(300));",
                "    assert_eq!(dfa.get_config().hybrid, None);",
                "    assert_eq!(dfa.get_config().dfa, Some(true));",
                "    assert_eq!(dfa.get_config().dfa_size_limit, Some(Some(400)));",
                "    assert_eq!(dfa.get_config().dfa_state_limit, Some(Some(500)));",
                "    assert_eq!(dfa.get_config().onepass, None);",
                "    assert_eq!(dfa.get_config().backtrack, Some(true));",
                "    assert_eq!(dfa.get_config().byte_classes, Some(false));",
                "    assert_eq!(dfa.get_config().line_terminator, Some(0));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config {",
                "            match_kind: None,",
                "            utf8_empty: None,",
                "            autopre: None,",
                "            pre: None,",
                "            which_captures: None,",
                "            nfa_size_limit: None,",
                "            onepass_size_limit: None,",
                "            hybrid_cache_capacity: None,",
                "            hybrid: None,",
                "            dfa: None,",
                "            dfa_size_limit: None,",
                "            dfa_state_limit: None,",
                "            onepass: None,",
                "            backtrack: None,",
                "            byte_classes: None,",
                "            line_terminator: Some(128),",
                "        },",
                "        nfa: thompson::NFA::default(),",
                "        stride2: 0,",
                "        start_map: StartByteMap { map: [Start::default(); 256] },",
                "        classes: ByteClasses([0; 256]),",
                "        quitset: ByteSet::default(),",
                "        cache_capacity: 0,",
                "    };",
                "    dfa.get_config();",
                "}"
              ],
              "oracle": [
                "    let dfa = DFA { config: Config { match_kind: None, utf8_empty: None, autopre: None, pre: None, which_captures: None, nfa_size_limit: None, onepass_size_limit: None, hybrid_cache_capacity: None, hybrid: None, dfa: None, dfa_size_limit: None, dfa_state_limit: None, onepass: None, backtrack: None, byte_classes: None, line_terminator: Some(128), }, nfa: thompson::NFA::default(), stride2: 0, start_map: StartByteMap { map: [Start::default(); 256] }, classes: ByteClasses([0; 256]), quitset: ByteSet::default(), cache_capacity: 0, }; let config = dfa.get_config(); assert_eq!(config.line_terminator, Some(128)); assert!(config.match_kind.is_none()); assert!(config.utf8_empty.is_none()); assert!(config.autopre.is_none()); assert!(config.pre.is_none()); assert!(config.which_captures.is_none()); assert!(config.nfa_size_limit.is_none()); assert!(config.onepass_size_limit.is_none()); assert!(config.hybrid_cache_capacity.is_none()); assert!(config.hybrid.is_none()); assert!(config.dfa.is_none()); assert!(config.dfa_size_limit.is_none()); assert!(config.dfa_state_limit.is_none()); assert!(config.onepass.is_none()); assert!(config.backtrack.is_none()); assert!(config.byte_classes.is_none());"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config {",
                "            match_kind: None,",
                "            utf8_empty: None,",
                "            autopre: None,",
                "            pre: None,",
                "            which_captures: None,",
                "            nfa_size_limit: None,",
                "            onepass_size_limit: None,",
                "            hybrid_cache_capacity: None,",
                "            hybrid: None,",
                "            dfa: None,",
                "            dfa_size_limit: None,",
                "            dfa_state_limit: None,",
                "            onepass: None,",
                "            backtrack: None,",
                "            byte_classes: None,",
                "            line_terminator: Some(128),",
                "        },",
                "        nfa: thompson::NFA::default(),",
                "        stride2: 0,",
                "        start_map: StartByteMap { map: [Start::default(); 256] },",
                "        classes: ByteClasses([0; 256]),",
                "        quitset: ByteSet::default(),",
                "        cache_capacity: 0,",
                "    };",
                "    dfa.get_config();",
                "    let dfa = DFA { config: Config { match_kind: None, utf8_empty: None, autopre: None, pre: None, which_captures: None, nfa_size_limit: None, onepass_size_limit: None, hybrid_cache_capacity: None, hybrid: None, dfa: None, dfa_size_limit: None, dfa_state_limit: None, onepass: None, backtrack: None, byte_classes: None, line_terminator: Some(128), }, nfa: thompson::NFA::default(), stride2: 0, start_map: StartByteMap { map: [Start::default(); 256] }, classes: ByteClasses([0; 256]), quitset: ByteSet::default(), cache_capacity: 0, }; let config = dfa.get_config(); assert_eq!(config.line_terminator, Some(128)); assert!(config.match_kind.is_none()); assert!(config.utf8_empty.is_none()); assert!(config.autopre.is_none()); assert!(config.pre.is_none()); assert!(config.which_captures.is_none()); assert!(config.nfa_size_limit.is_none()); assert!(config.onepass_size_limit.is_none()); assert!(config.hybrid_cache_capacity.is_none()); assert!(config.hybrid.is_none()); assert!(config.dfa.is_none()); assert!(config.dfa_size_limit.is_none()); assert!(config.dfa_state_limit.is_none()); assert!(config.onepass.is_none()); assert!(config.backtrack.is_none()); assert!(config.byte_classes.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}