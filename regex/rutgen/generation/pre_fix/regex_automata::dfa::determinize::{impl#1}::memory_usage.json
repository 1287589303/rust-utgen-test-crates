{
  "name": "regex_automata::dfa::determinize::{impl#1}::memory_usage",
  "mod_info": {
    "name": "dfa::determinize",
    "loc": "regex-automata/src/dfa/mod.rs:350:1:350:17"
  },
  "visible": false,
  "loc": "regex-automata/src/dfa/determinize.rs:589:5:598:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: self.builder_states.len() * size_of::<State>()\n        // Maps likely use more memory than this, but it's probably close.\n        + self.cache.len() * (size_of::<State>() + size_of::<StateID>())\n        + self.memory_usage_state\n        + self.stack.capacity() * size_of::<StateID>()\n        + self.scratch_state_builder.capacity()\n"
      ],
      "input_infer": "builder_states length: 0-1000, cache length: 0-100, memory_usage_state: 0-4096, stack capacity: 0-100, scratch_state_builder capacity: 0-100\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: Vec::new(),",
                "        cache: StateMap::default(),",
                "        memory_usage_state: 0,",
                "        sparses: SparseSets::default(),",
                "        stack: Vec::new(),",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(runner.builder_states.len(), 0);",
                "    assert_eq!(runner.cache.len(), 0);",
                "    assert_eq!(runner.memory_usage_state, 0);",
                "    assert_eq!(runner.stack.capacity(), 0);",
                "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(runner.memory_usage(), 0);"
              ],
              "code": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: Vec::new(),",
                "        cache: StateMap::default(),",
                "        memory_usage_state: 0,",
                "        sparses: SparseSets::default(),",
                "        stack: Vec::new(),",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "    assert_eq!(runner.builder_states.len(), 0);",
                "    assert_eq!(runner.cache.len(), 0);",
                "    assert_eq!(runner.memory_usage_state, 0);",
                "    assert_eq!(runner.stack.capacity(), 0);",
                "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(runner.memory_usage(), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let state = State {",
                "        id: StateID(0),",
                "        transitions: &[],",
                "    };",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: vec![state],",
                "        cache: StateMap::default(),",
                "        memory_usage_state: 10,",
                "        sparses: SparseSets::default(),",
                "        stack: Vec::new(),",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(runner.builder_states.len(), 1);",
                "    assert_eq!(core::mem::size_of::<State>(), expected_size_of_state);",
                "    assert_eq!(runner.cache.len(), 0);",
                "    assert_eq!(runner.memory_usage_state, 10);",
                "    assert_eq!(runner.stack.capacity(), 0);",
                "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(runner.memory_usage(),",
                "    runner.builder_states.len() * core::mem::size_of::<State>() +",
                "    runner.cache.len() * (core::mem::size_of::<State>() + core::mem::size_of::<StateID>()) +",
                "    runner.memory_usage_state +",
                "    runner.stack.capacity() * core::mem::size_of::<StateID>() +",
                "    runner.scratch_state_builder.capacity());"
              ],
              "code": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let state = State {",
                "        id: StateID(0),",
                "        transitions: &[],",
                "    };",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: vec![state],",
                "        cache: StateMap::default(),",
                "        memory_usage_state: 10,",
                "        sparses: SparseSets::default(),",
                "        stack: Vec::new(),",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "    assert_eq!(runner.builder_states.len(), 1);",
                "    assert_eq!(core::mem::size_of::<State>(), expected_size_of_state);",
                "    assert_eq!(runner.cache.len(), 0);",
                "    assert_eq!(runner.memory_usage_state, 10);",
                "    assert_eq!(runner.stack.capacity(), 0);",
                "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(runner.memory_usage(),",
                "    runner.builder_states.len() * core::mem::size_of::<State>() +",
                "    runner.cache.len() * (core::mem::size_of::<State>() + core::mem::size_of::<StateID>()) +",
                "    runner.memory_usage_state +",
                "    runner.stack.capacity() * core::mem::size_of::<StateID>() +",
                "    runner.scratch_state_builder.capacity());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let states: Vec<State> = (0..10).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: states,",
                "        cache: StateMap::default(),",
                "        memory_usage_state: 50,",
                "        sparses: SparseSets::default(),",
                "        stack: vec![0; 5],",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(runner.builder_states.len(), 10);",
                "    assert_eq!(runner.cache.len(), 0);",
                "    assert_eq!(runner.memory_usage_state, 50);",
                "    assert_eq!(runner.stack.capacity(), 5);",
                "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
                "    let expected_memory_usage = (runner.builder_states.len() * core::mem::size_of::<State>()",
                "    + runner.cache.len() * (core::mem::size_of::<State>() + core::mem::size_of::<StateID>())",
                "    + runner.memory_usage_state",
                "    + runner.stack.capacity() * core::mem::size_of::<StateID>()",
                "    + runner.scratch_state_builder.capacity());",
                "    assert_eq!(runner.memory_usage(), expected_memory_usage);"
              ],
              "code": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let states: Vec<State> = (0..10).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: states,",
                "        cache: StateMap::default(),",
                "        memory_usage_state: 50,",
                "        sparses: SparseSets::default(),",
                "        stack: vec![0; 5],",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "    assert_eq!(runner.builder_states.len(), 10);",
                "    assert_eq!(runner.cache.len(), 0);",
                "    assert_eq!(runner.memory_usage_state, 50);",
                "    assert_eq!(runner.stack.capacity(), 5);",
                "    assert_eq!(runner.scratch_state_builder.capacity(), 0);",
                "    let expected_memory_usage = (runner.builder_states.len() * core::mem::size_of::<State>()",
                "    + runner.cache.len() * (core::mem::size_of::<State>() + core::mem::size_of::<StateID>())",
                "    + runner.memory_usage_state",
                "    + runner.stack.capacity() * core::mem::size_of::<StateID>()",
                "    + runner.scratch_state_builder.capacity());",
                "    assert_eq!(runner.memory_usage(), expected_memory_usage);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let states: Vec<State> = (0..1000).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: states,",
                "        cache: StateMap::default(),",
                "        memory_usage_state: 4096,",
                "        sparses: SparseSets::default(),",
                "        stack: vec![0; 100],",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "}"
              ],
              "oracle": [
                "    runner.builder_states.len() * size_of::<State>() == 1000 * size_of::<State>()",
                "    runner.cache.len() * (size_of::<State>() + size_of::<StateID>()) == 0 * (size_of::<State>() + size_of::<StateID>())",
                "    runner.memory_usage_state == 4096",
                "    runner.stack.capacity() * size_of::<StateID>() == 100 * size_of::<StateID>()",
                "    runner.scratch_state_builder.capacity() == 0"
              ],
              "code": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let states: Vec<State> = (0..1000).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: states,",
                "        cache: StateMap::default(),",
                "        memory_usage_state: 4096,",
                "        sparses: SparseSets::default(),",
                "        stack: vec![0; 100],",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "    runner.builder_states.len() * size_of::<State>() == 1000 * size_of::<State>()",
                "    runner.cache.len() * (size_of::<State>() + size_of::<StateID>()) == 0 * (size_of::<State>() + size_of::<StateID>())",
                "    runner.memory_usage_state == 4096",
                "    runner.stack.capacity() * size_of::<StateID>() == 100 * size_of::<StateID>()",
                "    runner.scratch_state_builder.capacity() == 0",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let states: Vec<State> = (0..50).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: states,",
                "        cache: StateMap::from_iter((0..5).map(|i| (State(i), StateID(i)))),",
                "        memory_usage_state: 100,",
                "        sparses: SparseSets::default(),",
                "        stack: vec![0; 20],",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(runner.memory_usage(), 50 * std::mem::size_of::<State>() + 5 * (std::mem::size_of::<State>() + std::mem::size_of::<StateID>()) + 100 + 20 * std::mem::size_of::<StateID>() + runner.scratch_state_builder.capacity());"
              ],
              "code": [
                "{",
                "    let config = Config::default();",
                "    let nfa = Box::new(thompson::NFA::new());",
                "    let mut dfa = dense::OwnedDFA::default();",
                "    let states: Vec<State> = (0..50).map(|i| State { id: StateID(i), transitions: &[] }).collect();",
                "    let runner = Runner {",
                "        config,",
                "        nfa: &nfa,",
                "        dfa: &mut dfa,",
                "        builder_states: states,",
                "        cache: StateMap::from_iter((0..5).map(|i| (State(i), StateID(i)))),",
                "        memory_usage_state: 100,",
                "        sparses: SparseSets::default(),",
                "        stack: vec![0; 20],",
                "        scratch_state_builder: StateBuilderEmpty::new(),",
                "    };",
                "    let _ = runner.memory_usage();",
                "    assert_eq!(runner.memory_usage(), 50 * std::mem::size_of::<State>() + 5 * (std::mem::size_of::<State>() + std::mem::size_of::<StateID>()) + 100 + 20 * std::mem::size_of::<StateID>() + runner.scratch_state_builder.capacity());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}