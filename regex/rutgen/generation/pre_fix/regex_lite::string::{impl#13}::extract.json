{
  "name": "regex_lite::string::{impl#13}::extract",
  "mod_info": {
    "name": "string",
    "loc": "regex-lite/src/lib.rs:884:1:884:12"
  },
  "visible": true,
  "loc": "regex-lite/src/string.rs:1795:5:1808:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: (*left_val == *right_val) at line 53 is true\n",
        "expected return value/type: (whole_match, group_matches)\n"
      ],
      "input_infer": "N must match the number of static explicit captures in the regex pattern, haystack must contain a valid string that can match the regex, N must be a positive integer and should range from 1 to the maximum number of capture groups defined in the regex, ensuring edge cases where haystack is empty, haystack matches multiple times, or no matches.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
                "    let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";",
                "    let captures = re.captures(hay).unwrap();",
                "    let (full, [year, month, day]) = captures.extract::<3>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(full, \"2010-03-14\");",
                "    assert_eq!(year, \"2010\");",
                "    assert_eq!(month, \"03\");",
                "    assert_eq!(day, \"14\");",
                "    ",
                "    let invalid_re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})|(c)\").unwrap();",
                "    let invalid_captures = invalid_re.captures(hay).unwrap();",
                "    let result = std::panic::catch_unwind(|| {",
                "    invalid_captures.extract::<3>()",
                "    });",
                "    assert!(result.is_err());",
                "    ",
                "    let re_varied = Regex::new(r\"(a)(b)|(c)\").unwrap();",
                "    let hay_varied = \"ac\";",
                "    let captures_varied = re_varied.captures(hay_varied).unwrap();",
                "    let result_varied = std::panic::catch_unwind(|| {",
                "    captures_varied.extract::<2>()",
                "    });",
                "    assert!(result_varied.is_err());",
                "    ",
                "    let empty_hay = \"\";",
                "    let empty_captures = re.captures(empty_hay).unwrap();",
                "    let result_empty = std::panic::catch_unwind(|| {",
                "    empty_captures.extract::<3>()",
                "    });",
                "    assert!(result_empty.is_err());",
                "    ",
                "    let no_capture_hay = \"Just some text.\";",
                "    let no_capture_captures = re.captures(no_capture_hay).unwrap();",
                "    let result_no_capture = std::panic::catch_unwind(|| {",
                "    no_capture_captures.extract::<3>()",
                "    });",
                "    assert!(result_no_capture.is_err());"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
                "    let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";",
                "    let captures = re.captures(hay).unwrap();",
                "    let (full, [year, month, day]) = captures.extract::<3>();",
                "    assert_eq!(full, \"2010-03-14\");",
                "    assert_eq!(year, \"2010\");",
                "    assert_eq!(month, \"03\");",
                "    assert_eq!(day, \"14\");",
                "    ",
                "    let invalid_re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})|(c)\").unwrap();",
                "    let invalid_captures = invalid_re.captures(hay).unwrap();",
                "    let result = std::panic::catch_unwind(|| {",
                "    invalid_captures.extract::<3>()",
                "    });",
                "    assert!(result.is_err());",
                "    ",
                "    let re_varied = Regex::new(r\"(a)(b)|(c)\").unwrap();",
                "    let hay_varied = \"ac\";",
                "    let captures_varied = re_varied.captures(hay_varied).unwrap();",
                "    let result_varied = std::panic::catch_unwind(|| {",
                "    captures_varied.extract::<2>()",
                "    });",
                "    assert!(result_varied.is_err());",
                "    ",
                "    let empty_hay = \"\";",
                "    let empty_captures = re.captures(empty_hay).unwrap();",
                "    let result_empty = std::panic::catch_unwind(|| {",
                "    empty_captures.extract::<3>()",
                "    });",
                "    assert!(result_empty.is_err());",
                "    ",
                "    let no_capture_hay = \"Just some text.\";",
                "    let no_capture_captures = re.captures(no_capture_hay).unwrap();",
                "    let result_no_capture = std::panic::catch_unwind(|| {",
                "    no_capture_captures.extract::<3>()",
                "    });",
                "    assert!(result_no_capture.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
                "    let hay = \"\";",
                "    let captures = re.captures(hay);",
                "    assert!(captures.is_none());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(captures.extract::<3>(), (\"\", [\"\", \"\", \"\"]));",
                "    assert!(captures.is_none());",
                "    assert_eq!(captures.extract::<0>(), (\"\", []));",
                "    assert_eq!(captures.extract::<1>(), (\"\", [\"\"]));",
                "    assert_eq!(captures.extract::<2>(), (\"\", [\"\", \"\"]));",
                "    assert!(!captures.is_some());",
                "    assert!(captures.len() == 0);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
                "    let hay = \"\";",
                "    let captures = re.captures(hay);",
                "    assert!(captures.is_none());",
                "    assert_eq!(captures.extract::<3>(), (\"\", [\"\", \"\", \"\"]));",
                "    assert!(captures.is_none());",
                "    assert_eq!(captures.extract::<0>(), (\"\", []));",
                "    assert_eq!(captures.extract::<1>(), (\"\", [\"\"]));",
                "    assert_eq!(captures.extract::<2>(), (\"\", [\"\", \"\"]));",
                "    assert!(!captures.is_some());",
                "    assert!(captures.len() == 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
                "    let hay = \"xyz\";",
                "    let captures = re.captures(hay);",
                "    assert!(captures.is_none());",
                "}"
              ],
              "oracle": [
                "    assert!(captures.is_none());",
                "    ",
                "    let captures = re.captures(\"abc\");",
                "    let (whole_match, group_matches) = captures.extract::<3>();",
                "    assert_eq!(whole_match, \"abc\");",
                "    assert_eq!(group_matches, [\"a\", \"b\", \"c\"]);",
                "    ",
                "    let captures = re.captures(\"a\");",
                "    assert!(captures.is_none());",
                "    ",
                "    let captures = re.captures(\"ab\");",
                "    assert!(captures.is_none());",
                "    ",
                "    let captures = re.captures(\"abcabc\");",
                "    let (whole_match, group_matches) = captures.extract::<3>();",
                "    assert_eq!(whole_match, \"abc\");",
                "    assert_eq!(group_matches, [\"a\", \"b\", \"c\"]);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
                "    let hay = \"xyz\";",
                "    let captures = re.captures(hay);",
                "    assert!(captures.is_none());",
                "    assert!(captures.is_none());",
                "    ",
                "    let captures = re.captures(\"abc\");",
                "    let (whole_match, group_matches) = captures.extract::<3>();",
                "    assert_eq!(whole_match, \"abc\");",
                "    assert_eq!(group_matches, [\"a\", \"b\", \"c\"]);",
                "    ",
                "    let captures = re.captures(\"a\");",
                "    assert!(captures.is_none());",
                "    ",
                "    let captures = re.captures(\"ab\");",
                "    assert!(captures.is_none());",
                "    ",
                "    let captures = re.captures(\"abcabc\");",
                "    let (whole_match, group_matches) = captures.extract::<3>();",
                "    assert_eq!(whole_match, \"abc\");",
                "    assert_eq!(group_matches, [\"a\", \"b\", \"c\"]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
                "    let hay = \"1973-01-05, 1975-08-25 and 1980-10-18\";",
                "    let mut dates: Vec<(&str, &str, &str)> = vec![];",
                "    for captures in re.captures_iter(hay) {",
                "        let (full, [year, month, day]) = captures.extract::<3>();",
                "        dates.push((year, month, day));",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dates.len(), 3);",
                "    assert_eq!(dates[0].0, \"1973\");",
                "    assert_eq!(dates[0].1, \"01\");",
                "    assert_eq!(dates[0].2, \"05\");",
                "    assert_eq!(dates[1].0, \"1975\");",
                "    assert_eq!(dates[1].1, \"08\");",
                "    assert_eq!(dates[1].2, \"25\");",
                "    assert_eq!(dates[2].0, \"1980\");",
                "    assert_eq!(dates[2].1, \"10\");",
                "    assert_eq!(dates[2].2, \"18\");"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
                "    let hay = \"1973-01-05, 1975-08-25 and 1980-10-18\";",
                "    let mut dates: Vec<(&str, &str, &str)> = vec![];",
                "    for captures in re.captures_iter(hay) {",
                "        let (full, [year, month, day]) = captures.extract::<3>();",
                "        dates.push((year, month, day));",
                "    }",
                "    assert_eq!(dates.len(), 3);",
                "    assert_eq!(dates[0].0, \"1973\");",
                "    assert_eq!(dates[0].1, \"01\");",
                "    assert_eq!(dates[0].2, \"05\");",
                "    assert_eq!(dates[1].0, \"1975\");",
                "    assert_eq!(dates[1].1, \"08\");",
                "    assert_eq!(dates[1].2, \"25\");",
                "    assert_eq!(dates[2].0, \"1980\");",
                "    assert_eq!(dates[2].1, \"10\");",
                "    assert_eq!(dates[2].2, \"18\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"(\\d+)\").unwrap();",
                "    let hay = \"There are 42 apples.\";",
                "    let captures = re.captures(hay).unwrap();",
                "    let (full, [number]) = captures.extract::<1>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(full, \"42\");",
                "    assert_eq!(number, \"42\");",
                "    assert_eq!(captures.len(), 1);",
                "    assert!(captures.get(0).is_some());",
                "    assert!(captures.name(\"0\").is_some());"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"(\\d+)\").unwrap();",
                "    let hay = \"There are 42 apples.\";",
                "    let captures = re.captures(hay).unwrap();",
                "    let (full, [number]) = captures.extract::<1>();",
                "    assert_eq!(full, \"42\");",
                "    assert_eq!(number, \"42\");",
                "    assert_eq!(captures.len(), 1);",
                "    assert!(captures.get(0).is_some());",
                "    assert!(captures.name(\"0\").is_some());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let re = Regex::new(r\"([a-z]+)-([0-9]+)\").unwrap();",
                "    let hay = \"foo-42\";",
                "    let captures = re.captures(hay).unwrap();",
                "    let (_, [string]) = captures.extract::<1>(); // This should panic since N != number of groups",
                "}"
              ],
              "oracle": [
                "    assert_eq!(captures.extract::<1>(), Err(\"asked for 1 groups, but must ask for 2\"));",
                "    assert_eq!(captures.len(), 2);",
                "    assert!(captures.get(0).is_some());",
                "    assert!(captures.get(1).is_some());",
                "    assert!(captures.name(\"0\").is_some());",
                "    assert!(captures.name(\"1\").is_some());",
                "    assert!(captures.iter().count() == captures.len());",
                "    assert!(captures.extract::<2>().0 == \"foo-42\");",
                "    assert!(captures.extract::<2>().1[0] == \"foo\");",
                "    assert!(captures.extract::<2>().1[1] == \"42\");",
                "    assert!(captures.get(0).unwrap().is_empty() == false);",
                "    assert!(captures.get(1).unwrap().is_empty() == false);"
              ],
              "code": [
                "{",
                "    let re = Regex::new(r\"([a-z]+)-([0-9]+)\").unwrap();",
                "    let hay = \"foo-42\";",
                "    let captures = re.captures(hay).unwrap();",
                "    let (_, [string]) = captures.extract::<1>(); // This should panic since N != number of groups",
                "    assert_eq!(captures.extract::<1>(), Err(\"asked for 1 groups, but must ask for 2\"));",
                "    assert_eq!(captures.len(), 2);",
                "    assert!(captures.get(0).is_some());",
                "    assert!(captures.get(1).is_some());",
                "    assert!(captures.name(\"0\").is_some());",
                "    assert!(captures.name(\"1\").is_some());",
                "    assert!(captures.iter().count() == captures.len());",
                "    assert!(captures.extract::<2>().0 == \"foo-42\");",
                "    assert!(captures.extract::<2>().1[0] == \"foo\");",
                "    assert!(captures.extract::<2>().1[1] == \"42\");",
                "    assert!(captures.get(0).unwrap().is_empty() == false);",
                "    assert!(captures.get(1).unwrap().is_empty() == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: (*left_val == *right_val) at line 53 is false\n"
      ],
      "input_infer": "self.pikevm.nfa().static_explicit_captures_len() must return a constant value N (1 to max captures) for which self.iter() returns a match with exactly N capture groups; haystack must not match a regex with a variable number of groups.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(r\"([0-9]{4})\"),",
                "        states: vec![],",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![Some(Arc::from(\"year\"))],",
                "        memory_extra: 0,",
                "    };",
                "    let pikevm = PikeVM::new(nfa);",
                "    let captures = Captures {",
                "        haystack: \"2010\",",
                "        slots: CaptureLocations(vec![Some(NonMaxUsize::new(0).unwrap())]),",
                "        pikevm: Arc::new(pikevm),",
                "    };",
                "",
                "    let (full, [year]) = captures.extract::<1>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(full, \"2010\");",
                "    assert_eq!(year, \"2010\");"
              ],
              "code": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(r\"([0-9]{4})\"),",
                "        states: vec![],",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![Some(Arc::from(\"year\"))],",
                "        memory_extra: 0,",
                "    };",
                "    let pikevm = PikeVM::new(nfa);",
                "    let captures = Captures {",
                "        haystack: \"2010\",",
                "        slots: CaptureLocations(vec![Some(NonMaxUsize::new(0).unwrap())]),",
                "        pikevm: Arc::new(pikevm),",
                "    };",
                "",
                "    let (full, [year]) = captures.extract::<1>();",
                "    assert_eq!(full, \"2010\");",
                "    assert_eq!(year, \"2010\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(r\"([0-9]{4})-([0-9]{2})\"),",
                "        states: vec![],",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(2),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![Some(Arc::from(\"year\")), Some(Arc::from(\"month\"))],",
                "        memory_extra: 0,",
                "    };",
                "    let pikevm = PikeVM::new(nfa);",
                "    let captures = Captures {",
                "        haystack: \"2010-03\",",
                "        slots: CaptureLocations(vec![Some(NonMaxUsize::new(0).unwrap()), Some(NonMaxUsize::new(1).unwrap())]),",
                "        pikevm: Arc::new(pikevm),",
                "    };",
                "",
                "    let (full, [year, month]) = captures.extract::<2>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(captures.extract::<2>(), (\"2010-03\", [\"2010\", \"03\"]));",
                "    let (full, [year, month]) = captures.extract::<2>();",
                "    assert!(matches!(captures.extract::<2>(), (\"2010-03\", [\"2010\", \"03\"]));",
                "    assert_eq!(captures.len(), 2);",
                "    assert!(captured.is_match_empty() == false);",
                "    assert!(captures.iter().next().is_some());",
                "    assert!(captures.get(0).is_some());",
                "    assert!(captures.get(1).is_some());",
                "    assert!(captures.name(\"year\").is_some());",
                "    assert!(captures.name(\"month\").is_some());",
                "    assert!(captures.extract::<3>().is_err());",
                "    assert!(captures.extract::<1>().is_err());"
              ],
              "code": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(r\"([0-9]{4})-([0-9]{2})\"),",
                "        states: vec![],",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(2),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![Some(Arc::from(\"year\")), Some(Arc::from(\"month\"))],",
                "        memory_extra: 0,",
                "    };",
                "    let pikevm = PikeVM::new(nfa);",
                "    let captures = Captures {",
                "        haystack: \"2010-03\",",
                "        slots: CaptureLocations(vec![Some(NonMaxUsize::new(0).unwrap()), Some(NonMaxUsize::new(1).unwrap())]),",
                "        pikevm: Arc::new(pikevm),",
                "    };",
                "",
                "    let (full, [year, month]) = captures.extract::<2>();",
                "    assert_eq!(captures.extract::<2>(), (\"2010-03\", [\"2010\", \"03\"]));",
                "    let (full, [year, month]) = captures.extract::<2>();",
                "    assert!(matches!(captures.extract::<2>(), (\"2010-03\", [\"2010\", \"03\"]));",
                "    assert_eq!(captures.len(), 2);",
                "    assert!(captured.is_match_empty() == false);",
                "    assert!(captures.iter().next().is_some());",
                "    assert!(captures.get(0).is_some());",
                "    assert!(captures.get(1).is_some());",
                "    assert!(captures.name(\"year\").is_some());",
                "    assert!(captures.name(\"month\").is_some());",
                "    assert!(captures.extract::<3>().is_err());",
                "    assert!(captures.extract::<1>().is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic(expected = \"asked for 3 groups, but must ask for 2\")]"
              ],
              "prefix": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(r\"([0-9]{4})-([0-9]{2})\"),",
                "        states: vec![],",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(2),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![Some(Arc::from(\"year\")), Some(Arc::from(\"month\"))],",
                "        memory_extra: 0,",
                "    };",
                "    let pikevm = PikeVM::new(nfa);",
                "    let captures = Captures {",
                "        haystack: \"2010-03\",",
                "        slots: CaptureLocations(vec![Some(NonMaxUsize::new(0).unwrap()), Some(NonMaxUsize::new(1).unwrap())]),",
                "        pikevm: Arc::new(pikevm),",
                "    };",
                "",
                "    let (full, [year, month, day]) = captures.extract::<3>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(captures.pikevm.nfa().static_explicit_captures_len(), Some(2));",
                "    #[should_panic(expected = \"number of capture groups can vary in a match\")]",
                "    let (full, [year, month, day]) = captures.extract::<3>();"
              ],
              "code": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(r\"([0-9]{4})-([0-9]{2})\"),",
                "        states: vec![],",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(2),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![Some(Arc::from(\"year\")), Some(Arc::from(\"month\"))],",
                "        memory_extra: 0,",
                "    };",
                "    let pikevm = PikeVM::new(nfa);",
                "    let captures = Captures {",
                "        haystack: \"2010-03\",",
                "        slots: CaptureLocations(vec![Some(NonMaxUsize::new(0).unwrap()), Some(NonMaxUsize::new(1).unwrap())]),",
                "        pikevm: Arc::new(pikevm),",
                "    };",
                "",
                "    let (full, [year, month, day]) = captures.extract::<3>();",
                "    assert_eq!(captures.pikevm.nfa().static_explicit_captures_len(), Some(2));",
                "    #[should_panic(expected = \"number of capture groups can vary in a match\")]",
                "    let (full, [year, month, day]) = captures.extract::<3>();",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(r\"Hello\"),",
                "        states: vec![],",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(0),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![],",
                "        memory_extra: 0,",
                "    };",
                "    let pikevm = PikeVM::new(nfa);",
                "    let captures = Captures {",
                "        haystack: \"Hello\",",
                "        slots: CaptureLocations(vec![]),",
                "        pikevm: Arc::new(pikevm),",
                "    };",
                "",
                "    let (full, groups): (&str, [&str; 0]) = captures.extract::<0>();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(full, \"Hello\");",
                "    assert_eq!(groups.len(), 0);",
                "    assert!(matches!(captures.extract::<1>(), _));",
                "    assert!(matches!(captures.extract::<2>(), _));",
                "    assert!(matches!(captures.extract::<3>(), _));",
                "    assert!(matches!(captures.extract::<4>(), _));"
              ],
              "code": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(r\"Hello\"),",
                "        states: vec![],",
                "        start: 0,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(0),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![],",
                "        memory_extra: 0,",
                "    };",
                "    let pikevm = PikeVM::new(nfa);",
                "    let captures = Captures {",
                "        haystack: \"Hello\",",
                "        slots: CaptureLocations(vec![]),",
                "        pikevm: Arc::new(pikevm),",
                "    };",
                "",
                "    let (full, groups): (&str, [&str; 0]) = captures.extract::<0>();",
                "    assert_eq!(full, \"Hello\");",
                "    assert_eq!(groups.len(), 0);",
                "    assert!(matches!(captures.extract::<1>(), _));",
                "    assert!(matches!(captures.extract::<2>(), _));",
                "    assert!(matches!(captures.extract::<3>(), _));",
                "    assert!(matches!(captures.extract::<4>(), _));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}