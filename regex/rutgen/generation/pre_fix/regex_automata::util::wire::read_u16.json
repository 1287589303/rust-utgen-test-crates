{
  "name": "regex_automata::util::wire::read_u16",
  "mod_info": {
    "name": "util::wire",
    "loc": "regex-automata/src/util/mod.rs:46:1:46:14"
  },
  "visible": true,
  "loc": "regex-automata/src/util/wire.rs:760:1:763:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Slice input must be of length 2 bytes, consisting of valid u8 values (0-255); valid inputs are [0, 0] to [255, 255] with edge cases of lengths less than 2 bytes causing a panic.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[0, 0];",
                "    let result = read_u16(slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 0);",
                "    let slice: &[u8] = &[1, 0];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 1);",
                "    let slice: &[u8] = &[0, 1];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 256);",
                "    let slice: &[u8] = &[255, 255];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 65535);",
                "    let slice: &[u8] = &[];",
                "    let result = std::panic::catch_unwind(|| read_u16(slice));",
                "    assert!(result.is_err());",
                "    let slice: &[u8] = &[0];",
                "    let result = std::panic::catch_unwind(|| read_u16(slice));",
                "    assert!(result.is_err());"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[0, 0];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 0);",
                "    let slice: &[u8] = &[1, 0];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 1);",
                "    let slice: &[u8] = &[0, 1];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 256);",
                "    let slice: &[u8] = &[255, 255];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 65535);",
                "    let slice: &[u8] = &[];",
                "    let result = std::panic::catch_unwind(|| read_u16(slice));",
                "    assert!(result.is_err());",
                "    let slice: &[u8] = &[0];",
                "    let result = std::panic::catch_unwind(|| read_u16(slice));",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[255, 255];",
                "    let result = read_u16(slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 65535);",
                "    assert_eq!(result, u16::from_ne_bytes([255, 255]));",
                "    assert!(std::panic::catch_unwind(|| read_u16(&[1])).is_err());",
                "    assert!(std::panic::catch_unwind(|| read_u16(&[])).is_err());"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[255, 255];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 65535);",
                "    assert_eq!(result, u16::from_ne_bytes([255, 255]));",
                "    assert!(std::panic::catch_unwind(|| read_u16(&[1])).is_err());",
                "    assert!(std::panic::catch_unwind(|| read_u16(&[])).is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[0];",
                "    let result = read_u16(slice);",
                "}"
              ],
              "oracle": [
                "    assert_panics!(|| read_u16(&[0]));",
                "    assert_panics!(|| read_u16(&[]));",
                "    assert_panics!(|| read_u16(&[1]));",
                "    assert_eq!(read_u16(&[1, 0]), 1);",
                "    assert_eq!(read_u16(&[0, 1]), 256);",
                "    assert_eq!(read_u16(&[255, 255]), 65535);",
                "    assert_eq!(read_u16(&[0, 0]), 0);"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[0];",
                "    let result = read_u16(slice);",
                "    assert_panics!(|| read_u16(&[0]));",
                "    assert_panics!(|| read_u16(&[]));",
                "    assert_panics!(|| read_u16(&[1]));",
                "    assert_eq!(read_u16(&[1, 0]), 1);",
                "    assert_eq!(read_u16(&[0, 1]), 256);",
                "    assert_eq!(read_u16(&[255, 255]), 65535);",
                "    assert_eq!(read_u16(&[0, 0]), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[];",
                "    let result = read_u16(slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(read_u16(&[0x01, 0x02]), 0x0201);",
                "    assert_eq!(read_u16(&[0xFF, 0x00]), 0x00FF);",
                "    assert_eq!(read_u16(&[0xAB, 0xCD]), 0xCDAB);",
                "    assert_eq!(read_u16(&[0x00, 0x00]), 0x0000);",
                "    assert_eq!(read_u16(&[0x12, 0x34]), 0x3432);",
                "    assert!(std::panic::catch_unwind(|| read_u16(&[])).is_err());"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[];",
                "    let result = read_u16(slice);",
                "    assert_eq!(read_u16(&[0x01, 0x02]), 0x0201);",
                "    assert_eq!(read_u16(&[0xFF, 0x00]), 0x00FF);",
                "    assert_eq!(read_u16(&[0xAB, 0xCD]), 0xCDAB);",
                "    assert_eq!(read_u16(&[0x00, 0x00]), 0x0000);",
                "    assert_eq!(read_u16(&[0x12, 0x34]), 0x3432);",
                "    assert!(std::panic::catch_unwind(|| read_u16(&[])).is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[1, 2];",
                "    let result = read_u16(slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 513);"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[1, 2];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 513);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[127, 128];",
                "    let result = read_u16(slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 32896);  // Expected value for u16 from bytes [127, 128] in native endian format.",
                "    assert!(panic::catch_unwind(|| read_u16(&[1])).is_err());  // Test for panic with insufficient bytes.",
                "    assert!(panic::catch_unwind(|| read_u16(&[])).is_err());  // Test for panic with empty slice.",
                "    assert_eq!(read_u16(&[0, 1]), 256);  // Test with bytes representing u16 value 256.",
                "    assert_eq!(read_u16(&[255, 255]), 65535);  // Test with maximum u16 value."
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[127, 128];",
                "    let result = read_u16(slice);",
                "    assert_eq!(result, 32896);  // Expected value for u16 from bytes [127, 128] in native endian format.",
                "    assert!(panic::catch_unwind(|| read_u16(&[1])).is_err());  // Test for panic with insufficient bytes.",
                "    assert!(panic::catch_unwind(|| read_u16(&[])).is_err());  // Test for panic with empty slice.",
                "    assert_eq!(read_u16(&[0, 1]), 256);  // Test with bytes representing u16 value 256.",
                "    assert_eq!(read_u16(&[255, 255]), 65535);  // Test with maximum u16 value.",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}