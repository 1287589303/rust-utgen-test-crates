{
  "name": "regex_syntax::hir::{impl#10}::maximum_len",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:190:1:190:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:997:5:1002:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: *self matches Class::Bytes(ref x) at line 998 is true\n"
      ],
      "input_infer": "self should be an instance of Class::Bytes initialized with a range containing one or more valid byte ranges; ranges must not be empty and should include edge cases like [0x00, 0xFF] or single-byte ranges like [0x61, 0x61].\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(0x61, 0x61)]));",
                "    let _ = byte_class.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(byte_class.maximum_len(), Some(1));"
              ],
              "code": [
                "{",
                "    let byte_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(0x61, 0x61)]));",
                "    let _ = byte_class.maximum_len();",
                "    assert_eq!(byte_class.maximum_len(), Some(1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte_class = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0x00, 0x1F),",
                "        ClassBytesRange::new(0x20, 0x7E),",
                "        ClassBytesRange::new(0x80, 0xFF),",
                "    ]));",
                "    let _ = byte_class.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(byte_class.maximum_len(), Some(1));"
              ],
              "code": [
                "{",
                "    let byte_class = Class::Bytes(ClassBytes::new(vec![",
                "        ClassBytesRange::new(0x00, 0x1F),",
                "        ClassBytesRange::new(0x20, 0x7E),",
                "        ClassBytesRange::new(0x80, 0xFF),",
                "    ]));",
                "    let _ = byte_class.maximum_len();",
                "    assert_eq!(byte_class.maximum_len(), Some(1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(0x00, 0xFF)]));",
                "    let _ = byte_class.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(byte_class.maximum_len(), Some(1));"
              ],
              "code": [
                "{",
                "    let byte_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(0x00, 0xFF)]));",
                "    let _ = byte_class.maximum_len();",
                "    assert_eq!(byte_class.maximum_len(), Some(1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte_class = Class::Bytes(ClassBytes::empty());",
                "    let _ = byte_class.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(None, byte_class.maximum_len());"
              ],
              "code": [
                "{",
                "    let byte_class = Class::Bytes(ClassBytes::empty());",
                "    let _ = byte_class.maximum_len();",
                "    assert_eq!(None, byte_class.maximum_len());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: *self matches Class::Unicode(ref x) at line 998 is true\n",
        "precondition: *self matches Class::Unicode(ref x) at line 998 is true\n"
      ],
      "input_infer": "Class::Unicode with ranges covering characters that produce maximum byte lengths of 1 to 4, including an empty ClassUnicode for None return value, and a ClassUnicode with an unbounded repeat scenario for maximum return of None.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let empty_class_unicode = Class::Unicode(ClassUnicode::empty());",
                "    let _ = empty_class_unicode.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(empty_class_unicode.maximum_len(), None);",
                "    let bounded_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a'..='z')]));",
                "    assert_eq!(bounded_class_unicode.maximum_len(), Some(1));",
                "    let unbounded_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('ðŸ˜€'..='ðŸ˜€')]));",
                "    assert_eq!(unbounded_class_unicode.maximum_len(), Some(4));",
                "    let negated_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a'..='z')]));",
                "    negated_class_unicode.negate();",
                "    assert_eq!(negated_class_unicode.maximum_len(), Some(1));",
                "    let mixed_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('A'..='Z'), ClassUnicodeRange::new('a'..='z')]));",
                "    assert_eq!(mixed_class_unicode.maximum_len(), Some(1));"
              ],
              "code": [
                "{",
                "    let empty_class_unicode = Class::Unicode(ClassUnicode::empty());",
                "    let _ = empty_class_unicode.maximum_len();",
                "    assert_eq!(empty_class_unicode.maximum_len(), None);",
                "    let bounded_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a'..='z')]));",
                "    assert_eq!(bounded_class_unicode.maximum_len(), Some(1));",
                "    let unbounded_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('ðŸ˜€'..='ðŸ˜€')]));",
                "    assert_eq!(unbounded_class_unicode.maximum_len(), Some(4));",
                "    let negated_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a'..='z')]));",
                "    negated_class_unicode.negate();",
                "    assert_eq!(negated_class_unicode.maximum_len(), Some(1));",
                "    let mixed_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('A'..='Z'), ClassUnicodeRange::new('a'..='z')]));",
                "    assert_eq!(mixed_class_unicode.maximum_len(), Some(1));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let single_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0041}'..= '\\u{0041}')]));",
                "    let _ = single_byte_class_unicode.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(single_byte_class_unicode.maximum_len(), Some(1));",
                "    ",
                "    let double_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{00C1}'..= '\\u{00C1}')]));",
                "    assert_eq!(double_byte_class_unicode.maximum_len(), Some(2));",
                "    ",
                "    let three_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{E1}'..= '\\u{E1}')]));",
                "    assert_eq!(three_byte_class_unicode.maximum_len(), Some(3));",
                "    ",
                "    let four_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{10FFFF}'..= '\\u{10FFFF}')]));",
                "    assert_eq!(four_byte_class_unicode.maximum_len(), Some(4));",
                "    ",
                "    let empty_unicode_class = Class::Unicode(ClassUnicode::empty());",
                "    assert_eq!(empty_unicode_class.maximum_len(), None);",
                "    ",
                "    let non_empty_unicode_class_bounded = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0041}'..= '\\u{007A}'), ClassUnicodeRange::new('\\u{00C1}'..= '\\u{00FF}')]));",
                "    assert_eq!(non_empty_unicode_class_bounded.maximum_len(), Some(4));",
                "    ",
                "    let non_empty_unicode_class_unbounded = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0041}'..= '\\u{FFFF}')]));",
                "    assert_eq!(non_empty_unicode_class_unbounded.maximum_len(), None);"
              ],
              "code": [
                "{",
                "    let single_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0041}'..= '\\u{0041}')]));",
                "    let _ = single_byte_class_unicode.maximum_len();",
                "    assert_eq!(single_byte_class_unicode.maximum_len(), Some(1));",
                "    ",
                "    let double_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{00C1}'..= '\\u{00C1}')]));",
                "    assert_eq!(double_byte_class_unicode.maximum_len(), Some(2));",
                "    ",
                "    let three_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{E1}'..= '\\u{E1}')]));",
                "    assert_eq!(three_byte_class_unicode.maximum_len(), Some(3));",
                "    ",
                "    let four_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{10FFFF}'..= '\\u{10FFFF}')]));",
                "    assert_eq!(four_byte_class_unicode.maximum_len(), Some(4));",
                "    ",
                "    let empty_unicode_class = Class::Unicode(ClassUnicode::empty());",
                "    assert_eq!(empty_unicode_class.maximum_len(), None);",
                "    ",
                "    let non_empty_unicode_class_bounded = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0041}'..= '\\u{007A}'), ClassUnicodeRange::new('\\u{00C1}'..= '\\u{00FF}')]));",
                "    assert_eq!(non_empty_unicode_class_bounded.maximum_len(), Some(4));",
                "    ",
                "    let non_empty_unicode_class_unbounded = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0041}'..= '\\u{FFFF}')]));",
                "    assert_eq!(non_empty_unicode_class_unbounded.maximum_len(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let two_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{00C1}'..= '\\u{00C1}')]));",
                "    let _ = two_byte_class_unicode.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(Some(2), two_byte_class_unicode.maximum_len());"
              ],
              "code": [
                "{",
                "    let two_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{00C1}'..= '\\u{00C1}')]));",
                "    let _ = two_byte_class_unicode.maximum_len();",
                "    assert_eq!(Some(2), two_byte_class_unicode.maximum_len());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let three_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0800}'..= '\\u{0800}')]));",
                "    let _ = three_byte_class_unicode.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(three_byte_class_unicode.maximum_len(), Some(3));"
              ],
              "code": [
                "{",
                "    let three_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0800}'..= '\\u{0800}')]));",
                "    let _ = three_byte_class_unicode.maximum_len();",
                "    assert_eq!(three_byte_class_unicode.maximum_len(), Some(3));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let four_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{10000}'..= '\\u{10FFFF}')]));",
                "    let _ = four_byte_class_unicode.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(four_byte_class_unicode.maximum_len(), Some(4));"
              ],
              "code": [
                "{",
                "    let four_byte_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{10000}'..= '\\u{10FFFF}')]));",
                "    let _ = four_byte_class_unicode.maximum_len();",
                "    assert_eq!(four_byte_class_unicode.maximum_len(), Some(4));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let unbounded_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0041}'..= '\\u{FFFF}')]));",
                "    let _ = unbounded_class_unicode.maximum_len();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(unbounded_class_unicode.maximum_len().unwrap(), 4);",
                "    assert!(unbounded_class_unicode.maximum_len().is_some());",
                "    assert_ne!(unbounded_class_unicode.maximum_len().unwrap(), 0);",
                "    assert!(unbounded_class_unicode.maximum_len().unwrap() > 0);"
              ],
              "code": [
                "{",
                "    let unbounded_class_unicode = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('\\u{0041}'..= '\\u{FFFF}')]));",
                "    let _ = unbounded_class_unicode.maximum_len();",
                "    assert_eq!(unbounded_class_unicode.maximum_len().unwrap(), 4);",
                "    assert!(unbounded_class_unicode.maximum_len().is_some());",
                "    assert_ne!(unbounded_class_unicode.maximum_len().unwrap(), 0);",
                "    assert!(unbounded_class_unicode.maximum_len().unwrap() > 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}