{
  "name": "regex_automata::util::search::{impl#14}::clear",
  "mod_info": {
    "name": "util::search",
    "loc": "regex-automata/src/util/mod.rs:53:1:53:23"
  },
  "visible": true,
  "loc": "regex-automata/src/util/search.rs:1202:5:1207:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: matched in self.which.iter_mut() at line 1204 is true\n",
        "precondition: matched in self.which.iter_mut() at line 1204 is false\n"
      ],
      "input_infer": "self.which must be a non-empty boxed slice of booleans with at least one true value and at least one false value\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pattern_set = PatternSet {",
                "        len: 2,",
                "        which: alloc::vec![true, false].into_boxed_slice(),",
                "    };",
                "    ",
                "    pattern_set.clear();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pattern_set.len(), 0);",
                "    assert_eq!(pattern_set.which[0], false);",
                "    assert_eq!(pattern_set.which[1], false);",
                "    assert!(pattern_set.is_empty());",
                "    assert!(!pattern_set.is_full());"
              ],
              "code": [
                "{",
                "    let mut pattern_set = PatternSet {",
                "        len: 2,",
                "        which: alloc::vec![true, false].into_boxed_slice(),",
                "    };",
                "    ",
                "    pattern_set.clear();",
                "    assert_eq!(pattern_set.len(), 0);",
                "    assert_eq!(pattern_set.which[0], false);",
                "    assert_eq!(pattern_set.which[1], false);",
                "    assert!(pattern_set.is_empty());",
                "    assert!(!pattern_set.is_full());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pattern_set = PatternSet {",
                "        len: 1,",
                "        which: alloc::vec![true, false].into_boxed_slice(),",
                "    };",
                "    ",
                "    pattern_set.clear();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pattern_set.len, 0);",
                "    assert_eq!(pattern_set.which[0], false);",
                "    assert_eq!(pattern_set.which[1], false);",
                "    ",
                "    let mut pattern_set_full = PatternSet {",
                "    len: 2,",
                "    which: alloc::vec![true, true].into_boxed_slice(),",
                "    };",
                "    ",
                "    pattern_set_full.clear();",
                "    assert_eq!(pattern_set_full.len, 0);",
                "    assert_eq!(pattern_set_full.which[0], false);",
                "    assert_eq!(pattern_set_full.which[1], false);"
              ],
              "code": [
                "{",
                "    let mut pattern_set = PatternSet {",
                "        len: 1,",
                "        which: alloc::vec![true, false].into_boxed_slice(),",
                "    };",
                "    ",
                "    pattern_set.clear();",
                "    assert_eq!(pattern_set.len, 0);",
                "    assert_eq!(pattern_set.which[0], false);",
                "    assert_eq!(pattern_set.which[1], false);",
                "    ",
                "    let mut pattern_set_full = PatternSet {",
                "    len: 2,",
                "    which: alloc::vec![true, true].into_boxed_slice(),",
                "    };",
                "    ",
                "    pattern_set_full.clear();",
                "    assert_eq!(pattern_set_full.len, 0);",
                "    assert_eq!(pattern_set_full.which[0], false);",
                "    assert_eq!(pattern_set_full.which[1], false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pattern_set = PatternSet {",
                "        len: 3,",
                "        which: alloc::vec![true, true, false].into_boxed_slice(),",
                "    };",
                "    ",
                "    pattern_set.clear();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pattern_set.len(), 0);",
                "    assert_eq!(pattern_set.which.as_ref(), &[false, false, false]);",
                "    assert!(pattern_set.is_empty());",
                "    assert!(!pattern_set.is_full());",
                "    assert_eq!(pattern_set.capacity(), 3);"
              ],
              "code": [
                "{",
                "    let mut pattern_set = PatternSet {",
                "        len: 3,",
                "        which: alloc::vec![true, true, false].into_boxed_slice(),",
                "    };",
                "    ",
                "    pattern_set.clear();",
                "    assert_eq!(pattern_set.len(), 0);",
                "    assert_eq!(pattern_set.which.as_ref(), &[false, false, false]);",
                "    assert!(pattern_set.is_empty());",
                "    assert!(!pattern_set.is_full());",
                "    assert_eq!(pattern_set.capacity(), 3);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pattern_set = PatternSet {",
                "        len: 1,",
                "        which: alloc::vec![false, false].into_boxed_slice(),",
                "    };",
                "",
                "    pattern_set.clear();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pattern_set.len, 0);",
                "    assert!(pattern_set.which.iter().all(|&matched| !matched));"
              ],
              "code": [
                "{",
                "    let mut pattern_set = PatternSet {",
                "        len: 1,",
                "        which: alloc::vec![false, false].into_boxed_slice(),",
                "    };",
                "",
                "    pattern_set.clear();",
                "    assert_eq!(pattern_set.len, 0);",
                "    assert!(pattern_set.which.iter().all(|&matched| !matched));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: matched in self.which.iter_mut() at line 1204 is false\n"
      ],
      "input_infer": "capacity > 0 and self.len == current capacity and self.which contains at least one true value\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pattern_set = PatternSet::new(5);",
                "    pattern_set.insert(PatternID::new(0)).unwrap();",
                "    pattern_set.insert(PatternID::new(1)).unwrap();",
                "    pattern_set.insert(PatternID::new(2)).unwrap();",
                "    pattern_set.insert(PatternID::new(3)).unwrap();",
                "    pattern_set.insert(PatternID::new(4)).unwrap();",
                "    ",
                "    pattern_set.clear();",
                "    pattern_set.len(); // This call is made to check state after clear",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pattern_set.len(), 0);",
                "    assert!(pattern_set.is_empty());",
                "    for i in 0..5 { assert!(!pattern_set.contains(PatternID::new(i))); }",
                "    assert_eq!(pattern_set.capacity(), 5);",
                "    assert!(!pattern_set.is_full());"
              ],
              "code": [
                "{",
                "    let mut pattern_set = PatternSet::new(5);",
                "    pattern_set.insert(PatternID::new(0)).unwrap();",
                "    pattern_set.insert(PatternID::new(1)).unwrap();",
                "    pattern_set.insert(PatternID::new(2)).unwrap();",
                "    pattern_set.insert(PatternID::new(3)).unwrap();",
                "    pattern_set.insert(PatternID::new(4)).unwrap();",
                "    ",
                "    pattern_set.clear();",
                "    pattern_set.len(); // This call is made to check state after clear",
                "    assert_eq!(pattern_set.len(), 0);",
                "    assert!(pattern_set.is_empty());",
                "    for i in 0..5 { assert!(!pattern_set.contains(PatternID::new(i))); }",
                "    assert_eq!(pattern_set.capacity(), 5);",
                "    assert!(!pattern_set.is_full());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pattern_set = PatternSet::new(10);",
                "    for i in 0..10 {",
                "        pattern_set.insert(PatternID::new(i)).unwrap();",
                "    }",
                "",
                "    pattern_set.clear();",
                "    pattern_set.len(); // This call is made to check state after clear",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pattern_set.len(), 0);",
                "    assert!(pattern_set.is_empty());",
                "    for i in 0..10 {",
                "    assert!(!pattern_set.contains(PatternID::new(i)));",
                "    }"
              ],
              "code": [
                "{",
                "    let mut pattern_set = PatternSet::new(10);",
                "    for i in 0..10 {",
                "        pattern_set.insert(PatternID::new(i)).unwrap();",
                "    }",
                "",
                "    pattern_set.clear();",
                "    pattern_set.len(); // This call is made to check state after clear",
                "    assert_eq!(pattern_set.len(), 0);",
                "    assert!(pattern_set.is_empty());",
                "    for i in 0..10 {",
                "    assert!(!pattern_set.contains(PatternID::new(i)));",
                "    }",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pattern_set = PatternSet::new(3);",
                "    pattern_set.insert(PatternID::new(0)).unwrap();",
                "    pattern_set.insert(PatternID::new(1)).unwrap();",
                "",
                "    pattern_set.try_insert(PatternID::new(2)).unwrap(); // Assuming insert was successful",
                "    pattern_set.clear();",
                "    pattern_set.len(); // This call is made to check state after clear",
                "}"
              ],
              "oracle": [
                "    pattern_set.len() == 0",
                "    pattern_set.is_empty() == true",
                "    pattern_set.contains(PatternID::new(0)) == false",
                "    pattern_set.contains(PatternID::new(1)) == false",
                "    pattern_set.contains(PatternID::new(2)) == false"
              ],
              "code": [
                "{",
                "    let mut pattern_set = PatternSet::new(3);",
                "    pattern_set.insert(PatternID::new(0)).unwrap();",
                "    pattern_set.insert(PatternID::new(1)).unwrap();",
                "",
                "    pattern_set.try_insert(PatternID::new(2)).unwrap(); // Assuming insert was successful",
                "    pattern_set.clear();",
                "    pattern_set.len(); // This call is made to check state after clear",
                "    pattern_set.len() == 0",
                "    pattern_set.is_empty() == true",
                "    pattern_set.contains(PatternID::new(0)) == false",
                "    pattern_set.contains(PatternID::new(1)) == false",
                "    pattern_set.contains(PatternID::new(2)) == false",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}