{
  "name": "regex_lite::string::{impl#6}::is_match",
  "mod_info": {
    "name": "string",
    "loc": "regex-lite/src/lib.rs:884:1:884:12"
  },
  "visible": true,
  "loc": "regex-lite/src/string.rs:192:5:194:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Valid regex patterns as inputs (e.g., r\"\\b\\w{1,20}\\b\") with varying complexity, haystack strings of different lengths (including empty strings), and edge cases such as strings with no matches, strings with multiple matches, and very large strings to test performance limits.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\d+\").unwrap();",
                "    let result = re.is_match(\"\");",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);",
                "    ",
                "    let result = re.is_match(\"123\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"abc\");",
                "    assert_eq!(result, false);",
                "    ",
                "    let result = re.is_match(\"1a2\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"abc123\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"123abc\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"abc123def\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"no digits here\");",
                "    assert_eq!(result, false);",
                "    ",
                "    let result = re.is_match(\" \");",
                "    assert_eq!(result, false);",
                "    ",
                "    let result = re.is_match(\"4567 \");",
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\d+\").unwrap();",
                "    let result = re.is_match(\"\");",
                "    assert_eq!(result, false);",
                "    ",
                "    let result = re.is_match(\"123\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"abc\");",
                "    assert_eq!(result, false);",
                "    ",
                "    let result = re.is_match(\"1a2\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"abc123\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"123abc\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"abc123def\");",
                "    assert_eq!(result, true);",
                "    ",
                "    let result = re.is_match(\"no digits here\");",
                "    assert_eq!(result, false);",
                "    ",
                "    let result = re.is_match(\" \");",
                "    assert_eq!(result, false);",
                "    ",
                "    let result = re.is_match(\"4567 \");",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = regex_lite::Regex::new(r\"abc\").unwrap();",
                "    let result = re.is_match(\"xyz\");",
                "}"
              ],
              "oracle": [
                "    assert!(!result);"
              ],
              "code": [
                "{",
                "    let re = regex_lite::Regex::new(r\"abc\").unwrap();",
                "    let result = re.is_match(\"xyz\");",
                "    assert!(!result);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\w+\").unwrap();",
                "    let result = re.is_match(\"hello\");",
                "}"
              ],
              "oracle": [
                "    assert!(result);",
                "    let result = re.is_match(\"12345\");",
                "    assert!(result);",
                "    let result = re.is_match(\"hello123\");",
                "    assert!(result);",
                "    let result = re.is_match(\"!@#\");",
                "    assert!(!result);",
                "    let re = regex_lite::Regex::new(r\"\\w{13}\").unwrap();",
                "    let result = re.is_match(\"abcdefghijklm\");",
                "    assert!(result);",
                "    let result = re.is_match(\"abcdefghijk\");",
                "    assert!(!result);"
              ],
              "code": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\w+\").unwrap();",
                "    let result = re.is_match(\"hello\");",
                "    assert!(result);",
                "    let result = re.is_match(\"12345\");",
                "    assert!(result);",
                "    let result = re.is_match(\"hello123\");",
                "    assert!(result);",
                "    let result = re.is_match(\"!@#\");",
                "    assert!(!result);",
                "    let re = regex_lite::Regex::new(r\"\\w{13}\").unwrap();",
                "    let result = re.is_match(\"abcdefghijklm\");",
                "    assert!(result);",
                "    let result = re.is_match(\"abcdefghijk\");",
                "    assert!(!result);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\d+\").unwrap();",
                "    let result = re.is_match(\"There are 2 cats and 3 dogs.\");",
                "}"
              ],
              "oracle": [
                "    assert!(result);"
              ],
              "code": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\d+\").unwrap();",
                "    let result = re.is_match(\"There are 2 cats and 3 dogs.\");",
                "    assert!(result);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                "    let result = re.is_match(\"I categorically deny having triskaidekaphobia.\");",
                "}"
              ],
              "oracle": [
                "    assert!(result);",
                "    let result_empty = re.is_match(\"\");",
                "    assert!(!result_empty);",
                "    let result_no_match = re.is_match(\"short word\");",
                "    assert!(!result_no_match);",
                "    let result_special_chars = re.is_match(\"word_with_13_chars!\");",
                "    assert!(result_special_chars);",
                "    let result_multiple_matches = re.is_match(\"firstword triskaidekaphobia secondword\");",
                "    assert!(result_multiple_matches);",
                "    let re_another = regex_lite::Regex::new(r\"\\d{3}\").unwrap();",
                "    let result_digits = re_another.is_match(\"123\");",
                "    assert!(result_digits);",
                "    let result_digits_no_match = re_another.is_match(\"12\");",
                "    assert!(!result_digits_no_match);"
              ],
              "code": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                "    let result = re.is_match(\"I categorically deny having triskaidekaphobia.\");",
                "    assert!(result);",
                "    let result_empty = re.is_match(\"\");",
                "    assert!(!result_empty);",
                "    let result_no_match = re.is_match(\"short word\");",
                "    assert!(!result_no_match);",
                "    let result_special_chars = re.is_match(\"word_with_13_chars!\");",
                "    assert!(result_special_chars);",
                "    let result_multiple_matches = re.is_match(\"firstword triskaidekaphobia secondword\");",
                "    assert!(result_multiple_matches);",
                "    let re_another = regex_lite::Regex::new(r\"\\d{3}\").unwrap();",
                "    let result_digits = re_another.is_match(\"123\");",
                "    assert!(result_digits);",
                "    let result_digits_no_match = re_another.is_match(\"12\");",
                "    assert!(!result_digits_no_match);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let large_haystack = \"a \".repeat(1_000_000) + \"apple\"; // large string with a match",
                "    let result = re.is_match(&large_haystack);",
                "}"
              ],
              "oracle": [
                "    assert!(result);",
                "    let re_empty = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let empty_haystack = \"\";",
                "    let result_empty = re_empty.is_match(&empty_haystack);",
                "    assert!(!result_empty);",
                "    let re_multiple = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let multiple_haystack = \"apple banana cherry date\";",
                "    let result_multiple = re_multiple.is_match(&multiple_haystack);",
                "    assert!(result_multiple);",
                "    let re_non_matching = regex_lite::Regex::new(r\"\\b\\w{6}\\b\").unwrap();",
                "    let non_matching_haystack = \"I have an apple.\";",
                "    let result_non_matching = re_non_matching.is_match(&non_matching_haystack);",
                "    assert!(!result_non_matching);",
                "    let re_special_chars = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let special_chars_haystack = \"hello! @world$\";",
                "    let result_special = re_special_chars.is_match(&special_chars_haystack);",
                "    assert!(result_special);",
                "    let re_no_matches = regex_lite::Regex::new(r\"\\b\\w{4}\\b\").unwrap();",
                "    let no_matches_haystack = \"This is test.\";",
                "    let result_no_matches = re_no_matches.is_match(&no_matches_haystack);",
                "    assert!(!result_no_matches);",
                "    let re_boundary_test = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let boundary_haystack = \"abcde\";",
                "    let result_boundary = re_boundary_test.is_match(&boundary_haystack);",
                "    assert!(result_boundary);"
              ],
              "code": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let large_haystack = \"a \".repeat(1_000_000) + \"apple\"; // large string with a match",
                "    let result = re.is_match(&large_haystack);",
                "    assert!(result);",
                "    let re_empty = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let empty_haystack = \"\";",
                "    let result_empty = re_empty.is_match(&empty_haystack);",
                "    assert!(!result_empty);",
                "    let re_multiple = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let multiple_haystack = \"apple banana cherry date\";",
                "    let result_multiple = re_multiple.is_match(&multiple_haystack);",
                "    assert!(result_multiple);",
                "    let re_non_matching = regex_lite::Regex::new(r\"\\b\\w{6}\\b\").unwrap();",
                "    let non_matching_haystack = \"I have an apple.\";",
                "    let result_non_matching = re_non_matching.is_match(&non_matching_haystack);",
                "    assert!(!result_non_matching);",
                "    let re_special_chars = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let special_chars_haystack = \"hello! @world$\";",
                "    let result_special = re_special_chars.is_match(&special_chars_haystack);",
                "    assert!(result_special);",
                "    let re_no_matches = regex_lite::Regex::new(r\"\\b\\w{4}\\b\").unwrap();",
                "    let no_matches_haystack = \"This is test.\";",
                "    let result_no_matches = re_no_matches.is_match(&no_matches_haystack);",
                "    assert!(!result_no_matches);",
                "    let re_boundary_test = regex_lite::Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
                "    let boundary_haystack = \"abcde\";",
                "    let result_boundary = re_boundary_test.is_match(&boundary_haystack);",
                "    assert!(result_boundary);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = regex_lite::Regex::new(r\"(\\w+)-(\\w+)\").unwrap();",
                "    let result = re.is_match(\"hello-world\");",
                "}"
              ],
              "oracle": [
                "    assert!(result);",
                "    let result = re.is_match(\"hello world\");",
                "    assert!(!result);",
                "    let result = re.is_match(\"hello-\");",
                "    assert!(!result);",
                "    let result = re.is_match(\"-world\");",
                "    assert!(!result);",
                "    let result = re.is_match(\"hello-world-test\");",
                "    assert!(result);",
                "    let result = re.is_match(\"test.\");",
                "    assert!(!result);",
                "    let result = re.is_match(\"string-with-dashes\");",
                "    assert!(result);",
                "    let result = re.is_match(\"\");",
                "    assert!(!result);",
                "    let re = regex_lite::Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                "    let result = re.is_match(\"I categorically\");",
                "    assert!(result);",
                "    let result = re.is_match(\"short\");",
                "    assert!(!result);"
              ],
              "code": [
                "{",
                "    let re = regex_lite::Regex::new(r\"(\\w+)-(\\w+)\").unwrap();",
                "    let result = re.is_match(\"hello-world\");",
                "    assert!(result);",
                "    let result = re.is_match(\"hello world\");",
                "    assert!(!result);",
                "    let result = re.is_match(\"hello-\");",
                "    assert!(!result);",
                "    let result = re.is_match(\"-world\");",
                "    assert!(!result);",
                "    let result = re.is_match(\"hello-world-test\");",
                "    assert!(result);",
                "    let result = re.is_match(\"test.\");",
                "    assert!(!result);",
                "    let result = re.is_match(\"string-with-dashes\");",
                "    assert!(result);",
                "    let result = re.is_match(\"\");",
                "    assert!(!result);",
                "    let re = regex_lite::Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                "    let result = re.is_match(\"I categorically\");",
                "    assert!(result);",
                "    let result = re.is_match(\"short\");",
                "    assert!(!result);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\w{1,20}\").unwrap();",
                "    let result = re.is_match(\"a\"); // minimum length",
                "}"
              ],
              "oracle": [
                "    assert!(result); // test for single character match",
                "    let result = re.is_match(\"abcdefghijklmnopqrstuvwxyz\"); // exceed maximum length",
                "    assert!(!result); // test for exceeding maximum length",
                "    let result = re.is_match(\"12345678901234567890\"); // exactly 20 characters",
                "    assert!(result); // test for exact match at max length",
                "    let result = re.is_match(\"\"); // empty string",
                "    assert!(!result); // test for empty string match",
                "    let result = re.is_match(\"This is a test.\"); // valid string within the range",
                "    assert!(result); // test for valid match with special characters",
                "    let result = re.is_match(\"HelloWorld!\"); // valid string with punctuation",
                "    assert!(result); // test valid match with punctuation characters",
                "    let result = re.is_match(\"abcdefg\"); // valid string within the range",
                "    assert!(result); // test valid match for single word",
                "    let result = re.is_match(\"abc123\"); // valid alphanumeric characters",
                "    assert!(result); // test valid alphanumeric match"
              ],
              "code": [
                "{",
                "    let re = regex_lite::Regex::new(r\"\\w{1,20}\").unwrap();",
                "    let result = re.is_match(\"a\"); // minimum length",
                "    assert!(result); // test for single character match",
                "    let result = re.is_match(\"abcdefghijklmnopqrstuvwxyz\"); // exceed maximum length",
                "    assert!(!result); // test for exceeding maximum length",
                "    let result = re.is_match(\"12345678901234567890\"); // exactly 20 characters",
                "    assert!(result); // test for exact match at max length",
                "    let result = re.is_match(\"\"); // empty string",
                "    assert!(!result); // test for empty string match",
                "    let result = re.is_match(\"This is a test.\"); // valid string within the range",
                "    assert!(result); // test for valid match with special characters",
                "    let result = re.is_match(\"HelloWorld!\"); // valid string with punctuation",
                "    assert!(result); // test valid match with punctuation characters",
                "    let result = re.is_match(\"abcdefg\"); // valid string within the range",
                "    assert!(result); // test valid match for single word",
                "    let result = re.is_match(\"abc123\"); // valid alphanumeric characters",
                "    assert!(result); // test valid alphanumeric match",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}