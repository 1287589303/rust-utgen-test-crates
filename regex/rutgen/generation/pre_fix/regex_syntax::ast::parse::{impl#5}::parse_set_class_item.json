{
  "name": "regex_syntax::ast::parse::{impl#5}::parse_set_class_item",
  "mod_info": {
    "name": "ast::parse",
    "loc": "regex-syntax/src/ast/mod.rs:11:1:11:15"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/parse.rs:1991:5:2003:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.char() == '\\\\' at line 1992 is false\n"
      ],
      "input_infer": "self.char() is any valid character except '\\\\' or input contains only valid ASCII characters for literals and spans between 1 to 1000 bytes in size\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(\"a\")),",
                "        },",
                "        pattern: \"a\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::from(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"b\")), }, pattern: \"b\", }; assert_eq!(parser.parse_set_class_item().unwrap(), Primitive::Literal(ast::Literal { span: parser.span_char(), kind: ast::LiteralKind::Verbatim, c: 'b' })); let parser = ParserI { parser: Parser { pos: Cell::new(Position::from(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"c\")), }, pattern: \"c\", }; assert_eq!(parser.parse_set_class_item().unwrap(), Primitive::Literal(ast::Literal { span: parser.span_char(), kind: ast::LiteralKind::Verbatim, c: 'c' }));"
              ],
              "code": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(\"a\")),",
                "        },",
                "        pattern: \"a\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::from(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"b\")), }, pattern: \"b\", }; assert_eq!(parser.parse_set_class_item().unwrap(), Primitive::Literal(ast::Literal { span: parser.span_char(), kind: ast::LiteralKind::Verbatim, c: 'b' })); let parser = ParserI { parser: Parser { pos: Cell::new(Position::from(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"c\")), }, pattern: \"c\", }; assert_eq!(parser.parse_set_class_item().unwrap(), Primitive::Literal(ast::Literal { span: parser.span_char(), kind: ast::LiteralKind::Verbatim, c: 'c' }));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(input)),",
                "        },",
                "        pattern: input,",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.char(), 'a');",
                "    assert_eq!(parser.char(), 'z');",
                "    assert_eq!(parser.char(), 'A');",
                "    assert_eq!(parser.char(), 'Z');",
                "    assert_eq!(parser.char(), '0');",
                "    assert_eq!(parser.char(), '9');",
                "    assert_eq!(parser.bump(), true);",
                "    assert_eq!(parser.parse_set_class_item().is_ok(), true);",
                "    assert!(parser.scratch.borrow().len() > 0);",
                "    assert_eq!(parser.capture_index.get(), 0);"
              ],
              "code": [
                "{",
                "    let input = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(input)),",
                "        },",
                "        pattern: input,",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    assert_eq!(parser.char(), 'a');",
                "    assert_eq!(parser.char(), 'z');",
                "    assert_eq!(parser.char(), 'A');",
                "    assert_eq!(parser.char(), 'Z');",
                "    assert_eq!(parser.char(), '0');",
                "    assert_eq!(parser.char(), '9');",
                "    assert_eq!(parser.bump(), true);",
                "    assert_eq!(parser.parse_set_class_item().is_ok(), true);",
                "    assert!(parser.scratch.borrow().len() > 0);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(\"☃\")),",
                "        },",
                "        pattern: \"☃\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.char(), '☃');",
                "    assert_eq!(parser.pos.get(), Position::from(0));",
                "    assert_eq!(parser.scratch.borrow(), \"☃\");",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.capture_index.get(), 0);"
              ],
              "code": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(\"☃\")),",
                "        },",
                "        pattern: \"☃\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    assert_eq!(parser.char(), '☃');",
                "    assert_eq!(parser.pos.get(), Position::from(0));",
                "    assert_eq!(parser.scratch.borrow(), \"☃\");",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(\"hello\")),",
                "        },",
                "        pattern: \"hello\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.pos.get(), Position::from(0));",
                "    assert_eq!(parser.scratch.borrow().as_str(), \"hello\");",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.parser.capture_index.get(), 0);",
                "    assert_eq!(parser.parser.nest_limit, 10);",
                "    assert!(!parser.parser.octal);",
                "    assert!(!parser.parser.empty_min_range);",
                "    assert!(!parser.parser.initial_ignore_whitespace);",
                "    assert!(!parser.parser.ignore_whitespace.get());",
                "    assert!(matches!(parser.parse_set_class_item().unwrap(), Ok(Primitive::Literal(_))));",
                "    assert!(parser.pos.get() > Position::from(0));",
                "    assert_eq!(parser.scratch.borrow().as_str(), \"hello\");"
              ],
              "code": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(\"hello\")),",
                "        },",
                "        pattern: \"hello\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    assert_eq!(parser.pos.get(), Position::from(0));",
                "    assert_eq!(parser.scratch.borrow().as_str(), \"hello\");",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.parser.capture_index.get(), 0);",
                "    assert_eq!(parser.parser.nest_limit, 10);",
                "    assert!(!parser.parser.octal);",
                "    assert!(!parser.parser.empty_min_range);",
                "    assert!(!parser.parser.initial_ignore_whitespace);",
                "    assert!(!parser.parser.ignore_whitespace.get());",
                "    assert!(matches!(parser.parse_set_class_item().unwrap(), Ok(Primitive::Literal(_))));",
                "    assert!(parser.pos.get() > Position::from(0));",
                "    assert_eq!(parser.scratch.borrow().as_str(), \"hello\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(\".*?\")),",
                "        },",
                "        pattern: \".*?\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.char(), '.');",
                "    assert_eq!(parser.pos.get(), Position::from(0));",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.scratch.borrow().as_str(), \".*?\");",
                "    assert!(matches!(parser.parse_set_class_item().unwrap(), Primitive::Literal(ast::Literal { kind: LiteralKind::Verbatim, c: '.', .. })));"
              ],
              "code": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::from(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::from(\".*?\")),",
                "        },",
                "        pattern: \".*?\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    assert_eq!(parser.char(), '.');",
                "    assert_eq!(parser.pos.get(), Position::from(0));",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.scratch.borrow().as_str(), \".*?\");",
                "    assert!(matches!(parser.parse_set_class_item().unwrap(), Primitive::Literal(ast::Literal { kind: LiteralKind::Verbatim, c: '.', .. })));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.char() == '\\\\' at line 1992 is true\n",
        "expected return value/type: Ok(x)\n"
      ],
      "input_infer": "self.char() = '\\\\'; valid escape sequences following '\\\\' (e.g., 'n', 't', 'u', octal digits '0'-'7'); self.char() not exceeding the length of the pattern string\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\n\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.char(), '\\\\');",
                "    assert!(parser.parse_set_class_item().is_ok());",
                "    assert_eq!(parser.pos.get(), Position::new(1));",
                "    assert_eq!(parser.scratch.borrow().is_empty(), true);",
                "    assert_eq!(parser.stack_class.borrow().is_empty(), true);",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert!(parser.parser.nest_limit > 0);",
                "    assert!(parser.parser.octal);",
                "    assert_eq!(parser.parser.initial_ignore_whitespace, false);",
                "    assert_eq!(parser.parser.capture_index.get(), 0);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.scratch.borrow().is_empty(), true);",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.char(), 'n');",
                "    assert!(matches!(parser.parse_set_class_item().unwrap(), Primitive::Literal(_)));",
                "    assert!(parser.parse_escape().is_ok());",
                "    assert_eq!(parser.char(), 'n');",
                "    assert!(parser.char() != '\\\\');"
              ],
              "code": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\n\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    assert_eq!(parser.char(), '\\\\');",
                "    assert!(parser.parse_set_class_item().is_ok());",
                "    assert_eq!(parser.pos.get(), Position::new(1));",
                "    assert_eq!(parser.scratch.borrow().is_empty(), true);",
                "    assert_eq!(parser.stack_class.borrow().is_empty(), true);",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert!(parser.parser.nest_limit > 0);",
                "    assert!(parser.parser.octal);",
                "    assert_eq!(parser.parser.initial_ignore_whitespace, false);",
                "    assert_eq!(parser.parser.capture_index.get(), 0);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.scratch.borrow().is_empty(), true);",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.char(), 'n');",
                "    assert!(matches!(parser.parse_set_class_item().unwrap(), Primitive::Literal(_)));",
                "    assert!(parser.parse_escape().is_ok());",
                "    assert_eq!(parser.char(), 'n');",
                "    assert!(parser.char() != '\\\\');",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\t\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.char(), '\\\\');",
                "    assert!(parser.parse_set_class_item().is_ok());",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.pos.get(), Position::new(1));",
                "    assert!(parser.scratch.borrow().is_empty());",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());"
              ],
              "code": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\t\",",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    assert_eq!(parser.char(), '\\\\');",
                "    assert!(parser.parse_set_class_item().is_ok());",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.pos.get(), Position::new(1));",
                "    assert!(parser.scratch.borrow().is_empty());",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\141\", // octal for 'a'",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.char(), '\\\\');",
                "    let result = parser.parse_set_class_item();",
                "    assert!(result.is_ok());",
                "    assert!(matches!(result.unwrap(), Primitive::Literal(ast::Literal { kind: LiteralKind::Verbatim, c: 'a', .. })));"
              ],
              "code": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\141\", // octal for 'a'",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    assert_eq!(parser.char(), '\\\\');",
                "    let result = parser.parse_set_class_item();",
                "    assert!(result.is_ok());",
                "    assert!(matches!(result.unwrap(), Primitive::Literal(ast::Literal { kind: LiteralKind::Verbatim, c: 'a', .. })));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\u03A9\", // Unicode for 'Ω'",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.char(), '\\\\');",
                "    assert!(parser.parse_set_class_item().is_ok());",
                "    assert_eq!(parser.scratch.borrow().len(), 0);",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.pos.get(), Position::new(0));",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.nest_limit, 10);",
                "    assert!(parser.parser.octal);"
              ],
              "code": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            empty_min_range: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\u03A9\", // Unicode for 'Ω'",
                "    };",
                "    parser.parse_set_class_item().unwrap();",
                "    assert_eq!(parser.char(), '\\\\');",
                "    assert!(parser.parse_set_class_item().is_ok());",
                "    assert_eq!(parser.scratch.borrow().len(), 0);",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.pos.get(), Position::new(0));",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.nest_limit, 10);",
                "    assert!(parser.parser.octal);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}