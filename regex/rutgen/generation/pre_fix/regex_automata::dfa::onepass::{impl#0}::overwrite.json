{
  "name": "regex_automata::dfa::onepass::{impl#0}::overwrite",
  "mod_info": {
    "name": "dfa::onepass",
    "loc": "regex-automata/src/dfa/mod.rs:339:1:339:17"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/onepass.rs:270:5:279:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Config {\n            match_kind: o.match_kind.or(self.match_kind),\n            starts_for_each_pattern: o\n                .starts_for_each_pattern\n                .or(self.starts_for_each_pattern),\n            byte_classes: o.byte_classes.or(self.byte_classes),\n            size_limit: o.size_limit.or(self.size_limit),\n        }\n"
      ],
      "input_infer": "o: Config with match_kind (All or LeftmostFirst), starts_for_each_pattern (true or false), byte_classes (true or false), size_limit (None or 0 to 2^32-1); self: Config with any or all fields set to None or corresponding types as above.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .size_limit(Some(10));",
                "    let o_config = Config::default()",
                "        .match_kind(MatchKind::All);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.match_kind, Some(MatchKind::All));",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);",
                "    assert_eq!(result.size_limit, Some(10));"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .size_limit(Some(10));",
                "    let o_config = Config::default()",
                "        .match_kind(MatchKind::All);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, Some(MatchKind::All));",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);",
                "    assert_eq!(result.size_limit, Some(10));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .byte_classes(true);",
                "    let o_config = Config::default()",
                "        .match_kind(MatchKind::LeftmostFirst);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    let expected_match_kind = MatchKind::LeftmostFirst;",
                "    let expected_starts_for_each_pattern = false;",
                "    let expected_byte_classes = true;",
                "    let expected_size_limit = None;",
                "    assert_eq!(result.get_match_kind(), expected_match_kind);",
                "    assert_eq!(result.get_starts_for_each_pattern(), expected_starts_for_each_pattern);",
                "    assert_eq!(result.get_byte_classes(), expected_byte_classes);",
                "    assert_eq!(result.get_size_limit(), expected_size_limit);"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .byte_classes(true);",
                "    let o_config = Config::default()",
                "        .match_kind(MatchKind::LeftmostFirst);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    let expected_match_kind = MatchKind::LeftmostFirst;",
                "    let expected_starts_for_each_pattern = false;",
                "    let expected_byte_classes = true;",
                "    let expected_size_limit = None;",
                "    assert_eq!(result.get_match_kind(), expected_match_kind);",
                "    assert_eq!(result.get_starts_for_each_pattern(), expected_starts_for_each_pattern);",
                "    assert_eq!(result.get_byte_classes(), expected_byte_classes);",
                "    assert_eq!(result.get_size_limit(), expected_size_limit);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .match_kind(MatchKind::All);",
                "    let o_config = Config::default()",
                "        .starts_for_each_pattern(true);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.match_kind, Some(MatchKind::All));",
                "    assert_eq!(result.starts_for_each_pattern, Some(true));",
                "    assert_eq!(result.byte_classes, None);",
                "    assert_eq!(result.size_limit, None);",
                "    ",
                "    let self_config = Config::default()",
                "    .byte_classes(true);",
                "    let o_config = Config::default()",
                "    .match_kind(MatchKind::LeftmostFirst);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, Some(MatchKind::LeftmostFirst));",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, Some(true));",
                "    assert_eq!(result.size_limit, None);",
                "    ",
                "    let self_config = Config::default()",
                "    .size_limit(Some(10));",
                "    let o_config = Config::default()",
                "    .size_limit(None);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);",
                "    assert_eq!(result.size_limit, Some(10));",
                "    ",
                "    let self_config = Config::default();",
                "    let o_config = Config::default();",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);",
                "    assert_eq!(result.size_limit, None);"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .match_kind(MatchKind::All);",
                "    let o_config = Config::default()",
                "        .starts_for_each_pattern(true);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, Some(MatchKind::All));",
                "    assert_eq!(result.starts_for_each_pattern, Some(true));",
                "    assert_eq!(result.byte_classes, None);",
                "    assert_eq!(result.size_limit, None);",
                "    ",
                "    let self_config = Config::default()",
                "    .byte_classes(true);",
                "    let o_config = Config::default()",
                "    .match_kind(MatchKind::LeftmostFirst);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, Some(MatchKind::LeftmostFirst));",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, Some(true));",
                "    assert_eq!(result.size_limit, None);",
                "    ",
                "    let self_config = Config::default()",
                "    .size_limit(Some(10));",
                "    let o_config = Config::default()",
                "    .size_limit(None);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);",
                "    assert_eq!(result.size_limit, Some(10));",
                "    ",
                "    let self_config = Config::default();",
                "    let o_config = Config::default();",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);",
                "    assert_eq!(result.size_limit, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .starts_for_each_pattern(Some(true));",
                "    let o_config = Config::default()",
                "        .starts_for_each_pattern(false);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    result.get_match_kind() == MatchKind::All",
                "    result.get_starts_for_each_pattern() == false",
                "    result.get_byte_classes() == false",
                "    result.get_size_limit() == None"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .starts_for_each_pattern(Some(true));",
                "    let o_config = Config::default()",
                "        .starts_for_each_pattern(false);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    result.get_match_kind() == MatchKind::All",
                "    result.get_starts_for_each_pattern() == false",
                "    result.get_byte_classes() == false",
                "    result.get_size_limit() == None",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .byte_classes(false);",
                "    let o_config = Config::default()",
                "        .byte_classes(true);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.get_match_kind(), MatchKind::All);",
                "    assert_eq!(result.get_starts_for_each_pattern(), false);",
                "    assert_eq!(result.get_byte_classes(), true);",
                "    assert_eq!(result.get_size_limit(), None);"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .byte_classes(false);",
                "    let o_config = Config::default()",
                "        .byte_classes(true);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.get_match_kind(), MatchKind::All);",
                "    assert_eq!(result.get_starts_for_each_pattern(), false);",
                "    assert_eq!(result.get_byte_classes(), true);",
                "    assert_eq!(result.get_size_limit(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .byte_classes(Some(true));",
                "    let o_config = Config::default()",
                "        .byte_classes(false);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, Some(false));",
                "    assert_eq!(result.size_limit, None);",
                "    ",
                "    let self_config2 = Config::default()",
                "    .match_kind(MatchKind::All)",
                "    .starts_for_each_pattern(true);",
                "    let o_config2 = Config::default()",
                "    .match_kind(MatchKind::LeftmostFirst)",
                "    .size_limit(Some(10));",
                "    ",
                "    let result2 = self_config2.overwrite(o_config2);",
                "    assert_eq!(result2.match_kind, Some(MatchKind::LeftmostFirst));",
                "    assert_eq!(result2.starts_for_each_pattern, Some(true));",
                "    assert_eq!(result2.byte_classes, None);",
                "    assert_eq!(result2.size_limit, Some(10));",
                "    ",
                "    let self_config3 = Config::default()",
                "    .byte_classes(Some(true))",
                "    .size_limit(Some(5));",
                "    let o_config3 = Config::default();",
                "    ",
                "    let result3 = self_config3.overwrite(o_config3);",
                "    assert_eq!(result3.match_kind, None);",
                "    assert_eq!(result3.starts_for_each_pattern, None);",
                "    assert_eq!(result3.byte_classes, Some(true));",
                "    assert_eq!(result3.size_limit, Some(5));",
                "    ",
                "    let self_config4 = Config::default();",
                "    let o_config4 = Config::default()",
                "    .byte_classes(Some(false))",
                "    .size_limit(None);",
                "    ",
                "    let result4 = self_config4.overwrite(o_config4);",
                "    assert_eq!(result4.match_kind, None);",
                "    assert_eq!(result4.starts_for_each_pattern, None);",
                "    assert_eq!(result4.byte_classes, Some(false));",
                "    assert_eq!(result4.size_limit, None);"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .byte_classes(Some(true));",
                "    let o_config = Config::default()",
                "        .byte_classes(false);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, Some(false));",
                "    assert_eq!(result.size_limit, None);",
                "    ",
                "    let self_config2 = Config::default()",
                "    .match_kind(MatchKind::All)",
                "    .starts_for_each_pattern(true);",
                "    let o_config2 = Config::default()",
                "    .match_kind(MatchKind::LeftmostFirst)",
                "    .size_limit(Some(10));",
                "    ",
                "    let result2 = self_config2.overwrite(o_config2);",
                "    assert_eq!(result2.match_kind, Some(MatchKind::LeftmostFirst));",
                "    assert_eq!(result2.starts_for_each_pattern, Some(true));",
                "    assert_eq!(result2.byte_classes, None);",
                "    assert_eq!(result2.size_limit, Some(10));",
                "    ",
                "    let self_config3 = Config::default()",
                "    .byte_classes(Some(true))",
                "    .size_limit(Some(5));",
                "    let o_config3 = Config::default();",
                "    ",
                "    let result3 = self_config3.overwrite(o_config3);",
                "    assert_eq!(result3.match_kind, None);",
                "    assert_eq!(result3.starts_for_each_pattern, None);",
                "    assert_eq!(result3.byte_classes, Some(true));",
                "    assert_eq!(result3.size_limit, Some(5));",
                "    ",
                "    let self_config4 = Config::default();",
                "    let o_config4 = Config::default()",
                "    .byte_classes(Some(false))",
                "    .size_limit(None);",
                "    ",
                "    let result4 = self_config4.overwrite(o_config4);",
                "    assert_eq!(result4.match_kind, None);",
                "    assert_eq!(result4.starts_for_each_pattern, None);",
                "    assert_eq!(result4.byte_classes, Some(false));",
                "    assert_eq!(result4.size_limit, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .size_limit(Some(15));",
                "    let o_config = Config::default()",
                "        .size_limit(None);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.size_limit, Some(15));",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .size_limit(Some(15));",
                "    let o_config = Config::default()",
                "        .size_limit(None);",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.size_limit, Some(15));",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .size_limit(Some(5));",
                "    let o_config = Config::default()",
                "        .size_limit(Some(0));",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    let expected_match_kind = None;",
                "    let expected_starts_for_each_pattern = false;",
                "    let expected_byte_classes = false;",
                "    let expected_size_limit = Some(5);",
                "    assert_eq!(result.match_kind, expected_match_kind);",
                "    assert_eq!(result.starts_for_each_pattern, expected_starts_for_each_pattern);",
                "    assert_eq!(result.byte_classes, expected_byte_classes);",
                "    assert_eq!(result.size_limit, expected_size_limit);"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .size_limit(Some(5));",
                "    let o_config = Config::default()",
                "        .size_limit(Some(0));",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    let expected_match_kind = None;",
                "    let expected_starts_for_each_pattern = false;",
                "    let expected_byte_classes = false;",
                "    let expected_size_limit = Some(5);",
                "    assert_eq!(result.match_kind, expected_match_kind);",
                "    assert_eq!(result.starts_for_each_pattern, expected_starts_for_each_pattern);",
                "    assert_eq!(result.byte_classes, expected_byte_classes);",
                "    assert_eq!(result.size_limit, expected_size_limit);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let self_config = Config::default()",
                "        .size_limit(Some(100));",
                "    let o_config = Config::default()",
                "        .size_limit(Some(u32::MAX));",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.size_limit, Some(u32::MAX));",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);"
              ],
              "code": [
                "{",
                "    let self_config = Config::default()",
                "        .size_limit(Some(100));",
                "    let o_config = Config::default()",
                "        .size_limit(Some(u32::MAX));",
                "    ",
                "    let result = self_config.overwrite(o_config);",
                "    assert_eq!(result.size_limit, Some(u32::MAX));",
                "    assert_eq!(result.match_kind, None);",
                "    assert_eq!(result.starts_for_each_pattern, None);",
                "    assert_eq!(result.byte_classes, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}