{
  "name": "regex_syntax::hir::{impl#27}::contains_word",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:190:1:190:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:2768:5:2770:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.contains_word_unicode() at line 2769 is true\n",
        "expected return value/type: self.contains_word_unicode() || self.contains_word_ascii()\n"
      ],
      "input_infer": "self.bits = 0 (empty LookSet), self.bits = 1 (only Look::WordUnicode), self.bits = 2 (only Look::WordAscii), self.bits = 3 (both Look::WordUnicode and Look::WordAscii)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let look_set = LookSet::empty();",
                "    let result = look_set.contains_word();",
                "}"
              ],
              "oracle": [
                "    let look_set = LookSet::singleton(Look::WordUnicode);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::singleton(Look::WordAscii);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::singleton(Look::WordUnicodeNegate);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::singleton(Look::WordAsciiNegate);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::full();",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::empty();",
                "    assert_eq!(look_set.contains_word(), false);",
                "    let look_set = LookSet::singleton(Look::WordStartUnicode);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::singleton(Look::WordEndAscii);",
                "    assert_eq!(look_set.contains_word(), true);"
              ],
              "code": [
                "{",
                "    let look_set = LookSet::empty();",
                "    let result = look_set.contains_word();",
                "    let look_set = LookSet::singleton(Look::WordUnicode);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::singleton(Look::WordAscii);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::singleton(Look::WordUnicodeNegate);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::singleton(Look::WordAsciiNegate);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::full();",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::empty();",
                "    assert_eq!(look_set.contains_word(), false);",
                "    let look_set = LookSet::singleton(Look::WordStartUnicode);",
                "    assert_eq!(look_set.contains_word(), true);",
                "    let look_set = LookSet::singleton(Look::WordEndAscii);",
                "    assert_eq!(look_set.contains_word(), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let look_set = LookSet::singleton(Look::WordUnicode);",
                "    let result = look_set.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let look_set = LookSet::singleton(Look::WordUnicode);",
                "    let result = look_set.contains_word();",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let look_set = LookSet::singleton(Look::WordAscii);",
                "    let result = look_set.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert!(result);"
              ],
              "code": [
                "{",
                "    let look_set = LookSet::singleton(Look::WordAscii);",
                "    let result = look_set.contains_word();",
                "    assert!(result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut look_set = LookSet::empty();",
                "    look_set.set_insert(Look::WordUnicode);",
                "    look_set.set_insert(Look::WordAscii);",
                "    let result = look_set.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert!(result, \"Expected contains_word to be true when Unicode and ASCII word boundaries are present.\");"
              ],
              "code": [
                "{",
                "    let mut look_set = LookSet::empty();",
                "    look_set.set_insert(Look::WordUnicode);",
                "    look_set.set_insert(Look::WordAscii);",
                "    let result = look_set.contains_word();",
                "    assert!(result, \"Expected contains_word to be true when Unicode and ASCII word boundaries are present.\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.contains_word_unicode() at line 2769 is false\n"
      ],
      "input_infer": "self.contains_word_ascii() should be tested for all possible values of Look variants that represent ASCII word boundaries, especially edge cases for empty and full LookSet, as well as valid combinations of Look variants in both disjoint and overlapping configurations, including scenarios with only one Look variant.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lookset = LookSet::empty();",
                "    lookset.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lookset.contains_word(), false);"
              ],
              "code": [
                "{",
                "    let lookset = LookSet::empty();",
                "    lookset.contains_word();",
                "    assert_eq!(lookset.contains_word(), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lookset = LookSet::full();",
                "    lookset.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lookset.contains_word(), true);",
                "    let lookset_empty = LookSet::empty();",
                "    assert_eq!(lookset_empty.contains_word(), false);",
                "    let lookset_singleton = LookSet::singleton(Look::WordAscii);",
                "    assert_eq!(lookset_singleton.contains_word(), true);",
                "    let lookset_ascii_negate = LookSet::singleton(Look::WordAsciiNegate);",
                "    assert_eq!(lookset_ascii_negate.contains_word(), true);",
                "    let lookset_unicode_negate = LookSet::singleton(Look::WordUnicodeNegate);",
                "    assert_eq!(lookset_unicode_negate.contains_word(), true);",
                "    let lookset_no_words = LookSet::empty().insert(Look::SomeOtherLook);",
                "    assert_eq!(lookset_no_words.contains_word(), false);"
              ],
              "code": [
                "{",
                "    let lookset = LookSet::full();",
                "    lookset.contains_word();",
                "    assert_eq!(lookset.contains_word(), true);",
                "    let lookset_empty = LookSet::empty();",
                "    assert_eq!(lookset_empty.contains_word(), false);",
                "    let lookset_singleton = LookSet::singleton(Look::WordAscii);",
                "    assert_eq!(lookset_singleton.contains_word(), true);",
                "    let lookset_ascii_negate = LookSet::singleton(Look::WordAsciiNegate);",
                "    assert_eq!(lookset_ascii_negate.contains_word(), true);",
                "    let lookset_unicode_negate = LookSet::singleton(Look::WordUnicodeNegate);",
                "    assert_eq!(lookset_unicode_negate.contains_word(), true);",
                "    let lookset_no_words = LookSet::empty().insert(Look::SomeOtherLook);",
                "    assert_eq!(lookset_no_words.contains_word(), false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lookset = LookSet::singleton(Look::WordAscii);",
                "    lookset.contains_word();",
                "}"
              ],
              "oracle": [
                "    let lookset = LookSet::singleton(Look::WordAscii);",
                "    assert_eq!(lookset.contains_word(), true);",
                "    let lookset_empty = LookSet::empty();",
                "    assert_eq!(lookset_empty.contains_word(), false);",
                "    let lookset_full = LookSet::full();",
                "    assert_eq!(lookset_full.contains_word(), true);",
                "    let lookset_negated = LookSet::singleton(Look::WordAsciiNegate);",
                "    assert_eq!(lookset_negated.contains_word(), true);",
                "    let lookset_unicode = LookSet::singleton(Look::WordUnicode);",
                "    assert_eq!(lookset_unicode.contains_word(), true);"
              ],
              "code": [
                "{",
                "    let lookset = LookSet::singleton(Look::WordAscii);",
                "    lookset.contains_word();",
                "    let lookset = LookSet::singleton(Look::WordAscii);",
                "    assert_eq!(lookset.contains_word(), true);",
                "    let lookset_empty = LookSet::empty();",
                "    assert_eq!(lookset_empty.contains_word(), false);",
                "    let lookset_full = LookSet::full();",
                "    assert_eq!(lookset_full.contains_word(), true);",
                "    let lookset_negated = LookSet::singleton(Look::WordAsciiNegate);",
                "    assert_eq!(lookset_negated.contains_word(), true);",
                "    let lookset_unicode = LookSet::singleton(Look::WordUnicode);",
                "    assert_eq!(lookset_unicode.contains_word(), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lookset = LookSet::singleton(Look::WordAsciiNegate);",
                "    lookset.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lookset.contains_word(), true);"
              ],
              "code": [
                "{",
                "    let lookset = LookSet::singleton(Look::WordAsciiNegate);",
                "    lookset.contains_word();",
                "    assert_eq!(lookset.contains_word(), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lookset = LookSet::singleton(Look::WordStartHalfAscii);",
                "    lookset.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lookset.contains_word(), false);"
              ],
              "code": [
                "{",
                "    let lookset = LookSet::singleton(Look::WordStartHalfAscii);",
                "    lookset.contains_word();",
                "    assert_eq!(lookset.contains_word(), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lookset = LookSet::singleton(Look::WordEndHalfAscii);",
                "    lookset.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lookset.contains_word(), true);"
              ],
              "code": [
                "{",
                "    let lookset = LookSet::singleton(Look::WordEndHalfAscii);",
                "    lookset.contains_word();",
                "    assert_eq!(lookset.contains_word(), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lookset = LookSet::empty();",
                "    lookset.set_insert(Look::WordAscii);",
                "    lookset.set_insert(Look::WordStartHalfAscii);",
                "    lookset.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert!(!lookset.contains_word_unicode());",
                "    assert!(lookset.contains_word_ascii());",
                "    assert!(lookset.contains_word());",
                "    assert_eq!(lookset.len(), 2);",
                "    assert!(!lookset.is_empty());"
              ],
              "code": [
                "{",
                "    let mut lookset = LookSet::empty();",
                "    lookset.set_insert(Look::WordAscii);",
                "    lookset.set_insert(Look::WordStartHalfAscii);",
                "    lookset.contains_word();",
                "    assert!(!lookset.contains_word_unicode());",
                "    assert!(lookset.contains_word_ascii());",
                "    assert!(lookset.contains_word());",
                "    assert_eq!(lookset.len(), 2);",
                "    assert!(!lookset.is_empty());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lookset = LookSet::empty();",
                "    lookset.set_insert(Look::WordAscii);",
                "    lookset.set_insert(Look::WordAsciiNegate);",
                "    lookset.contains_word();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lookset.contains_word(), true);",
                "    lookset.set_remove(Look::WordAscii);",
                "    assert_eq!(lookset.contains_word(), true);",
                "    lookset.set_remove(Look::WordAsciiNegate);",
                "    assert_eq!(lookset.contains_word(), false);"
              ],
              "code": [
                "{",
                "    let mut lookset = LookSet::empty();",
                "    lookset.set_insert(Look::WordAscii);",
                "    lookset.set_insert(Look::WordAsciiNegate);",
                "    lookset.contains_word();",
                "    assert_eq!(lookset.contains_word(), true);",
                "    lookset.set_remove(Look::WordAscii);",
                "    assert_eq!(lookset.contains_word(), true);",
                "    lookset.set_remove(Look::WordAsciiNegate);",
                "    assert_eq!(lookset.contains_word(), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}