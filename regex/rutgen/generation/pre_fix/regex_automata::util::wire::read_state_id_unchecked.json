{
  "name": "regex_automata::util::wire::read_state_id_unchecked",
  "mod_info": {
    "name": "util::wire",
    "loc": "regex-automata/src/util/mod.rs:46:1:46:14"
  },
  "visible": true,
  "loc": "regex-automata/src/util/wire.rs:652:1:657:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: (sid, StateID::SIZE)\n"
      ],
      "input_infer": "slice: byte array of length >= StateID::SIZE\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let valid_slice: &[u8] = &[0u8; StateID::SIZE]; // Example byte slice with valid length",
                "    let result = read_state_id_unchecked(valid_slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.1, StateID::SIZE);",
                "    assert_eq!(result.0, StateID::from_ne_bytes_unchecked([0u8; StateID::SIZE]));"
              ],
              "code": [
                "{",
                "    let valid_slice: &[u8] = &[0u8; StateID::SIZE]; // Example byte slice with valid length",
                "    let result = read_state_id_unchecked(valid_slice);",
                "    assert_eq!(result.1, StateID::SIZE);",
                "    assert_eq!(result.0, StateID::from_ne_bytes_unchecked([0u8; StateID::SIZE]));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let insufficient_slice: &[u8] = &[0u8; StateID::SIZE - 1]; // Example byte slice with length less than required",
                "    let _ = read_state_id_unchecked(insufficient_slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(read_state_id_unchecked(&[0u8; StateID::SIZE]).1, StateID::SIZE);",
                "    assert!(std::panic::catch_unwind(|| read_state_id_unchecked(&[0u8; StateID::SIZE - 1])).is_err());",
                "    assert!(std::panic::catch_unwind(|| read_state_id_unchecked(&[])).is_err());",
                "    let valid_slice: &[u8] = &[1, 2, 3, 4];",
                "    let (sid, bytes_read) = read_state_id_unchecked(&valid_slice);",
                "    assert_eq!(bytes_read, StateID::SIZE);"
              ],
              "code": [
                "{",
                "    let insufficient_slice: &[u8] = &[0u8; StateID::SIZE - 1]; // Example byte slice with length less than required",
                "    let _ = read_state_id_unchecked(insufficient_slice);",
                "    assert_eq!(read_state_id_unchecked(&[0u8; StateID::SIZE]).1, StateID::SIZE);",
                "    assert!(std::panic::catch_unwind(|| read_state_id_unchecked(&[0u8; StateID::SIZE - 1])).is_err());",
                "    assert!(std::panic::catch_unwind(|| read_state_id_unchecked(&[])).is_err());",
                "    let valid_slice: &[u8] = &[1, 2, 3, 4];",
                "    let (sid, bytes_read) = read_state_id_unchecked(&valid_slice);",
                "    assert_eq!(bytes_read, StateID::SIZE);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let boundary_slice: &[u8] = &[0u8; StateID::SIZE]; // Exact length condition",
                "    let result = read_state_id_unchecked(boundary_slice);",
                "}"
              ],
              "oracle": [
                "    let boundary_slice: &[u8] = &[0u8; StateID::SIZE];",
                "    assert_eq!(result.1, StateID::SIZE);",
                "    assert_eq!(result.0, StateID::from_ne_bytes_unchecked(boundary_slice.try_into().unwrap()));"
              ],
              "code": [
                "{",
                "    let boundary_slice: &[u8] = &[0u8; StateID::SIZE]; // Exact length condition",
                "    let result = read_state_id_unchecked(boundary_slice);",
                "    let boundary_slice: &[u8] = &[0u8; StateID::SIZE];",
                "    assert_eq!(result.1, StateID::SIZE);",
                "    assert_eq!(result.0, StateID::from_ne_bytes_unchecked(boundary_slice.try_into().unwrap()));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}