{
  "name": "regex_lite::pikevm::{impl#0}::nexts",
  "mod_info": {
    "name": "pikevm",
    "loc": "regex-lite/src/lib.rs:881:1:881:12"
  },
  "visible": false,
  "loc": "regex-lite/src/pikevm.rs:198:5:219:6",
  "doc": "/// Process the active states in 'curr' to find the states (written to\n/// 'next') we should process for the next byte in the haystack.\n///\n/// 'stack' is used to perform a depth first traversal of the NFA when\n/// computing an epsilon closure.\n///\n/// When a match is found, the slots for that match state (in 'curr') are\n/// copied to 'caps'. Moreover, once a match is seen, processing for 'curr'\n/// stops (unless the PikeVM was configured with MatchKind::All semantics).\n///\n/// `at_ch` is the Unicode scalar value whose UTF-8 encoding begins at `at`\n/// in `haystack`.\n///\n/// `at_len` is the number of bytes consumed by `at_ch`. This is usually\n/// equal to `at_ch.len_utf8()`, but not always. For example, in the case\n/// where `at_ch` is the replacement codepoint that results from decoding\n/// invalid UTF-8. In that case, `at_len` can be 1, 2 or 3.\n",
  "code": [
    "fn nexts(",
    "    &self,",
    "    stack: &mut Vec<FollowEpsilon>,",
    "    curr: &mut ActiveStates,",
    "    next: &mut ActiveStates,",
    "    haystack: &[u8],",
    "    at: usize,",
    "    at_ch: char,",
    "    at_len: usize,",
    "    slots: &mut [Option<NonMaxUsize>],",
    ") -> bool {",
    "    let ActiveStates { ref set, ref mut slot_table } = *curr;",
    "    for sid in set.iter() {",
    "        if self.next(",
    "            stack, slot_table, next, haystack, at, at_ch, at_len, sid,",
    "        ) {",
    "            slots.copy_from_slice(slot_table.for_state(sid));",
    "            return true;",
    "        }",
    "    }",
    "    false",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 1,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "sid in set.iter()",
          "norm": null,
          "value": "true",
          "line": 210,
          "bound": null
        },
        {
          "cond": "self.next(\n                stack, slot_table, next, haystack, at, at_ch, at_len, sid,\n            )",
          "norm": null,
          "value": "true",
          "line": 211,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        11,
        12,
        13,
        15
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "sid in set.iter()",
          "norm": null,
          "value": "true",
          "line": 210,
          "bound": null
        },
        {
          "cond": "self.next(\n                stack, slot_table, next, haystack, at, at_ch, at_len, sid,\n            )",
          "norm": null,
          "value": "false",
          "line": 211,
          "bound": null
        },
        {
          "cond": "sid in set.iter()",
          "norm": null,
          "value": "false",
          "line": 210,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        14,
        3,
        4,
        5,
        7,
        9,
        15
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "sid in set.iter()",
          "norm": null,
          "value": "false",
          "line": 210,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        15
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}