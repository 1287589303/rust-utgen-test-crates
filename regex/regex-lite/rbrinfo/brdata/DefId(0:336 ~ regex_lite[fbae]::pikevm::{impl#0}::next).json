{
  "name": "regex_lite::pikevm::{impl#0}::next",
  "mod_info": {
    "name": "pikevm",
    "loc": "regex-lite/src/lib.rs:881:1:881:12"
  },
  "visible": false,
  "loc": "regex-lite/src/pikevm.rs:241:5:292:6",
  "doc": "/// Starting from `sid`, if the position `at` in the `haystack` has a\n/// transition defined out of `sid`, then add the state transitioned to and\n/// its epsilon closure to the `next` set of states to explore.\n///\n/// `stack` is used by the epsilon closure computation to perform a depth\n/// first traversal of the NFA.\n///\n/// `curr_slot_table` should be the table of slots for the current set of\n/// states being explored. If there is a transition out of `sid`, then\n/// sid's row in the slot table is used to perform the epsilon closure.\n///\n/// `at_ch` is the Unicode scalar value whose UTF-8 encoding begins at `at`\n/// in `haystack`. The caller provides it so that this routine doesn't\n/// need to re-decode it. (Since it's expected that this routine is called\n/// multiple times for each position.)\n///\n/// `at_len` is the number of bytes consumed by `at_ch`. This is usually\n/// equal to `at_ch.len_utf8()`, but not always. For example, in the case\n/// where `at_ch` is the replacement codepoint that results from decoding\n/// invalid UTF-8. In that case, `at_len` can be 1, 2 or 3.\n",
  "code": [
    "fn next(",
    "    &self,",
    "    stack: &mut Vec<FollowEpsilon>,",
    "    curr_slot_table: &mut SlotTable,",
    "    next: &mut ActiveStates,",
    "    haystack: &[u8],",
    "    at: usize,",
    "    at_ch: char,",
    "    at_len: usize,",
    "    sid: StateID,",
    ") -> bool {",
    "    match *self.nfa.state(sid) {",
    "        State::Fail",
    "        | State::Goto { .. }",
    "        | State::Splits { .. }",
    "        | State::Capture { .. } => false,",
    "        State::Char { target, ch } => {",
    "            if at_ch == ch && at_len > 0 {",
    "                let slots = curr_slot_table.for_state(sid);",
    "                // OK because `at_len` is always derived from the number",
    "                // of bytes read from `at` that make up `at_ch`. So this",
    "                // will never wrap.",
    "                let at = at.wrapping_add(at_len);",
    "                self.epsilon_closure(",
    "                    stack, slots, next, haystack, at, target,",
    "                );",
    "            }",
    "            false",
    "        }",
    "        State::Ranges { target, ref ranges } => {",
    "            for (start, end) in ranges.iter().copied() {",
    "                if start > at_ch {",
    "                    break;",
    "                } else if start <= at_ch && at_ch <= end {",
    "                    if at_len == 0 {",
    "                        return false;",
    "                    }",
    "                    let slots = curr_slot_table.for_state(sid);",
    "                    // OK because `at_len` is always derived from the",
    "                    // number of bytes read from `at` that make up `at_ch`.",
    "                    // So this will never wrap.",
    "                    let at = at.wrapping_add(at_len);",
    "                    self.epsilon_closure(",
    "                        stack, slots, next, haystack, at, target,",
    "                    );",
    "                }",
    "            }",
    "            false",
    "        }",
    "        State::Match => true,",
    "    }",
    "}"
  ],
  "size": {
    "chain": 14,
    "contra": 3,
    "min_set": 14
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Match",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        5,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Fail",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Goto { .. } or State::Splits { .. } or State::Fail or State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        6,
        7,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Goto { .. } or State::Splits { .. } or State::Fail or State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        6,
        7,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Goto { .. }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Goto { .. } or State::Splits { .. } or State::Fail or State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        6,
        7,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Splits { .. }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Goto { .. } or State::Splits { .. } or State::Fail or State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        6,
        7,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "true",
          "line": 271,
          "bound": null
        },
        {
          "cond": "start > at_ch",
          "norm": "at_ch < start",
          "value": "true",
          "line": 272,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        4,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        28,
        30,
        43,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "true",
          "line": 271,
          "bound": null
        },
        {
          "cond": "start > at_ch",
          "norm": "at_ch < start",
          "value": "false",
          "line": 272,
          "bound": "start == at_ch"
        },
        {
          "cond": "start <= at_ch",
          "norm": "at_ch >= start",
          "value": "true",
          "line": 274,
          "bound": "start == at_ch"
        },
        {
          "cond": "at_ch <= end",
          "norm": null,
          "value": "true",
          "line": 274,
          "bound": "at_ch == end"
        },
        {
          "cond": "at_len == 0",
          "norm": "0 == at_len",
          "value": "false",
          "line": 275,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        4,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        28,
        31,
        32,
        33,
        34,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "true",
          "line": 271,
          "bound": null
        },
        {
          "cond": "start > at_ch",
          "norm": "at_ch < start",
          "value": "false",
          "line": 272,
          "bound": "start == at_ch"
        },
        {
          "cond": "start <= at_ch",
          "norm": "at_ch >= start",
          "value": "true",
          "line": 274,
          "bound": "start == at_ch"
        },
        {
          "cond": "at_ch <= end",
          "norm": null,
          "value": "true",
          "line": 274,
          "bound": "at_ch == end"
        },
        {
          "cond": "at_len == 0",
          "norm": "0 == at_len",
          "value": "true",
          "line": 275,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        4,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        28,
        31,
        32,
        33,
        35,
        36,
        37,
        38,
        42,
        23,
        24,
        25,
        27,
        29,
        43,
        44,
        45
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "true",
          "line": 271,
          "bound": null
        },
        {
          "cond": "start > at_ch",
          "norm": "at_ch < start",
          "value": "false",
          "line": 272,
          "bound": "start == at_ch"
        },
        {
          "cond": "start <= at_ch",
          "norm": "at_ch >= start",
          "value": "true",
          "line": 274,
          "bound": "start == at_ch"
        },
        {
          "cond": "at_ch <= end",
          "norm": null,
          "value": "false",
          "line": 274,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        4,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        28,
        31,
        32,
        39,
        41,
        42,
        23,
        24,
        25,
        27,
        29,
        43,
        44,
        45
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "true",
          "line": 271,
          "bound": null
        },
        {
          "cond": "start > at_ch",
          "norm": "at_ch < start",
          "value": "false",
          "line": 272,
          "bound": "start == at_ch"
        },
        {
          "cond": "start <= at_ch",
          "norm": "at_ch >= start",
          "value": "false",
          "line": 274,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        4,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        28,
        31,
        40,
        41,
        42,
        23,
        24,
        25,
        27,
        29,
        43,
        44,
        45
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Ranges { target, ref ranges }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "(start, end) in ranges.iter().copied()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        4,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        27,
        29,
        43,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Char { target, ch }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Char { target, ch }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "at_ch == ch",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "at_len > 0",
          "norm": "0 < at_len",
          "value": "true",
          "line": 258,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        3,
        8,
        9,
        10,
        11,
        12,
        13,
        17,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Char { target, ch }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Char { target, ch }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "at_ch == ch",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "at_len > 0",
          "norm": "0 < at_len",
          "value": "false",
          "line": 258,
          "bound": "at_len == 0"
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        3,
        8,
        9,
        14,
        16,
        17,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 14,
      "conds": [
        {
          "cond": "*self.nfa.state(sid) matches State::Char { target, ch }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "*self.nfa.state(sid) matches State::Char { target, ch }",
          "norm": null,
          "value": "true",
          "line": 252,
          "bound": null
        },
        {
          "cond": "at_ch == ch",
          "norm": null,
          "value": "false",
          "line": 258,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        3,
        8,
        15,
        16,
        17,
        44,
        45
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}