{
  "name": "regex_lite::string::{impl#40}::ignore_whitespace",
  "mod_info": {
    "name": "string",
    "loc": "regex-lite/src/lib.rs:884:1:884:12"
  },
  "visible": true,
  "loc": "regex-lite/src/string.rs:2900:5:2903:6",
  "doc": "/// This configures verbose mode for the entire pattern.\n///\n/// When enabled, whitespace will treated as insignifcant in the pattern\n/// and `#` can be used to start a comment until the next new line.\n///\n/// Normally, in most places in a pattern, whitespace is treated literally.\n/// For example ` +` will match one or more ASCII whitespace characters.\n///\n/// When verbose mode is enabled, `\\#` can be used to match a literal `#`\n/// and `\\ ` can be used to match a literal ASCII whitespace character.\n///\n/// Verbose mode is useful for permitting regexes to be formatted and\n/// broken up more nicely. This may make them more easily readable.\n///\n/// This setting can also be configured using the inline flag `x` in the\n/// pattern.\n///\n/// The default for this is `false`.\n///\n/// # Example\n///\n/// ```\n/// use regex_lite::RegexBuilder;\n///\n/// let pat = r\"\n///     \\b\n///     (?<first>[A-Z]\\w*)  # always start with uppercase letter\n///     \\s+                 # whitespace should separate names\n///     (?: # middle name can be an initial!\n///         (?:(?<initial>[A-Z])\\.|(?<middle>[A-Z]\\w*))\n///         \\s+\n///     )?\n///     (?<last>[A-Z]\\w*)\n///     \\b\n/// \";\n/// let re = RegexBuilder::new(pat)\n///     .ignore_whitespace(true)\n///     .build()\n///     .unwrap();\n///\n/// let caps = re.captures(\"Harry Potter\").unwrap();\n/// assert_eq!(\"Harry\", &caps[\"first\"]);\n/// assert_eq!(\"Potter\", &caps[\"last\"]);\n///\n/// let caps = re.captures(\"Harry J. Potter\").unwrap();\n/// assert_eq!(\"Harry\", &caps[\"first\"]);\n/// // Since a middle name/initial isn't required for an overall match,\n/// // we can't assume that 'initial' or 'middle' will be populated!\n/// assert_eq!(Some(\"J\"), caps.name(\"initial\").map(|m| m.as_str()));\n/// assert_eq!(None, caps.name(\"middle\").map(|m| m.as_str()));\n/// assert_eq!(\"Potter\", &caps[\"last\"]);\n///\n/// let caps = re.captures(\"Harry James Potter\").unwrap();\n/// assert_eq!(\"Harry\", &caps[\"first\"]);\n/// // Since a middle name/initial isn't required for an overall match,\n/// // we can't assume that 'initial' or 'middle' will be populated!\n/// assert_eq!(None, caps.name(\"initial\").map(|m| m.as_str()));\n/// assert_eq!(Some(\"James\"), caps.name(\"middle\").map(|m| m.as_str()));\n/// assert_eq!(\"Potter\", &caps[\"last\"]);\n/// ```\n",
  "code": [
    "pub fn ignore_whitespace(&mut self, yes: bool) -> &mut RegexBuilder {",
    "    self.hir_config.flags.ignore_whitespace = yes;",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}