{
  "name": "regex_lite::utf8::decode",
  "mod_info": {
    "name": "utf8",
    "loc": "regex-lite/src/lib.rs:885:1:885:10"
  },
  "visible": true,
  "loc": "regex-lite/src/utf8.rs:56:1:83:2",
  "doc": "/// UTF-8 decode a single Unicode scalar value from the beginning of a slice.\n///\n/// When successful, the corresponding Unicode scalar value is returned along\n/// with the number of bytes it was encoded with. The number of bytes consumed\n/// for a successful decode is always between 1 and 4, inclusive.\n///\n/// When unsuccessful, `None` is returned along with the number of bytes that\n/// make up a maximal prefix of a valid UTF-8 code unit sequence. In this case,\n/// the number of bytes consumed is always between 0 and 3, inclusive, where\n/// 0 is only returned when `slice` is empty.\n",
  "code": [
    "pub(crate) fn decode<B: AsRef<[u8]>>(slice: B) -> (Option<char>, usize) {",
    "    let slice = slice.as_ref();",
    "    match slice.get(0) {",
    "        None => return (None, 0),",
    "        Some(&b) if b <= 0x7F => return (Some(b as char), 1),",
    "        _ => {}",
    "    }",
    "",
    "    let (mut state, mut cp, mut i) = (ACCEPT, 0, 0);",
    "    while i < slice.len() {",
    "        decode_step(&mut state, &mut cp, slice[i]);",
    "        i += 1;",
    "",
    "        if state == ACCEPT {",
    "            // OK since `decode_step` guarantees that `cp` is a valid Unicode",
    "            // scalar value in an ACCEPT state.",
    "            //",
    "            // We don't have to use safe code here, but do so because perf",
    "            // isn't our primary objective in regex-lite.",
    "            let ch = char::from_u32(cp).unwrap();",
    "            return (Some(ch), i);",
    "        } else if state == REJECT {",
    "            // At this point, we always want to advance at least one byte.",
    "            return (None, core::cmp::max(1, i.saturating_sub(1)));",
    "        }",
    "    }",
    "    (None, i)",
    "}"
  ],
  "size": {
    "chain": 10,
    "contra": 2,
    "min_set": 6
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "false",
          "line": 60,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches _",
          "norm": null,
          "value": "true",
          "line": 61,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches None",
          "norm": null,
          "value": "false",
          "line": 59,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "true",
          "line": 65,
          "bound": null
        },
        {
          "cond": "state == ACCEPT",
          "norm": "ACCEPT == state",
          "value": "true",
          "line": 69,
          "bound": null
        }
      ],
      "ret": "(Some(ch), i)",
      "path": [
        0,
        1,
        2,
        3,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        26,
        28,
        29
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "false",
          "line": 60,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches _",
          "norm": null,
          "value": "true",
          "line": 61,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches None",
          "norm": null,
          "value": "false",
          "line": 59,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "true",
          "line": 65,
          "bound": null
        },
        {
          "cond": "state == ACCEPT",
          "norm": "ACCEPT == state",
          "value": "false",
          "line": 69,
          "bound": null
        },
        {
          "cond": "state == REJECT",
          "norm": "REJECT == state",
          "value": "true",
          "line": 77,
          "bound": null
        }
      ],
      "ret": "(None, core::cmp::max(1, i.saturating_sub(1)))",
      "path": [
        0,
        1,
        2,
        3,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        20,
        21,
        22,
        23,
        26,
        28,
        29
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "false",
          "line": 60,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches _",
          "norm": null,
          "value": "true",
          "line": 61,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches None",
          "norm": null,
          "value": "false",
          "line": 59,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "true",
          "line": 65,
          "bound": null
        },
        {
          "cond": "state == ACCEPT",
          "norm": "ACCEPT == state",
          "value": "false",
          "line": 69,
          "bound": null
        },
        {
          "cond": "state == REJECT",
          "norm": "REJECT == state",
          "value": "false",
          "line": 77,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "false",
          "line": 65,
          "bound": "i == slice.len()"
        }
      ],
      "ret": "(None, i)",
      "path": [
        0,
        1,
        2,
        3,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        20,
        24,
        10,
        11,
        12,
        25,
        29
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "false",
          "line": 60,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches _",
          "norm": null,
          "value": "true",
          "line": 61,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches None",
          "norm": null,
          "value": "false",
          "line": 59,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "false",
          "line": 65,
          "bound": "i == slice.len()"
        }
      ],
      "ret": "(None, i)",
      "path": [
        0,
        1,
        2,
        3,
        10,
        11,
        12,
        25,
        29
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "b <= 0x7F",
          "norm": "0x7F >= b",
          "value": "true",
          "line": 60,
          "bound": "b == 0x7F"
        }
      ],
      "ret": "(Some(b as char), 1)",
      "path": [
        0,
        1,
        2,
        5,
        7,
        8,
        27,
        28,
        29
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "b <= 0x7F",
          "norm": "0x7F >= b",
          "value": "false",
          "line": 60,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "true",
          "line": 65,
          "bound": null
        },
        {
          "cond": "state == ACCEPT",
          "norm": "ACCEPT == state",
          "value": "true",
          "line": 69,
          "bound": null
        }
      ],
      "ret": "(Some(ch), i)",
      "path": [
        0,
        1,
        2,
        5,
        7,
        9,
        3,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        26,
        28,
        29
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "b <= 0x7F",
          "norm": "0x7F >= b",
          "value": "false",
          "line": 60,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "true",
          "line": 65,
          "bound": null
        },
        {
          "cond": "state == ACCEPT",
          "norm": "ACCEPT == state",
          "value": "false",
          "line": 69,
          "bound": null
        },
        {
          "cond": "state == REJECT",
          "norm": "REJECT == state",
          "value": "true",
          "line": 77,
          "bound": null
        }
      ],
      "ret": "(None, core::cmp::max(1, i.saturating_sub(1)))",
      "path": [
        0,
        1,
        2,
        5,
        7,
        9,
        3,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        20,
        21,
        22,
        23,
        26,
        28,
        29
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "b <= 0x7F",
          "norm": "0x7F >= b",
          "value": "false",
          "line": 60,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "true",
          "line": 65,
          "bound": null
        },
        {
          "cond": "state == ACCEPT",
          "norm": "ACCEPT == state",
          "value": "false",
          "line": 69,
          "bound": null
        },
        {
          "cond": "state == REJECT",
          "norm": "REJECT == state",
          "value": "false",
          "line": 77,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "false",
          "line": 65,
          "bound": "i == slice.len()"
        }
      ],
      "ret": "(None, i)",
      "path": [
        0,
        1,
        2,
        5,
        7,
        9,
        3,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        20,
        24,
        10,
        11,
        12,
        25,
        29
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "b <= 0x7F",
          "norm": "0x7F >= b",
          "value": "false",
          "line": 60,
          "bound": null
        },
        {
          "cond": "i < slice.len()",
          "norm": null,
          "value": "false",
          "line": 65,
          "bound": "i == slice.len()"
        }
      ],
      "ret": "(None, i)",
      "path": [
        0,
        1,
        2,
        5,
        7,
        9,
        3,
        10,
        11,
        12,
        25,
        29
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "slice.get(0) matches None",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        },
        {
          "cond": "slice.get(0) matches None",
          "norm": null,
          "value": "true",
          "line": 58,
          "bound": null
        }
      ],
      "ret": "(None, 0)",
      "path": [
        0,
        1,
        2,
        4,
        6,
        27,
        28,
        29
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}