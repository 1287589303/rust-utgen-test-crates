{
  "name": "regex_lite::hir::parse::check_hir_nesting",
  "mod_info": {
    "name": "hir::parse",
    "loc": "regex-lite/src/hir/mod.rs:5:1:5:11"
  },
  "visible": false,
  "loc": "regex-lite/src/hir/parse.rs:1286:1:1314:2",
  "doc": "/// This checks the depth of the given `Hir` value, and if it exceeds the given\n/// limit, then an error is returned.\n",
  "code": [
    "fn check_hir_nesting(hir: &Hir, limit: u32) -> Result<(), Error> {",
    "    fn recurse(hir: &Hir, limit: u32, depth: u32) -> Result<(), Error> {",
    "        if depth > limit {",
    "            return Err(Error::new(ERR_TOO_MUCH_NESTING));",
    "        }",
    "        let Some(next_depth) = depth.checked_add(1) else {",
    "            return Err(Error::new(ERR_TOO_MUCH_NESTING));",
    "        };",
    "        match *hir.kind() {",
    "            HirKind::Empty",
    "            | HirKind::Char(_)",
    "            | HirKind::Class(_)",
    "            | HirKind::Look(_) => Ok(()),",
    "            HirKind::Repetition(hir::Repetition { ref sub, .. }) => {",
    "                recurse(sub, limit, next_depth)",
    "            }",
    "            HirKind::Capture(hir::Capture { ref sub, .. }) => {",
    "                recurse(sub, limit, next_depth)",
    "            }",
    "            HirKind::Concat(ref subs) | HirKind::Alternation(ref subs) => {",
    "                for sub in subs.iter() {",
    "                    recurse(sub, limit, next_depth)?;",
    "                }",
    "                Ok(())",
    "            }",
    "        }",
    "    }",
    "    recurse(hir, limit, 0)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}