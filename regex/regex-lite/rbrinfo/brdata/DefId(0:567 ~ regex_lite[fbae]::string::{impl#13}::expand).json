{
  "name": "regex_lite::string::{impl#13}::expand",
  "mod_info": {
    "name": "string",
    "loc": "regex-lite/src/lib.rs:884:1:884:12"
  },
  "visible": true,
  "loc": "regex-lite/src/string.rs:1863:5:1876:6",
  "doc": "/// Expands all instances of `$ref` in `replacement` to the corresponding\n/// capture group, and writes them to the `dst` buffer given. A `ref` can\n/// be a capture group index or a name. If `ref` doesn't refer to a capture\n/// group that participated in the match, then it is replaced with the\n/// empty string.\n///\n/// # Format\n///\n/// The format of the replacement string supports two different kinds of\n/// capture references: unbraced and braced.\n///\n/// For the unbraced format, the format supported is `$ref` where `name`\n/// can be any character in the class `[0-9A-Za-z_]`. `ref` is always\n/// the longest possible parse. So for example, `$1a` corresponds to the\n/// capture group named `1a` and not the capture group at index `1`. If\n/// `ref` matches `^[0-9]+$`, then it is treated as a capture group index\n/// itself and not a name.\n///\n/// For the braced format, the format supported is `${ref}` where `ref` can\n/// be any sequence of bytes except for `}`. If no closing brace occurs,\n/// then it is not considered a capture reference. As with the unbraced\n/// format, if `ref` matches `^[0-9]+$`, then it is treated as a capture\n/// group index and not a name.\n///\n/// The braced format is useful for exerting precise control over the name\n/// of the capture reference. For example, `${1}a` corresponds to the\n/// capture group reference `1` followed by the letter `a`, where as `$1a`\n/// (as mentioned above) corresponds to the capture group reference `1a`.\n/// The braced format is also useful for expressing capture group names\n/// that use characters not supported by the unbraced format. For example,\n/// `${foo[bar].baz}` refers to the capture group named `foo[bar].baz`.\n///\n/// If a capture group reference is found and it does not refer to a valid\n/// capture group, then it will be replaced with the empty string.\n///\n/// To write a literal `$`, use `$$`.\n///\n/// # Example\n///\n/// ```\n/// use regex_lite::Regex;\n///\n/// let re = Regex::new(\n///     r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\",\n/// ).unwrap();\n/// let hay = \"On 14-03-2010, I became a Tenneessee lamb.\";\n/// let caps = re.captures(hay).unwrap();\n///\n/// let mut dst = String::new();\n/// caps.expand(\"year=$year, month=$month, day=$day\", &mut dst);\n/// assert_eq!(dst, \"year=2010, month=03, day=14\");\n/// ```\n",
  "code": [
    "pub fn expand(&self, replacement: &str, dst: &mut String) {",
    "    interpolate::string(",
    "        replacement,",
    "        |index, dst| {",
    "            let m = match self.get(index) {",
    "                None => return,",
    "                Some(m) => m,",
    "            };",
    "            dst.push_str(&self.haystack[m.range()]);",
    "        },",
    "        |name| self.pikevm.nfa().to_index(name),",
    "        dst,",
    "    );",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}