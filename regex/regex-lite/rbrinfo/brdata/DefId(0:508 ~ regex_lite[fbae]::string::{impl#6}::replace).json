{
  "name": "regex_lite::string::{impl#6}::replace",
  "mod_info": {
    "name": "string",
    "loc": "regex-lite/src/lib.rs:884:1:884:12"
  },
  "visible": true,
  "loc": "regex-lite/src/string.rs:736:5:742:6",
  "doc": "/// Replaces the leftmost-first match in the given haystack with the\n/// replacement provided. The replacement can be a regular string (where\n/// `$N` and `$name` are expanded to match capture groups) or a function\n/// that takes a [`Captures`] and returns the replaced string.\n///\n/// If no match is found, then the haystack is returned unchanged. In that\n/// case, this implementation will likely return a `Cow::Borrowed` value\n/// such that no allocation is performed.\n///\n/// # Replacement string syntax\n///\n/// All instances of `$ref` in the replacement string are replaced with\n/// the substring corresponding to the capture group identified by `ref`.\n///\n/// `ref` may be an integer corresponding to the index of the capture group\n/// (counted by order of opening parenthesis where `0` is the entire match)\n/// or it can be a name (consisting of letters, digits or underscores)\n/// corresponding to a named capture group.\n///\n/// If `ref` isn't a valid capture group (whether the name doesn't exist or\n/// isn't a valid index), then it is replaced with the empty string.\n///\n/// The longest possible name is used. For example, `$1a` looks up the\n/// capture group named `1a` and not the capture group at index `1`. To\n/// exert more precise control over the name, use braces, e.g., `${1}a`.\n///\n/// To write a literal `$` use `$$`.\n///\n/// # Example\n///\n/// Note that this function is polymorphic with respect to the replacement.\n/// In typical usage, this can just be a normal string:\n///\n/// ```\n/// use regex_lite::Regex;\n///\n/// let re = Regex::new(r\"[^01]+\").unwrap();\n/// assert_eq!(re.replace(\"1078910\", \"\"), \"1010\");\n/// ```\n///\n/// But anything satisfying the [`Replacer`] trait will work. For example,\n/// a closure of type `|&Captures| -> String` provides direct access to the\n/// captures corresponding to a match. This allows one to access capturing\n/// group matches easily:\n///\n/// ```\n/// use regex_lite::{Captures, Regex};\n///\n/// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", |caps: &Captures| {\n///     format!(\"{} {}\", &caps[2], &caps[1])\n/// });\n/// assert_eq!(result, \"Bruce Springsteen\");\n/// ```\n///\n/// But this is a bit cumbersome to use all the time. Instead, a simple\n/// syntax is supported (as described above) that expands `$name` into the\n/// corresponding capture group. Here's the last example, but using this\n/// expansion technique with named capture groups:\n///\n/// ```\n/// use regex_lite::Regex;\n///\n/// let re = Regex::new(r\"(?<last>[^,\\s]+),\\s+(?<first>\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", \"$first $last\");\n/// assert_eq!(result, \"Bruce Springsteen\");\n/// ```\n///\n/// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n/// would produce the same result. To write a literal `$` use `$$`.\n///\n/// Sometimes the replacement string requires use of curly braces to\n/// delineate a capture group replacement when it is adjacent to some other\n/// literal text. For example, if we wanted to join two words together with\n/// an underscore:\n///\n/// ```\n/// use regex_lite::Regex;\n///\n/// let re = Regex::new(r\"(?<first>\\w+)\\s+(?<second>\\w+)\").unwrap();\n/// let result = re.replace(\"deep fried\", \"${first}_$second\");\n/// assert_eq!(result, \"deep_fried\");\n/// ```\n///\n/// Without the curly braces, the capture group name `first_` would be\n/// used, and since it doesn't exist, it would be replaced with the empty\n/// string.\n///\n/// Finally, sometimes you just want to replace a literal string with no\n/// regard for capturing group expansion. This can be done by wrapping a\n/// string with [`NoExpand`]:\n///\n/// ```\n/// use regex_lite::{NoExpand, Regex};\n///\n/// let re = Regex::new(r\"(?<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", NoExpand(\"$2 $last\"));\n/// assert_eq!(result, \"$2 $last\");\n/// ```\n///\n/// Using `NoExpand` may also be faster, since the replacement string won't\n/// need to be parsed for the `$` syntax.\n",
  "code": [
    "pub fn replace<'h, R: Replacer>(",
    "    &self,",
    "    haystack: &'h str,",
    "    rep: R,",
    ") -> Cow<'h, str> {",
    "    self.replacen(haystack, 1, rep)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}