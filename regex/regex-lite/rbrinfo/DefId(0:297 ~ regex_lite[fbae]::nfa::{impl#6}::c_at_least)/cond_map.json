{
  "regex-lite/src/nfa.rs:494:26:494:53": [
    {
      "Try": "self.c_exactly(hir, n - 1)?"
    }
  ],
  "regex-lite/src/nfa.rs:486:19:486:25": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "n == 1",
          "lhs": "n",
          "rhs": "1",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-lite/src/nfa.rs:454:17:454:37": [
    {
      "Bool": {
        "Other": "hir.is_match_empty()"
      }
    }
  ],
  "regex-lite/src/nfa.rs:489:17:489:79": [
    {
      "Try": "self.add(State::Splits { targets: vec![], reverse: !greedy })?"
    }
  ],
  "regex-lite/src/nfa.rs:460:17:460:52": [
    {
      "Try": "self.patch(splits, compiled.start)?"
    }
  ],
  "regex-lite/src/nfa.rs:500:13:500:44": [
    {
      "Try": "self.patch(splits, last.start)?"
    }
  ],
  "regex-lite/src/nfa.rs:487:28:487:40": [
    {
      "Try": "self.c(hir)?"
    }
  ],
  "regex-lite/src/nfa.rs:490:13:490:46": [
    {
      "Try": "self.patch(compiled.end, splits)?"
    }
  ],
  "regex-lite/src/nfa.rs:498:13:498:48": [
    {
      "Try": "self.patch(prefix.end, last.start)?"
    }
  ],
  "regex-lite/src/nfa.rs:455:30:458:20": [
    {
      "Try": "self.add(State::Splits {\n                    targets: vec![],\n                    reverse: !greedy,\n                })?"
    }
  ],
  "regex-lite/src/nfa.rs:481:25:481:42": [
    {
      "Try": "self.add_empty()?"
    }
  ],
  "regex-lite/src/nfa.rs:494:46:494:51": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "n - 1",
          "lhs": "n",
          "rhs": "1",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-lite/src/nfa.rs:461:17:461:50": [
    {
      "Try": "self.patch(compiled.end, splits)?"
    }
  ],
  "regex-lite/src/nfa.rs:483:13:483:41": [
    {
      "Try": "self.patch(question, empty)?"
    }
  ],
  "regex-lite/src/nfa.rs:491:13:491:48": [
    {
      "Try": "self.patch(splits, compiled.start)?"
    }
  ],
  "regex-lite/src/nfa.rs:475:17:475:79": [
    {
      "Try": "self.add(State::Splits { targets: vec![], reverse: !greedy })?"
    }
  ],
  "regex-lite/src/nfa.rs:473:28:473:40": [
    {
      "Try": "self.c(hir)?"
    }
  ],
  "regex-lite/src/nfa.rs:477:13:477:46": [
    {
      "Try": "self.patch(plus, compiled.start)?"
    }
  ],
  "regex-lite/src/nfa.rs:482:13:482:50": [
    {
      "Try": "self.patch(question, compiled.start)?"
    }
  ],
  "regex-lite/src/nfa.rs:497:17:497:79": [
    {
      "Try": "self.add(State::Splits { targets: vec![], reverse: !greedy })?"
    }
  ],
  "regex-lite/src/nfa.rs:484:13:484:37": [
    {
      "Try": "self.patch(plus, empty)?"
    }
  ],
  "regex-lite/src/nfa.rs:449:12:449:18": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "n == 0",
          "lhs": "n",
          "rhs": "0",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-lite/src/nfa.rs:499:13:499:42": [
    {
      "Try": "self.patch(last.end, splits)?"
    }
  ],
  "regex-lite/src/nfa.rs:480:17:480:79": [
    {
      "Try": "self.add(State::Splits { targets: vec![], reverse: !greedy })?"
    }
  ],
  "regex-lite/src/nfa.rs:476:13:476:44": [
    {
      "Try": "self.patch(compiled.end, plus)?"
    }
  ],
  "regex-lite/src/nfa.rs:459:32:459:44": [
    {
      "Try": "self.c(hir)?"
    }
  ],
  "regex-lite/src/nfa.rs:495:24:495:36": [
    {
      "Try": "self.c(hir)?"
    }
  ]
}