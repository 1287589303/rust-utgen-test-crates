{
  "name": "once_cell::sync::{impl#10}::new",
  "mod_info": {
    "name": "sync",
    "loc": "src/lib.rs:863:1:1409:2"
  },
  "visible": true,
  "loc": "src/lib.rs:1278:9:1280:10",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Lazy { cell: OnceCell::new(), init: Cell::new(Some(f)) }\n"
      ],
      "input_infer": "Test input conditions or ranges: a valid function pointer `f` of type `F` that can be initialized, including edge cases such as null pointers, no-op functions, and functions returning minimal and maximal values of type `T`.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    fn no_op_function() -> i32 {",
                "        0",
                "    }",
                "    let lazy = Lazy::new(no_op_function);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lazy.cell.get(), None);",
                "    assert_eq!(lazy.init.get(), Some(no_op_function));"
              ],
              "code": [
                "{",
                "    fn no_op_function() -> i32 {",
                "        0",
                "    }",
                "    let lazy = Lazy::new(no_op_function);",
                "    assert_eq!(lazy.cell.get(), None);",
                "    assert_eq!(lazy.init.get(), Some(no_op_function));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    fn minimal_value_function() -> i32 {",
                "        i32::MIN",
                "    }",
                "    let lazy = Lazy::new(minimal_value_function);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lazy.cell.get(), None);",
                "    assert!(lazy.init.get().is_some());",
                "    assert_eq!(lazy.init.get().unwrap() as *const _ as usize, minimal_value_function as *const _ as usize);",
                "    assert_eq!(lazy.cell, OnceCell::new());"
              ],
              "code": [
                "{",
                "    fn minimal_value_function() -> i32 {",
                "        i32::MIN",
                "    }",
                "    let lazy = Lazy::new(minimal_value_function);",
                "    assert_eq!(lazy.cell.get(), None);",
                "    assert!(lazy.init.get().is_some());",
                "    assert_eq!(lazy.init.get().unwrap() as *const _ as usize, minimal_value_function as *const _ as usize);",
                "    assert_eq!(lazy.cell, OnceCell::new());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    fn maximal_value_function() -> i32 {",
                "        i32::MAX",
                "    }",
                "    let lazy = Lazy::new(maximal_value_function);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lazy.cell.get(), None);",
                "    assert_eq!(lazy.init.get().is_some(), true);",
                "    assert_eq!(lazy.init.get().unwrap() as *const _ as usize, maximal_value_function as *const _ as usize);",
                "    assert!(matches!(lazy.cell, OnceCell { .. }));"
              ],
              "code": [
                "{",
                "    fn maximal_value_function() -> i32 {",
                "        i32::MAX",
                "    }",
                "    let lazy = Lazy::new(maximal_value_function);",
                "    assert_eq!(lazy.cell.get(), None);",
                "    assert_eq!(lazy.init.get().is_some(), true);",
                "    assert_eq!(lazy.init.get().unwrap() as *const _ as usize, maximal_value_function as *const _ as usize);",
                "    assert!(matches!(lazy.cell, OnceCell { .. }));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lazy = Lazy::<i32, fn() -> i32>::new(core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
                "}"
              ],
              "oracle": [
                "    let lazy = Lazy::<i32, fn() -> i32>::new(core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
                "    assert!(lazy.cell.get().is_none());",
                "    assert!(lazy.init.get().is_some());",
                "    assert_eq!(lazy.init.get().unwrap(), core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
                "    let lazy_empty = Lazy::<i32, fn() -> i32>::new(|| 42);",
                "    assert!(lazy_empty.cell.get().is_none());",
                "    assert!(lazy_empty.init.get().is_some());",
                "    assert_ne!(lazy_empty.init.get().unwrap(), core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);"
              ],
              "code": [
                "{",
                "    let lazy = Lazy::<i32, fn() -> i32>::new(core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
                "    let lazy = Lazy::<i32, fn() -> i32>::new(core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
                "    assert!(lazy.cell.get().is_none());",
                "    assert!(lazy.init.get().is_some());",
                "    assert_eq!(lazy.init.get().unwrap(), core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
                "    let lazy_empty = Lazy::<i32, fn() -> i32>::new(|| 42);",
                "    assert!(lazy_empty.cell.get().is_none());",
                "    assert!(lazy_empty.init.get().is_some());",
                "    assert_ne!(lazy_empty.init.get().unwrap(), core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    fn complex_function() -> String {",
                "        String::from(\"Hello, world!\")",
                "    }",
                "    let lazy = Lazy::new(complex_function);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(lazy.cell.get(), None);",
                "    assert!(lazy.init.get().is_some());",
                "    assert!(lazy.init.get().unwrap() as *const _ == complex_function as *const _);",
                "    assert_eq!(lazy.init.get().unwrap()(), \"Hello, world!\");"
              ],
              "code": [
                "{",
                "    fn complex_function() -> String {",
                "        String::from(\"Hello, world!\")",
                "    }",
                "    let lazy = Lazy::new(complex_function);",
                "    assert_eq!(lazy.cell.get(), None);",
                "    assert!(lazy.init.get().is_some());",
                "    assert!(lazy.init.get().unwrap() as *const _ == complex_function as *const _);",
                "    assert_eq!(lazy.init.get().unwrap()(), \"Hello, world!\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}