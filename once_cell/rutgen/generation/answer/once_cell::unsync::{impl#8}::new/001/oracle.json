[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cell: OnceCell<i32> = OnceCell::new();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(cell.get(), None);",
          "    assert!(std::mem::is_uninit(&cell.inner));",
          "    assert!(cell.inner.get() == &Some(None));",
          "    assert!(std::ptr::eq(cell.inner.get(), UnsafeCell::new(None)));"
        ],
        "code": [
          "{",
          "    let cell: OnceCell<i32> = OnceCell::new();",
          "    assert_eq!(cell.get(), None);",
          "    assert!(std::mem::is_uninit(&cell.inner));",
          "    assert!(cell.inner.get() == &Some(None));",
          "    assert!(std::ptr::eq(cell.inner.get(), UnsafeCell::new(None)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cell: OnceCell<f64> = OnceCell::new();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(cell.get(), None);",
          "    assert!(cell.inner.get().is_null());",
          "    assert!(core::mem::size_of::<OnceCell<f64>>() > 0);"
        ],
        "code": [
          "{",
          "    let cell: OnceCell<f64> = OnceCell::new();",
          "    assert_eq!(cell.get(), None);",
          "    assert!(cell.inner.get().is_null());",
          "    assert!(core::mem::size_of::<OnceCell<f64>>() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cell: OnceCell<char> = OnceCell::new();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(cell.get(), None);",
          "    assert_eq!(mem::size_of_val(&cell), mem::size_of::<OnceCell<char>>());",
          "    assert!(unsafe { &*cell.inner.get() }.is_none());",
          "    assert!(cell.take().is_none());"
        ],
        "code": [
          "{",
          "    let cell: OnceCell<char> = OnceCell::new();",
          "    assert_eq!(cell.get(), None);",
          "    assert_eq!(mem::size_of_val(&cell), mem::size_of::<OnceCell<char>>());",
          "    assert!(unsafe { &*cell.inner.get() }.is_none());",
          "    assert!(cell.take().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cell: OnceCell<()> = OnceCell::new();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(cell.get(), None);",
          "    assert!(cell.inner.get().is_none());",
          "    assert!(std::mem::size_of::<OnceCell<()>>() > 0);",
          "    assert!(std::mem::size_of::<UnsafeCell<Option<()>>>() > 0);",
          "    assert!(cell.inner.get() as *const _ == UnsafeCell::new(None) as *const _);"
        ],
        "code": [
          "{",
          "    let cell: OnceCell<()> = OnceCell::new();",
          "    assert_eq!(cell.get(), None);",
          "    assert!(cell.inner.get().is_none());",
          "    assert!(std::mem::size_of::<OnceCell<()>>() > 0);",
          "    assert!(std::mem::size_of::<UnsafeCell<Option<()>>>() > 0);",
          "    assert!(cell.inner.get() as *const _ == UnsafeCell::new(None) as *const _);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyStruct;",
          "    let cell: OnceCell<MyStruct> = OnceCell::new();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(cell.get(), None);",
          "    assert!(std::ptr::eq(unsafe { &*(cell.inner.get() as *const Option<MyStruct>) }, &None));"
        ],
        "code": [
          "{",
          "    struct MyStruct;",
          "    let cell: OnceCell<MyStruct> = OnceCell::new();",
          "    assert_eq!(cell.get(), None);",
          "    assert!(std::ptr::eq(unsafe { &*(cell.inner.get() as *const Option<MyStruct>) }, &None));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    enum MyEnum {",
          "        Variant1,",
          "        Variant2,",
          "    }",
          "    let cell: OnceCell<MyEnum> = OnceCell::new();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(cell.get(), None);",
          "    assert!(std::ptr::eq(unsafe { &*cell.inner.get() }, std::ptr::null()));",
          "    assert!(std::mem::size_of::<OnceCell<MyEnum>>() > 0);",
          "    assert!(mem::align_of::<OnceCell<MyEnum>>() > 0);",
          "    assert!(cell.inner.get().is_null());"
        ],
        "code": [
          "{",
          "    enum MyEnum {",
          "        Variant1,",
          "        Variant2,",
          "    }",
          "    let cell: OnceCell<MyEnum> = OnceCell::new();",
          "    assert_eq!(cell.get(), None);",
          "    assert!(std::ptr::eq(unsafe { &*cell.inner.get() }, std::ptr::null()));",
          "    assert!(std::mem::size_of::<OnceCell<MyEnum>>() > 0);",
          "    assert!(mem::align_of::<OnceCell<MyEnum>>() > 0);",
          "    assert!(cell.inner.get().is_null());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]