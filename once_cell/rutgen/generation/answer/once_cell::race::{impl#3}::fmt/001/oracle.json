[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let once_ref = OnceRef::<i32> {",
          "        inner: AtomicPtr::new(ptr::null_mut()),",
          "        ghost: PhantomData,",
          "    };",
          "    let _ = format!(\"{:?}\", once_ref);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{:?}\", once_ref), \"OnceRef(0x0)\");"
        ],
        "code": [
          "{",
          "    let once_ref = OnceRef::<i32> {",
          "        inner: AtomicPtr::new(ptr::null_mut()),",
          "        ghost: PhantomData,",
          "    };",
          "    let _ = format!(\"{:?}\", once_ref);",
          "    assert_eq!(format!(\"{:?}\", once_ref), \"OnceRef(0x0)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = Box::new(42);",
          "    let once_ref = OnceRef::<i32> {",
          "        inner: AtomicPtr::new(Box::into_raw(value)),",
          "        ghost: PhantomData,",
          "    };",
          "    let _ = format!(\"{:?}\", once_ref);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{:?}\", once_ref), \"OnceRef(0x...)\", \"The debug format should include the pointer address.\");",
          "    assert!(once_ref.inner.load(Ordering::SeqCst).is_non_null(), \"The inner AtomicPtr should be non-null.\");",
          "    assert!(once_ref.ghost.is_some(), \"The ghost field should be valid as PhantomData.\");"
        ],
        "code": [
          "{",
          "    let value = Box::new(42);",
          "    let once_ref = OnceRef::<i32> {",
          "        inner: AtomicPtr::new(Box::into_raw(value)),",
          "        ghost: PhantomData,",
          "    };",
          "    let _ = format!(\"{:?}\", once_ref);",
          "    assert_eq!(format!(\"{:?}\", once_ref), \"OnceRef(0x...)\", \"The debug format should include the pointer address.\");",
          "    assert!(once_ref.inner.load(Ordering::SeqCst).is_non_null(), \"The inner AtomicPtr should be non-null.\");",
          "    assert!(once_ref.ghost.is_some(), \"The ghost field should be valid as PhantomData.\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let once_ref = OnceRef::<NonZeroUsize> {",
          "        inner: AtomicPtr::new(ptr::null_mut()),",
          "        ghost: PhantomData,",
          "    };",
          "    let _ = format!(\"{:?}\", once_ref);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{:?}\", once_ref), \"OnceRef(0x0)\");",
          "    once_ref.inner.store(AtomicPtr::new(&NonZeroUsize::new(1).unwrap() as *const _ as *mut _), Ordering::SeqCst);",
          "    assert_eq!(format!(\"{:?}\", once_ref), format!(\"OnceRef({:?})\", &NonZeroUsize::new(1).unwrap()));",
          "    once_ref.inner.store(AtomicPtr::new(&NonZeroUsize::new(2).unwrap() as *const _ as *mut _), Ordering::SeqCst);",
          "    assert_eq!(format!(\"{:?}\", once_ref), format!(\"OnceRef({:?})\", &NonZeroUsize::new(2).unwrap()));",
          "    once_ref.inner.store(AtomicPtr::new(ptr::null_mut()), Ordering::SeqCst);",
          "    assert_eq!(format!(\"{:?}\", once_ref), \"OnceRef(0x0)\");"
        ],
        "code": [
          "{",
          "    let once_ref = OnceRef::<NonZeroUsize> {",
          "        inner: AtomicPtr::new(ptr::null_mut()),",
          "        ghost: PhantomData,",
          "    };",
          "    let _ = format!(\"{:?}\", once_ref);",
          "    assert_eq!(format!(\"{:?}\", once_ref), \"OnceRef(0x0)\");",
          "    once_ref.inner.store(AtomicPtr::new(&NonZeroUsize::new(1).unwrap() as *const _ as *mut _), Ordering::SeqCst);",
          "    assert_eq!(format!(\"{:?}\", once_ref), format!(\"OnceRef({:?})\", &NonZeroUsize::new(1).unwrap()));",
          "    once_ref.inner.store(AtomicPtr::new(&NonZeroUsize::new(2).unwrap() as *const _ as *mut _), Ordering::SeqCst);",
          "    assert_eq!(format!(\"{:?}\", once_ref), format!(\"OnceRef({:?})\", &NonZeroUsize::new(2).unwrap()));",
          "    once_ref.inner.store(AtomicPtr::new(ptr::null_mut()), Ordering::SeqCst);",
          "    assert_eq!(format!(\"{:?}\", once_ref), \"OnceRef(0x0)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]