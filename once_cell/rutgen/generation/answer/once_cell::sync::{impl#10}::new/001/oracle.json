[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    fn no_op_function() -> i32 {",
          "        0",
          "    }",
          "    let lazy = Lazy::new(no_op_function);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lazy.cell.get(), None);",
          "    assert_eq!(lazy.init.get(), Some(no_op_function));"
        ],
        "code": [
          "{",
          "    fn no_op_function() -> i32 {",
          "        0",
          "    }",
          "    let lazy = Lazy::new(no_op_function);",
          "    assert_eq!(lazy.cell.get(), None);",
          "    assert_eq!(lazy.init.get(), Some(no_op_function));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    fn minimal_value_function() -> i32 {",
          "        i32::MIN",
          "    }",
          "    let lazy = Lazy::new(minimal_value_function);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lazy.cell.get(), None);",
          "    assert!(lazy.init.get().is_some());",
          "    assert_eq!(lazy.init.get().unwrap() as *const _ as usize, minimal_value_function as *const _ as usize);",
          "    assert_eq!(lazy.cell, OnceCell::new());"
        ],
        "code": [
          "{",
          "    fn minimal_value_function() -> i32 {",
          "        i32::MIN",
          "    }",
          "    let lazy = Lazy::new(minimal_value_function);",
          "    assert_eq!(lazy.cell.get(), None);",
          "    assert!(lazy.init.get().is_some());",
          "    assert_eq!(lazy.init.get().unwrap() as *const _ as usize, minimal_value_function as *const _ as usize);",
          "    assert_eq!(lazy.cell, OnceCell::new());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    fn maximal_value_function() -> i32 {",
          "        i32::MAX",
          "    }",
          "    let lazy = Lazy::new(maximal_value_function);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lazy.cell.get(), None);",
          "    assert_eq!(lazy.init.get().is_some(), true);",
          "    assert_eq!(lazy.init.get().unwrap() as *const _ as usize, maximal_value_function as *const _ as usize);",
          "    assert!(matches!(lazy.cell, OnceCell { .. }));"
        ],
        "code": [
          "{",
          "    fn maximal_value_function() -> i32 {",
          "        i32::MAX",
          "    }",
          "    let lazy = Lazy::new(maximal_value_function);",
          "    assert_eq!(lazy.cell.get(), None);",
          "    assert_eq!(lazy.init.get().is_some(), true);",
          "    assert_eq!(lazy.init.get().unwrap() as *const _ as usize, maximal_value_function as *const _ as usize);",
          "    assert!(matches!(lazy.cell, OnceCell { .. }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lazy = Lazy::<i32, fn() -> i32>::new(core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
          "}"
        ],
        "oracle": [
          "    let lazy = Lazy::<i32, fn() -> i32>::new(core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
          "    assert!(lazy.cell.get().is_none());",
          "    assert!(lazy.init.get().is_some());",
          "    assert_eq!(lazy.init.get().unwrap(), core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
          "    let lazy_empty = Lazy::<i32, fn() -> i32>::new(|| 42);",
          "    assert!(lazy_empty.cell.get().is_none());",
          "    assert!(lazy_empty.init.get().is_some());",
          "    assert_ne!(lazy_empty.init.get().unwrap(), core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);"
        ],
        "code": [
          "{",
          "    let lazy = Lazy::<i32, fn() -> i32>::new(core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
          "    let lazy = Lazy::<i32, fn() -> i32>::new(core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
          "    assert!(lazy.cell.get().is_none());",
          "    assert!(lazy.init.get().is_some());",
          "    assert_eq!(lazy.init.get().unwrap(), core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
          "    let lazy_empty = Lazy::<i32, fn() -> i32>::new(|| 42);",
          "    assert!(lazy_empty.cell.get().is_none());",
          "    assert!(lazy_empty.init.get().is_some());",
          "    assert_ne!(lazy_empty.init.get().unwrap(), core::ptr::null::<fn() -> i32>() as *const () as fn() -> i32);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    fn complex_function() -> String {",
          "        String::from(\"Hello, world!\")",
          "    }",
          "    let lazy = Lazy::new(complex_function);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lazy.cell.get(), None);",
          "    assert!(lazy.init.get().is_some());",
          "    assert!(lazy.init.get().unwrap() as *const _ == complex_function as *const _);",
          "    assert_eq!(lazy.init.get().unwrap()(), \"Hello, world!\");"
        ],
        "code": [
          "{",
          "    fn complex_function() -> String {",
          "        String::from(\"Hello, world!\")",
          "    }",
          "    let lazy = Lazy::new(complex_function);",
          "    assert_eq!(lazy.cell.get(), None);",
          "    assert!(lazy.init.get().is_some());",
          "    assert!(lazy.init.get().unwrap() as *const _ == complex_function as *const _);",
          "    assert_eq!(lazy.init.get().unwrap()(), \"Hello, world!\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]