[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestOnce {",
          "        once: OnceNonZeroUsize,",
          "    }",
          "    ",
          "    impl TestOnce {",
          "        fn new() -> Self {",
          "            Self {",
          "                once: OnceNonZeroUsize::new(),",
          "            }",
          "        }",
          "    ",
          "        fn init_value(&self) -> NonZeroUsize {",
          "            NonZeroUsize::new(1).unwrap() // returns a NonZeroUsize greater than 0",
          "        }",
          "    }",
          "",
          "    let test_instance = TestOnce::new();",
          "    let _ = test_instance.once.init(|_| {",
          "        Ok(test_instance.init_value())",
          "    });",
          "}"
        ],
        "oracle": [
          "    assert!(test_instance.once.inner.load(Ordering::Acquire) == 1);",
          "    assert!(test_instance.once.get().is_some());",
          "    assert_eq!(test_instance.once.get().unwrap().get(), 1);",
          "    assert!(std::mem::size_of::<NonZeroUsize>() > 0);",
          "    assert!(test_instance.once.inner.load(Ordering::Acquire) != 0);",
          "    assert!(test_instance.once.get_unchecked().get() == 1);"
        ],
        "code": [
          "{",
          "    struct TestOnce {",
          "        once: OnceNonZeroUsize,",
          "    }",
          "    ",
          "    impl TestOnce {",
          "        fn new() -> Self {",
          "            Self {",
          "                once: OnceNonZeroUsize::new(),",
          "            }",
          "        }",
          "    ",
          "        fn init_value(&self) -> NonZeroUsize {",
          "            NonZeroUsize::new(1).unwrap() // returns a NonZeroUsize greater than 0",
          "        }",
          "    }",
          "",
          "    let test_instance = TestOnce::new();",
          "    let _ = test_instance.once.init(|_| {",
          "        Ok(test_instance.init_value())",
          "    });",
          "    assert!(test_instance.once.inner.load(Ordering::Acquire) == 1);",
          "    assert!(test_instance.once.get().is_some());",
          "    assert_eq!(test_instance.once.get().unwrap().get(), 1);",
          "    assert!(std::mem::size_of::<NonZeroUsize>() > 0);",
          "    assert!(test_instance.once.inner.load(Ordering::Acquire) != 0);",
          "    assert!(test_instance.once.get_unchecked().get() == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestOnce {",
          "        once: OnceNonZeroUsize,",
          "    }",
          "",
          "    impl TestOnce {",
          "        fn new() -> Self {",
          "            Self {",
          "                once: OnceNonZeroUsize::new(),",
          "            }",
          "        }",
          "",
          "        fn other_value(&self) -> Result<NonZeroUsize, ()> {",
          "            Ok(NonZeroUsize::new(2).unwrap()) // returns a different NonZeroUsize greater than 0",
          "        }",
          "    }",
          "",
          "    let test_instance = TestOnce::new();",
          "    let _ = test_instance.once.init(|_| {",
          "        let other = test_instance.other_value();",
          "        match other {",
          "            Ok(val) => Ok(val),",
          "            Err(_) => Err(()),",
          "        }",
          "    });",
          "}"
        ],
        "oracle": [
          "    assert_eq!(test_instance.once.init(|_| Ok(NonZeroUsize::new(1).unwrap())), Ok(NonZeroUsize::new_unchecked(1)));",
          "    assert_eq!(test_instance.once.init(|_| Ok(NonZeroUsize::new(3).unwrap())), Ok(NonZeroUsize::new_unchecked(3)));",
          "    assert_eq!(test_instance.once.init(|_| test_instance.other_value()), Ok(NonZeroUsize::new_unchecked(2)));"
        ],
        "code": [
          "{",
          "    struct TestOnce {",
          "        once: OnceNonZeroUsize,",
          "    }",
          "",
          "    impl TestOnce {",
          "        fn new() -> Self {",
          "            Self {",
          "                once: OnceNonZeroUsize::new(),",
          "            }",
          "        }",
          "",
          "        fn other_value(&self) -> Result<NonZeroUsize, ()> {",
          "            Ok(NonZeroUsize::new(2).unwrap()) // returns a different NonZeroUsize greater than 0",
          "        }",
          "    }",
          "",
          "    let test_instance = TestOnce::new();",
          "    let _ = test_instance.once.init(|_| {",
          "        let other = test_instance.other_value();",
          "        match other {",
          "            Ok(val) => Ok(val),",
          "            Err(_) => Err(()),",
          "        }",
          "    });",
          "    assert_eq!(test_instance.once.init(|_| Ok(NonZeroUsize::new(1).unwrap())), Ok(NonZeroUsize::new_unchecked(1)));",
          "    assert_eq!(test_instance.once.init(|_| Ok(NonZeroUsize::new(3).unwrap())), Ok(NonZeroUsize::new_unchecked(3)));",
          "    assert_eq!(test_instance.once.init(|_| test_instance.other_value()), Ok(NonZeroUsize::new_unchecked(2)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestOnce {",
          "        once: OnceNonZeroUsize,",
          "    }",
          "",
          "    impl TestOnce {",
          "        fn new() -> Self {",
          "            Self {",
          "                once: OnceNonZeroUsize::new(),",
          "            }",
          "        }",
          "",
          "        fn init_value(&self) -> Result<NonZeroUsize, ()> {",
          "            Ok(NonZeroUsize::new(3).unwrap()) // returns a NonZeroUsize greater than 0",
          "        }",
          "    }",
          "",
          "    let test_instance = TestOnce::new();",
          "    let _ = test_instance.once.init(|_| {",
          "        test_instance.init_value()",
          "    });",
          "    let _ = test_instance.once.init(|_| {",
          "        test_instance.init_value()",
          "    }); // Should trigger exchange case",
          "}"
        ],
        "oracle": [
          "    assert_eq!(test_instance.once.inner.get(), 3);",
          "    assert!(test_instance.once.get().is_some());",
          "    assert_eq!(test_instance.once.get().unwrap().get(), 3);",
          "    assert_eq!(test_instance.once.init(|_| test_instance.init_value()), Ok(unsafe { NonZeroUsize::new_unchecked(3) }));",
          "    assert_ne!(test_instance.once.inner.get(), 0);"
        ],
        "code": [
          "{",
          "    struct TestOnce {",
          "        once: OnceNonZeroUsize,",
          "    }",
          "",
          "    impl TestOnce {",
          "        fn new() -> Self {",
          "            Self {",
          "                once: OnceNonZeroUsize::new(),",
          "            }",
          "        }",
          "",
          "        fn init_value(&self) -> Result<NonZeroUsize, ()> {",
          "            Ok(NonZeroUsize::new(3).unwrap()) // returns a NonZeroUsize greater than 0",
          "        }",
          "    }",
          "",
          "    let test_instance = TestOnce::new();",
          "    let _ = test_instance.once.init(|_| {",
          "        test_instance.init_value()",
          "    });",
          "    let _ = test_instance.once.init(|_| {",
          "        test_instance.init_value()",
          "    }); // Should trigger exchange case",
          "    assert_eq!(test_instance.once.inner.get(), 3);",
          "    assert!(test_instance.once.get().is_some());",
          "    assert_eq!(test_instance.once.get().unwrap().get(), 3);",
          "    assert_eq!(test_instance.once.init(|_| test_instance.init_value()), Ok(unsafe { NonZeroUsize::new_unchecked(3) }));",
          "    assert_ne!(test_instance.once.inner.get(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]