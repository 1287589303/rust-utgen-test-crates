{
  "name": "once_cell::unsync::{impl#8}::new",
  "mod_info": {
    "name": "unsync",
    "loc": "src/lib.rs:383:1:859:2"
  },
  "visible": true,
  "loc": "src/lib.rs:470:9:472:10",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: OnceCell { inner: UnsafeCell::new(None) }\n"
      ],
      "input_infer": "Test input conditions or ranges: Test the creation of OnceCell<T> with various types T, including basic types (e.g., i32, f64, char), complex types (e.g., structs, enums), and edge cases with no type parameters (unit type).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cell: OnceCell<i32> = OnceCell::new();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cell.get(), None);",
                "    assert!(std::mem::is_uninit(&cell.inner));",
                "    assert!(cell.inner.get() == &Some(None));",
                "    assert!(std::ptr::eq(cell.inner.get(), UnsafeCell::new(None)));"
              ],
              "code": [
                "{",
                "    let cell: OnceCell<i32> = OnceCell::new();",
                "    assert_eq!(cell.get(), None);",
                "    assert!(std::mem::is_uninit(&cell.inner));",
                "    assert!(cell.inner.get() == &Some(None));",
                "    assert!(std::ptr::eq(cell.inner.get(), UnsafeCell::new(None)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cell: OnceCell<f64> = OnceCell::new();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cell.get(), None);",
                "    assert!(cell.inner.get().is_null());",
                "    assert!(core::mem::size_of::<OnceCell<f64>>() > 0);"
              ],
              "code": [
                "{",
                "    let cell: OnceCell<f64> = OnceCell::new();",
                "    assert_eq!(cell.get(), None);",
                "    assert!(cell.inner.get().is_null());",
                "    assert!(core::mem::size_of::<OnceCell<f64>>() > 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cell: OnceCell<char> = OnceCell::new();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cell.get(), None);",
                "    assert_eq!(mem::size_of_val(&cell), mem::size_of::<OnceCell<char>>());",
                "    assert!(unsafe { &*cell.inner.get() }.is_none());",
                "    assert!(cell.take().is_none());"
              ],
              "code": [
                "{",
                "    let cell: OnceCell<char> = OnceCell::new();",
                "    assert_eq!(cell.get(), None);",
                "    assert_eq!(mem::size_of_val(&cell), mem::size_of::<OnceCell<char>>());",
                "    assert!(unsafe { &*cell.inner.get() }.is_none());",
                "    assert!(cell.take().is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cell: OnceCell<()> = OnceCell::new();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cell.get(), None);",
                "    assert!(cell.inner.get().is_none());",
                "    assert!(std::mem::size_of::<OnceCell<()>>() > 0);",
                "    assert!(std::mem::size_of::<UnsafeCell<Option<()>>>() > 0);",
                "    assert!(cell.inner.get() as *const _ == UnsafeCell::new(None) as *const _);"
              ],
              "code": [
                "{",
                "    let cell: OnceCell<()> = OnceCell::new();",
                "    assert_eq!(cell.get(), None);",
                "    assert!(cell.inner.get().is_none());",
                "    assert!(std::mem::size_of::<OnceCell<()>>() > 0);",
                "    assert!(std::mem::size_of::<UnsafeCell<Option<()>>>() > 0);",
                "    assert!(cell.inner.get() as *const _ == UnsafeCell::new(None) as *const _);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyStruct;",
                "    let cell: OnceCell<MyStruct> = OnceCell::new();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cell.get(), None);",
                "    assert!(std::ptr::eq(unsafe { &*(cell.inner.get() as *const Option<MyStruct>) }, &None));"
              ],
              "code": [
                "{",
                "    struct MyStruct;",
                "    let cell: OnceCell<MyStruct> = OnceCell::new();",
                "    assert_eq!(cell.get(), None);",
                "    assert!(std::ptr::eq(unsafe { &*(cell.inner.get() as *const Option<MyStruct>) }, &None));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    enum MyEnum {",
                "        Variant1,",
                "        Variant2,",
                "    }",
                "    let cell: OnceCell<MyEnum> = OnceCell::new();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cell.get(), None);",
                "    assert!(std::ptr::eq(unsafe { &*cell.inner.get() }, std::ptr::null()));",
                "    assert!(std::mem::size_of::<OnceCell<MyEnum>>() > 0);",
                "    assert!(mem::align_of::<OnceCell<MyEnum>>() > 0);",
                "    assert!(cell.inner.get().is_null());"
              ],
              "code": [
                "{",
                "    enum MyEnum {",
                "        Variant1,",
                "        Variant2,",
                "    }",
                "    let cell: OnceCell<MyEnum> = OnceCell::new();",
                "    assert_eq!(cell.get(), None);",
                "    assert!(std::ptr::eq(unsafe { &*cell.inner.get() }, std::ptr::null()));",
                "    assert!(std::mem::size_of::<OnceCell<MyEnum>>() > 0);",
                "    assert!(mem::align_of::<OnceCell<MyEnum>>() > 0);",
                "    assert!(cell.inner.get().is_null());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}