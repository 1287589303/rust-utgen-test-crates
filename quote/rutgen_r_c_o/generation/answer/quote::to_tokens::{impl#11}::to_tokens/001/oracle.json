[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(i64::MIN);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    tokens.append(Literal::i64_suffixed(i64::MIN));",
          "    assert_eq!(tokens.to_string(), \"i64::MIN\");",
          "    let value = TestStruct(0);",
          "    tokens.clear();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.append(Literal::i64_suffixed(0));",
          "    assert_eq!(tokens.to_string(), \"0\");",
          "    let value = TestStruct(i64::MAX);",
          "    tokens.clear();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.append(Literal::i64_suffixed(i64::MAX));",
          "    assert_eq!(tokens.to_string(), \"i64::MAX\");"
        ],
        "code": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(i64::MIN);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.append(Literal::i64_suffixed(i64::MIN));",
          "    assert_eq!(tokens.to_string(), \"i64::MIN\");",
          "    let value = TestStruct(0);",
          "    tokens.clear();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.append(Literal::i64_suffixed(0));",
          "    assert_eq!(tokens.to_string(), \"0\");",
          "    let value = TestStruct(i64::MAX);",
          "    tokens.clear();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.append(Literal::i64_suffixed(i64::MAX));",
          "    assert_eq!(tokens.to_string(), \"i64::MAX\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(0);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    let value = TestStruct(0);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    assert_eq!(tokens.to_string(), \"0\");"
        ],
        "code": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(0);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    let value = TestStruct(0);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    assert_eq!(tokens.to_string(), \"0\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(i64::MAX);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(tokens.to_string(), \"9223372036854775807\");",
          "    assert!(tokens.clone().into_iter().count() > 0);",
          "    assert!(tokens.iter().any(|t| matches!(t, TokenTree::Literal(_))));",
          "    assert!(tokens.iter().any(|t| t.to_string() == \"9223372036854775807\"));",
          "    assert!(tokens.iter().all(|t| if let TokenTree::Literal(lit) = t { lit.to_string().parse::<i64>().is_ok() } else { true }));"
        ],
        "code": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(i64::MAX);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    assert_eq!(tokens.to_string(), \"9223372036854775807\");",
          "    assert!(tokens.clone().into_iter().count() > 0);",
          "    assert!(tokens.iter().any(|t| matches!(t, TokenTree::Literal(_))));",
          "    assert!(tokens.iter().any(|t| t.to_string() == \"9223372036854775807\"));",
          "    assert!(tokens.iter().all(|t| if let TokenTree::Literal(lit) = t { lit.to_string().parse::<i64>().is_ok() } else { true }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(-1);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    tokens.assert_eq(Literal::i64_suffixed(-1));"
        ],
        "code": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(-1);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.assert_eq(Literal::i64_suffixed(-1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(1);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    tokens.len() == 1",
          "    tokens.to_string() == \"1\"",
          "    tokens.into_iter().next().unwrap() == TokenTree::Literal(Literal::i64_suffixed(1))"
        ],
        "code": [
          "{",
          "    struct TestStruct(i64);",
          "    let value = TestStruct(1);",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.len() == 1",
          "    tokens.to_string() == \"1\"",
          "    tokens.into_iter().next().unwrap() == TokenTree::Literal(Literal::i64_suffixed(1))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]