[
  {
    "uses": [
      "use proc_macro2::Literal;",
      "use proc_macro2::TokenStream;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use proc_macro2::Literal;",
          "    use proc_macro2::TokenStream;",
          "",
          "    let empty_literal = Literal::string(\"\");",
          "    let mut tokens = TokenStream::new();",
          "    empty_literal.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert!(tokens.is_empty());",
          "    assert_eq!(tokens.to_string(), \"\");",
          "    ",
          "    let literal_hello = Literal::string(\"hello\");",
          "    let mut tokens_hello = TokenStream::new();",
          "    literal_hello.to_tokens(&mut tokens_hello);",
          "    assert_eq!(tokens_hello.to_string(), \"hello\");",
          "    ",
          "    let literal_num = Literal::usize_unsuffixed(42);",
          "    let mut tokens_num = TokenStream::new();",
          "    literal_num.to_tokens(&mut tokens_num);",
          "    assert_eq!(tokens_num.to_string(), \"42\");",
          "    ",
          "    let literal_float = Literal::f64_unsuffixed(3.14);",
          "    let mut tokens_float = TokenStream::new();",
          "    literal_float.to_tokens(&mut tokens_float);",
          "    assert_eq!(tokens_float.to_string(), \"3.14\");",
          "    ",
          "    let literal_bool = Literal::bool(true);",
          "    let mut tokens_bool = TokenStream::new();",
          "    literal_bool.to_tokens(&mut tokens_bool);",
          "    assert_eq!(tokens_bool.to_string(), \"true\");",
          "    ",
          "    let literal_char = Literal::character('a');",
          "    let mut tokens_char = TokenStream::new();",
          "    literal_char.to_tokens(&mut tokens_char);",
          "    assert_eq!(tokens_char.to_string(), \"'a'\");"
        ],
        "code": [
          "{",
          "    use proc_macro2::Literal;",
          "    use proc_macro2::TokenStream;",
          "",
          "    let empty_literal = Literal::string(\"\");",
          "    let mut tokens = TokenStream::new();",
          "    empty_literal.to_tokens(&mut tokens);",
          "    assert!(tokens.is_empty());",
          "    assert_eq!(tokens.to_string(), \"\");",
          "    ",
          "    let literal_hello = Literal::string(\"hello\");",
          "    let mut tokens_hello = TokenStream::new();",
          "    literal_hello.to_tokens(&mut tokens_hello);",
          "    assert_eq!(tokens_hello.to_string(), \"hello\");",
          "    ",
          "    let literal_num = Literal::usize_unsuffixed(42);",
          "    let mut tokens_num = TokenStream::new();",
          "    literal_num.to_tokens(&mut tokens_num);",
          "    assert_eq!(tokens_num.to_string(), \"42\");",
          "    ",
          "    let literal_float = Literal::f64_unsuffixed(3.14);",
          "    let mut tokens_float = TokenStream::new();",
          "    literal_float.to_tokens(&mut tokens_float);",
          "    assert_eq!(tokens_float.to_string(), \"3.14\");",
          "    ",
          "    let literal_bool = Literal::bool(true);",
          "    let mut tokens_bool = TokenStream::new();",
          "    literal_bool.to_tokens(&mut tokens_bool);",
          "    assert_eq!(tokens_bool.to_string(), \"true\");",
          "    ",
          "    let literal_char = Literal::character('a');",
          "    let mut tokens_char = TokenStream::new();",
          "    literal_char.to_tokens(&mut tokens_char);",
          "    assert_eq!(tokens_char.to_string(), \"'a'\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use proc_macro2::Literal;",
          "    use proc_macro2::TokenStream;",
          "",
          "    let small_literal = Literal::u32(1);",
          "    let mut tokens = TokenStream::new();",
          "    small_literal.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    tokens.is_empty() == false",
          "    tokens.to_string() == \"1\"",
          "    tokens.clone().into_iter().count() == 1",
          "    tokens.clone().into_iter().next().unwrap().to_string() == \"1\""
        ],
        "code": [
          "{",
          "    use proc_macro2::Literal;",
          "    use proc_macro2::TokenStream;",
          "",
          "    let small_literal = Literal::u32(1);",
          "    let mut tokens = TokenStream::new();",
          "    small_literal.to_tokens(&mut tokens);",
          "    tokens.is_empty() == false",
          "    tokens.to_string() == \"1\"",
          "    tokens.clone().into_iter().count() == 1",
          "    tokens.clone().into_iter().next().unwrap().to_string() == \"1\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use proc_macro2::Literal;",
          "    use proc_macro2::TokenStream;",
          "",
          "    let large_literal = Literal::u32(u32::MAX);",
          "    let mut tokens = TokenStream::new();",
          "    large_literal.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert!(tokens.clone().to_string().contains(\"4294967295\"));",
          "    assert_eq!(tokens.clone().into_iter().count(), 1);",
          "    assert!(tokens.clone().into_iter().next().is_some());",
          "    assert!(tokens.clone().into_iter().next().unwrap().to_string().contains(\"u32\"));",
          "    assert!(tokens.is_empty() == false);",
          "    assert!(tokens.clone().to_string() == \"4294967295\");",
          "    assert!(tokens.clone().to_string() != \"\");",
          "    assert!(tokens.clone().into_iter().next().unwrap().to_string() == \"4294967295\");"
        ],
        "code": [
          "{",
          "    use proc_macro2::Literal;",
          "    use proc_macro2::TokenStream;",
          "",
          "    let large_literal = Literal::u32(u32::MAX);",
          "    let mut tokens = TokenStream::new();",
          "    large_literal.to_tokens(&mut tokens);",
          "    assert!(tokens.clone().to_string().contains(\"4294967295\"));",
          "    assert_eq!(tokens.clone().into_iter().count(), 1);",
          "    assert!(tokens.clone().into_iter().next().is_some());",
          "    assert!(tokens.clone().into_iter().next().unwrap().to_string().contains(\"u32\"));",
          "    assert!(tokens.is_empty() == false);",
          "    assert!(tokens.clone().to_string() == \"4294967295\");",
          "    assert!(tokens.clone().to_string() != \"\");",
          "    assert!(tokens.clone().into_iter().next().unwrap().to_string() == \"4294967295\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use proc_macro2::Literal;",
          "    use proc_macro2::TokenStream;",
          "",
          "    let zero_literal = Literal::u32(0);",
          "    let mut tokens = TokenStream::new();",
          "    zero_literal.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(tokens.to_string(), \"0\");"
        ],
        "code": [
          "{",
          "    use proc_macro2::Literal;",
          "    use proc_macro2::TokenStream;",
          "",
          "    let zero_literal = Literal::u32(0);",
          "    let mut tokens = TokenStream::new();",
          "    zero_literal.to_tokens(&mut tokens);",
          "    assert_eq!(tokens.to_string(), \"0\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]