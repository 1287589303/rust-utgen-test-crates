[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: f32 = 1.0;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    tokens.to_string() == \"1.0f32\"",
          "    tokens.is_empty() == false",
          "    tokens.clone().to_string() == \"1.0f32\"",
          "    tokens.len() > 0"
        ],
        "code": [
          "{",
          "    let value: f32 = 1.0;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.to_string() == \"1.0f32\"",
          "    tokens.is_empty() == false",
          "    tokens.clone().to_string() == \"1.0f32\"",
          "    tokens.len() > 0",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: f32 = -1.0;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(tokens.to_string(), \"Literal(-1.0f32)\");",
          "    assert!(tokens.is_empty() == false);",
          "    assert!(tokens.clone().into_iter().count() == 1);",
          "    assert!(tokens.clone().next().is_some());",
          "    assert!(tokens.clone().next().unwrap().to_string() == \"Literal(-1.0f32)\");",
          "    assert!(tokens.clone().collect::<Vec<_>>().len() == 1);",
          "    assert!(tokens.clone().to_string().contains(\"-1.0f32\"));",
          "    assert!(tokens.ne(TokenStream::new()));"
        ],
        "code": [
          "{",
          "    let value: f32 = -1.0;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    assert_eq!(tokens.to_string(), \"Literal(-1.0f32)\");",
          "    assert!(tokens.is_empty() == false);",
          "    assert!(tokens.clone().into_iter().count() == 1);",
          "    assert!(tokens.clone().next().is_some());",
          "    assert!(tokens.clone().next().unwrap().to_string() == \"Literal(-1.0f32)\");",
          "    assert!(tokens.clone().collect::<Vec<_>>().len() == 1);",
          "    assert!(tokens.clone().to_string().contains(\"-1.0f32\"));",
          "    assert!(tokens.ne(TokenStream::new()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: f32 = 0.0;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(tokens.to_string(), \"0.0f32\");"
        ],
        "code": [
          "{",
          "    let value: f32 = 0.0;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    assert_eq!(tokens.to_string(), \"0.0f32\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: f32 = 3.40282347e+38;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    tokens.to_string() == \"3.40282347e+38\"",
          "    tokens.is_empty() == false",
          "    tokens.len() > 0"
        ],
        "code": [
          "{",
          "    let value: f32 = 3.40282347e+38;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.to_string() == \"3.40282347e+38\"",
          "    tokens.is_empty() == false",
          "    tokens.len() > 0",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: f32 = -3.40282347e+38;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(tokens.to_string(), \"SomeExpectedOutputForNegativeMaxFloat\");",
          "    assert!(tokens.is_empty() == false);",
          "    assert!(tokens.iter().count() == 1);",
          "    assert!(tokens.clone().into_iter().last().is_some());",
          "    assert!(tokens.clone().into_iter().next().unwrap().is_literal());",
          "    assert!(tokens.clone().into_iter().next().unwrap().to_string() == \"-3.40282347e+38\");"
        ],
        "code": [
          "{",
          "    let value: f32 = -3.40282347e+38;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    assert_eq!(tokens.to_string(), \"SomeExpectedOutputForNegativeMaxFloat\");",
          "    assert!(tokens.is_empty() == false);",
          "    assert!(tokens.iter().count() == 1);",
          "    assert!(tokens.clone().into_iter().last().is_some());",
          "    assert!(tokens.clone().into_iter().next().unwrap().is_literal());",
          "    assert!(tokens.clone().into_iter().next().unwrap().to_string() == \"-3.40282347e+38\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: f32 = std::f32::INFINITY;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    tokens.to_string() == \"infinity\"",
          "    tokens.is_empty() == false",
          "    tokens.count() == 1",
          "    tokens.into_iter().next().unwrap().into_token_stream().to_string() == \"infinity\""
        ],
        "code": [
          "{",
          "    let value: f32 = std::f32::INFINITY;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    tokens.to_string() == \"infinity\"",
          "    tokens.is_empty() == false",
          "    tokens.count() == 1",
          "    tokens.into_iter().next().unwrap().into_token_stream().to_string() == \"infinity\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: f32 = std::f32::NEG_INFINITY;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(tokens.to_string(), \"f32::NEG_INFINITY\");",
          "    assert!(tokens.is_some());",
          "    assert!(tokens.len() > 0);",
          "    assert!(tokens.to_string().contains(\"f32\"));",
          "    assert!(tokens.to_string().contains(\"-\"));",
          "    assert!(tokens.to_string().contains(\"Infinity\"));"
        ],
        "code": [
          "{",
          "    let value: f32 = std::f32::NEG_INFINITY;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    assert_eq!(tokens.to_string(), \"f32::NEG_INFINITY\");",
          "    assert!(tokens.is_some());",
          "    assert!(tokens.len() > 0);",
          "    assert!(tokens.to_string().contains(\"f32\"));",
          "    assert!(tokens.to_string().contains(\"-\"));",
          "    assert!(tokens.to_string().contains(\"Infinity\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: f32 = std::f32::NAN;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "}"
        ],
        "oracle": [
          "    assert!(tokens.to_string().contains(\"NAN\"));",
          "    assert_eq!(tokens.clone().into_iter().count(), 1);",
          "    assert!(tokens.clone().into_iter().next().is_some());"
        ],
        "code": [
          "{",
          "    let value: f32 = std::f32::NAN;",
          "    let mut tokens = TokenStream::new();",
          "    value.to_tokens(&mut tokens);",
          "    assert!(tokens.to_string().contains(\"NAN\"));",
          "    assert_eq!(tokens.clone().into_iter().count(), 1);",
          "    assert!(tokens.clone().into_iter().next().is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]