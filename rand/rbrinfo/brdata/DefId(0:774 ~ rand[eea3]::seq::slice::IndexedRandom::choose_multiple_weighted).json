{
  "name": "rand::seq::slice::IndexedRandom::choose_multiple_weighted",
  "mod_info": {
    "name": "seq::slice",
    "loc": "src/seq/mod.rs:32:1:32:11"
  },
  "visible": true,
  "loc": "src/seq/slice.rs:215:5:239:6",
  "doc": "/// Biased sampling of `amount` distinct elements\n///\n/// Similar to [`choose_multiple`], but where the likelihood of each element's\n/// inclusion in the output may be specified. The elements are returned in an\n/// arbitrary, unspecified order.\n///\n/// The specified function `weight` maps each item `x` to a relative\n/// likelihood `weight(x)`. The probability of each item being selected is\n/// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n///\n/// If all of the weights are equal, even if they are all zero, each element has\n/// an equal likelihood of being selected.\n///\n/// This implementation uses `O(length + amount)` space and `O(length)` time\n/// if the \"nightly\" feature is enabled, or `O(length)` space and\n/// `O(length + amount * log length)` time otherwise.\n///\n/// # Known issues\n///\n/// The algorithm currently used to implement this method loses accuracy\n/// when small values are used for weights.\n/// See [#1476](https://github.com/rust-random/rand/issues/1476).\n///\n/// # Example\n///\n/// ```\n/// use rand::prelude::*;\n///\n/// let choices = [('a', 2), ('b', 1), ('c', 1)];\n/// let mut rng = rand::rng();\n/// // First Draw * Second Draw = total odds\n/// // -----------------------\n/// // (50% * 50%) + (25% * 67%) = 41.7% chance that the output is `['a', 'b']` in some order.\n/// // (50% * 50%) + (25% * 67%) = 41.7% chance that the output is `['a', 'c']` in some order.\n/// // (25% * 33%) + (25% * 33%) = 16.6% chance that the output is `['b', 'c']` in some order.\n/// println!(\"{:?}\", choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).unwrap().collect::<Vec<_>>());\n/// ```\n/// [`choose_multiple`]: IndexedRandom::choose_multiple\n",
  "code": [
    "fn choose_multiple_weighted<R, F, X>(",
    "    &self,",
    "    rng: &mut R,",
    "    amount: usize,",
    "    weight: F,",
    ") -> Result<SliceChooseIter<Self, Self::Output>, WeightError>",
    "where",
    "    Self::Output: Sized,",
    "    R: Rng + ?Sized,",
    "    F: Fn(&Self::Output) -> X,",
    "    X: Into<f64>,",
    "{",
    "    let amount = core::cmp::min(amount, self.len());",
    "    Ok(SliceChooseIter {",
    "        slice: self,",
    "        _phantom: Default::default(),",
    "        indices: index::sample_weighted(",
    "            rng,",
    "            self.len(),",
    "            |idx| weight(&self[idx]).into(),",
    "            amount,",
    "        )?",
    "        .into_iter(),",
    "    })",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "index::sample_weighted(\n                rng,\n                self.len(),\n                |idx| weight(&self[idx]).into(),\n                amount,\n            )?",
          "norm": null,
          "value": "Err/None",
          "line": 231,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        8,
        10,
        11,
        17,
        18
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "index::sample_weighted(\n                rng,\n                self.len(),\n                |idx| weight(&self[idx]).into(),\n                amount,\n            )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 231,
          "bound": null
        }
      ],
      "ret": "Ok(SliceChooseIter {\n            slice: self,\n            _phantom: Default::default(),\n            indices: index::sample_weighted(\n                rng,\n                self.len(),\n                |idx| weight(&self[idx]).into(),\n                amount,\n            )?\n            .into_iter(),\n        })",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        9,
        12,
        13,
        14,
        15,
        16,
        18
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}