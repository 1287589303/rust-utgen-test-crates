{
  "name": "rand_core::impls::fill_via_chunks",
  "mod_info": {
    "name": "impls",
    "loc": "rand_core/src/lib.rs:44:1:44:15"
  },
  "visible": true,
  "loc": "rand_core/src/impls.rs:78:1:101:2",
  "doc": "/// Fill dest from src\n///\n/// Returns `(n, byte_len)`. `src[..n]` is consumed,\n/// `dest[..byte_len]` is filled. `src[n..]` and `dest[byte_len..]` are left\n/// unaltered.\n",
  "code": [
    "pub(crate) fn fill_via_chunks<T: Observable>(src: &[T], dest: &mut [u8]) -> (usize, usize) {",
    "    let size = core::mem::size_of::<T>();",
    "",
    "    // Always use little endian for portability of results.",
    "",
    "    let mut dest = dest.chunks_exact_mut(size);",
    "    let mut src = src.iter();",
    "",
    "    let zipped = dest.by_ref().zip(src.by_ref());",
    "    let num_chunks = zipped.len();",
    "    zipped.for_each(|(dest, src)| dest.copy_from_slice(src.to_le_bytes().as_ref()));",
    "",
    "    let byte_len = num_chunks * size;",
    "    if let Some(src) = src.next() {",
    "        // We have consumed all full chunks of dest, but not src.",
    "        let dest = dest.into_remainder();",
    "        let n = dest.len();",
    "        if n > 0 {",
    "            dest.copy_from_slice(&src.to_le_bytes().as_ref()[..n]);",
    "            return (num_chunks + 1, byte_len + n);",
    "        }",
    "    }",
    "    (num_chunks, byte_len)",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "let Some(src) = src.next()",
          "norm": null,
          "value": "true",
          "line": 91,
          "bound": null
        }
      ],
      "ret": "(num_chunks, byte_len)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        24,
        25,
        26
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "let Some(src) = src.next()",
          "norm": null,
          "value": "true",
          "line": 91,
          "bound": null
        },
        {
          "cond": "n > 0",
          "norm": "0 < n",
          "value": "true",
          "line": 95,
          "bound": null
        }
      ],
      "ret": "(num_chunks + 1, byte_len + n)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        26
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "let Some(src) = src.next()",
          "norm": null,
          "value": "true",
          "line": 91,
          "bound": null
        },
        {
          "cond": "n > 0",
          "norm": "0 < n",
          "value": "false",
          "line": 95,
          "bound": "n == 0"
        }
      ],
      "ret": "(num_chunks, byte_len)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        23,
        25,
        26
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}