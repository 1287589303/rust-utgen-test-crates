{
  "name": "rand::seq::slice::IndexedRandom::choose_weighted",
  "mod_info": {
    "name": "seq::slice",
    "loc": "src/seq/mod.rs:32:1:32:11"
  },
  "visible": true,
  "loc": "src/seq/slice.rs:158:5:172:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))? at line 170 is Err/None\n"
      ],
      "input_infer": "self.len() > 0, weight function returns valid weights (non-negative, within expected range), weights must be properly ordered, sum of weights should not exceed the representable range for type X\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct EmptySlice;",
                "    ",
                "    impl Index<usize> for EmptySlice {",
                "        type Output = ();",
                "        ",
                "        fn index(&self, _: usize) -> &Self::Output {",
                "            panic!(\"Index out of bounds\");",
                "        }",
                "    }",
                "    ",
                "    impl IndexedRandom for EmptySlice {",
                "        fn len(&self) -> usize { 0 }",
                "        ",
                "        #[inline]",
                "        fn is_empty(&self) -> bool { true }",
                "    }",
                "    ",
                "    let mut rng = rand::rng();",
                "    let empty_slice = EmptySlice;",
                "    let result: Result<_, WeightError> = empty_slice.choose_weighted(&mut rng, |&_: &()| 1);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), WeightError::InvalidInput);"
              ],
              "code": [
                "{",
                "    struct EmptySlice;",
                "    ",
                "    impl Index<usize> for EmptySlice {",
                "        type Output = ();",
                "        ",
                "        fn index(&self, _: usize) -> &Self::Output {",
                "            panic!(\"Index out of bounds\");",
                "        }",
                "    }",
                "    ",
                "    impl IndexedRandom for EmptySlice {",
                "        fn len(&self) -> usize { 0 }",
                "        ",
                "        #[inline]",
                "        fn is_empty(&self) -> bool { true }",
                "    }",
                "    ",
                "    let mut rng = rand::rng();",
                "    let empty_slice = EmptySlice;",
                "    let result: Result<_, WeightError> = empty_slice.choose_weighted(&mut rng, |&_: &()| 1);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), WeightError::InvalidInput);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct WeightedSlice {",
                "        elements: Vec<char>,",
                "        weights: Vec<i32>,",
                "    }",
                "",
                "    impl Index<usize> for WeightedSlice {",
                "        type Output = char;",
                "        ",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.elements[index]",
                "        }",
                "    }",
                "    ",
                "    impl IndexedRandom for WeightedSlice {",
                "        fn len(&self) -> usize { self.elements.len() }",
                "        ",
                "        #[inline]",
                "        fn is_empty(&self) -> bool { self.elements.is_empty() }",
                "    }",
                "    ",
                "    let elements = vec!['a', 'b', 'c', 'd'];",
                "    let weights = vec![1, -1, 1, 0]; // Invalid negative weight",
                "    let weighted_slice = WeightedSlice {",
                "        elements,",
                "        weights,",
                "    };",
                "    ",
                "    let mut rng = rand::rng();",
                "    let result: Result<_, WeightError> = weighted_slice.choose_weighted(&mut rng, |&elem| {",
                "        match elem {",
                "            'a' => weights[0],",
                "            'b' => weights[1],",
                "            'c' => weights[2],",
                "            'd' => weights[3],",
                "            _ => 0,",
                "        }",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.is_err(), true);",
                "    assert_eq!(result.unwrap_err(), WeightError::InvalidWeight);"
              ],
              "code": [
                "{",
                "    struct WeightedSlice {",
                "        elements: Vec<char>,",
                "        weights: Vec<i32>,",
                "    }",
                "",
                "    impl Index<usize> for WeightedSlice {",
                "        type Output = char;",
                "        ",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.elements[index]",
                "        }",
                "    }",
                "    ",
                "    impl IndexedRandom for WeightedSlice {",
                "        fn len(&self) -> usize { self.elements.len() }",
                "        ",
                "        #[inline]",
                "        fn is_empty(&self) -> bool { self.elements.is_empty() }",
                "    }",
                "    ",
                "    let elements = vec!['a', 'b', 'c', 'd'];",
                "    let weights = vec![1, -1, 1, 0]; // Invalid negative weight",
                "    let weighted_slice = WeightedSlice {",
                "        elements,",
                "        weights,",
                "    };",
                "    ",
                "    let mut rng = rand::rng();",
                "    let result: Result<_, WeightError> = weighted_slice.choose_weighted(&mut rng, |&elem| {",
                "        match elem {",
                "            'a' => weights[0],",
                "            'b' => weights[1],",
                "            'c' => weights[2],",
                "            'd' => weights[3],",
                "            _ => 0,",
                "        }",
                "    });",
                "    assert_eq!(result.is_err(), true);",
                "    assert_eq!(result.unwrap_err(), WeightError::InvalidWeight);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct OverflowSlice {",
                "        elements: Vec<char>,",
                "    }",
                "",
                "    impl Index<usize> for OverflowSlice {",
                "        type Output = char;",
                "        ",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.elements[index]",
                "        }",
                "    }",
                "",
                "    impl IndexedRandom for OverflowSlice {",
                "        fn len(&self) -> usize { self.elements.len() }",
                "        ",
                "        #[inline]",
                "        fn is_empty(&self) -> bool { self.elements.is_empty() }",
                "    }",
                "",
                "    let elements = vec!['a', 'b', 'c'];",
                "    let weights = vec![i32::MAX, i32::MAX, i32::MAX]; // Weights that will exceed sum limits",
                "    let overflow_slice = OverflowSlice {",
                "        elements,",
                "    };",
                "    ",
                "    let mut rng = rand::rng();",
                "    let result: Result<_, WeightError> = overflow_slice.choose_weighted(&mut rng, |&elem| {",
                "        match elem {",
                "            'a' => weights[0],",
                "            'b' => weights[1],",
                "            'c' => weights[2],",
                "            _ => 0,",
                "        }",
                "    });",
                "}"
              ],
              "oracle": [
                "    let result = overflow_slice.choose_weighted(&mut rng, |&elem| {",
                "    match elem {",
                "    'a' => weights[0],",
                "    'b' => weights[1],",
                "    'c' => weights[2],",
                "    _ => 0,",
                "    }",
                "    });",
                "    assert!(result.is_err(), \"Expected an error due to overflow in weights.\");"
              ],
              "code": [
                "{",
                "    struct OverflowSlice {",
                "        elements: Vec<char>,",
                "    }",
                "",
                "    impl Index<usize> for OverflowSlice {",
                "        type Output = char;",
                "        ",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.elements[index]",
                "        }",
                "    }",
                "",
                "    impl IndexedRandom for OverflowSlice {",
                "        fn len(&self) -> usize { self.elements.len() }",
                "        ",
                "        #[inline]",
                "        fn is_empty(&self) -> bool { self.elements.is_empty() }",
                "    }",
                "",
                "    let elements = vec!['a', 'b', 'c'];",
                "    let weights = vec![i32::MAX, i32::MAX, i32::MAX]; // Weights that will exceed sum limits",
                "    let overflow_slice = OverflowSlice {",
                "        elements,",
                "    };",
                "    ",
                "    let mut rng = rand::rng();",
                "    let result: Result<_, WeightError> = overflow_slice.choose_weighted(&mut rng, |&elem| {",
                "        match elem {",
                "            'a' => weights[0],",
                "            'b' => weights[1],",
                "            'c' => weights[2],",
                "            _ => 0,",
                "        }",
                "    });",
                "    let result = overflow_slice.choose_weighted(&mut rng, |&elem| {",
                "    match elem {",
                "    'a' => weights[0],",
                "    'b' => weights[1],",
                "    'c' => weights[2],",
                "    _ => 0,",
                "    }",
                "    });",
                "    assert!(result.is_err(), \"Expected an error due to overflow in weights.\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NonZeroSlice {",
                "        elements: Vec<char>,",
                "    }",
                "",
                "    impl Index<usize> for NonZeroSlice {",
                "        type Output = char;",
                "        ",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.elements[index]",
                "        }",
                "    }",
                "",
                "    impl IndexedRandom for NonZeroSlice {",
                "        fn len(&self) -> usize { self.elements.len() }",
                "        ",
                "        #[inline]",
                "        fn is_empty(&self) -> bool { self.elements.is_empty() }",
                "    }",
                "",
                "    let elements = vec!['a', 'b', 'c'];",
                "    let weights = vec![0, 0, 0]; // All weights zero",
                "    let non_zero_slice = NonZeroSlice {",
                "        elements,",
                "    };",
                "    ",
                "    let mut rng = rand::rng();",
                "    let result: Result<_, WeightError> = non_zero_slice.choose_weighted(&mut rng, |&elem| {",
                "        match elem {",
                "            'a' => weights[0],",
                "            'b' => weights[1],",
                "            'c' => weights[2],",
                "            _ => 0,",
                "        }",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.is_err(), true);",
                "    assert_eq!(result.unwrap_err(), WeightError::InvalidInput);",
                "    assert_eq!(non_zero_slice.len(), 3);",
                "    assert!(non_zero_slice.is_empty() == false);",
                "    assert!(rng.random_range(..non_zero_slice.len()) >= 0 && rng.random_range(..non_zero_slice.len()) < non_zero_slice.len());"
              ],
              "code": [
                "{",
                "    struct NonZeroSlice {",
                "        elements: Vec<char>,",
                "    }",
                "",
                "    impl Index<usize> for NonZeroSlice {",
                "        type Output = char;",
                "        ",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.elements[index]",
                "        }",
                "    }",
                "",
                "    impl IndexedRandom for NonZeroSlice {",
                "        fn len(&self) -> usize { self.elements.len() }",
                "        ",
                "        #[inline]",
                "        fn is_empty(&self) -> bool { self.elements.is_empty() }",
                "    }",
                "",
                "    let elements = vec!['a', 'b', 'c'];",
                "    let weights = vec![0, 0, 0]; // All weights zero",
                "    let non_zero_slice = NonZeroSlice {",
                "        elements,",
                "    };",
                "    ",
                "    let mut rng = rand::rng();",
                "    let result: Result<_, WeightError> = non_zero_slice.choose_weighted(&mut rng, |&elem| {",
                "        match elem {",
                "            'a' => weights[0],",
                "            'b' => weights[1],",
                "            'c' => weights[2],",
                "            _ => 0,",
                "        }",
                "    });",
                "    assert_eq!(result.is_err(), true);",
                "    assert_eq!(result.unwrap_err(), WeightError::InvalidInput);",
                "    assert_eq!(non_zero_slice.len(), 3);",
                "    assert!(non_zero_slice.is_empty() == false);",
                "    assert!(rng.random_range(..non_zero_slice.len()) >= 0 && rng.random_range(..non_zero_slice.len()) < non_zero_slice.len());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))? at line 170 is Ok/Some\n",
        "expected return value/type: Ok(&self[distr.sample(rng)])\n"
      ],
      "input_infer": "self.len() > 0, all weights obtained from weight function must be non-negative and sum to a positive value, weight function must return valid values for every element in self, rng must be a valid Rng instance\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestData<'a> {",
                "        items: &'a [(char, u32)],",
                "    }",
                "    ",
                "    impl<'a> Index<usize> for TestData<'a> {",
                "        type Output = (char, u32);",
                "        ",
                "        fn index(&self, index: usize) -> &(char, u32) {",
                "            &self.items[index]",
                "        }",
                "    }",
                "    ",
                "    impl<'a> IndexedRandom for TestData<'a> {",
                "        fn len(&self) -> usize {",
                "            self.items.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.items.is_empty()",
                "        }",
                "    }",
                "",
                "    let choices = TestData { items: &[('a', 2), ('b', 1), ('c', 1)] };",
                "    let mut rng = rand::thread_rng();",
                "    ",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    let _ = result.unwrap(); // Ensure it compiles and runs without failure",
                "}"
              ],
              "oracle": [
                "    assert_eq!(choices.len(), 3);",
                "    assert!(!choices.is_empty());",
                "    assert!(choices.choose_weighted(&mut rng, |item| item.1).is_ok());",
                "    assert!(choices.choose_weighted(&mut rng, |item| item.1).unwrap().0 == 'a' ||",
                "    choices.choose_weighted(&mut rng, |item| item.1).unwrap().0 == 'b' ||",
                "    choices.choose_weighted(&mut rng, |item| item.1).unwrap().0 == 'c');",
                "    assert!(choices.choose_weighted(&mut rng, |item| item.1).unwrap_err().is_empty() == false);"
              ],
              "code": [
                "{",
                "    struct TestData<'a> {",
                "        items: &'a [(char, u32)],",
                "    }",
                "    ",
                "    impl<'a> Index<usize> for TestData<'a> {",
                "        type Output = (char, u32);",
                "        ",
                "        fn index(&self, index: usize) -> &(char, u32) {",
                "            &self.items[index]",
                "        }",
                "    }",
                "    ",
                "    impl<'a> IndexedRandom for TestData<'a> {",
                "        fn len(&self) -> usize {",
                "            self.items.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.items.is_empty()",
                "        }",
                "    }",
                "",
                "    let choices = TestData { items: &[('a', 2), ('b', 1), ('c', 1)] };",
                "    let mut rng = rand::thread_rng();",
                "    ",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    let _ = result.unwrap(); // Ensure it compiles and runs without failure",
                "    assert_eq!(choices.len(), 3);",
                "    assert!(!choices.is_empty());",
                "    assert!(choices.choose_weighted(&mut rng, |item| item.1).is_ok());",
                "    assert!(choices.choose_weighted(&mut rng, |item| item.1).unwrap().0 == 'a' ||",
                "    choices.choose_weighted(&mut rng, |item| item.1).unwrap().0 == 'b' ||",
                "    choices.choose_weighted(&mut rng, |item| item.1).unwrap().0 == 'c');",
                "    assert!(choices.choose_weighted(&mut rng, |item| item.1).unwrap_err().is_empty() == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestData<'a> {",
                "        items: &'a [(char, u32)],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestData<'a> {",
                "        type Output = (char, u32);",
                "        ",
                "        fn index(&self, index: usize) -> &(char, u32) {",
                "            &self.items[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestData<'a> {",
                "        fn len(&self) -> usize {",
                "            self.items.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.items.is_empty()",
                "        }",
                "    }",
                "",
                "    let choices = TestData { items: &[] };",
                "    let mut rng = rand::thread_rng();",
                "    ",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    let _ = result.unwrap_err(); // Ensure it compiles and runs without failure",
                "}"
              ],
              "oracle": [
                "    let choices = TestData { items: &[('a', 2), ('b', 1), ('c', 1), ('d', 0)] };",
                "    let mut rng = rand::thread_rng();",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    assert!(result.is_ok());",
                "    let chosen_item = result.unwrap();",
                "    assert!(chosen_item.0 == 'a' || chosen_item.0 == 'b' || chosen_item.0 == 'c');",
                "    assert!(chosen_item.1 >= 0);",
                "    let weights = vec![2, 1, 1, 0];",
                "    let sum_weights: u32 = weights.iter().sum();",
                "    assert!(sum_weights > 0);",
                "    let weight_fn = |item| item.1;",
                "    assert!(WeightedIndex::new((0..choices.len()).map(|idx| weight_fn(&choices[idx]))).is_ok());",
                "    assert!(choices.len() > 0);"
              ],
              "code": [
                "{",
                "    struct TestData<'a> {",
                "        items: &'a [(char, u32)],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestData<'a> {",
                "        type Output = (char, u32);",
                "        ",
                "        fn index(&self, index: usize) -> &(char, u32) {",
                "            &self.items[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestData<'a> {",
                "        fn len(&self) -> usize {",
                "            self.items.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.items.is_empty()",
                "        }",
                "    }",
                "",
                "    let choices = TestData { items: &[] };",
                "    let mut rng = rand::thread_rng();",
                "    ",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    let _ = result.unwrap_err(); // Ensure it compiles and runs without failure",
                "    let choices = TestData { items: &[('a', 2), ('b', 1), ('c', 1), ('d', 0)] };",
                "    let mut rng = rand::thread_rng();",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    assert!(result.is_ok());",
                "    let chosen_item = result.unwrap();",
                "    assert!(chosen_item.0 == 'a' || chosen_item.0 == 'b' || chosen_item.0 == 'c');",
                "    assert!(chosen_item.1 >= 0);",
                "    let weights = vec![2, 1, 1, 0];",
                "    let sum_weights: u32 = weights.iter().sum();",
                "    assert!(sum_weights > 0);",
                "    let weight_fn = |item| item.1;",
                "    assert!(WeightedIndex::new((0..choices.len()).map(|idx| weight_fn(&choices[idx]))).is_ok());",
                "    assert!(choices.len() > 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestData<'a> {",
                "        items: &'a [(char, i32)],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestData<'a> {",
                "        type Output = (char, i32);",
                "",
                "        fn index(&self, index: usize) -> &(char, i32) {",
                "            &self.items[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestData<'a> {",
                "        fn len(&self) -> usize {",
                "            self.items.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.items.is_empty()",
                "        }",
                "    }",
                "",
                "    let choices = TestData { items: &[('a', 0), ('b', 0), ('c', 0)] };",
                "    let mut rng = rand::thread_rng();",
                "    ",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    let _ = result.unwrap_err(); // Ensure it compiles and runs without failure",
                "}"
              ],
              "oracle": [
                "    assert!(choices.len() == 3);",
                "    assert!(choices.is_empty() == false);",
                "    assert!(choices.choose_weighted(&mut rng, |item| item.1).is_err());",
                "    assert!(matches!(result, Err(WeightError::InvalidInput)));"
              ],
              "code": [
                "{",
                "    struct TestData<'a> {",
                "        items: &'a [(char, i32)],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestData<'a> {",
                "        type Output = (char, i32);",
                "",
                "        fn index(&self, index: usize) -> &(char, i32) {",
                "            &self.items[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestData<'a> {",
                "        fn len(&self) -> usize {",
                "            self.items.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.items.is_empty()",
                "        }",
                "    }",
                "",
                "    let choices = TestData { items: &[('a', 0), ('b', 0), ('c', 0)] };",
                "    let mut rng = rand::thread_rng();",
                "    ",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    let _ = result.unwrap_err(); // Ensure it compiles and runs without failure",
                "    assert!(choices.len() == 3);",
                "    assert!(choices.is_empty() == false);",
                "    assert!(choices.choose_weighted(&mut rng, |item| item.1).is_err());",
                "    assert!(matches!(result, Err(WeightError::InvalidInput)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestData<'a> {",
                "        items: &'a [(char, u32)],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestData<'a> {",
                "        type Output = (char, u32);",
                "        ",
                "        fn index(&self, index: usize) -> &(char, u32) {",
                "            &self.items[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestData<'a> {",
                "        fn len(&self) -> usize {",
                "            self.items.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.items.is_empty()",
                "        }",
                "    }",
                "",
                "    let choices = TestData { items: &[('a', 1), ('b', 1), ('c', 1), ('d', 1)] };",
                "    let mut rng = rand::thread_rng();",
                "    ",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    let _ = result.unwrap(); // Ensure it compiles and runs without failure",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.is_ok(), true);",
                "    assert!(result.is_err() == false);",
                "    let distr = WeightedIndex::new((0..choices.len()).map(|idx| choices[idx].1)).unwrap();",
                "    let sample = distr.sample(&mut rng);",
                "    assert!(sample < choices.len());",
                "    assert!(sample >= 0);",
                "    let selected_item = &choices[sample];",
                "    assert!(selected_item.1 > 0);"
              ],
              "code": [
                "{",
                "    struct TestData<'a> {",
                "        items: &'a [(char, u32)],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestData<'a> {",
                "        type Output = (char, u32);",
                "        ",
                "        fn index(&self, index: usize) -> &(char, u32) {",
                "            &self.items[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestData<'a> {",
                "        fn len(&self) -> usize {",
                "            self.items.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.items.is_empty()",
                "        }",
                "    }",
                "",
                "    let choices = TestData { items: &[('a', 1), ('b', 1), ('c', 1), ('d', 1)] };",
                "    let mut rng = rand::thread_rng();",
                "    ",
                "    let result = choices.choose_weighted(&mut rng, |item| item.1);",
                "    let _ = result.unwrap(); // Ensure it compiles and runs without failure",
                "    assert_eq!(result.is_ok(), true);",
                "    assert!(result.is_err() == false);",
                "    let distr = WeightedIndex::new((0..choices.len()).map(|idx| choices[idx].1)).unwrap();",
                "    let sample = distr.sample(&mut rng);",
                "    assert!(sample < choices.len());",
                "    assert!(sample >= 0);",
                "    let selected_item = &choices[sample];",
                "    assert!(selected_item.1 > 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}