{
  "name": "rand::seq::slice::IndexedRandom::choose_multiple",
  "mod_info": {
    "name": "seq::slice",
    "loc": "src/seq/mod.rs:32:1:32:11"
  },
  "visible": true,
  "loc": "src/seq/slice.rs:90:5:101:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: SliceChooseIter {\n            slice: self,\n            _phantom: Default::default(),\n            indices: index::sample(rng, self.len(), amount).into_iter(),\n        }\n"
      ],
      "input_infer": "self.len() > 0, amount >= 1 and amount <= self.len(), rng is a valid Rng instance\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSlice<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestSlice<'a> {",
                "        type Output = u8;",
                "",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.data[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestSlice<'a> {",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.len() == 0",
                "        }",
                "    }",
                "",
                "    let mut rng = &mut rand::rng();",
                "    let sample = TestSlice { data: b\"Hello\" };",
                "    let amount = 3;",
                "    let result = sample.choose_multiple(&mut rng, amount);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.slice.data, sample.data);",
                "    assert!(result._phantom.is_empty());",
                "    assert_eq!(result.indices.len(), 3);",
                "    assert!(result.indices.all(|idx| idx < sample.len()));",
                "    assert!(result.indices.iter().all_unique());",
                "    assert!(result.indices.iter().all(|&idx| sample.get(idx).is_some()));"
              ],
              "code": [
                "{",
                "    struct TestSlice<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestSlice<'a> {",
                "        type Output = u8;",
                "",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.data[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestSlice<'a> {",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "        ",
                "        fn is_empty(&self) -> bool {",
                "            self.len() == 0",
                "        }",
                "    }",
                "",
                "    let mut rng = &mut rand::rng();",
                "    let sample = TestSlice { data: b\"Hello\" };",
                "    let amount = 3;",
                "    let result = sample.choose_multiple(&mut rng, amount);",
                "    assert_eq!(result.slice.data, sample.data);",
                "    assert!(result._phantom.is_empty());",
                "    assert_eq!(result.indices.len(), 3);",
                "    assert!(result.indices.all(|idx| idx < sample.len()));",
                "    assert!(result.indices.iter().all_unique());",
                "    assert!(result.indices.iter().all(|&idx| sample.get(idx).is_some()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSlice<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestSlice<'a> {",
                "        type Output = u8;",
                "",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.data[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestSlice<'a> {",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn is_empty(&self) -> bool {",
                "            self.len() == 0",
                "        }",
                "    }",
                "",
                "    let mut rng = &mut rand::rng();",
                "    let sample = TestSlice { data: b\"World\" };",
                "    let amount = 5; // same as length",
                "    let result = sample.choose_multiple(&mut rng, amount);",
                "}"
              ],
              "oracle": [
                "    result.slice == sample",
                "    result._phantom == Default::default()",
                "    result.indices.len() == amount",
                "    result.indices.all(|index| index < sample.len())",
                "    result.indices.distinct()",
                "    result.indices.iter().count() == amount"
              ],
              "code": [
                "{",
                "    struct TestSlice<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestSlice<'a> {",
                "        type Output = u8;",
                "",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.data[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestSlice<'a> {",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn is_empty(&self) -> bool {",
                "            self.len() == 0",
                "        }",
                "    }",
                "",
                "    let mut rng = &mut rand::rng();",
                "    let sample = TestSlice { data: b\"World\" };",
                "    let amount = 5; // same as length",
                "    let result = sample.choose_multiple(&mut rng, amount);",
                "    result.slice == sample",
                "    result._phantom == Default::default()",
                "    result.indices.len() == amount",
                "    result.indices.all(|index| index < sample.len())",
                "    result.indices.distinct()",
                "    result.indices.iter().count() == amount",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSlice<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestSlice<'a> {",
                "        type Output = u8;",
                "",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.data[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestSlice<'a> {",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn is_empty(&self) -> bool {",
                "            self.len() == 0",
                "        }",
                "    }",
                "",
                "    let mut rng = &mut rand::rng();",
                "    let sample = TestSlice { data: b\"Random\" };",
                "    let amount = 1; // minimum non-zero amount",
                "    let result = sample.choose_multiple(&mut rng, amount);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.slice.data, b\"Random\");",
                "    assert_eq!(result.indices.len(), 1);",
                "    assert!(result.indices.nth(0).is_some());",
                "    assert!(sample.len() >= amount);",
                "    assert!(!sample.is_empty());",
                "    assert!(result._phantom.is_default());",
                "    assert!(result.indices.clone().all(|index| index < sample.len()));"
              ],
              "code": [
                "{",
                "    struct TestSlice<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestSlice<'a> {",
                "        type Output = u8;",
                "",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.data[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestSlice<'a> {",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn is_empty(&self) -> bool {",
                "            self.len() == 0",
                "        }",
                "    }",
                "",
                "    let mut rng = &mut rand::rng();",
                "    let sample = TestSlice { data: b\"Random\" };",
                "    let amount = 1; // minimum non-zero amount",
                "    let result = sample.choose_multiple(&mut rng, amount);",
                "    assert_eq!(result.slice.data, b\"Random\");",
                "    assert_eq!(result.indices.len(), 1);",
                "    assert!(result.indices.nth(0).is_some());",
                "    assert!(sample.len() >= amount);",
                "    assert!(!sample.is_empty());",
                "    assert!(result._phantom.is_default());",
                "    assert!(result.indices.clone().all(|index| index < sample.len()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSlice<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestSlice<'a> {",
                "        type Output = u8;",
                "",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.data[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestSlice<'a> {",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn is_empty(&self) -> bool {",
                "            self.len() == 0",
                "        }",
                "    }",
                "",
                "    let mut rng = &mut rand::rng();",
                "    let sample = TestSlice { data: b\"Boundary\" };",
                "    let amount = 8; // maximum amount (same as length)",
                "    let result = sample.choose_multiple(&mut rng, amount);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.slice.data, b\"Boundary\");",
                "    assert!(result.indices.count() <= 8);",
                "    assert_eq!(result.indices.len(), 8);",
                "    assert!(!result.indices.is_empty());",
                "    assert!(result.indices.all(|index| index < sample.len()));"
              ],
              "code": [
                "{",
                "    struct TestSlice<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'a> Index<usize> for TestSlice<'a> {",
                "        type Output = u8;",
                "",
                "        fn index(&self, index: usize) -> &Self::Output {",
                "            &self.data[index]",
                "        }",
                "    }",
                "",
                "    impl<'a> IndexedRandom for TestSlice<'a> {",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn is_empty(&self) -> bool {",
                "            self.len() == 0",
                "        }",
                "    }",
                "",
                "    let mut rng = &mut rand::rng();",
                "    let sample = TestSlice { data: b\"Boundary\" };",
                "    let amount = 8; // maximum amount (same as length)",
                "    let result = sample.choose_multiple(&mut rng, amount);",
                "    assert_eq!(result.slice.data, b\"Boundary\");",
                "    assert!(result.indices.count() <= 8);",
                "    assert_eq!(result.indices.len(), 8);",
                "    assert!(!result.indices.is_empty());",
                "    assert!(result.indices.all(|index| index < sample.len()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}