{
  "name": "rand_pcg::pcg128::{impl#0}::advance",
  "mod_info": {
    "name": "pcg128",
    "loc": "rand_pcg/src/lib.rs:92:1:92:12"
  },
  "visible": true,
  "loc": "rand_pcg/src/pcg128.rs:60:5:77:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 67 is true\n",
        "precondition: (mdelta & 1) != 0 at line 68 is true\n",
        "precondition: mdelta > 0 at line 67 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "delta is a positive 128-bit integer (1 to 2^128-1) for mdelta > 0, and delta = 0 for mdelta == 0.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_after_advancing_by_1);",
                "    rng.advance(2);",
                "    assert_eq!(rng.state, expected_state_after_advancing_by_2);",
                "    rng.advance(3);",
                "    assert_eq!(rng.state, expected_state_after_advancing_by_3);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, initial_state);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(1);",
                "    assert_eq!(rng.state, expected_state_after_advancing_by_1);",
                "    rng.advance(2);",
                "    assert_eq!(rng.state, expected_state_after_advancing_by_2);",
                "    rng.advance(3);",
                "    assert_eq!(rng.state, expected_state_after_advancing_by_3);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, initial_state);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(1_000_000_000_000_000_000_000_000);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_after_large_delta);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, initial_state);",
                "    rng.advance(1);",
                "    assert!(rng.state > initial_state);",
                "    rng.advance(1);",
                "    assert!(rng.state > previous_state);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(1_000_000_000_000_000_000_000_000);",
                "    assert_eq!(rng.state, expected_state_after_large_delta);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, initial_state);",
                "    rng.advance(1);",
                "    assert!(rng.state > initial_state);",
                "    rng.advance(1);",
                "    assert!(rng.state > previous_state);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(2_000_000_000_000_000_000);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_after_advance_with_large_delta);",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(1); assert!(rng.state > 1);",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(0); assert_eq!(rng.state, 1);",
                "    let mut rng = Lcg128Xsl64::new(1, 0);",
                "    rng.advance(1); assert!(rng.state != 1);",
                "    let mut rng = Lcg128Xsl64::new(0, 1);",
                "    rng.advance(2); assert!(rng.state > 0);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(2_000_000_000_000_000_000);",
                "    assert_eq!(rng.state, expected_state_after_advance_with_large_delta);",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(1); assert!(rng.state > 1);",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(0); assert_eq!(rng.state, 1);",
                "    let mut rng = Lcg128Xsl64::new(1, 0);",
                "    rng.advance(1); assert!(rng.state != 1);",
                "    let mut rng = Lcg128Xsl64::new(0, 1);",
                "    rng.advance(2); assert!(rng.state > 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 1);",
                "    let mut rng = Lcg128Xsl64::new(2, 1);",
                "    rng.advance(1);",
                "    assert_eq!(rng.state, MULTIPLIER.wrapping_add(2));",
                "    let mut rng = Lcg128Xsl64::new(3, 1);",
                "    rng.advance(2);",
                "    assert_eq!(rng.state, MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_add(3)).wrapping_add(1));",
                "    let mut rng = Lcg128Xsl64::new(4, 5);",
                "    rng.advance(4);",
                "    assert_eq!(rng.state, MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_mul(4).wrapping_add(6)).wrapping_add(5)).wrapping_add(5)).wrapping_add(5));",
                "    let mut rng = Lcg128Xsl64::new(u128::MAX, 1);",
                "    rng.advance(u128::MAX);",
                "    assert!(rng.state > 0);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(1, 1);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 1);",
                "    let mut rng = Lcg128Xsl64::new(2, 1);",
                "    rng.advance(1);",
                "    assert_eq!(rng.state, MULTIPLIER.wrapping_add(2));",
                "    let mut rng = Lcg128Xsl64::new(3, 1);",
                "    rng.advance(2);",
                "    assert_eq!(rng.state, MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_add(3)).wrapping_add(1));",
                "    let mut rng = Lcg128Xsl64::new(4, 5);",
                "    rng.advance(4);",
                "    assert_eq!(rng.state, MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_mul(4).wrapping_add(6)).wrapping_add(5)).wrapping_add(5)).wrapping_add(5));",
                "    let mut rng = Lcg128Xsl64::new(u128::MAX, 1);",
                "    rng.advance(u128::MAX);",
                "    assert!(rng.state > 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 67 is true\n",
        "precondition: (mdelta & 1) != 0 at line 68 is false\n",
        "precondition: mdelta > 0 at line 67 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "mdelta = [1, 2, 3, ..., maximum u128 value] with special cases mdelta = 0 and mdelta = 1 for testing boundary conditions; corresponding delta values confirm mdelta's relation to advance functionality.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(2); // mdelta = 2 (even)",
                "}"
              ],
              "oracle": [
                "    let mut rng = Lcg128Xsl64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(2);",
                "    assert_eq!(rng.state, expected_state_for_mdelta_2);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, same_state_as_before);",
                "    rng.advance(1);",
                "    assert_eq!(rng.state, expected_state_for_mdelta_1);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(2); // mdelta = 2 (even)",
                "    let mut rng = Lcg128Xsl64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(2);",
                "    assert_eq!(rng.state, expected_state_for_mdelta_2);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, same_state_as_before);",
                "    rng.advance(1);",
                "    assert_eq!(rng.state, expected_state_for_mdelta_1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(3); // mdelta = 3 (odd)",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_after_advance_3);",
                "    rng.advance(4); // mdelta = 4 (even)",
                "    assert_eq!(rng.state, expected_state_after_advance_4);",
                "    rng.advance(0); // mdelta = 0 (mdelta > 0 is false)",
                "    assert_eq!(rng.state, initial_state);",
                "    rng.advance(1); // mdelta = 1 (odd)",
                "    assert_eq!(rng.state, expected_state_after_advance_1);",
                "    rng.advance(2); // mdelta = 2 (even)",
                "    assert_eq!(rng.state, expected_state_after_advance_2);",
                "    rng.advance(5); // mdelta = 5 (odd)",
                "    assert_eq!(rng.state, expected_state_after_advance_5);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(3); // mdelta = 3 (odd)",
                "    assert_eq!(rng.state, expected_state_after_advance_3);",
                "    rng.advance(4); // mdelta = 4 (even)",
                "    assert_eq!(rng.state, expected_state_after_advance_4);",
                "    rng.advance(0); // mdelta = 0 (mdelta > 0 is false)",
                "    assert_eq!(rng.state, initial_state);",
                "    rng.advance(1); // mdelta = 1 (odd)",
                "    assert_eq!(rng.state, expected_state_after_advance_1);",
                "    rng.advance(2); // mdelta = 2 (even)",
                "    assert_eq!(rng.state, expected_state_after_advance_2);",
                "    rng.advance(5); // mdelta = 5 (odd)",
                "    assert_eq!(rng.state, expected_state_after_advance_5);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(0); // mdelta = 0",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 12345678901234567890);  // Check state remains unchanged when delta = 0",
                "    rng.advance(1); // mdelta > 0; should update state",
                "    assert!(rng.state != 12345678901234567890);  // Ensure state has changed from initial value after advance(1)",
                "    rng.advance(2); // Test with delta for mdelta > 0 and (mdelta & 1) != 0",
                "    assert!(rng.state != 0);  // Ensure state updates correctly with larger delta",
                "    rng.advance(1); // mdelta > 0; should update state again",
                "    assert!(rng.state != 0);  // Ensure state has changed from prior value after advance(1) again",
                "    rng.advance(u128::MAX); // Test with maximum delta value",
                "    assert!(rng.state != u128::MAX);  // Ensure state updates correctly with maximum delta value",
                "    _rng.advance(u128::MAX / 2); // Test with half of max delta",
                "    assert!(rng.state != u128::MAX / 2);  // Check state updates correctly with a large delta input"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(0); // mdelta = 0",
                "    assert_eq!(rng.state, 12345678901234567890);  // Check state remains unchanged when delta = 0",
                "    rng.advance(1); // mdelta > 0; should update state",
                "    assert!(rng.state != 12345678901234567890);  // Ensure state has changed from initial value after advance(1)",
                "    rng.advance(2); // Test with delta for mdelta > 0 and (mdelta & 1) != 0",
                "    assert!(rng.state != 0);  // Ensure state updates correctly with larger delta",
                "    rng.advance(1); // mdelta > 0; should update state again",
                "    assert!(rng.state != 0);  // Ensure state has changed from prior value after advance(1) again",
                "    rng.advance(u128::MAX); // Test with maximum delta value",
                "    assert!(rng.state != u128::MAX);  // Ensure state updates correctly with maximum delta value",
                "    _rng.advance(u128::MAX / 2); // Test with half of max delta",
                "    assert!(rng.state != u128::MAX / 2);  // Check state updates correctly with a large delta input",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 67 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "delta = 0, state = any u128, increment = any u128\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345, 67890);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 12345);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345, 67890);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 12345);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(0, 67890);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 1);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(0, 67890);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 1);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(u128::MAX, 67890);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, u128::MAX.wrapping_add(67931); // Initial state incremented by 67890 + 1",
                "    assert!(rng.state <= u128::MAX); // Ensure state does not exceed u128 max",
                "    assert_eq!(rng.increment, 135780); // Check if increment is correctly set",
                "    assert_eq!(rng.state, 0); // Check state must remain unchanged when delta is zero"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(u128::MAX, 67890);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, u128::MAX.wrapping_add(67931); // Initial state incremented by 67890 + 1",
                "    assert!(rng.state <= u128::MAX); // Ensure state does not exceed u128 max",
                "    assert_eq!(rng.increment, 135780); // Check if increment is correctly set",
                "    assert_eq!(rng.state, 0); // Check state must remain unchanged when delta is zero",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345, 0);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 12345);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345, 0);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 12345);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345, u128::MAX);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 12345);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128Xsl64::new(12345, u128::MAX);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 12345);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}