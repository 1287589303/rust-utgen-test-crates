{
  "name": "rand_core::le::read_u32_into",
  "mod_info": {
    "name": "le",
    "loc": "rand_core/src/lib.rs:45:1:45:12"
  },
  "visible": true,
  "loc": "rand_core/src/le.rs:21:1:26:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: src.len() >= 4 * dst.len() at line 22 is true, with bound src.len() == 4 * dst.len()\n",
        "precondition: (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) at line 23 is true\n",
        "precondition: (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) at line 23 is false\n"
      ],
      "input_infer": "src.len() = 4 * dst.len(), src.len() = 4 * dst.len() + 1, dst.len() = 0, dst.len() = 1, src.len() = 4, src.len() = 5\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[should_panic]",
            "fn test_read_u32_into_insufficient_src_length() {",
            "    let src: &[u8] = &[1, 0, 0, 0];",
            "    let mut dst: &mut [u32] = &mut [0; 1];",
            "    read_u32_into(src, dst);",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    read_u32_into(src, dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dst, &[1, 2]);",
                "    assert!(src.len() >= 4 * dst.len());",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let dst: &mut [u32] = &mut [0; 2];",
                "    assert_eq!(dst.len(), 2);",
                "    let src: &[u8] = &[0; 0];",
                "    let dst: &mut [u32] = &mut [];",
                "    assert_eq!(dst.len(), 0);",
                "    assert!(src.len() >= 4 * dst.len());",
                "    let src: &[u8] = &[1, 0, 0, 0];",
                "    let dst: &mut [u32] = &mut [0; 1];",
                "    assert!(dst.len() > 0);",
                "    assert_eq!(dst[0], 1);"
              ],
              "code": [
                "{",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst, &[1, 2]);",
                "    assert!(src.len() >= 4 * dst.len());",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let dst: &mut [u32] = &mut [0; 2];",
                "    assert_eq!(dst.len(), 2);",
                "    let src: &[u8] = &[0; 0];",
                "    let dst: &mut [u32] = &mut [];",
                "    assert_eq!(dst.len(), 0);",
                "    assert!(src.len() >= 4 * dst.len());",
                "    let src: &[u8] = &[1, 0, 0, 0];",
                "    let dst: &mut [u32] = &mut [0; 1];",
                "    assert!(dst.len() > 0);",
                "    assert_eq!(dst[0], 1);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    read_u32_into(src, dst);",
                "}"
              ],
              "oracle": [
                "    assert!(src.len() >= 4 * dst.len());",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3];",
                "    let dst: &mut [u32] = &mut [0; 2];",
                "    assert_eq!(dst.len(), 2);",
                "    assert!(dst.iter().all(|&x| x == 0));",
                "    let src: &[u8] = &[1, 0, 0, 0];",
                "    let dst: &mut [u32] = &mut [0; 1];",
                "    assert!(src.len() < 4 * dst.len());",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    assert!(src.chunks_exact(4).len() >= dst.len());"
              ],
              "code": [
                "{",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    read_u32_into(src, dst);",
                "    assert!(src.len() >= 4 * dst.len());",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3];",
                "    let dst: &mut [u32] = &mut [0; 2];",
                "    assert_eq!(dst.len(), 2);",
                "    assert!(dst.iter().all(|&x| x == 0));",
                "    let src: &[u8] = &[1, 0, 0, 0];",
                "    let dst: &mut [u32] = &mut [0; 1];",
                "    assert!(src.len() < 4 * dst.len());",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    assert!(src.chunks_exact(4).len() >= dst.len());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src: &[u8] = &[];",
                "    let mut dst: &mut [u32] = &mut [];",
                "    read_u32_into(src, dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dst.len(), src.len() / 4);",
                "    let src: &[u8] = &[1, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 1];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst[0], 1);",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    let src: &[u8] = &[1, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 1];",
                "    #[should_panic]",
                "    read_u32_into(src, dst);",
                "    let src: &[u8] = &[1, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [];",
                "    read_u32_into(src, dst);",
                "    assert!(dst.is_empty());",
                "    let src: &[u8] = &[0; 8];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst[0], 0);",
                "    assert_eq!(dst[1], 0);",
                "    let src: &[u8] = &[255, 255, 255, 255];",
                "    let mut dst: &mut [u32] = &mut [0; 1];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst[0], 4294967295);"
              ],
              "code": [
                "{",
                "    let src: &[u8] = &[];",
                "    let mut dst: &mut [u32] = &mut [];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst.len(), src.len() / 4);",
                "    let src: &[u8] = &[1, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 1];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst[0], 1);",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    let src: &[u8] = &[1, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [0; 1];",
                "    #[should_panic]",
                "    read_u32_into(src, dst);",
                "    let src: &[u8] = &[1, 0, 0, 0];",
                "    let mut dst: &mut [u32] = &mut [];",
                "    read_u32_into(src, dst);",
                "    assert!(dst.is_empty());",
                "    let src: &[u8] = &[0; 8];",
                "    let mut dst: &mut [u32] = &mut [0; 2];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst[0], 0);",
                "    assert_eq!(dst[1], 0);",
                "    let src: &[u8] = &[255, 255, 255, 255];",
                "    let mut dst: &mut [u32] = &mut [0; 1];",
                "    read_u32_into(src, dst);",
                "    assert_eq!(dst[0], 4294967295);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: src.len() >= 4 * dst.len() at line 22 is true, with bound src.len() == 4 * dst.len()\n",
        "precondition: (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) at line 23 is false\n"
      ],
      "input_infer": "src: array of u8 with length equal to 4 * dst.length; dst: array of u32 with length of at least 1 and less than or equal to (src.len() / 4) for boundary case testing\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src: [u8; 4] = [1, 0, 0, 0]; // 4 * 1",
                "    let mut dst: [u32; 1] = [0];",
                "    read_u32_into(&src, &mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dst[0], 1);",
                "    assert!(src.len() >= 4 * dst.len());",
                "    let src: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
                "    let mut dst: [u32; 2] = [0; 2];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    let src: [u8; 0] = [];",
                "    let mut dst: [u32; 0] = [];",
                "    read_u32_into(&src, &mut dst);",
                "    let src: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // 4 * 4",
                "    let mut dst: [u32; 4] = [0; 4];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    assert_eq!(dst[2], 3);",
                "    assert_eq!(dst[3], 4);",
                "    let src: [u8; 6] = [1, 0, 0, 0, 2, 0];",
                "    let mut dst: [u32; 2] = [0; 2];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);"
              ],
              "code": [
                "{",
                "    let src: [u8; 4] = [1, 0, 0, 0]; // 4 * 1",
                "    let mut dst: [u32; 1] = [0];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert!(src.len() >= 4 * dst.len());",
                "    let src: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
                "    let mut dst: [u32; 2] = [0; 2];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    let src: [u8; 0] = [];",
                "    let mut dst: [u32; 0] = [];",
                "    read_u32_into(&src, &mut dst);",
                "    let src: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // 4 * 4",
                "    let mut dst: [u32; 4] = [0; 4];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    assert_eq!(dst[2], 3);",
                "    assert_eq!(dst[3], 4);",
                "    let src: [u8; 6] = [1, 0, 0, 0, 2, 0];",
                "    let mut dst: [u32; 2] = [0; 2];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let src: [u8; 4] = [1, 0, 0, 0]; // src.len() == 4, dst.len() == 0",
                "    let mut dst: [u32; 0] = [];",
                "    read_u32_into(&src, &mut dst);",
                "}"
              ],
              "oracle": [
                "    assert!(std::panic::catch_unwind(|| read_u32_into(&src, &mut dst)).is_err());",
                "    let src: [u8; 4] = [1, 0, 0, 0];",
                "    let mut dst: [u32; 0] = [];",
                "    assert!(dst.len() == 0);",
                "    assert!(src.len() == 4);",
                "    assert!(src.len() >= 4 * dst.len());"
              ],
              "code": [
                "{",
                "    let src: [u8; 4] = [1, 0, 0, 0]; // src.len() == 4, dst.len() == 0",
                "    let mut dst: [u32; 0] = [];",
                "    read_u32_into(&src, &mut dst);",
                "    assert!(std::panic::catch_unwind(|| read_u32_into(&src, &mut dst)).is_err());",
                "    let src: [u8; 4] = [1, 0, 0, 0];",
                "    let mut dst: [u32; 0] = [];",
                "    assert!(dst.len() == 0);",
                "    assert!(src.len() == 4);",
                "    assert!(src.len() >= 4 * dst.len());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
                "    let mut dst: [u32; 2] = [0, 0];",
                "    read_u32_into(&src, &mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    assert!(std::panic::catch_unwind(|| read_u32_into(&src, &mut [0u32; 1])).is_err());",
                "    assert!(std::panic::catch_unwind(|| read_u32_into(&src[0..6], &mut dst)).is_err());"
              ],
              "code": [
                "{",
                "    let src: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
                "    let mut dst: [u32; 2] = [0, 0];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst[0], 1);",
                "    assert_eq!(dst[1], 2);",
                "    assert!(std::panic::catch_unwind(|| read_u32_into(&src, &mut [0u32; 1])).is_err());",
                "    assert!(std::panic::catch_unwind(|| read_u32_into(&src[0..6], &mut dst)).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src: [u8; 12] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]; // 4 * 3",
                "    let mut dst: [u32; 3] = [0, 0, 0];",
                "    read_u32_into(&src, &mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dst, [1, 2, 3]);",
                "    let src_empty: [u8; 0] = [];",
                "    let mut dst_empty: [u32; 0] = [];",
                "    read_u32_into(&src_empty, &mut dst_empty);",
                "    let src_short: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
                "    let mut dst_short: [u32; 2] = [0, 0];",
                "    read_u32_into(&src_short, &mut dst_short);",
                "    assert_eq!(dst_short, [1, 2]);",
                "    let src_single: [u8; 4] = [3, 0, 0, 0]; // 4 * 1",
                "    let mut dst_single: [u32; 1] = [0];",
                "    read_u32_into(&src_single, &mut dst_single);",
                "    assert_eq!(dst_single, [3]);",
                "    let src_small: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // 4 * 4",
                "    let mut dst_large: [u32; 4] = [0, 0, 0, 0];",
                "    read_u32_into(&src_small, &mut dst_large);",
                "    assert_eq!(dst_large, [1, 2, 3, 4]);"
              ],
              "code": [
                "{",
                "    let src: [u8; 12] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]; // 4 * 3",
                "    let mut dst: [u32; 3] = [0, 0, 0];",
                "    read_u32_into(&src, &mut dst);",
                "    assert_eq!(dst, [1, 2, 3]);",
                "    let src_empty: [u8; 0] = [];",
                "    let mut dst_empty: [u32; 0] = [];",
                "    read_u32_into(&src_empty, &mut dst_empty);",
                "    let src_short: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
                "    let mut dst_short: [u32; 2] = [0, 0];",
                "    read_u32_into(&src_short, &mut dst_short);",
                "    assert_eq!(dst_short, [1, 2]);",
                "    let src_single: [u8; 4] = [3, 0, 0, 0]; // 4 * 1",
                "    let mut dst_single: [u32; 1] = [0];",
                "    read_u32_into(&src_single, &mut dst_single);",
                "    assert_eq!(dst_single, [3]);",
                "    let src_small: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // 4 * 4",
                "    let mut dst_large: [u32; 4] = [0, 0, 0, 0];",
                "    read_u32_into(&src_small, &mut dst_large);",
                "    assert_eq!(dst_large, [1, 2, 3, 4]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let src: [u8; 4] = [1, 0, 0, 0]; // src.len() < 4 * dst.len()",
                "    let mut dst: [u32; 2] = [0, 0]; // 4 * 2 = 8; src.len() is 4",
                "    read_u32_into(&src, &mut dst);",
                "}"
              ],
              "oracle": [
                "    assert!(std::panic::catch_unwind(|| {",
                "    let src: [u8; 4] = [1, 0, 0, 0];",
                "    let mut dst: [u32; 2] = [0, 0];",
                "    read_u32_into(&src, &mut dst);",
                "    }).is_err());"
              ],
              "code": [
                "{",
                "    let src: [u8; 4] = [1, 0, 0, 0]; // src.len() < 4 * dst.len()",
                "    let mut dst: [u32; 2] = [0, 0]; // 4 * 2 = 8; src.len() is 4",
                "    read_u32_into(&src, &mut dst);",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let src: [u8; 4] = [1, 0, 0, 0];",
                "    let mut dst: [u32; 2] = [0, 0];",
                "    read_u32_into(&src, &mut dst);",
                "    }).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: src.len() >= 4 * dst.len() at line 22 is false\n"
      ],
      "input_infer": "src.len() < 4 * dst.len() (e.g., src.len() = 0, dst.len() > 0 or src.len() = 3, dst.len() = 1 or src.len() = 5, dst.len() = 2)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let src: &[u8] = &[];",
                "    let mut dst = vec![0u32; 1];",
                "    read_u32_into(src, &mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dst, vec![0u32; 1]);",
                "    assert!(std::panic::catch_unwind(|| read_u32_into(src, &mut dst)).is_err());"
              ],
              "code": [
                "{",
                "    let src: &[u8] = &[];",
                "    let mut dst = vec![0u32; 1];",
                "    read_u32_into(src, &mut dst);",
                "    assert_eq!(dst, vec![0u32; 1]);",
                "    assert!(std::panic::catch_unwind(|| read_u32_into(src, &mut dst)).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let src: &[u8] = &[1, 2, 3];",
                "    let mut dst = vec![0u32; 1];",
                "    read_u32_into(src, &mut dst);",
                "}"
              ],
              "oracle": [
                "    assertion_failed!(src.len() >= 4 * dst.len());",
                "    ",
                "    let src: &[u8] = &[1, 2, 3];",
                "    let mut dst = vec![0u32; 1];",
                "    read_u32_into(src, &mut dst);  // should panic"
              ],
              "code": [
                "{",
                "    let src: &[u8] = &[1, 2, 3];",
                "    let mut dst = vec![0u32; 1];",
                "    read_u32_into(src, &mut dst);",
                "    assertion_failed!(src.len() >= 4 * dst.len());",
                "    ",
                "    let src: &[u8] = &[1, 2, 3];",
                "    let mut dst = vec![0u32; 1];",
                "    read_u32_into(src, &mut dst);  // should panic",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let src: &[u8] = &[1, 2, 3, 4, 5];",
                "    let mut dst = vec![0u32; 2];",
                "    read_u32_into(src, &mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(src.len() >= 4 * dst.len(), false);",
                "    let src: &[u8] = &[1, 2, 3, 4, 5];",
                "    let mut dst = vec![0u32; 2];",
                "    read_u32_into(src, &mut dst);"
              ],
              "code": [
                "{",
                "    let src: &[u8] = &[1, 2, 3, 4, 5];",
                "    let mut dst = vec![0u32; 2];",
                "    read_u32_into(src, &mut dst);",
                "    assert_eq!(src.len() >= 4 * dst.len(), false);",
                "    let src: &[u8] = &[1, 2, 3, 4, 5];",
                "    let mut dst = vec![0u32; 2];",
                "    read_u32_into(src, &mut dst);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}