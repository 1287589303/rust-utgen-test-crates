{
  "name": "rand_pcg::pcg64::{impl#2}::from_seed",
  "mod_info": {
    "name": "pcg64",
    "loc": "rand_pcg/src/lib.rs:94:1:94:11"
  },
  "visible": true,
  "loc": "rand_pcg/src/pcg64.rs:129:5:135:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Seed input must be a 16-byte array where the last byte's least significant bit is ignored and the second 64-bit integer must be odd; valid values include all combinations for the first 8 bytes while the last 8 bytes must be in the range (0 to 2^64-1) with an odd least significant bit.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let seed: [u8; 16] = [0; 16];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment % 2, 1);",
                "    assert_eq!(rng.increment, 1);",
                "    assert_ne!(rng.state, 0);",
                "    assert_eq!(rng.state, Lcg64Xsh32::from_state_incr(0, 1).state);",
                "    assert_eq!(rng.increment, Lcg64Xsh32::from_state_incr(0, 1).increment);"
              ],
              "code": [
                "{",
                "    let seed: [u8; 16] = [0; 16];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment % 2, 1);",
                "    assert_eq!(rng.increment, 1);",
                "    assert_ne!(rng.state, 0);",
                "    assert_eq!(rng.state, Lcg64Xsh32::from_state_incr(0, 1).state);",
                "    assert_eq!(rng.increment, Lcg64Xsh32::from_state_incr(0, 1).increment);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let seed: [u8; 16] = [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 1]; // last byte has a bit ignored",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_value); // Replace with expected state after initialization",
                "    assert_eq!(rng.increment & 1, 1); // Verify that increment is odd",
                "    assert_eq!(rng.increment, expected_increment_value); // Replace with expected increment based on seed",
                "    assert_eq!(seed_u64[0], expected_seed_u64_0); // Validate seed conversion to u64[0]",
                "    assert_eq!(seed_u64[1] & !1, expected_seed_u64_1); // Validate seed conversion for u64[1] with lowest bit ignored"
              ],
              "code": [
                "{",
                "    let seed: [u8; 16] = [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 1]; // last byte has a bit ignored",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, expected_state_value); // Replace with expected state after initialization",
                "    assert_eq!(rng.increment & 1, 1); // Verify that increment is odd",
                "    assert_eq!(rng.increment, expected_increment_value); // Replace with expected increment based on seed",
                "    assert_eq!(seed_u64[0], expected_seed_u64_0); // Validate seed conversion to u64[0]",
                "    assert_eq!(seed_u64[1] & !1, expected_seed_u64_1); // Validate seed conversion for u64[1] with lowest bit ignored",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let seed: [u8; 16] = [255; 15].iter().cloned().chain(Some(1)).collect::<Vec<u8>>().try_into().unwrap(); // LSB in the last byte is ignored, thus 255...255,1",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "}"
              ],
              "oracle": [
                "    let seed: [u8; 16] = [255; 15].iter().cloned().chain(Some(1)).collect::<Vec<u8>>().try_into().unwrap();",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, expected_state_value);",
                "    assert_eq!(rng.increment, expected_increment_value);"
              ],
              "code": [
                "{",
                "    let seed: [u8; 16] = [255; 15].iter().cloned().chain(Some(1)).collect::<Vec<u8>>().try_into().unwrap(); // LSB in the last byte is ignored, thus 255...255,1",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    let seed: [u8; 16] = [255; 15].iter().cloned().chain(Some(1)).collect::<Vec<u8>>().try_into().unwrap();",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, expected_state_value);",
                "    assert_eq!(rng.increment, expected_increment_value);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let seed: [u8; 16] = [",
                "        0, 0, 0, 0, 0, 0, 0, 0, ",
                "        255, 255, 255, 255, 255, 255, 255, 255 // last byte is odd",
                "    ];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "}"
              ],
              "oracle": [
                "    let seed: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment, 255);",
                "    let seed: [u8; 16] = [1, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 2);",
                "    assert_eq!(rng.increment, 255);",
                "    let seed: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment, 0);",
                "    let seed: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment, 3);",
                "    let seed: [u8; 16] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment, 3);"
              ],
              "code": [
                "{",
                "    let seed: [u8; 16] = [",
                "        0, 0, 0, 0, 0, 0, 0, 0, ",
                "        255, 255, 255, 255, 255, 255, 255, 255 // last byte is odd",
                "    ];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    let seed: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment, 255);",
                "    let seed: [u8; 16] = [1, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 2);",
                "    assert_eq!(rng.increment, 255);",
                "    let seed: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment, 0);",
                "    let seed: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment, 3);",
                "    let seed: [u8; 16] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(rng.state, 1);",
                "    assert_eq!(rng.increment, 3);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let seed: [u8; 16] = [",
                "        42, 42, 42, 42, 42, 42, 42, 42,",
                "        0, 0, 0, 0, 0, 0, 0, 3 // odd number",
                "    ];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "}"
              ],
              "oracle": [
                "    let expected_state = Lcg64Xsh32::from_state_incr(0x0000000000000000, 0x0000000000000003);",
                "    assert_eq!(rng.state, expected_state.state);",
                "    assert_eq!(rng.increment, expected_state.increment);"
              ],
              "code": [
                "{",
                "    let seed: [u8; 16] = [",
                "        42, 42, 42, 42, 42, 42, 42, 42,",
                "        0, 0, 0, 0, 0, 0, 0, 3 // odd number",
                "    ];",
                "    let rng = Lcg64Xsh32::from_seed(seed);",
                "    let expected_state = Lcg64Xsh32::from_state_incr(0x0000000000000000, 0x0000000000000003);",
                "    assert_eq!(rng.state, expected_state.state);",
                "    assert_eq!(rng.increment, expected_state.increment);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let seed: [u8; 16] = [1; 8].iter().cloned().chain(Some(0)).collect::<Vec<u8>>().try_into().unwrap(); // last byte is 0, so LSB is not odd",
                "    let _rng = Lcg64Xsh32::from_seed(seed);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([1; 16])).is_err(), true);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([0; 16])).is_err(), true);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([1; 8].iter().cloned().chain(Some(0)).collect::<Vec<u8>>().try_into().unwrap())).is_err(), true);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([3; 16])).is_err(), false);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([2; 16])).is_err(), true);"
              ],
              "code": [
                "{",
                "    let seed: [u8; 16] = [1; 8].iter().cloned().chain(Some(0)).collect::<Vec<u8>>().try_into().unwrap(); // last byte is 0, so LSB is not odd",
                "    let _rng = Lcg64Xsh32::from_seed(seed);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([1; 16])).is_err(), true);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([0; 16])).is_err(), true);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([1; 8].iter().cloned().chain(Some(0)).collect::<Vec<u8>>().try_into().unwrap())).is_err(), true);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([3; 16])).is_err(), false);",
                "    assert_eq!(std::panic::catch_unwind(|| Lcg64Xsh32::from_seed([2; 16])).is_err(), true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}