{
  "name": "rand_pcg::pcg128cm::{impl#0}::advance",
  "mod_info": {
    "name": "pcg128cm",
    "loc": "rand_pcg/src/lib.rs:93:1:93:14"
  },
  "visible": true,
  "loc": "rand_pcg/src/pcg128cm.rs:63:5:80:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 70 is true\n",
        "precondition: (mdelta & 1) != 0 at line 71 is true\n",
        "precondition: mdelta > 0 at line 70 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "delta: 1 to maximum valid u128; delta: 0 (for boundary cases)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 1);",
                "    rng.advance(1); // delta = 1, odd",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_after_advance_with_delta_1);",
                "    rng.advance(2); // delta = 2, even",
                "    assert_eq!(rng.state, expected_state_after_advance_with_delta_2);",
                "    rng.advance(3); // delta = 3, odd",
                "    assert_eq!(rng.state, expected_state_after_advance_with_delta_3);",
                "    rng.advance(0); // delta = 0, mdelta > 0 condition is false",
                "    assert_eq!(rng.state, expected_state_after_advance_with_delta_0);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 1);",
                "    rng.advance(1); // delta = 1, odd",
                "    assert_eq!(rng.state, expected_state_after_advance_with_delta_1);",
                "    rng.advance(2); // delta = 2, even",
                "    assert_eq!(rng.state, expected_state_after_advance_with_delta_2);",
                "    rng.advance(3); // delta = 3, odd",
                "    assert_eq!(rng.state, expected_state_after_advance_with_delta_3);",
                "    rng.advance(0); // delta = 0, mdelta > 0 condition is false",
                "    assert_eq!(rng.state, expected_state_after_advance_with_delta_0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(2, 2);",
                "    rng.advance(2); // delta = 2, even",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_after_advance_with_positive_delta); // Check state after advancing with positive delta",
                "    assert_eq!(rng.increment, expected_increment); // Verify that increment remains unchanged",
                "    assert_eq!(rng.state, initial_state + MULTIPLIER * initial_state + increment); // Verify RV post-advance for delta > 0",
                "    rng.advance(0); // delta = 0, should not change state",
                "    assert_eq!(rng.state, unchanged_state); // Ensure state remains the same after advancing with delta = 0"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(2, 2);",
                "    rng.advance(2); // delta = 2, even",
                "    assert_eq!(rng.state, expected_state_after_advance_with_positive_delta); // Check state after advancing with positive delta",
                "    assert_eq!(rng.increment, expected_increment); // Verify that increment remains unchanged",
                "    assert_eq!(rng.state, initial_state + MULTIPLIER * initial_state + increment); // Verify RV post-advance for delta > 0",
                "    rng.advance(0); // delta = 0, should not change state",
                "    assert_eq!(rng.state, unchanged_state); // Ensure state remains the same after advancing with delta = 0",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(u128::MAX - 1, 3);",
                "    rng.advance(u128::MAX); // delta = maximum valid u128",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_after_max_delta);",
                "    rng.advance(1);",
                "    assert_eq!(rng.state, expected_state_after_increment);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, rng.state);",
                "    rng.advance(2);",
                "    assert_eq!(rng.state, expected_state_after_delta_2);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(u128::MAX - 1, 3);",
                "    rng.advance(u128::MAX); // delta = maximum valid u128",
                "    assert_eq!(rng.state, expected_state_after_max_delta);",
                "    rng.advance(1);",
                "    assert_eq!(rng.state, expected_state_after_increment);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, rng.state);",
                "    rng.advance(2);",
                "    assert_eq!(rng.state, expected_state_after_delta_2);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, 4);",
                "    rng.advance(0); // boundary case, delta = 0",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 0); // ensure state remains unchanged for delta = 0",
                "    rng.advance(1); // test with delta = 1",
                "    assert!(rng.state > 0); // ensure state changes for delta = 1",
                "    assert_eq!(rng.increment, 9); // verify increment is correct after new instance with stream 4",
                "    rng.advance(u128::MAX); // test with maximum delta",
                "    assert!(rng.state > 0); // ensure state changes for maximum delta",
                "    rng.advance(2); // test with delta that only alters the state",
                "    assert!(rng.state > 0); // ensure state changes for delta = 2"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, 4);",
                "    rng.advance(0); // boundary case, delta = 0",
                "    assert_eq!(rng.state, 0); // ensure state remains unchanged for delta = 0",
                "    rng.advance(1); // test with delta = 1",
                "    assert!(rng.state > 0); // ensure state changes for delta = 1",
                "    assert_eq!(rng.increment, 9); // verify increment is correct after new instance with stream 4",
                "    rng.advance(u128::MAX); // test with maximum delta",
                "    assert!(rng.state > 0); // ensure state changes for maximum delta",
                "    rng.advance(2); // test with delta that only alters the state",
                "    assert!(rng.state > 0); // ensure state changes for delta = 2",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 70 is true\n",
        "precondition: (mdelta & 1) != 0 at line 71 is false\n",
        "precondition: mdelta > 0 at line 70 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "delta: u128 in the range [1, u128::MAX] for mdelta > 0; delta: u128 = 0 for mdelta == 0;\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    rng.advance(2); // delta is 2, mdelta will be greater than 0 and condition (mdelta & 1) != 0 will be false.",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_when_mdelta_greater_than_0_and_condition_false);",
                "    rng.advance(0); assert_eq!(rng.state, 1);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    rng.advance(2); // delta is 2, mdelta will be greater than 0 and condition (mdelta & 1) != 0 will be false.",
                "    assert_eq!(rng.state, expected_state_when_mdelta_greater_than_0_and_condition_false);",
                "    rng.advance(0); assert_eq!(rng.state, 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    rng.advance(0); // delta is 0, mdelta will be equal to 0.",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 1); // Ensure state remains unchanged when delta is 0.",
                "    rng.advance(1); // Test mdelta > 0, (mdelta & 1) != 0 will be true.",
                "    assert!(rng.state > 1); // Ensure state changes after advancing with delta 1.",
                "    rng.advance(2); // Test mdelta > 0, (mdelta & 1) != 0 will be false.",
                "    assert!(rng.state > 1); // Ensure state changes after doubling delta to 2."
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    rng.advance(0); // delta is 0, mdelta will be equal to 0.",
                "    assert_eq!(rng.state, 1); // Ensure state remains unchanged when delta is 0.",
                "    rng.advance(1); // Test mdelta > 0, (mdelta & 1) != 0 will be true.",
                "    assert!(rng.state > 1); // Ensure state changes after advancing with delta 1.",
                "    rng.advance(2); // Test mdelta > 0, (mdelta & 1) != 0 will be false.",
                "    assert!(rng.state > 1); // Ensure state changes after doubling delta to 2.",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    rng.advance(1); // delta is 1, mdelta will be greater than 0 and condition (mdelta & 1) will be true.",
                "}"
              ],
              "oracle": [
                "    let mut rng = Lcg128CmDxsm64::new(1, 2); rng.advance(1); // test case for mdelta > 0 and (mdelta & 1) != 0 being true.",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2); rng.advance(2); // test case for mdelta > 0 and (mdelta & 1) != 0 being false, since mdelta is even.",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2); rng.advance(0); // test case for mdelta == 0, verifying behavior when delta is zero."
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    rng.advance(1); // delta is 1, mdelta will be greater than 0 and condition (mdelta & 1) will be true.",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2); rng.advance(1); // test case for mdelta > 0 and (mdelta & 1) != 0 being true.",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2); rng.advance(2); // test case for mdelta > 0 and (mdelta & 1) != 0 being false, since mdelta is even.",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2); rng.advance(0); // test case for mdelta == 0, verifying behavior when delta is zero.",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 70 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "delta = 0, state = 0 to (u128 max), increment = 0 to (u128 max)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, 0);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 0);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, 0);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(u128::MAX, 0);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, u128::MAX + 1);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(u128::MAX, 0);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, u128::MAX + 1);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, 1);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 1);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, 1);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 1);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, u128::MAX);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, initial_state);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, u128::MAX);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, initial_state);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 12345678901234567890);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(12345678901234567890, 98765432109876543210);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 12345678901234567890);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}