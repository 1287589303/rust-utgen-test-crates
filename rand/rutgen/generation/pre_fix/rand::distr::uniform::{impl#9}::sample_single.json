{
  "name": "rand::distr::uniform::{impl#9}::sample_single",
  "mod_info": {
    "name": "distr::uniform",
    "loc": "src/distr/mod.rs:101:1:101:17"
  },
  "visible": true,
  "loc": "src/distr/uniform.rs:444:5:446:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Valid input conditions include non-empty RangeInclusive<T> where T is any type that implements SampleUniform and PartialOrd, with start being less than or equal to end, covering scenarios where T takes on edge values and both finite and non-finite values to check the EmptyRange and NonFinite error types.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<i32> = 0..=10;",
                "    let result = range.sample_single(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.is_ok(), true);",
                "    assert!(result.unwrap() >= 0);",
                "    assert!(result.unwrap() <= 10);",
                "    assert!(result.unwrap() == 0 || result.unwrap() == 10 || (0 < result.unwrap() && result.unwrap() < 10));"
              ],
              "code": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<i32> = 0..=10;",
                "    let result = range.sample_single(&mut rng);",
                "    assert_eq!(result.is_ok(), true);",
                "    assert!(result.unwrap() >= 0);",
                "    assert!(result.unwrap() <= 10);",
                "    assert!(result.unwrap() == 0 || result.unwrap() == 10 || (0 < result.unwrap() && result.unwrap() < 10));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<f64> = 0.0..=1.0;",
                "    let result = range.sample_single(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    let value = result.unwrap();",
                "    assert!(value >= 0.0 && value <= 1.0);",
                "    assert!(range.is_empty() == false);"
              ],
              "code": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<f64> = 0.0..=1.0;",
                "    let result = range.sample_single(&mut rng);",
                "    assert!(result.is_ok());",
                "    let value = result.unwrap();",
                "    assert!(value >= 0.0 && value <= 1.0);",
                "    assert!(range.is_empty() == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<i32> = 5..=5;  // Start and end are equal",
                "    let result = range.sample_single(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Err(Error::EmptyRange));"
              ],
              "code": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<i32> = 5..=5;  // Start and end are equal",
                "    let result = range.sample_single(&mut rng);",
                "    assert_eq!(result, Err(Error::EmptyRange));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<f64> = f64::NAN..=f64::NAN;  // Non-finite values",
                "    let result = range.sample_single(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Err(Error::NonFinite));"
              ],
              "code": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<f64> = f64::NAN..=f64::NAN;  // Non-finite values",
                "    let result = range.sample_single(&mut rng);",
                "    assert_eq!(result, Err(Error::NonFinite));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<char> = 'a'..='z';",
                "    let result = range.sample_single(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    assert!(result.unwrap() >= 'a' && result.unwrap() <= 'z');",
                "    let empty_range: RangeInclusive<char> = 'z'..='a';",
                "    let error_result = empty_range.sample_single(&mut rng);",
                "    assert_eq!(error_result, Err(Error::EmptyRange));",
                "    let non_finite_range: RangeInclusive<f64> = f64::NAN..=f64::INFINITY;",
                "    let non_finite_result = non_finite_range.sample_single(&mut rng);",
                "    assert_eq!(non_finite_result, Err(Error::NonFinite));"
              ],
              "code": [
                "{",
                "    struct DummyRng;",
                "",
                "    impl RngCore for DummyRng {",
                "        // Implement necessary methods for DummyRng",
                "    }",
                "",
                "    let mut rng = DummyRng;",
                "    let range: RangeInclusive<char> = 'a'..='z';",
                "    let result = range.sample_single(&mut rng);",
                "    assert!(result.is_ok());",
                "    assert!(result.unwrap() >= 'a' && result.unwrap() <= 'z');",
                "    let empty_range: RangeInclusive<char> = 'z'..='a';",
                "    let error_result = empty_range.sample_single(&mut rng);",
                "    assert_eq!(error_result, Err(Error::EmptyRange));",
                "    let non_finite_range: RangeInclusive<f64> = f64::NAN..=f64::INFINITY;",
                "    let non_finite_result = non_finite_range.sample_single(&mut rng);",
                "    assert_eq!(non_finite_result, Err(Error::NonFinite));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}