[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src: [u8; 4] = [1, 0, 0, 0]; // 4 * 1",
          "    let mut dst: [u32; 1] = [0];",
          "    read_u32_into(&src, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst[0], 1);",
          "    assert!(src.len() >= 4 * dst.len());",
          "    let src: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
          "    let mut dst: [u32; 2] = [0; 2];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    let src: [u8; 0] = [];",
          "    let mut dst: [u32; 0] = [];",
          "    read_u32_into(&src, &mut dst);",
          "    let src: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // 4 * 4",
          "    let mut dst: [u32; 4] = [0; 4];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    assert_eq!(dst[2], 3);",
          "    assert_eq!(dst[3], 4);",
          "    let src: [u8; 6] = [1, 0, 0, 0, 2, 0];",
          "    let mut dst: [u32; 2] = [0; 2];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);"
        ],
        "code": [
          "{",
          "    let src: [u8; 4] = [1, 0, 0, 0]; // 4 * 1",
          "    let mut dst: [u32; 1] = [0];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert!(src.len() >= 4 * dst.len());",
          "    let src: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
          "    let mut dst: [u32; 2] = [0; 2];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    let src: [u8; 0] = [];",
          "    let mut dst: [u32; 0] = [];",
          "    read_u32_into(&src, &mut dst);",
          "    let src: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // 4 * 4",
          "    let mut dst: [u32; 4] = [0; 4];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    assert_eq!(dst[2], 3);",
          "    assert_eq!(dst[3], 4);",
          "    let src: [u8; 6] = [1, 0, 0, 0, 2, 0];",
          "    let mut dst: [u32; 2] = [0; 2];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let src: [u8; 4] = [1, 0, 0, 0]; // src.len() == 4, dst.len() == 0",
          "    let mut dst: [u32; 0] = [];",
          "    read_u32_into(&src, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| read_u32_into(&src, &mut dst)).is_err());",
          "    let src: [u8; 4] = [1, 0, 0, 0];",
          "    let mut dst: [u32; 0] = [];",
          "    assert!(dst.len() == 0);",
          "    assert!(src.len() == 4);",
          "    assert!(src.len() >= 4 * dst.len());"
        ],
        "code": [
          "{",
          "    let src: [u8; 4] = [1, 0, 0, 0]; // src.len() == 4, dst.len() == 0",
          "    let mut dst: [u32; 0] = [];",
          "    read_u32_into(&src, &mut dst);",
          "    assert!(std::panic::catch_unwind(|| read_u32_into(&src, &mut dst)).is_err());",
          "    let src: [u8; 4] = [1, 0, 0, 0];",
          "    let mut dst: [u32; 0] = [];",
          "    assert!(dst.len() == 0);",
          "    assert!(src.len() == 4);",
          "    assert!(src.len() >= 4 * dst.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
          "    let mut dst: [u32; 2] = [0, 0];",
          "    read_u32_into(&src, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    assert!(std::panic::catch_unwind(|| read_u32_into(&src, &mut [0u32; 1])).is_err());",
          "    assert!(std::panic::catch_unwind(|| read_u32_into(&src[0..6], &mut dst)).is_err());"
        ],
        "code": [
          "{",
          "    let src: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
          "    let mut dst: [u32; 2] = [0, 0];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    assert!(std::panic::catch_unwind(|| read_u32_into(&src, &mut [0u32; 1])).is_err());",
          "    assert!(std::panic::catch_unwind(|| read_u32_into(&src[0..6], &mut dst)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src: [u8; 12] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]; // 4 * 3",
          "    let mut dst: [u32; 3] = [0, 0, 0];",
          "    read_u32_into(&src, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, [1, 2, 3]);",
          "    let src_empty: [u8; 0] = [];",
          "    let mut dst_empty: [u32; 0] = [];",
          "    read_u32_into(&src_empty, &mut dst_empty);",
          "    let src_short: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
          "    let mut dst_short: [u32; 2] = [0, 0];",
          "    read_u32_into(&src_short, &mut dst_short);",
          "    assert_eq!(dst_short, [1, 2]);",
          "    let src_single: [u8; 4] = [3, 0, 0, 0]; // 4 * 1",
          "    let mut dst_single: [u32; 1] = [0];",
          "    read_u32_into(&src_single, &mut dst_single);",
          "    assert_eq!(dst_single, [3]);",
          "    let src_small: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // 4 * 4",
          "    let mut dst_large: [u32; 4] = [0, 0, 0, 0];",
          "    read_u32_into(&src_small, &mut dst_large);",
          "    assert_eq!(dst_large, [1, 2, 3, 4]);"
        ],
        "code": [
          "{",
          "    let src: [u8; 12] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]; // 4 * 3",
          "    let mut dst: [u32; 3] = [0, 0, 0];",
          "    read_u32_into(&src, &mut dst);",
          "    assert_eq!(dst, [1, 2, 3]);",
          "    let src_empty: [u8; 0] = [];",
          "    let mut dst_empty: [u32; 0] = [];",
          "    read_u32_into(&src_empty, &mut dst_empty);",
          "    let src_short: [u8; 8] = [1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2",
          "    let mut dst_short: [u32; 2] = [0, 0];",
          "    read_u32_into(&src_short, &mut dst_short);",
          "    assert_eq!(dst_short, [1, 2]);",
          "    let src_single: [u8; 4] = [3, 0, 0, 0]; // 4 * 1",
          "    let mut dst_single: [u32; 1] = [0];",
          "    read_u32_into(&src_single, &mut dst_single);",
          "    assert_eq!(dst_single, [3]);",
          "    let src_small: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // 4 * 4",
          "    let mut dst_large: [u32; 4] = [0, 0, 0, 0];",
          "    read_u32_into(&src_small, &mut dst_large);",
          "    assert_eq!(dst_large, [1, 2, 3, 4]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let src: [u8; 4] = [1, 0, 0, 0]; // src.len() < 4 * dst.len()",
          "    let mut dst: [u32; 2] = [0, 0]; // 4 * 2 = 8; src.len() is 4",
          "    read_u32_into(&src, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| {",
          "    let src: [u8; 4] = [1, 0, 0, 0];",
          "    let mut dst: [u32; 2] = [0, 0];",
          "    read_u32_into(&src, &mut dst);",
          "    }).is_err());"
        ],
        "code": [
          "{",
          "    let src: [u8; 4] = [1, 0, 0, 0]; // src.len() < 4 * dst.len()",
          "    let mut dst: [u32; 2] = [0, 0]; // 4 * 2 = 8; src.len() is 4",
          "    read_u32_into(&src, &mut dst);",
          "    assert!(std::panic::catch_unwind(|| {",
          "    let src: [u8; 4] = [1, 0, 0, 0];",
          "    let mut dst: [u32; 2] = [0, 0];",
          "    read_u32_into(&src, &mut dst);",
          "    }).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]