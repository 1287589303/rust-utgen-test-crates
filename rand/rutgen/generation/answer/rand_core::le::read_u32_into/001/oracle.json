[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[should_panic]",
      "fn test_read_u32_into_insufficient_src_length() {",
      "    let src: &[u8] = &[1, 0, 0, 0];",
      "    let mut dst: &mut [u32] = &mut [0; 1];",
      "    read_u32_into(src, dst);",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    read_u32_into(src, dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, &[1, 2]);",
          "    assert!(src.len() >= 4 * dst.len());",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
          "    let dst: &mut [u32] = &mut [0; 2];",
          "    assert_eq!(dst.len(), 2);",
          "    let src: &[u8] = &[0; 0];",
          "    let dst: &mut [u32] = &mut [];",
          "    assert_eq!(dst.len(), 0);",
          "    assert!(src.len() >= 4 * dst.len());",
          "    let src: &[u8] = &[1, 0, 0, 0];",
          "    let dst: &mut [u32] = &mut [0; 1];",
          "    assert!(dst.len() > 0);",
          "    assert_eq!(dst[0], 1);"
        ],
        "code": [
          "{",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst, &[1, 2]);",
          "    assert!(src.len() >= 4 * dst.len());",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
          "    let dst: &mut [u32] = &mut [0; 2];",
          "    assert_eq!(dst.len(), 2);",
          "    let src: &[u8] = &[0; 0];",
          "    let dst: &mut [u32] = &mut [];",
          "    assert_eq!(dst.len(), 0);",
          "    assert!(src.len() >= 4 * dst.len());",
          "    let src: &[u8] = &[1, 0, 0, 0];",
          "    let dst: &mut [u32] = &mut [0; 1];",
          "    assert!(dst.len() > 0);",
          "    assert_eq!(dst[0], 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    read_u32_into(src, dst);",
          "}"
        ],
        "oracle": [
          "    assert!(src.len() >= 4 * dst.len());",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3];",
          "    let dst: &mut [u32] = &mut [0; 2];",
          "    assert_eq!(dst.len(), 2);",
          "    assert!(dst.iter().all(|&x| x == 0));",
          "    let src: &[u8] = &[1, 0, 0, 0];",
          "    let dst: &mut [u32] = &mut [0; 1];",
          "    assert!(src.len() < 4 * dst.len());",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    assert!(src.chunks_exact(4).len() >= dst.len());"
        ],
        "code": [
          "{",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    read_u32_into(src, dst);",
          "    assert!(src.len() >= 4 * dst.len());",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3];",
          "    let dst: &mut [u32] = &mut [0; 2];",
          "    assert_eq!(dst.len(), 2);",
          "    assert!(dst.iter().all(|&x| x == 0));",
          "    let src: &[u8] = &[1, 0, 0, 0];",
          "    let dst: &mut [u32] = &mut [0; 1];",
          "    assert!(src.len() < 4 * dst.len());",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    assert!(src.chunks_exact(4).len() >= dst.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src: &[u8] = &[];",
          "    let mut dst: &mut [u32] = &mut [];",
          "    read_u32_into(src, dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst.len(), src.len() / 4);",
          "    let src: &[u8] = &[1, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 1];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst[0], 1);",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    let src: &[u8] = &[1, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 1];",
          "    #[should_panic]",
          "    read_u32_into(src, dst);",
          "    let src: &[u8] = &[1, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [];",
          "    read_u32_into(src, dst);",
          "    assert!(dst.is_empty());",
          "    let src: &[u8] = &[0; 8];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst[0], 0);",
          "    assert_eq!(dst[1], 0);",
          "    let src: &[u8] = &[255, 255, 255, 255];",
          "    let mut dst: &mut [u32] = &mut [0; 1];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst[0], 4294967295);"
        ],
        "code": [
          "{",
          "    let src: &[u8] = &[];",
          "    let mut dst: &mut [u32] = &mut [];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst.len(), src.len() / 4);",
          "    let src: &[u8] = &[1, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 1];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst[0], 1);",
          "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst[0], 1);",
          "    assert_eq!(dst[1], 2);",
          "    let src: &[u8] = &[1, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [0; 1];",
          "    #[should_panic]",
          "    read_u32_into(src, dst);",
          "    let src: &[u8] = &[1, 0, 0, 0];",
          "    let mut dst: &mut [u32] = &mut [];",
          "    read_u32_into(src, dst);",
          "    assert!(dst.is_empty());",
          "    let src: &[u8] = &[0; 8];",
          "    let mut dst: &mut [u32] = &mut [0; 2];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst[0], 0);",
          "    assert_eq!(dst[1], 0);",
          "    let src: &[u8] = &[255, 255, 255, 255];",
          "    let mut dst: &mut [u32] = &mut [0; 1];",
          "    read_u32_into(src, dst);",
          "    assert_eq!(dst[0], 4294967295);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]