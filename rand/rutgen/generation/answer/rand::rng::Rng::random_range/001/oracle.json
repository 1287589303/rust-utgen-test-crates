[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [
          "#[should_panic(expected = \"cannot sample empty range\")]"
        ],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _dest: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> rand_core::Result<()> { Ok(()) }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "",
          "    // Exclusive range where low >= high",
          "    let _: u32 = rng.random_range(10..10);",
          "}"
        ],
        "oracle": [
          "    assert_panic!(test);",
          "    assert_eq!(rng.random_range(10..10), assert_err!(Error::EmptyRange));",
          "    assert_panic!(rng.random_range(0..0));",
          "    assert_panic!(rng.random_range(5..5));",
          "    assert_panic!(rng.random_range(-5..-5));",
          "    assert_panic!(rng.random_range(2.0..2.0));",
          "    assert_panic!(rng.random_range(3.5..3.5));",
          "    assert_panic!(rng.random_range(10u32..0u32));",
          "    assert_panic!(rng.random_range(0f64..0f64));",
          "    assert_panic!(rng.random_range(10..9));"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _dest: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> rand_core::Result<()> { Ok(()) }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "",
          "    // Exclusive range where low >= high",
          "    let _: u32 = rng.random_range(10..10);",
          "    assert_panic!(test);",
          "    assert_eq!(rng.random_range(10..10), assert_err!(Error::EmptyRange));",
          "    assert_panic!(rng.random_range(0..0));",
          "    assert_panic!(rng.random_range(5..5));",
          "    assert_panic!(rng.random_range(-5..-5));",
          "    assert_panic!(rng.random_range(2.0..2.0));",
          "    assert_panic!(rng.random_range(3.5..3.5));",
          "    assert_panic!(rng.random_range(10u32..0u32));",
          "    assert_panic!(rng.random_range(0f64..0f64));",
          "    assert_panic!(rng.random_range(10..9));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic(expected = \"cannot sample empty range\")]"
        ],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _dest: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> rand_core::Result<()> { Ok(()) }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "",
          "    // Inclusive range where high < low",
          "    let _: u32 = rng.random_range(10..=5);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.random_range(10..=5), Err(Error::EmptyRange));",
          "    assert!(std::panic::catch_unwind(|| rng.random_range(..0)).is_err());",
          "    assert!(std::panic::catch_unwind(|| rng.random_range(-1.0..-2.0)).is_err());",
          "    assert!(std::panic::catch_unwind(|| rng.random_range(5..5)).is_err());",
          "    assert!(std::panic::catch_unwind(|| rng.random_range(..)).is_err());"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _dest: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> rand_core::Result<()> { Ok(()) }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "",
          "    // Inclusive range where high < low",
          "    let _: u32 = rng.random_range(10..=5);",
          "    assert_eq!(rng.random_range(10..=5), Err(Error::EmptyRange));",
          "    assert!(std::panic::catch_unwind(|| rng.random_range(..0)).is_err());",
          "    assert!(std::panic::catch_unwind(|| rng.random_range(-1.0..-2.0)).is_err());",
          "    assert!(std::panic::catch_unwind(|| rng.random_range(5..5)).is_err());",
          "    assert!(std::panic::catch_unwind(|| rng.random_range(..)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic(expected = \"cannot sample empty range\")]"
        ],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _dest: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> rand_core::Result<()> { Ok(()) }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "",
          "    // Exclusive range where low >= high",
          "    let _: f64 = rng.random_range(1.0..1.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.random_range(1.0..1.0).is_nan(), true);",
          "    let _: f64 = rng.random_range(5..5);",
          "    assert_eq!(rng.random_range(5..5), 5);",
          "    let _: f64 = rng.random_range(2..=2);",
          "    assert_eq!(rng.random_range(2..=2), 2);",
          "    #[should_panic(expected = \"cannot sample empty range\")]",
          "    let _: f64 = rng.random_range(5..3);",
          "    #[should_panic(expected = \"cannot sample empty range\")]",
          "    let _: f64 = rng.random_range(0..0);"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _dest: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> rand_core::Result<()> { Ok(()) }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "",
          "    // Exclusive range where low >= high",
          "    let _: f64 = rng.random_range(1.0..1.0);",
          "    assert_eq!(rng.random_range(1.0..1.0).is_nan(), true);",
          "    let _: f64 = rng.random_range(5..5);",
          "    assert_eq!(rng.random_range(5..5), 5);",
          "    let _: f64 = rng.random_range(2..=2);",
          "    assert_eq!(rng.random_range(2..=2), 2);",
          "    #[should_panic(expected = \"cannot sample empty range\")]",
          "    let _: f64 = rng.random_range(5..3);",
          "    #[should_panic(expected = \"cannot sample empty range\")]",
          "    let _: f64 = rng.random_range(0..0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic(expected = \"cannot sample empty range\")]"
        ],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _dest: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> rand_core::Result<()> { Ok(()) }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "",
          "    // Inclusive range where high < low",
          "    let _: f64 = rng.random_range(1.0..=0.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.random_range(1..=0), Err(Error::EmptyRange));",
          "    assert_eq!(rng.random_range(0..0), Err(Error::EmptyRange));",
          "    assert_eq!(rng.random_range(..0), Err(Error::EmptyRange));",
          "    assert_eq!(rng.random_range(0..=0), Err(Error::EmptyRange));",
          "    assert_eq!(rng.random_range(..=0), Err(Error::EmptyRange));",
          "    assert!(panic::catch_unwind(|| rng.random_range(1..=0)).is_err());",
          "    assert!(panic::catch_unwind(|| rng.random_range(0..0)).is_err());",
          "    assert!(panic::catch_unwind(|| rng.random_range(..0)).is_err());",
          "    assert!(panic::catch_unwind(|| rng.random_range(0..=0)).is_err());",
          "    assert!(panic::catch_unwind(|| rng.random_range(..=0)).is_err());"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _dest: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> rand_core::Result<()> { Ok(()) }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "",
          "    // Inclusive range where high < low",
          "    let _: f64 = rng.random_range(1.0..=0.0);",
          "    assert_eq!(rng.random_range(1..=0), Err(Error::EmptyRange));",
          "    assert_eq!(rng.random_range(0..0), Err(Error::EmptyRange));",
          "    assert_eq!(rng.random_range(..0), Err(Error::EmptyRange));",
          "    assert_eq!(rng.random_range(0..=0), Err(Error::EmptyRange));",
          "    assert_eq!(rng.random_range(..=0), Err(Error::EmptyRange));",
          "    assert!(panic::catch_unwind(|| rng.random_range(1..=0)).is_err());",
          "    assert!(panic::catch_unwind(|| rng.random_range(0..0)).is_err());",
          "    assert!(panic::catch_unwind(|| rng.random_range(..0)).is_err());",
          "    assert!(panic::catch_unwind(|| rng.random_range(0..=0)).is_err());",
          "    assert!(panic::catch_unwind(|| rng.random_range(..=0)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]