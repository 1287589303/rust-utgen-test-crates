[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    let n: u32 = rng.random_range(1..10);",
          "}"
        ],
        "oracle": [
          "    assert!(n >= 1 && n < 10);",
          "    let m: f64 = rng.random_range(-40.0..1.3e5);",
          "    assert!(m >= -40.0 && m < 1.3e5);",
          "    let n: u32 = rng.random_range(..=10);",
          "    assert!(n <= 10);",
          "    let n_empty: u32 = rng.random_range(10..10);",
          "    assert!(n_empty.is_err());",
          "    let n_floats: f64 = rng.random_range(0.0..1.0);",
          "    assert!(n_floats >= 0.0 && n_floats < 1.0);",
          "    let n_large_range: u32 = rng.random_range(0..=u32::MAX);",
          "    assert!(n_large_range <= u32::MAX);",
          "    let n_non_finite: u32 = rng.random_range(0.0..f64::INFINITY);",
          "    assert!(n_non_finite.is_err());",
          "    let _ = rng.random_range(1u32..3u32);",
          "    let sample_empty = rng.random_range(1..1);",
          "    assert!(sample_empty.is_err());",
          "    let _ = rng.random_range(0u32..10u32);",
          "    assert!(n >= 0 && n < 10);"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    let n: u32 = rng.random_range(1..10);",
          "    assert!(n >= 1 && n < 10);",
          "    let m: f64 = rng.random_range(-40.0..1.3e5);",
          "    assert!(m >= -40.0 && m < 1.3e5);",
          "    let n: u32 = rng.random_range(..=10);",
          "    assert!(n <= 10);",
          "    let n_empty: u32 = rng.random_range(10..10);",
          "    assert!(n_empty.is_err());",
          "    let n_floats: f64 = rng.random_range(0.0..1.0);",
          "    assert!(n_floats >= 0.0 && n_floats < 1.0);",
          "    let n_large_range: u32 = rng.random_range(0..=u32::MAX);",
          "    assert!(n_large_range <= u32::MAX);",
          "    let n_non_finite: u32 = rng.random_range(0.0..f64::INFINITY);",
          "    assert!(n_non_finite.is_err());",
          "    let _ = rng.random_range(1u32..3u32);",
          "    let sample_empty = rng.random_range(1..1);",
          "    assert!(sample_empty.is_err());",
          "    let _ = rng.random_range(0u32..10u32);",
          "    assert!(n >= 0 && n < 10);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    let n: u32 = rng.random_range(1..=10);",
          "}"
        ],
        "oracle": [
          "    assert!(n >= 1 && n <= 10, \"The sampled value should be within the range 1 to 10 (inclusive)\");",
          "    let m: f64 = rng.random_range(-40.0..1.3e5);",
          "    assert!(m >= -40.0 && m < 1.3e5, \"The sampled value should be in the range [-40.0, 1.3e5)\");",
          "    let p: f64 = 0.5;",
          "    let b: bool = rng.random_bool(p);",
          "    assert!(b == true || b == false, \"The result of random_bool should be a boolean\");",
          "    let ratio_result: bool = rng.random_ratio(3, 5);",
          "    assert!(ratio_result == true || ratio_result == false, \"The result of random_ratio should be a boolean\");",
          "    let empty_range_result = std::panic::catch_unwind(|| { rng.random_range(1..=1); });",
          "    assert!(empty_range_result.is_err(), \"random_range should panic when sampling from an empty range\");",
          "    let non_finite_range_result = std::panic::catch_unwind(|| { rng.random_range(f64::NAN..f64::INFINITY); });",
          "    assert!(non_finite_range_result.is_err(), \"random_range should panic with non-finite ranges\");"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    let n: u32 = rng.random_range(1..=10);",
          "    assert!(n >= 1 && n <= 10, \"The sampled value should be within the range 1 to 10 (inclusive)\");",
          "    let m: f64 = rng.random_range(-40.0..1.3e5);",
          "    assert!(m >= -40.0 && m < 1.3e5, \"The sampled value should be in the range [-40.0, 1.3e5)\");",
          "    let p: f64 = 0.5;",
          "    let b: bool = rng.random_bool(p);",
          "    assert!(b == true || b == false, \"The result of random_bool should be a boolean\");",
          "    let ratio_result: bool = rng.random_ratio(3, 5);",
          "    assert!(ratio_result == true || ratio_result == false, \"The result of random_ratio should be a boolean\");",
          "    let empty_range_result = std::panic::catch_unwind(|| { rng.random_range(1..=1); });",
          "    assert!(empty_range_result.is_err(), \"random_range should panic when sampling from an empty range\");",
          "    let non_finite_range_result = std::panic::catch_unwind(|| { rng.random_range(f64::NAN..f64::INFINITY); });",
          "    assert!(non_finite_range_result.is_err(), \"random_range should panic with non-finite ranges\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    let m: f64 = rng.random_range(0.0..1.0);",
          "}"
        ],
        "oracle": [
          "    assert!(rng.random_range(0.0..1.0) >= 0.0);",
          "    assert!(rng.random_range(0.0..1.0) < 1.0);",
          "    assert!(rng.random_range(1..10) >= 1);",
          "    assert!(rng.random_range(1..10) < 10);",
          "    assert!(rng.random_range(-10..10) >= -10.0);",
          "    assert!(rng.random_range(-10..10) < 10.0);",
          "    assert!(rng.random_range(0..=5) >= 0);",
          "    assert!(rng.random_range(0..=5) <= 5);",
          "    assert!(rng.random_range(1.0..=5.0) >= 1.0);",
          "    assert!(rng.random_range(1.0..=5.0) <= 5.0);"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    let m: f64 = rng.random_range(0.0..1.0);",
          "    assert!(rng.random_range(0.0..1.0) >= 0.0);",
          "    assert!(rng.random_range(0.0..1.0) < 1.0);",
          "    assert!(rng.random_range(1..10) >= 1);",
          "    assert!(rng.random_range(1..10) < 10);",
          "    assert!(rng.random_range(-10..10) >= -10.0);",
          "    assert!(rng.random_range(-10..10) < 10.0);",
          "    assert!(rng.random_range(0..=5) >= 0);",
          "    assert!(rng.random_range(0..=5) <= 5);",
          "    assert!(rng.random_range(1.0..=5.0) >= 1.0);",
          "    assert!(rng.random_range(1.0..=5.0) <= 5.0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    let m: f64 = rng.random_range(0.0..=100.0);",
          "}"
        ],
        "oracle": [
          "    assert!(m >= 0.0, \"Expected m to be greater than or equal to 0.0\");",
          "    assert!(m <= 100.0, \"Expected m to be less than or equal to 100.0\");",
          "    ",
          "    let n: u32 = rng.random_range(0..=10);",
          "    assert!(n >= 0, \"Expected n to be greater than or equal to 0\");",
          "    assert!(n <= 10, \"Expected n to be less than or equal to 10\");",
          "    ",
          "    let p = 0.5;",
          "    let b: bool = rng.random_bool(p);",
          "    assert!(b == true || b == false, \"Expected b to be a boolean value\");",
          "    ",
          "    let ratio_result: bool = rng.random_ratio(1, 10);",
          "    assert!(ratio_result == true || ratio_result == false, \"Expected ratio_result to be a boolean value\");"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    let m: f64 = rng.random_range(0.0..=100.0);",
          "    assert!(m >= 0.0, \"Expected m to be greater than or equal to 0.0\");",
          "    assert!(m <= 100.0, \"Expected m to be less than or equal to 100.0\");",
          "    ",
          "    let n: u32 = rng.random_range(0..=10);",
          "    assert!(n >= 0, \"Expected n to be greater than or equal to 0\");",
          "    assert!(n <= 10, \"Expected n to be less than or equal to 10\");",
          "    ",
          "    let p = 0.5;",
          "    let b: bool = rng.random_bool(p);",
          "    assert!(b == true || b == false, \"Expected b to be a boolean value\");",
          "    ",
          "    let ratio_result: bool = rng.random_ratio(1, 10);",
          "    assert!(ratio_result == true || ratio_result == false, \"Expected ratio_result to be a boolean value\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    // Just to illustrate, this should panic due to non-finite value",
          "    // Depending on the actual implementation, you’d want to handle that",
          "    let _m: f64 = rng.random_range(0.0..std::f64::INFINITY); ",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| { rng.random_range(0.0..std::f64::INFINITY); }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { rng.random_range(10..10); }).is_err());",
          "    let n: u32 = rng.random_range(1..10);",
          "    assert!(n >= 1 && n < 10);",
          "    let m: f64 = rng.random_range(-40.0..1.3e5);",
          "    assert!(m >= -40.0 && m < 1.3e5);",
          "    let inclusive_n: u32 = rng.random_range(1..=10);",
          "    assert!(inclusive_n >= 1 && inclusive_n <= 10);"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "    impl RngCore for TestRng {",
          "        // Implement required methods...",
          "    }",
          "    let mut rng = TestRng;",
          "    // Just to illustrate, this should panic due to non-finite value",
          "    // Depending on the actual implementation, you’d want to handle that",
          "    let _m: f64 = rng.random_range(0.0..std::f64::INFINITY); ",
          "    assert!(std::panic::catch_unwind(|| { rng.random_range(0.0..std::f64::INFINITY); }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { rng.random_range(10..10); }).is_err());",
          "    let n: u32 = rng.random_range(1..10);",
          "    assert!(n >= 1 && n < 10);",
          "    let m: f64 = rng.random_range(-40.0..1.3e5);",
          "    assert!(m >= -40.0 && m < 1.3e5);",
          "    let inclusive_n: u32 = rng.random_range(1..=10);",
          "    assert!(inclusive_n >= 1 && inclusive_n <= 10);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]