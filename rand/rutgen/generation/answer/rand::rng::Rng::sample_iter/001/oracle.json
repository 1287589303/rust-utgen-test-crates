[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let samples: Vec<f32> = rng.sample_iter(StandardUniform).take(16).collect();",
          "}"
        ],
        "oracle": [
          "    let samples: Vec<f32> = rng.sample_iter(StandardUniform).take(16).collect();",
          "    assert_eq!(samples.len(), 16);",
          "    for sample in &samples { assert!(sample >= &0.0 && sample < &1.0); }",
          "    let samples: Vec<char> = rng.sample_iter(Alphanumeric).take(7).map(char::from).collect();",
          "    assert_eq!(samples.len(), 7);",
          "    assert!(samples.iter().all(|&c| c.is_ascii_alphanumeric()));",
          "    let combined_samples: Vec<(f64, bool)> = rng.sample_iter(StandardUniform).take(5).collect();",
          "    assert_eq!(combined_samples.len(), 5);",
          "    for (f, b) in &combined_samples { assert!(f >= &0.0 && f < &1.0); assert!(b == &true || b == &false); }",
          "    let die_range = Uniform::new_inclusive(1, 6).unwrap();",
          "    let mut roll_die = rng.sample_iter(die_range);",
          "    let mut rolls = Vec::new();",
          "    while let Some(roll) = roll_die.next() { rolls.push(roll); if roll == 6 { break; } }",
          "    assert!(rolls.iter().all(|&roll| roll >= 1 && roll <= 6));"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let samples: Vec<f32> = rng.sample_iter(StandardUniform).take(16).collect();",
          "    let samples: Vec<f32> = rng.sample_iter(StandardUniform).take(16).collect();",
          "    assert_eq!(samples.len(), 16);",
          "    for sample in &samples { assert!(sample >= &0.0 && sample < &1.0); }",
          "    let samples: Vec<char> = rng.sample_iter(Alphanumeric).take(7).map(char::from).collect();",
          "    assert_eq!(samples.len(), 7);",
          "    assert!(samples.iter().all(|&c| c.is_ascii_alphanumeric()));",
          "    let combined_samples: Vec<(f64, bool)> = rng.sample_iter(StandardUniform).take(5).collect();",
          "    assert_eq!(combined_samples.len(), 5);",
          "    for (f, b) in &combined_samples { assert!(f >= &0.0 && f < &1.0); assert!(b == &true || b == &false); }",
          "    let die_range = Uniform::new_inclusive(1, 6).unwrap();",
          "    let mut roll_die = rng.sample_iter(die_range);",
          "    let mut rolls = Vec::new();",
          "    while let Some(roll) = roll_die.next() { rolls.push(roll); if roll == 6 { break; } }",
          "    assert!(rolls.iter().all(|&roll| roll >= 1 && roll <= 6));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let samples: String = rng.sample_iter(Alphanumeric).take(7).map(char::from).collect();",
          "}"
        ],
        "oracle": [
          "    let samples: String = rng.sample_iter(Alphanumeric).take(7).map(char::from).collect();",
          "    assert_eq!(samples.len(), 7);",
          "    for ch in samples.chars() {",
          "    assert!(ch.is_ascii_alphanumeric());",
          "    }"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let samples: String = rng.sample_iter(Alphanumeric).take(7).map(char::from).collect();",
          "    let samples: String = rng.sample_iter(Alphanumeric).take(7).map(char::from).collect();",
          "    assert_eq!(samples.len(), 7);",
          "    for ch in samples.chars() {",
          "    assert!(ch.is_ascii_alphanumeric());",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let die_range = Uniform::new_inclusive(1, 6).unwrap();",
          "    let mut roll_die = rng.sample_iter(die_range);",
          "    while roll_die.next().unwrap() != 6 {}",
          "}"
        ],
        "oracle": [
          "    let v: Vec<f32> = (&mut rng).sample_iter(StandardUniform).take(16).collect();",
          "    let s: String = (&mut rng).sample_iter(Alphanumeric).take(7).map(char::from).collect();",
          "    let combined_values: Vec<(f64, bool)> = (&mut rng).sample_iter(StandardUniform).take(5).collect();",
          "    let mut roll_die = rng.sample_iter(die_range);",
          "    assert!(roll_die.next().unwrap() <= 6);",
          "    assert!(roll_die.next().unwrap() >= 1);",
          "    assert_eq!(roll_die.next().unwrap(), 6);",
          "    assert!(roll_die.clone().count() > 0);"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let die_range = Uniform::new_inclusive(1, 6).unwrap();",
          "    let mut roll_die = rng.sample_iter(die_range);",
          "    while roll_die.next().unwrap() != 6 {}",
          "    let v: Vec<f32> = (&mut rng).sample_iter(StandardUniform).take(16).collect();",
          "    let s: String = (&mut rng).sample_iter(Alphanumeric).take(7).map(char::from).collect();",
          "    let combined_values: Vec<(f64, bool)> = (&mut rng).sample_iter(StandardUniform).take(5).collect();",
          "    let mut roll_die = rng.sample_iter(die_range);",
          "    assert!(roll_die.next().unwrap() <= 6);",
          "    assert!(roll_die.next().unwrap() >= 1);",
          "    assert_eq!(roll_die.next().unwrap(), 6);",
          "    assert!(roll_die.clone().count() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let empty_distribution = Uniform::new(0, 0).unwrap();  // Technically empty range",
          "    let samples: Vec<u32> = rng.sample_iter(empty_distribution).collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(samples, Vec::<u32>::new());"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let empty_distribution = Uniform::new(0, 0).unwrap();  // Technically empty range",
          "    let samples: Vec<u32> = rng.sample_iter(empty_distribution).collect();",
          "    assert_eq!(samples, Vec::<u32>::new());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let samples: Vec<u8> = rng.sample_iter(StandardUniform).take(1000).collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(samples.len(), 1000);",
          "    assert!(samples.iter().all(|&x| x >= 0.0 && x < 1.0));"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 { 0 }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, _: &mut [u8]) {}",
          "        fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), rand_core::error::Error> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng;",
          "    let samples: Vec<u8> = rng.sample_iter(StandardUniform).take(1000).collect();",
          "    assert_eq!(samples.len(), 1000);",
          "    assert!(samples.iter().all(|&x| x >= 0.0 && x < 1.0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]