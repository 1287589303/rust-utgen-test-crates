[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let xs: &[u8] = &[0, 0, 0, 0];",
          "    let result = read_u32le(xs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(read_u32le(&[0, 0, 0, 0]), 0);",
          "    assert_eq!(read_u32le(&[1, 0, 0, 0]), 1);",
          "    assert_eq!(read_u32le(&[0, 1, 0, 0]), 256);",
          "    assert_eq!(read_u32le(&[0, 0, 1, 0]), 65536);",
          "    assert_eq!(read_u32le(&[0, 0, 0, 1]), 16777216);",
          "    assert_eq!(read_u32le(&[255, 255, 255, 255]), 4294967295);",
          "    assert_eq!(read_u32le(&[0, 0, 0, 0]), 0);",
          "    assert_eq!(read_u32le(&[255, 0, 0, 0]), 255);",
          "    assert_eq!(read_u32le(&[0, 255, 0, 0]), 65280);",
          "    assert_eq!(read_u32le(&[0, 0, 255, 0]), 16711680);",
          "    assert_eq!(read_u32le(&[0, 0, 0, 255]), 4278190080);"
        ],
        "code": [
          "{",
          "    let xs: &[u8] = &[0, 0, 0, 0];",
          "    let result = read_u32le(xs);",
          "    assert_eq!(read_u32le(&[0, 0, 0, 0]), 0);",
          "    assert_eq!(read_u32le(&[1, 0, 0, 0]), 1);",
          "    assert_eq!(read_u32le(&[0, 1, 0, 0]), 256);",
          "    assert_eq!(read_u32le(&[0, 0, 1, 0]), 65536);",
          "    assert_eq!(read_u32le(&[0, 0, 0, 1]), 16777216);",
          "    assert_eq!(read_u32le(&[255, 255, 255, 255]), 4294967295);",
          "    assert_eq!(read_u32le(&[0, 0, 0, 0]), 0);",
          "    assert_eq!(read_u32le(&[255, 0, 0, 0]), 255);",
          "    assert_eq!(read_u32le(&[0, 255, 0, 0]), 65280);",
          "    assert_eq!(read_u32le(&[0, 0, 255, 0]), 16711680);",
          "    assert_eq!(read_u32le(&[0, 0, 0, 255]), 4278190080);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let xs: &[u8] = &[255, 255, 255, 255];",
          "    let result = read_u32le(xs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 4294967295);",
          "    assert_eq!(result, u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24));",
          "    assert_eq!(xs.len(), 4);",
          "    assert!(result.is_u32());"
        ],
        "code": [
          "{",
          "    let xs: &[u8] = &[255, 255, 255, 255];",
          "    let result = read_u32le(xs);",
          "    assert_eq!(result, 4294967295);",
          "    assert_eq!(result, u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24));",
          "    assert_eq!(xs.len(), 4);",
          "    assert!(result.is_u32());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let xs: &[u8] = &[128, 128, 128, 128];",
          "    let result = read_u32le(xs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0x80808080);",
          "    assert_eq!(result, u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24));",
          "    assert!(xs.len() == 4);"
        ],
        "code": [
          "{",
          "    let xs: &[u8] = &[128, 128, 128, 128];",
          "    let result = read_u32le(xs);",
          "    assert_eq!(result, 0x80808080);",
          "    assert_eq!(result, u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24));",
          "    assert!(xs.len() == 4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let xs: &[u8] = &[1, 2, 3, 4];",
          "    let result = read_u32le(xs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0x04030201);"
        ],
        "code": [
          "{",
          "    let xs: &[u8] = &[1, 2, 3, 4];",
          "    let result = read_u32le(xs);",
          "    assert_eq!(result, 0x04030201);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let xs: &[u8] = &[42, 43, 44, 45];",
          "    let result = read_u32le(xs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0x2D2C2B2A);"
        ],
        "code": [
          "{",
          "    let xs: &[u8] = &[42, 43, 44, 45];",
          "    let result = read_u32le(xs);",
          "    assert_eq!(result, 0x2D2C2B2A);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let xs: &[u8] = &[1, 2, 3];",
          "    let result = read_u32le(xs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0);",
          "    assert_panics!(read_u32le(&[1, 2, 3]));",
          "    assert_panics!(read_u32le(&[1, 2, 3, 4, 5]));",
          "    let xs_valid: &[u8] = &[1, 2, 3, 4];",
          "    let result_valid = read_u32le(xs_valid);",
          "    assert_eq!(result_valid, 67305985);"
        ],
        "code": [
          "{",
          "    let xs: &[u8] = &[1, 2, 3];",
          "    let result = read_u32le(xs);",
          "    assert_eq!(result, 0);",
          "    assert_panics!(read_u32le(&[1, 2, 3]));",
          "    assert_panics!(read_u32le(&[1, 2, 3, 4, 5]));",
          "    let xs_valid: &[u8] = &[1, 2, 3, 4];",
          "    let result_valid = read_u32le(xs_valid);",
          "    assert_eq!(result_valid, 67305985);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]