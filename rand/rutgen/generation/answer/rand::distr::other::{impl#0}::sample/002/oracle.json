[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        // Implement necessary Rng methods here.",
          "        fn random(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0xE000 }; // n is 0xE000 which is > 0xDFFF",
          "    let distr: StandardUniform = StandardUniform;",
          "    let result = distr.sample(&mut rng);",
          "}"
        ],
        "oracle": [
          "    assert!(result as u32 >= 0xE000 && result as u32 < 0x110000);",
          "    assert!(result != char::from_u32_unchecked(0xD800));",
          "    assert!(result != char::from_u32_unchecked(0xDFFF));"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        // Implement necessary Rng methods here.",
          "        fn random(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0xE000 }; // n is 0xE000 which is > 0xDFFF",
          "    let distr: StandardUniform = StandardUniform;",
          "    let result = distr.sample(&mut rng);",
          "    assert!(result as u32 >= 0xE000 && result as u32 < 0x110000);",
          "    assert!(result != char::from_u32_unchecked(0xD800));",
          "    assert!(result != char::from_u32_unchecked(0xDFFF));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        // Implement necessary Rng methods here.",
          "        fn random(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0x110000 }; // n is 0x110000 which is >= 0x110000",
          "    let distr: StandardUniform = StandardUniform;",
          "    let result = distr.sample(&mut rng);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, char::from_u32_unchecked(0x110000));",
          "    assert!(result.is_valid());",
          "    assert!(result > char::from_u32_unchecked(0xDFFF));",
          "    assert!(result <= char::from_u32_unchecked(0x10FFFF));",
          "    assert!(result.is_ascii() == false);",
          "    assert_ne!(result, char::from_u32_unchecked(0xD800));",
          "    assert_ne!(result, char::from_u32_unchecked(0xDFFF));"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        // Implement necessary Rng methods here.",
          "        fn random(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0x110000 }; // n is 0x110000 which is >= 0x110000",
          "    let distr: StandardUniform = StandardUniform;",
          "    let result = distr.sample(&mut rng);",
          "    assert_eq!(result, char::from_u32_unchecked(0x110000));",
          "    assert!(result.is_valid());",
          "    assert!(result > char::from_u32_unchecked(0xDFFF));",
          "    assert!(result <= char::from_u32_unchecked(0x10FFFF));",
          "    assert!(result.is_ascii() == false);",
          "    assert_ne!(result, char::from_u32_unchecked(0xD800));",
          "    assert_ne!(result, char::from_u32_unchecked(0xDFFF));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        // Implement necessary Rng methods here.",
          "        fn random(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0x10FFFF }; // n is 0x10FFFF, valid char value",
          "    let distr: StandardUniform = StandardUniform;",
          "    let result = distr.sample(&mut rng);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ascii() || (result >= '\\u{0}' && result < '\\u{D800}') || (result > '\\u{DFFF}' && result < '\\u{110000}'));",
          "    assert_eq!(result as u32, 0x10FFFF);",
          "    assert!(result as u32 >= 0 && result as u32 < 0x110000);",
          "    assert!(result as u32 != 0xD800);",
          "    assert!(result as u32 != 0xDFFF);",
          "    assert!(result != char::from_u32(0xD800).unwrap());",
          "    assert!(result != char::from_u32(0xDFFF).unwrap());"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        // Implement necessary Rng methods here.",
          "        fn random(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0x10FFFF }; // n is 0x10FFFF, valid char value",
          "    let distr: StandardUniform = StandardUniform;",
          "    let result = distr.sample(&mut rng);",
          "    assert!(result.is_ascii() || (result >= '\\u{0}' && result < '\\u{D800}') || (result > '\\u{DFFF}' && result < '\\u{110000}'));",
          "    assert_eq!(result as u32, 0x10FFFF);",
          "    assert!(result as u32 >= 0 && result as u32 < 0x110000);",
          "    assert!(result as u32 != 0xD800);",
          "    assert!(result as u32 != 0xDFFF);",
          "    assert!(result != char::from_u32(0xD800).unwrap());",
          "    assert!(result != char::from_u32(0xDFFF).unwrap());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]