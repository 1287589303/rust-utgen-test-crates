[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize) + 1).collect();",
          "    let amount = 0; ",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "}"
        ],
        "oracle": [
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 0;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.0, &mut []);",
          "    assert_eq!(result.1, &mut slice[..]);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 1;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize) - 1);",
          "    assert_eq!(result.0.len(), 1);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = (u32::MAX as usize) - 1;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.1.len(), 1);",
          "    assert_eq!(result.0.len(), (u32::MAX as usize) - 1);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 100;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.1.len(), 100);",
          "    assert_eq!(result.0.len(), (u32::MAX as usize) - 100);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize + 1)).collect();",
          "    let amount = 1;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert!(result.0.len() > 0);",
          "    assert!(result.1.len() > 0);",
          "    assert!(result.0.len() + result.1.len() == (u32::MAX as usize + 1));",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize + 1)).collect();",
          "    let amount = (u32::MAX as usize);",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert!(result.1.is_empty());",
          "    assert!(result.0.len() == (u32::MAX as usize + 1));",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 0;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    for &i in result.1 {",
          "    assert!(slice.contains(&i));",
          "    }"
        ],
        "code": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize) + 1).collect();",
          "    let amount = 0; ",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 0;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.0, &mut []);",
          "    assert_eq!(result.1, &mut slice[..]);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 1;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize) - 1);",
          "    assert_eq!(result.0.len(), 1);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = (u32::MAX as usize) - 1;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.1.len(), 1);",
          "    assert_eq!(result.0.len(), (u32::MAX as usize) - 1);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 100;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.1.len(), 100);",
          "    assert_eq!(result.0.len(), (u32::MAX as usize) - 100);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize + 1)).collect();",
          "    let amount = 1;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert!(result.0.len() > 0);",
          "    assert!(result.1.len() > 0);",
          "    assert!(result.0.len() + result.1.len() == (u32::MAX as usize + 1));",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize + 1)).collect();",
          "    let amount = (u32::MAX as usize);",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert!(result.1.is_empty());",
          "    assert!(result.0.len() == (u32::MAX as usize + 1));",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 0;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    for &i in result.1 {",
          "    assert!(slice.contains(&i));",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 0; ",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "}"
        ],
        "oracle": [
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 0;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize));",
          "    assert_eq!(result.0.as_ptr(), slice.as_ptr().add((u32::MAX as usize)));",
          "    assert_eq!(result.1.as_ptr(), slice.as_ptr());",
          "    assert!(result.1.iter().copied().eq(slice.iter().copied()));",
          "    assert!(result.0.is_empty());",
          "    assert!(result.1.len() == (u32::MAX as usize));",
          "    assert!(slice.len() == (u32::MAX as usize));",
          "    let amount = 1;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.0.len(), 1);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize - 1));",
          "    assert!(result.1.iter().copied().all(|x| x != result.0[0]));"
        ],
        "code": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 0; ",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = 0;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize));",
          "    assert_eq!(result.0.as_ptr(), slice.as_ptr().add((u32::MAX as usize)));",
          "    assert_eq!(result.1.as_ptr(), slice.as_ptr());",
          "    assert!(result.1.iter().copied().eq(slice.iter().copied()));",
          "    assert!(result.0.is_empty());",
          "    assert!(result.1.len() == (u32::MAX as usize));",
          "    assert!(slice.len() == (u32::MAX as usize));",
          "    let amount = 1;",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.0.len(), 1);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize - 1));",
          "    assert!(result.1.iter().copied().all(|x| x != result.0[0]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = (u32::MAX as usize) - 1; ",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.0.len(), 1);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize) - 1);",
          "    assert!(result.1.iter().all(|&x| x < (u32::MAX as usize)));",
          "    assert!(result.0.iter().all(|&x| x >= (u32::MAX as usize)));",
          "    assert_eq!(result.1[0], (u32::MAX as usize) - 1);",
          "    assert!(result.0.first().is_some());",
          "    assert!(result.0.first().unwrap() >= &0);",
          "    assert!(result.1.contains(&(u32::MAX as usize - 1)));",
          "    assert!(result.1.contains(&(u32::MAX as usize - 2)));",
          "    assert!(result.1.contains(&(u32::MAX as usize - 3)));",
          "    assert!(result.1.len() + result.0.len() == (u32::MAX as usize));",
          "    assert!(result.0.len() <= (u32::MAX as usize));"
        ],
        "code": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let amount = (u32::MAX as usize) - 1; ",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    assert_eq!(result.0.len(), 1);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize) - 1);",
          "    assert!(result.1.iter().all(|&x| x < (u32::MAX as usize)));",
          "    assert!(result.0.iter().all(|&x| x >= (u32::MAX as usize)));",
          "    assert_eq!(result.1[0], (u32::MAX as usize) - 1);",
          "    assert!(result.0.first().is_some());",
          "    assert!(result.0.first().unwrap() >= &0);",
          "    assert!(result.1.contains(&(u32::MAX as usize - 1)));",
          "    assert!(result.1.contains(&(u32::MAX as usize - 2)));",
          "    assert!(result.1.contains(&(u32::MAX as usize - 3)));",
          "    assert!(result.1.len() + result.0.len() == (u32::MAX as usize));",
          "    assert!(result.0.len() <= (u32::MAX as usize));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize) + 2).collect();",
          "    let amount = 1; ",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "}"
        ],
        "oracle": [
          "    let slice_length = (u32::MAX as usize) + 2;",
          "    assert_eq!(slice.len(), slice_length);",
          "    assert!(result.0.len() > 0);",
          "    assert_eq!(result.1.len(), amount);",
          "    assert_eq!(result.0.len() + result.1.len(), slice_length);",
          "    let m = slice_length.saturating_sub(amount);",
          "    assert!(m < slice_length);",
          "    assert!(result.0.len() == amount);",
          "    assert!(result.1.len() == m);",
          "    assert!(result.1.iter().all(|&x| slice.contains(&x)));",
          "    assert!(result.0.iter().all(|&x| slice.contains(&x)));"
        ],
        "code": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize) + 2).collect();",
          "    let amount = 1; ",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, amount);",
          "    let slice_length = (u32::MAX as usize) + 2;",
          "    assert_eq!(slice.len(), slice_length);",
          "    assert!(result.0.len() > 0);",
          "    assert_eq!(result.1.len(), amount);",
          "    assert_eq!(result.0.len() + result.1.len(), slice_length);",
          "    let m = slice_length.saturating_sub(amount);",
          "    assert!(m < slice_length);",
          "    assert!(result.0.len() == amount);",
          "    assert!(result.1.len() == m);",
          "    assert!(result.1.iter().all(|&x| slice.contains(&x)));",
          "    assert!(result.0.iter().all(|&x| slice.contains(&x)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, (u32::MAX as usize));",
          "}"
        ],
        "oracle": [
          "    let slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, (u32::MAX as usize));",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize));",
          "    assert!(result.1.iter().all(|&x| x < (u32::MAX as usize) as u32));",
          "    assert_eq!(slice.len(), (u32::MAX as usize));",
          "    assert!(slice.iter().all(|&x| x < (u32::MAX as usize) as u32));",
          "    let slice_len = slice.len();",
          "    for i in 0..slice_len {",
          "    let index = rng.random_range(..i + 1);",
          "    assert!(index < slice_len);",
          "    }",
          "    let m = slice_len.saturating_sub((u32::MAX as usize));",
          "    for i in m..slice_len {",
          "    let index = rng.random_range(..slice_len);",
          "    assert!(index < slice_len);",
          "    }"
        ],
        "code": [
          "{",
          "    let mut slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, (u32::MAX as usize));",
          "    let slice: Vec<u32> = (0..(u32::MAX as usize)).collect();",
          "    let rng = &mut rand::thread_rng();",
          "    let result = slice.partial_shuffle(rng, (u32::MAX as usize));",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1.len(), (u32::MAX as usize));",
          "    assert!(result.1.iter().all(|&x| x < (u32::MAX as usize) as u32));",
          "    assert_eq!(slice.len(), (u32::MAX as usize));",
          "    assert!(slice.iter().all(|&x| x < (u32::MAX as usize) as u32));",
          "    let slice_len = slice.len();",
          "    for i in 0..slice_len {",
          "    let index = rng.random_range(..i + 1);",
          "    assert!(index < slice_len);",
          "    }",
          "    let m = slice_len.saturating_sub((u32::MAX as usize));",
          "    for i in m..slice_len {",
          "    let index = rng.random_range(..slice_len);",
          "    assert!(index < slice_len);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]