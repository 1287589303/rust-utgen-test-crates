[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = [1, 2, 3, 4, 5];",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "}"
        ],
        "oracle": [
          "    let mut data = [1, 2, 3, 4, 5];",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    assert_eq!(result.0, []);",
          "    assert_eq!(result.1, [1, 2, 3, 4, 5]);",
          "    assert!(data.len() == 5);"
        ],
        "code": [
          "{",
          "    let mut data = [1, 2, 3, 4, 5];",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    let mut data = [1, 2, 3, 4, 5];",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    assert_eq!(result.0, []);",
          "    assert_eq!(result.1, [1, 2, 3, 4, 5]);",
          "    assert!(data.len() == 5);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = [42];",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "}"
        ],
        "oracle": [
          "    let mut data = [42];",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1, &mut data);",
          "    assert_eq!(result.1.len(), 1);"
        ],
        "code": [
          "{",
          "    let mut data = [42];",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    let mut data = [42];",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1, &mut data);",
          "    assert_eq!(result.1.len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data: Vec<i32> = Vec::new();",
          "    let amount = 0;",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "}"
        ],
        "oracle": [
          "    let mut data: Vec<i32> = Vec::new();",
          "    let amount = 0;",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1.len(), 0);"
        ],
        "code": [
          "{",
          "    let mut data: Vec<i32> = Vec::new();",
          "    let amount = 0;",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    let mut data: Vec<i32> = Vec::new();",
          "    let amount = 0;",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data: Vec<i32> = (1..100).collect();",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "}"
        ],
        "oracle": [
          "    let mut data: Vec<i32> = (1..100).collect();",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1.len(), amount);",
          "    assert_eq!(data.len(), amount);",
          "    assert!(data.iter().all(|&x| (1..100).contains(&x)));"
        ],
        "code": [
          "{",
          "    let mut data: Vec<i32> = (1..100).collect();",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    let mut data: Vec<i32> = (1..100).collect();",
          "    let amount = data.len();",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    assert_eq!(result.0.len(), 0);",
          "    assert_eq!(result.1.len(), amount);",
          "    assert_eq!(data.len(), amount);",
          "    assert!(data.iter().all(|&x| (1..100).contains(&x)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = [1, 2, 3];",
          "    let amount = 1;",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "}"
        ],
        "oracle": [
          "    result.0.len() == 1",
          "    result.1.len() == 2",
          "    result.0[0] == 3",
          "    result.1.contains(&1)",
          "    result.1.contains(&2)",
          "    result.0[0] != result.1[0]",
          "    result.0[0] != result.1[1]"
        ],
        "code": [
          "{",
          "    let mut data = [1, 2, 3];",
          "    let amount = 1;",
          "    let mut rng = rand::thread_rng();",
          "    let result = data.partial_shuffle(&mut rng, amount);",
          "    result.0.len() == 1",
          "    result.1.len() == 2",
          "    result.0[0] == 3",
          "    result.1.contains(&1)",
          "    result.1.contains(&2)",
          "    result.0[0] != result.1[0]",
          "    result.0[0] != result.1[1]",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]