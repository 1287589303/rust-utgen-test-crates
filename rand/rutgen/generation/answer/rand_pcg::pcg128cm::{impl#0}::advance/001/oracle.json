[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(1, 1);",
          "    rng.advance(1); // delta = 1, odd",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, expected_state_after_advance_with_delta_1);",
          "    rng.advance(2); // delta = 2, even",
          "    assert_eq!(rng.state, expected_state_after_advance_with_delta_2);",
          "    rng.advance(3); // delta = 3, odd",
          "    assert_eq!(rng.state, expected_state_after_advance_with_delta_3);",
          "    rng.advance(0); // delta = 0, mdelta > 0 condition is false",
          "    assert_eq!(rng.state, expected_state_after_advance_with_delta_0);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(1, 1);",
          "    rng.advance(1); // delta = 1, odd",
          "    assert_eq!(rng.state, expected_state_after_advance_with_delta_1);",
          "    rng.advance(2); // delta = 2, even",
          "    assert_eq!(rng.state, expected_state_after_advance_with_delta_2);",
          "    rng.advance(3); // delta = 3, odd",
          "    assert_eq!(rng.state, expected_state_after_advance_with_delta_3);",
          "    rng.advance(0); // delta = 0, mdelta > 0 condition is false",
          "    assert_eq!(rng.state, expected_state_after_advance_with_delta_0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(2, 2);",
          "    rng.advance(2); // delta = 2, even",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, expected_state_after_advance_with_positive_delta); // Check state after advancing with positive delta",
          "    assert_eq!(rng.increment, expected_increment); // Verify that increment remains unchanged",
          "    assert_eq!(rng.state, initial_state + MULTIPLIER * initial_state + increment); // Verify RV post-advance for delta > 0",
          "    rng.advance(0); // delta = 0, should not change state",
          "    assert_eq!(rng.state, unchanged_state); // Ensure state remains the same after advancing with delta = 0"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(2, 2);",
          "    rng.advance(2); // delta = 2, even",
          "    assert_eq!(rng.state, expected_state_after_advance_with_positive_delta); // Check state after advancing with positive delta",
          "    assert_eq!(rng.increment, expected_increment); // Verify that increment remains unchanged",
          "    assert_eq!(rng.state, initial_state + MULTIPLIER * initial_state + increment); // Verify RV post-advance for delta > 0",
          "    rng.advance(0); // delta = 0, should not change state",
          "    assert_eq!(rng.state, unchanged_state); // Ensure state remains the same after advancing with delta = 0",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(u128::MAX - 1, 3);",
          "    rng.advance(u128::MAX); // delta = maximum valid u128",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, expected_state_after_max_delta);",
          "    rng.advance(1);",
          "    assert_eq!(rng.state, expected_state_after_increment);",
          "    rng.advance(0);",
          "    assert_eq!(rng.state, rng.state);",
          "    rng.advance(2);",
          "    assert_eq!(rng.state, expected_state_after_delta_2);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(u128::MAX - 1, 3);",
          "    rng.advance(u128::MAX); // delta = maximum valid u128",
          "    assert_eq!(rng.state, expected_state_after_max_delta);",
          "    rng.advance(1);",
          "    assert_eq!(rng.state, expected_state_after_increment);",
          "    rng.advance(0);",
          "    assert_eq!(rng.state, rng.state);",
          "    rng.advance(2);",
          "    assert_eq!(rng.state, expected_state_after_delta_2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(0, 4);",
          "    rng.advance(0); // boundary case, delta = 0",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 0); // ensure state remains unchanged for delta = 0",
          "    rng.advance(1); // test with delta = 1",
          "    assert!(rng.state > 0); // ensure state changes for delta = 1",
          "    assert_eq!(rng.increment, 9); // verify increment is correct after new instance with stream 4",
          "    rng.advance(u128::MAX); // test with maximum delta",
          "    assert!(rng.state > 0); // ensure state changes for maximum delta",
          "    rng.advance(2); // test with delta that only alters the state",
          "    assert!(rng.state > 0); // ensure state changes for delta = 2"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(0, 4);",
          "    rng.advance(0); // boundary case, delta = 0",
          "    assert_eq!(rng.state, 0); // ensure state remains unchanged for delta = 0",
          "    rng.advance(1); // test with delta = 1",
          "    assert!(rng.state > 0); // ensure state changes for delta = 1",
          "    assert_eq!(rng.increment, 9); // verify increment is correct after new instance with stream 4",
          "    rng.advance(u128::MAX); // test with maximum delta",
          "    assert!(rng.state > 0); // ensure state changes for maximum delta",
          "    rng.advance(2); // test with delta that only alters the state",
          "    assert!(rng.state > 0); // ensure state changes for delta = 2",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]