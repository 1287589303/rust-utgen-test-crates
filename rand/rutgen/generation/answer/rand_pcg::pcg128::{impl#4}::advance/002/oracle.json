[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Mcg128Xsl64::new(12345);",
          "    rng.advance(5);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 12345); // Check state after advancing with delta = 5, mdelta should be > 0 at line 198 is true",
          "    ",
          "    let mut rng = Mcg128Xsl64::new(12345);",
          "    rng.advance(6); // The value of mdelta = 6 leads to (mdelta & 1) != 0 being false which means iterations on both sides.",
          "    assert_eq!(rng.state, 67890); // Dummy expected state for delta = 6, replace with actual expected state.",
          "    ",
          "    let mut rng = Mcg128Xsl64::new(12345);",
          "    rng.advance(0); // Check when delta is 0, mdelta > 0 at line 198 is false",
          "    assert_eq!(rng.state, 12345); // State should remain unchanged for delta = 0."
        ],
        "code": [
          "{",
          "    let mut rng = Mcg128Xsl64::new(12345);",
          "    rng.advance(5);",
          "    assert_eq!(rng.state, 12345); // Check state after advancing with delta = 5, mdelta should be > 0 at line 198 is true",
          "    ",
          "    let mut rng = Mcg128Xsl64::new(12345);",
          "    rng.advance(6); // The value of mdelta = 6 leads to (mdelta & 1) != 0 being false which means iterations on both sides.",
          "    assert_eq!(rng.state, 67890); // Dummy expected state for delta = 6, replace with actual expected state.",
          "    ",
          "    let mut rng = Mcg128Xsl64::new(12345);",
          "    rng.advance(0); // Check when delta is 0, mdelta > 0 at line 198 is false",
          "    assert_eq!(rng.state, 12345); // State should remain unchanged for delta = 0.",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Mcg128Xsl64::new(67890);",
          "    rng.advance(4);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_4);",
          "    rng.advance(0);",
          "    assert_eq!(rng.state, 67891); // state should remain unchanged when delta is 0",
          "    rng.advance(1);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_1);",
          "    rng.advance(2);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_2);",
          "    rng.advance(3);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_3);",
          "    rng.advance(5);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_5);",
          "    rng.advance(std::u128::MAX);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_max);",
          "    rng.advance(0); // checking for no change",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_4);  // should still match expected_state_after_advance_with_mdelta_4"
        ],
        "code": [
          "{",
          "    let mut rng = Mcg128Xsl64::new(67890);",
          "    rng.advance(4);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_4);",
          "    rng.advance(0);",
          "    assert_eq!(rng.state, 67891); // state should remain unchanged when delta is 0",
          "    rng.advance(1);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_1);",
          "    rng.advance(2);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_2);",
          "    rng.advance(3);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_3);",
          "    rng.advance(5);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_5);",
          "    rng.advance(std::u128::MAX);",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_max);",
          "    rng.advance(0); // checking for no change",
          "    assert_eq!(rng.state, expected_state_after_advance_with_mdelta_4);  // should still match expected_state_after_advance_with_mdelta_4",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Mcg128Xsl64::new(13579);",
          "    rng.advance(0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 13579 | 1);",
          "    let mut rng = Mcg128Xsl64::new(13579);",
          "    rng.advance(1);",
          "    assert!(rng.state > 13579 | 1);",
          "    let mut rng = Mcg128Xsl64::new(1);",
          "    rng.advance(2);",
          "    assert!(rng.state > 1);",
          "    let mut rng = Mcg128Xsl64::new(15);",
          "    rng.advance(3);",
          "    assert!(rng.state > 15);",
          "    let mut rng = Mcg128Xsl64::new(0);",
          "    rng.advance(10);",
          "    assert!(rng.state > 0);"
        ],
        "code": [
          "{",
          "    let mut rng = Mcg128Xsl64::new(13579);",
          "    rng.advance(0);",
          "    assert_eq!(rng.state, 13579 | 1);",
          "    let mut rng = Mcg128Xsl64::new(13579);",
          "    rng.advance(1);",
          "    assert!(rng.state > 13579 | 1);",
          "    let mut rng = Mcg128Xsl64::new(1);",
          "    rng.advance(2);",
          "    assert!(rng.state > 1);",
          "    let mut rng = Mcg128Xsl64::new(15);",
          "    rng.advance(3);",
          "    assert!(rng.state > 15);",
          "    let mut rng = Mcg128Xsl64::new(0);",
          "    rng.advance(10);",
          "    assert!(rng.state > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]