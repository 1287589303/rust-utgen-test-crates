[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u8,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
          "            self.value = range.start; // set to minimum for testing",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0 };",
          "    let alphabetic = Alphabetic;",
          "    let result = alphabetic.sample(&mut rng);",
          "}"
        ],
        "oracle": [
          "    let mut rng = MockRng { value: 0 };",
          "    let alphabetic = Alphabetic;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'A');",
          "    rng.value = 25;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'Z');",
          "    rng.value = 26;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'a');",
          "    rng.value = 51;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'z');",
          "    rng.value = 27;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert!(result >= b'A' && result <= b'z');",
          "    rng.value = 24;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'Y');"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u8,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
          "            self.value = range.start; // set to minimum for testing",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0 };",
          "    let alphabetic = Alphabetic;",
          "    let result = alphabetic.sample(&mut rng);",
          "    let mut rng = MockRng { value: 0 };",
          "    let alphabetic = Alphabetic;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'A');",
          "    rng.value = 25;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'Z');",
          "    rng.value = 26;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'a');",
          "    rng.value = 51;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'z');",
          "    rng.value = 27;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert!(result >= b'A' && result <= b'z');",
          "    rng.value = 24;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'Y');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u8,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
          "            self.value = range.end - 1; // set to maximum for testing",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0 };",
          "    let alphabetic = Alphabetic;",
          "    let result = alphabetic.sample(&mut rng);",
          "}"
        ],
        "oracle": [
          "    assert!(result >= b'A' && result <= b'z', \"Result out of bounds: {}\", result);",
          "    assert!(result < 128, \"Result exceeds valid ASCII range: {}\", result);",
          "    assert!(result > b'Z' || result < b'a', \"Result does not correctly handle character wrapping: {}\", result);",
          "    assert_eq!(result, b'Z' + 1 + (b'a' - b'Z' - 1), \"Unexpected result for upper-case overflow: {}\", result);"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u8,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
          "            self.value = range.end - 1; // set to maximum for testing",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0 };",
          "    let alphabetic = Alphabetic;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert!(result >= b'A' && result <= b'z', \"Result out of bounds: {}\", result);",
          "    assert!(result < 128, \"Result exceeds valid ASCII range: {}\", result);",
          "    assert!(result > b'Z' || result < b'a', \"Result does not correctly handle character wrapping: {}\", result);",
          "    assert_eq!(result, b'Z' + 1 + (b'a' - b'Z' - 1), \"Unexpected result for upper-case overflow: {}\", result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u8,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
          "            self.value = range.start + 26; // test middle of the range",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0 };",
          "    let alphabetic = Alphabetic;",
          "    let result = alphabetic.sample(&mut rng);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, b'Z' + (b'Z' > b'Z') as u8 * (b'a' - b'Z' - 1));",
          "    assert!(result >= b'A' && result <= b'z');",
          "    assert!(result < 52);",
          "    assert_eq!(result, b'Z' + (1) * (b'a' - b'Z' - 1));",
          "    assert_eq!(result, b'a');",
          "    assert!(result >= b'A' && result <= b'z');",
          "    assert_eq!(result, b'Z' + (0) * (b'a' - b'Z' - 1));",
          "    assert_eq!(result, b'Z');"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u8,",
          "    }",
          "",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
          "            self.value = range.start + 26; // test middle of the range",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 0 };",
          "    let alphabetic = Alphabetic;",
          "    let result = alphabetic.sample(&mut rng);",
          "    assert_eq!(result, b'Z' + (b'Z' > b'Z') as u8 * (b'a' - b'Z' - 1));",
          "    assert!(result >= b'A' && result <= b'z');",
          "    assert!(result < 52);",
          "    assert_eq!(result, b'Z' + (1) * (b'a' - b'Z' - 1));",
          "    assert_eq!(result, b'a');",
          "    assert!(result >= b'A' && result <= b'z');",
          "    assert_eq!(result, b'Z' + (0) * (b'a' - b'Z' - 1));",
          "    assert_eq!(result, b'Z');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]