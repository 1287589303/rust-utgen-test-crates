[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng;",
          "    ",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            42 // Arbitrary fixed value",
          "        }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, dest: &mut [u8]) {}",
          "    }",
          "    ",
          "    impl Rng for TestRng {}",
          "",
          "    let rng = SmallRng(TestRng);",
          "    let result = rng.next_u32();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 42);"
        ],
        "code": [
          "{",
          "    struct TestRng;",
          "    ",
          "    impl RngCore for TestRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            42 // Arbitrary fixed value",
          "        }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, dest: &mut [u8]) {}",
          "    }",
          "    ",
          "    impl Rng for TestRng {}",
          "",
          "    let rng = SmallRng(TestRng);",
          "    let result = rng.next_u32();",
          "    assert_eq!(result, 42);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct CounterRng {",
          "        count: u32,",
          "    }",
          "    ",
          "    impl RngCore for CounterRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.count += 1;",
          "            self.count",
          "        }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, dest: &mut [u8]) {}",
          "    }",
          "    ",
          "    impl Rng for CounterRng {}",
          "",
          "    let mut rng = SmallRng(CounterRng { count: 0 });",
          "    let result1 = rng.next_u32();",
          "    let result2 = rng.next_u32();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result1, 1);",
          "    assert_eq!(result2, 2);"
        ],
        "code": [
          "{",
          "    struct CounterRng {",
          "        count: u32,",
          "    }",
          "    ",
          "    impl RngCore for CounterRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.count += 1;",
          "            self.count",
          "        }",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, dest: &mut [u8]) {}",
          "    }",
          "    ",
          "    impl Rng for CounterRng {}",
          "",
          "    let mut rng = SmallRng(CounterRng { count: 0 });",
          "    let result1 = rng.next_u32();",
          "    let result2 = rng.next_u32();",
          "    assert_eq!(result1, 1);",
          "    assert_eq!(result2, 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct EdgeRng {",
          "        toggle: bool,",
          "    }",
          "    ",
          "    impl RngCore for EdgeRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            if self.toggle {",
          "                u32::MAX // Maximum value",
          "            } else {",
          "                u32::MIN // Minimum value",
          "            }",
          "        }",
          "        ",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, dest: &mut [u8]) {}",
          "    }",
          "    ",
          "    impl Rng for EdgeRng {}",
          "",
          "    let mut rng = SmallRng(EdgeRng { toggle: false });",
          "    let min_result = rng.next_u32();",
          "    rng.0.toggle = true; // Change internal state",
          "    let max_result = rng.next_u32();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(min_result, u32::MIN);",
          "    assert_eq!(max_result, u32::MAX);"
        ],
        "code": [
          "{",
          "    struct EdgeRng {",
          "        toggle: bool,",
          "    }",
          "    ",
          "    impl RngCore for EdgeRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            if self.toggle {",
          "                u32::MAX // Maximum value",
          "            } else {",
          "                u32::MIN // Minimum value",
          "            }",
          "        }",
          "        ",
          "        fn next_u64(&mut self) -> u64 { 0 }",
          "        fn fill_bytes(&mut self, dest: &mut [u8]) {}",
          "    }",
          "    ",
          "    impl Rng for EdgeRng {}",
          "",
          "    let mut rng = SmallRng(EdgeRng { toggle: false });",
          "    let min_result = rng.next_u32();",
          "    rng.0.toggle = true; // Change internal state",
          "    let max_result = rng.next_u32();",
          "    assert_eq!(min_result, u32::MIN);",
          "    assert_eq!(max_result, u32::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]