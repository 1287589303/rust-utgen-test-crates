[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seed: [u8; 32] = [0; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "}"
        ],
        "oracle": [
          "    let seed: [u8; 32] = [0; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 0);",
          "    assert_eq!(rng.increment, 1);",
          "    assert_eq!(rng.increment & 1, 1);",
          "    let seed: [u8; 32] = [1; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 11529215046068469761);",
          "    assert_eq!(rng.increment, 11529215046068469763);",
          "    assert_eq!(rng.increment & 1, 1);",
          "    let seed: [u8; 32] = [255; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 18446744073709551615);",
          "    assert_eq!(rng.increment, 18446744073709551617);",
          "    assert_eq!(rng.increment & 1, 1);",
          "    let seed: [u8; 32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 1);",
          "    assert_eq!(rng.increment, 3);",
          "    assert_eq!(rng.increment & 1, 1);"
        ],
        "code": [
          "{",
          "    let seed: [u8; 32] = [0; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    let seed: [u8; 32] = [0; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 0);",
          "    assert_eq!(rng.increment, 1);",
          "    assert_eq!(rng.increment & 1, 1);",
          "    let seed: [u8; 32] = [1; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 11529215046068469761);",
          "    assert_eq!(rng.increment, 11529215046068469763);",
          "    assert_eq!(rng.increment & 1, 1);",
          "    let seed: [u8; 32] = [255; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 18446744073709551615);",
          "    assert_eq!(rng.increment, 18446744073709551617);",
          "    assert_eq!(rng.increment & 1, 1);",
          "    let seed: [u8; 32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 1);",
          "    assert_eq!(rng.increment, 3);",
          "    assert_eq!(rng.increment & 1, 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seed: [u8; 32] = [255; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, expected_state);",
          "    assert_eq!(rng.increment, expected_increment);",
          "    assert_eq!(rng.state % 2, 1);   // Check if increment is odd",
          "    assert_eq!(rng.increment & 1, 1);  // Ensure lowest bit of increment is set to 1",
          "    assert_eq!(rng.state, u128::from(255u64) | (u128::from(255u64) << 64));  // Check initial state",
          "    assert_eq!(rng.increment, u128::from(255u64) | (u128::from(255u64) << 64) | 1);  // Check initial increment"
        ],
        "code": [
          "{",
          "    let seed: [u8; 32] = [255; 32];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, expected_state);",
          "    assert_eq!(rng.increment, expected_increment);",
          "    assert_eq!(rng.state % 2, 1);   // Check if increment is odd",
          "    assert_eq!(rng.increment & 1, 1);  // Ensure lowest bit of increment is set to 1",
          "    assert_eq!(rng.state, u128::from(255u64) | (u128::from(255u64) << 64));  // Check initial state",
          "    assert_eq!(rng.increment, u128::from(255u64) | (u128::from(255u64) << 64) | 1);  // Check initial increment",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seed: [u8; 32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "}"
        ],
        "oracle": [
          "    let expected_state = 0u128; // Calculate expected state from seed[0] and seed[1]",
          "    let expected_increment = 1u128; // Increment derived from seed[2] and seed[3] should be odd",
          "    assert_eq!(rng.state, expected_state);",
          "    assert_eq!(rng.increment, expected_increment);"
        ],
        "code": [
          "{",
          "    let seed: [u8; 32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    let expected_state = 0u128; // Calculate expected state from seed[0] and seed[1]",
          "    let expected_increment = 1u128; // Increment derived from seed[2] and seed[3] should be odd",
          "    assert_eq!(rng.state, expected_state);",
          "    assert_eq!(rng.increment, expected_increment);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seed: [u8; 32] = [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 0x0000000000000001_0000000000000000);",
          "    assert_eq!(rng.increment, 0x0000000000000001);",
          "    assert_eq!(rng.increment & 1, 1);",
          "    assert_eq!(rng.state & 1, 0);"
        ],
        "code": [
          "{",
          "    let seed: [u8; 32] = [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 0x0000000000000001_0000000000000000);",
          "    assert_eq!(rng.increment, 0x0000000000000001);",
          "    assert_eq!(rng.increment & 1, 1);",
          "    assert_eq!(rng.state & 1, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seed: [u8; 32] = [0; 31];",
          "    let seed: [u8; 32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 1);",
          "    assert_eq!(rng.increment % 2, 1);",
          "    assert_eq!(rng.increment >> 1, 0);",
          "    assert_eq!(rng.increment, 1);",
          "    assert_ne!(rng.state & 1, 0);"
        ],
        "code": [
          "{",
          "    let seed: [u8; 32] = [0; 31];",
          "    let seed: [u8; 32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    assert_eq!(rng.state, 1);",
          "    assert_eq!(rng.increment % 2, 1);",
          "    assert_eq!(rng.increment >> 1, 0);",
          "    assert_eq!(rng.increment, 1);",
          "    assert_ne!(rng.state & 1, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seed: [u8; 32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "}"
        ],
        "oracle": [
          "    let expected_state: u128 = 0;",
          "    let expected_increment: u128 = 1;",
          "    assert_eq!(rng.state, expected_state);",
          "    assert_eq!(rng.increment, expected_increment);",
          "    let seed: [u8; 32] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32];",
          "    let rng2 = Lcg128CmDxsm64::from_seed(seed);",
          "    let expected_state2: u128 = u128::from_le_bytes([1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0]);",
          "    let expected_increment2: u128 = (u128::from_le_bytes([9, 10, 11, 12, 13, 14, 15, 16]) << 1) | 1;",
          "    assert_eq!(rng2.state, expected_state2);",
          "    assert_eq!(rng2.increment, expected_increment2);"
        ],
        "code": [
          "{",
          "    let seed: [u8; 32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0];",
          "    let rng = Lcg128CmDxsm64::from_seed(seed);",
          "    let expected_state: u128 = 0;",
          "    let expected_increment: u128 = 1;",
          "    assert_eq!(rng.state, expected_state);",
          "    assert_eq!(rng.increment, expected_increment);",
          "    let seed: [u8; 32] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32];",
          "    let rng2 = Lcg128CmDxsm64::from_seed(seed);",
          "    let expected_state2: u128 = u128::from_le_bytes([1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0]);",
          "    let expected_increment2: u128 = (u128::from_le_bytes([9, 10, 11, 12, 13, 14, 15, 16]) << 1) | 1;",
          "    assert_eq!(rng2.state, expected_state2);",
          "    assert_eq!(rng2.increment, expected_increment2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]