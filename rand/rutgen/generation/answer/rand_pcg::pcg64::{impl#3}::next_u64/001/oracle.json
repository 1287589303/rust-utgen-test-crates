[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };",
          "    let _result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 0);",
          "    assert_eq!(rng.increment, 0);",
          "    assert!(result.is::<u64>());",
          "    assert!(result >= 0);",
          "    assert!(result <= u64::MAX);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };",
          "    let _result = rng.next_u64();",
          "    assert_eq!(rng.state, 0);",
          "    assert_eq!(rng.increment, 0);",
          "    assert!(result.is::<u64>());",
          "    assert!(result >= 0);",
          "    assert!(result <= u64::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };",
          "    let _result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, expected_value);",
          "    assert_eq!(rng.state, expected_state);",
          "    assert_eq!(rng.increment, expected_increment);",
          "    assert!(rng.next_u64() >= 0);",
          "    assert!(rng.next_u64() <= u64::MAX);",
          "    assert_ne!(rng.next_u64(), rng.next_u64());",
          "    assert_eq!(rng.state, state_after_first_call);",
          "    assert_eq!(rng.increment, increment_after_first_call);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };",
          "    let _result = rng.next_u64();",
          "    assert_eq!(_result, expected_value);",
          "    assert_eq!(rng.state, expected_state);",
          "    assert_eq!(rng.increment, expected_increment);",
          "    assert!(rng.next_u64() >= 0);",
          "    assert!(rng.next_u64() <= u64::MAX);",
          "    assert_ne!(rng.next_u64(), rng.next_u64());",
          "    assert_eq!(rng.state, state_after_first_call);",
          "    assert_eq!(rng.increment, increment_after_first_call);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX / 2, increment: u64::MAX / 2 };",
          "    let _result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX / 2, increment: u64::MAX / 2 };",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, expected_value);",
          "    assert!(result >= 0);",
          "    assert!(result <= u64::MAX);",
          "    rng.fill_bytes(&mut [0; 16]);",
          "    assert!(!rng.state.is_nan());",
          "    assert!(!rng.increment.is_nan());"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX / 2, increment: u64::MAX / 2 };",
          "    let _result = rng.next_u64();",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX / 2, increment: u64::MAX / 2 };",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, expected_value);",
          "    assert!(result >= 0);",
          "    assert!(result <= u64::MAX);",
          "    rng.fill_bytes(&mut [0; 16]);",
          "    assert!(!rng.state.is_nan());",
          "    assert!(!rng.increment.is_nan());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: u64::MAX };",
          "    let _result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: u64::MAX };",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, expected_value);",
          "    assert!(result >= 0);",
          "    assert!(result <= u64::MAX);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: u64::MAX };",
          "    let _result = rng.next_u64();",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: u64::MAX };",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, expected_value);",
          "    assert!(result >= 0);",
          "    assert!(result <= u64::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: 0 };",
          "    let _result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, expected_value);",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };",
          "    assert_eq!(rng.next_u64(), 0);",
          "    let mut rng = Lcg64Xsh32 { state: 1, increment: 0 };",
          "    assert_ne!(rng.next_u64(), 1);",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: 1 };",
          "    assert_ne!(rng.next_u64(), 0);",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };",
          "    let result = rng.next_u64();",
          "    assert!(result < u64::MAX);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: 0 };",
          "    let _result = rng.next_u64();",
          "    assert_eq!(_result, expected_value);",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };",
          "    assert_eq!(rng.next_u64(), 0);",
          "    let mut rng = Lcg64Xsh32 { state: 1, increment: 0 };",
          "    assert_ne!(rng.next_u64(), 1);",
          "    let mut rng = Lcg64Xsh32 { state: 0, increment: 1 };",
          "    assert_ne!(rng.next_u64(), 0);",
          "    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };",
          "    let result = rng.next_u64();",
          "    assert!(result < u64::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]