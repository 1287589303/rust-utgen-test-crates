[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockMach;",
          "    impl Machine for MockMach {",
          "        type u32x4 = [u32; 4];",
          "        type u64x2 = [u64; 2];",
          "        fn unpack(&self, d: [u32; 4]) -> [u64; 2] {",
          "            [d[0] as u64, d[1] as u64]",
          "        }",
          "        fn vec(&self, arr: [u64; 2]) -> [u64; 2] {",
          "            arr",
          "        }",
          "    }",
          "",
          "    let mach = MockMach;",
          "    let d = [0, 0, 0, 0];",
          "    let i = 0;",
          "    add_pos(mach, d, i);",
          "}"
        ],
        "oracle": [
          "    let mach = MockMach;",
          "    let d = [0, 0, 0, 0];",
          "    let i = 1;",
          "    assert_eq!(add_pos(mach, d, i), [1, 0]);",
          "    let d = [1, 2, 3, 4];",
          "    let i = 2;",
          "    assert_eq!(add_pos(mach, d, i), [3, 2]);",
          "    let d = [u32::MAX, u32::MAX, u32::MAX, u32::MAX];",
          "    let i = 1;",
          "    assert_eq!(add_pos(mach, d, i), [u32::MAX as u64 + 1, u32::MAX as u64]);",
          "    let d = [10, 20, 30, 40];",
          "    let i = 5;",
          "    assert_eq!(add_pos(mach, d, i), [15, 20]);",
          "    let d = [u32::MAX, 0, 0, 0];",
          "    let i = 0;",
          "    assert_eq!(add_pos(mach, d, i), [u32::MAX as u64, 0]);"
        ],
        "code": [
          "{",
          "    struct MockMach;",
          "    impl Machine for MockMach {",
          "        type u32x4 = [u32; 4];",
          "        type u64x2 = [u64; 2];",
          "        fn unpack(&self, d: [u32; 4]) -> [u64; 2] {",
          "            [d[0] as u64, d[1] as u64]",
          "        }",
          "        fn vec(&self, arr: [u64; 2]) -> [u64; 2] {",
          "            arr",
          "        }",
          "    }",
          "",
          "    let mach = MockMach;",
          "    let d = [0, 0, 0, 0];",
          "    let i = 0;",
          "    add_pos(mach, d, i);",
          "    let mach = MockMach;",
          "    let d = [0, 0, 0, 0];",
          "    let i = 1;",
          "    assert_eq!(add_pos(mach, d, i), [1, 0]);",
          "    let d = [1, 2, 3, 4];",
          "    let i = 2;",
          "    assert_eq!(add_pos(mach, d, i), [3, 2]);",
          "    let d = [u32::MAX, u32::MAX, u32::MAX, u32::MAX];",
          "    let i = 1;",
          "    assert_eq!(add_pos(mach, d, i), [u32::MAX as u64 + 1, u32::MAX as u64]);",
          "    let d = [10, 20, 30, 40];",
          "    let i = 5;",
          "    assert_eq!(add_pos(mach, d, i), [15, 20]);",
          "    let d = [u32::MAX, 0, 0, 0];",
          "    let i = 0;",
          "    assert_eq!(add_pos(mach, d, i), [u32::MAX as u64, 0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockMach;",
          "    impl Machine for MockMach {",
          "        type u32x4 = [u32; 4];",
          "        type u64x2 = [u64; 2];",
          "        fn unpack(&self, d: [u32; 4]) -> [u64; 2] {",
          "            [d[0] as u64, d[1] as u64]",
          "        }",
          "        fn vec(&self, arr: [u64; 2]) -> [u64; 2] {",
          "            arr",
          "        }",
          "    }",
          "",
          "    let mach = MockMach;",
          "    let d = [u32::MAX, u32::MAX, u32::MAX, u32::MAX];",
          "    let i = 1;",
          "    add_pos(mach, d, i);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(add_pos(MockMach, [u32::MAX, u32::MAX, u32::MAX, u32::MAX], 1), [u32::MAX as u64 + 1, u32::MAX as u64]);",
          "    assert_eq!(add_pos(MockMach, [0, 0, 0, 0], 5), [5, 0]);",
          "    assert_eq!(add_pos(MockMach, [1, 2, 3, 4], 10), [11, 0]);",
          "    assert_eq!(add_pos(MockMach, [u32::MAX, 0, 0, 0], 1), [0, 0]);",
          "    assert_eq!(add_pos(MockMach, [0, u32::MAX, 0, 0], 3), [3, 0]);",
          "    assert_eq!(add_pos(MockMach, [0, 0, u32::MAX, 0], 7), [7, 0]);",
          "    assert_eq!(add_pos(MockMach, [0, 0, 0, u32::MAX], 15), [15, 0]);",
          "    assert_eq!(add_pos(MockMach, [1, 1, 1, 1], 0), [1, 0]);",
          "    assert_eq!(add_pos(MockMach, [5, 6, 7, 8], 1), [6, 0]);"
        ],
        "code": [
          "{",
          "    struct MockMach;",
          "    impl Machine for MockMach {",
          "        type u32x4 = [u32; 4];",
          "        type u64x2 = [u64; 2];",
          "        fn unpack(&self, d: [u32; 4]) -> [u64; 2] {",
          "            [d[0] as u64, d[1] as u64]",
          "        }",
          "        fn vec(&self, arr: [u64; 2]) -> [u64; 2] {",
          "            arr",
          "        }",
          "    }",
          "",
          "    let mach = MockMach;",
          "    let d = [u32::MAX, u32::MAX, u32::MAX, u32::MAX];",
          "    let i = 1;",
          "    add_pos(mach, d, i);",
          "    assert_eq!(add_pos(MockMach, [u32::MAX, u32::MAX, u32::MAX, u32::MAX], 1), [u32::MAX as u64 + 1, u32::MAX as u64]);",
          "    assert_eq!(add_pos(MockMach, [0, 0, 0, 0], 5), [5, 0]);",
          "    assert_eq!(add_pos(MockMach, [1, 2, 3, 4], 10), [11, 0]);",
          "    assert_eq!(add_pos(MockMach, [u32::MAX, 0, 0, 0], 1), [0, 0]);",
          "    assert_eq!(add_pos(MockMach, [0, u32::MAX, 0, 0], 3), [3, 0]);",
          "    assert_eq!(add_pos(MockMach, [0, 0, u32::MAX, 0], 7), [7, 0]);",
          "    assert_eq!(add_pos(MockMach, [0, 0, 0, u32::MAX], 15), [15, 0]);",
          "    assert_eq!(add_pos(MockMach, [1, 1, 1, 1], 0), [1, 0]);",
          "    assert_eq!(add_pos(MockMach, [5, 6, 7, 8], 1), [6, 0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockMach;",
          "    impl Machine for MockMach {",
          "        type u32x4 = [u32; 4];",
          "        type u64x2 = [u64; 2];",
          "        fn unpack(&self, d: [u32; 4]) -> [u64; 2] {",
          "            [d[0] as u64, d[1] as u64]",
          "        }",
          "        fn vec(&self, arr: [u64; 2]) -> [u64; 2] {",
          "            arr",
          "        }",
          "    }",
          "",
          "    let mach = MockMach;",
          "    let d = [1, 2, 3, 4];",
          "    let i = 100;",
          "    add_pos(mach, d, i);",
          "}"
        ],
        "oracle": [
          "    let mach = MockMach;",
          "    let d = [1, 2, 3, 4];",
          "    let i = 100;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [101, 2]);",
          "    ",
          "    let d = [5, 10, 15, 20];",
          "    let i = 50;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [55, 10]);",
          "    ",
          "    let d = [0, 0, 0, 0];",
          "    let i = 0;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [0, 0]);",
          "    ",
          "    let d = [u32::MAX, u32::MAX, u32::MAX, u32::MAX];",
          "    let i = 1;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [1, u32::MAX]);",
          "    ",
          "    let d = [u32::MAX, 0, 0, 0];",
          "    let i = 10;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [10, 0]);",
          "    ",
          "    let d = [100, 200, 300, 400];",
          "    let i = 700;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [800, 200]);"
        ],
        "code": [
          "{",
          "    struct MockMach;",
          "    impl Machine for MockMach {",
          "        type u32x4 = [u32; 4];",
          "        type u64x2 = [u64; 2];",
          "        fn unpack(&self, d: [u32; 4]) -> [u64; 2] {",
          "            [d[0] as u64, d[1] as u64]",
          "        }",
          "        fn vec(&self, arr: [u64; 2]) -> [u64; 2] {",
          "            arr",
          "        }",
          "    }",
          "",
          "    let mach = MockMach;",
          "    let d = [1, 2, 3, 4];",
          "    let i = 100;",
          "    add_pos(mach, d, i);",
          "    let mach = MockMach;",
          "    let d = [1, 2, 3, 4];",
          "    let i = 100;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [101, 2]);",
          "    ",
          "    let d = [5, 10, 15, 20];",
          "    let i = 50;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [55, 10]);",
          "    ",
          "    let d = [0, 0, 0, 0];",
          "    let i = 0;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [0, 0]);",
          "    ",
          "    let d = [u32::MAX, u32::MAX, u32::MAX, u32::MAX];",
          "    let i = 1;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [1, u32::MAX]);",
          "    ",
          "    let d = [u32::MAX, 0, 0, 0];",
          "    let i = 10;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [10, 0]);",
          "    ",
          "    let d = [100, 200, 300, 400];",
          "    let i = 700;",
          "    let result = add_pos(mach, d, i);",
          "    assert_eq!(result, [800, 200]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockMach;",
          "    impl Machine for MockMach {",
          "        type u32x4 = [u32; 4];",
          "        type u64x2 = [u64; 2];",
          "        fn unpack(&self, d: [u32; 4]) -> [u64; 2] {",
          "            [d[0] as u64, d[1] as u64]",
          "        }",
          "        fn vec(&self, arr: [u64; 2]) -> [u64; 2] {",
          "            arr",
          "        }",
          "    }",
          "",
          "    let mach = MockMach;",
          "    let d = [0, u32::MAX, 0, u32::MAX];",
          "    let i = u64::MAX;",
          "    add_pos(mach, d, i);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(add_pos(MockMach, [0, u32::MAX, 0, u32::MAX], u64::MAX), [u64::MAX, u64::MAX]);",
          "    assert_eq!(add_pos(MockMach, [1, 1, 1, 1], 5), [6, 1]);",
          "    assert_eq!(add_pos(MockMach, [u32::MAX, 0, 0, 0], 1), [0, 0]);",
          "    assert_eq!(add_pos(MockMach, [0, 0, 0, 0], 0), [0, 0]);",
          "    assert_eq!(add_pos(MockMach, [2, 2, 2, 2], 10), [12, 2]);"
        ],
        "code": [
          "{",
          "    struct MockMach;",
          "    impl Machine for MockMach {",
          "        type u32x4 = [u32; 4];",
          "        type u64x2 = [u64; 2];",
          "        fn unpack(&self, d: [u32; 4]) -> [u64; 2] {",
          "            [d[0] as u64, d[1] as u64]",
          "        }",
          "        fn vec(&self, arr: [u64; 2]) -> [u64; 2] {",
          "            arr",
          "        }",
          "    }",
          "",
          "    let mach = MockMach;",
          "    let d = [0, u32::MAX, 0, u32::MAX];",
          "    let i = u64::MAX;",
          "    add_pos(mach, d, i);",
          "    assert_eq!(add_pos(MockMach, [0, u32::MAX, 0, u32::MAX], u64::MAX), [u64::MAX, u64::MAX]);",
          "    assert_eq!(add_pos(MockMach, [1, 1, 1, 1], 5), [6, 1]);",
          "    assert_eq!(add_pos(MockMach, [u32::MAX, 0, 0, 0], 1), [0, 0]);",
          "    assert_eq!(add_pos(MockMach, [0, 0, 0, 0], 0), [0, 0]);",
          "    assert_eq!(add_pos(MockMach, [2, 2, 2, 2], 10), [12, 2]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]