[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(0, 1);",
          "    rng.step();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 15750249268501108918);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(0, 1);",
          "    rng.step();",
          "    assert_eq!(rng.state, 15750249268501108918);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(0, u128::MAX);",
          "    rng.step();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 15750249268501108917);",
          "    assert_eq!(rng.increment, u128::MAX | 1);",
          "    rng.advance(1);",
          "    let expected_state_after_advance = rng.state.wrapping_add(rng.increment);",
          "    rng.step();",
          "    assert_eq!(rng.state, expected_state_after_advance);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(0, u128::MAX);",
          "    rng.step();",
          "    assert_eq!(rng.state, 15750249268501108917);",
          "    assert_eq!(rng.increment, u128::MAX | 1);",
          "    rng.advance(1);",
          "    let expected_state_after_advance = rng.state.wrapping_add(rng.increment);",
          "    rng.step();",
          "    assert_eq!(rng.state, expected_state_after_advance);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(u128::MAX, 1);",
          "    rng.step();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, (u128::MAX.wrapping_mul(MULTIPLIER as u128)).wrapping_add(1));"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(u128::MAX, 1);",
          "    rng.step();",
          "    assert_eq!(rng.state, (u128::MAX.wrapping_mul(MULTIPLIER as u128)).wrapping_add(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(u128::MAX, u128::MAX);",
          "    rng.step();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, (u128::MAX.wrapping_mul(MULTIPLIER as u128)).wrapping_add(u128::MAX));"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128CmDxsm64::new(u128::MAX, u128::MAX);",
          "    rng.step();",
          "    assert_eq!(rng.state, (u128::MAX.wrapping_mul(MULTIPLIER as u128)).wrapping_add(u128::MAX));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mid_state = u128::MAX / 2;",
          "    let mid_increment = mid_state + 1; // ensuring increment is valid",
          "    let mut rng = Lcg128CmDxsm64::new(mid_state, mid_increment);",
          "    rng.step();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, mid_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(mid_increment));"
        ],
        "code": [
          "{",
          "    let mid_state = u128::MAX / 2;",
          "    let mid_increment = mid_state + 1; // ensuring increment is valid",
          "    let mut rng = Lcg128CmDxsm64::new(mid_state, mid_increment);",
          "    rng.step();",
          "    assert_eq!(rng.state, mid_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(mid_increment));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let large_state = 2u128.pow(127) - 1; // close to max",
          "    let large_increment = 2u128.pow(127); // ensuring valid increment",
          "    let mut rng = Lcg128CmDxsm64::new(large_state, large_increment);",
          "    rng.step();",
          "}"
        ],
        "oracle": [
          "    let large_state = 2u128.pow(127) - 1;",
          "    let large_increment = 2u128.pow(127);",
          "    let mut rng = Lcg128CmDxsm64::new(large_state, large_increment);",
          "    rng.step();",
          "    assert!(rng.state > large_state);",
          "    assert_eq!(rng.increment, large_increment);",
          "    assert_eq!(rng.state, (large_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(large_increment)));",
          "    assert!(rng.state < u128::MAX);"
        ],
        "code": [
          "{",
          "    let large_state = 2u128.pow(127) - 1; // close to max",
          "    let large_increment = 2u128.pow(127); // ensuring valid increment",
          "    let mut rng = Lcg128CmDxsm64::new(large_state, large_increment);",
          "    rng.step();",
          "    let large_state = 2u128.pow(127) - 1;",
          "    let large_increment = 2u128.pow(127);",
          "    let mut rng = Lcg128CmDxsm64::new(large_state, large_increment);",
          "    rng.step();",
          "    assert!(rng.state > large_state);",
          "    assert_eq!(rng.increment, large_increment);",
          "    assert_eq!(rng.state, (large_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(large_increment)));",
          "    assert!(rng.state < u128::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]