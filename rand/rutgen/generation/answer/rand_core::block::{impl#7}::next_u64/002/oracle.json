[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockBlockRngCore {",
          "        results: [u64; 4],",
          "    }",
          "",
          "    impl BlockRngCore for MockBlockRngCore {",
          "        type Item = u64;",
          "        type Results = [u64; 4];",
          "",
          "        fn generate(&mut self, results: &mut Self::Results) {",
          "            results.copy_from_slice(&self.results);",
          "        }",
          "    }",
          "",
          "    let mut core = MockBlockRngCore { results: [1, 2, 3, 4] };",
          "    let mut rng = BlockRng64 { results: [0; 4], index: 0, half_used: false, core };",
          "",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 1);",
          "    assert_eq!(rng.index, 1);",
          "    assert!(!rng.half_used);",
          "    rng.next_u64();",
          "    assert_eq!(result, 2);",
          "    assert_eq!(rng.index, 2);",
          "    rng.next_u64();",
          "    assert_eq!(result, 3);",
          "    assert_eq!(rng.index, 3);",
          "    rng.next_u64();",
          "    assert_eq!(result, 4);",
          "    assert_eq!(rng.index, 0);",
          "    rng.next_u64();"
        ],
        "code": [
          "{",
          "    struct MockBlockRngCore {",
          "        results: [u64; 4],",
          "    }",
          "",
          "    impl BlockRngCore for MockBlockRngCore {",
          "        type Item = u64;",
          "        type Results = [u64; 4];",
          "",
          "        fn generate(&mut self, results: &mut Self::Results) {",
          "            results.copy_from_slice(&self.results);",
          "        }",
          "    }",
          "",
          "    let mut core = MockBlockRngCore { results: [1, 2, 3, 4] };",
          "    let mut rng = BlockRng64 { results: [0; 4], index: 0, half_used: false, core };",
          "",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, 1);",
          "    assert_eq!(rng.index, 1);",
          "    assert!(!rng.half_used);",
          "    rng.next_u64();",
          "    assert_eq!(result, 2);",
          "    assert_eq!(rng.index, 2);",
          "    rng.next_u64();",
          "    assert_eq!(result, 3);",
          "    assert_eq!(rng.index, 3);",
          "    rng.next_u64();",
          "    assert_eq!(result, 4);",
          "    assert_eq!(rng.index, 0);",
          "    rng.next_u64();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockBlockRngCore {",
          "        results: [u64; 3],",
          "    }",
          "",
          "    impl BlockRngCore for MockBlockRngCore {",
          "        type Item = u64;",
          "        type Results = [u64; 3];",
          "",
          "        fn generate(&mut self, results: &mut Self::Results) {",
          "            results.copy_from_slice(&self.results);",
          "        }",
          "    }",
          "",
          "    let mut core = MockBlockRngCore { results: [5, 10, 15] };",
          "    let mut rng = BlockRng64 { results: [0; 3], index: 1, half_used: false, core };",
          "",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 10);",
          "    assert!(rng.index == 2);",
          "    assert!(!rng.half_used);",
          "    rng.next_u64();",
          "    assert!(rng.index == 0);",
          "    assert!(rng.half_used == false);",
          "    rng.core.results = [20, 25, 30];",
          "    rng.next_u64();",
          "    assert_eq!(result, 15);",
          "    assert!(rng.index == 0);",
          "    assert!(rng.half_used == false);"
        ],
        "code": [
          "{",
          "    struct MockBlockRngCore {",
          "        results: [u64; 3],",
          "    }",
          "",
          "    impl BlockRngCore for MockBlockRngCore {",
          "        type Item = u64;",
          "        type Results = [u64; 3];",
          "",
          "        fn generate(&mut self, results: &mut Self::Results) {",
          "            results.copy_from_slice(&self.results);",
          "        }",
          "    }",
          "",
          "    let mut core = MockBlockRngCore { results: [5, 10, 15] };",
          "    let mut rng = BlockRng64 { results: [0; 3], index: 1, half_used: false, core };",
          "",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, 10);",
          "    assert!(rng.index == 2);",
          "    assert!(!rng.half_used);",
          "    rng.next_u64();",
          "    assert!(rng.index == 0);",
          "    assert!(rng.half_used == false);",
          "    rng.core.results = [20, 25, 30];",
          "    rng.next_u64();",
          "    assert_eq!(result, 15);",
          "    assert!(rng.index == 0);",
          "    assert!(rng.half_used == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockBlockRngCore {",
          "        results: [u64; 2],",
          "    }",
          "",
          "    impl BlockRngCore for MockBlockRngCore {",
          "        type Item = u64;",
          "        type Results = [u64; 2];",
          "",
          "        fn generate(&mut self, results: &mut Self::Results) {",
          "            results.copy_from_slice(&self.results);",
          "        }",
          "    }",
          "",
          "    let mut core = MockBlockRngCore { results: [100, 200] };",
          "    let mut rng = BlockRng64 { results: [0; 2], index: 1, half_used: false, core };",
          "",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 200);"
        ],
        "code": [
          "{",
          "    struct MockBlockRngCore {",
          "        results: [u64; 2],",
          "    }",
          "",
          "    impl BlockRngCore for MockBlockRngCore {",
          "        type Item = u64;",
          "        type Results = [u64; 2];",
          "",
          "        fn generate(&mut self, results: &mut Self::Results) {",
          "            results.copy_from_slice(&self.results);",
          "        }",
          "    }",
          "",
          "    let mut core = MockBlockRngCore { results: [100, 200] };",
          "    let mut rng = BlockRng64 { results: [0; 2], index: 1, half_used: false, core };",
          "",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, 200);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]