[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIterator {",
          "        items: Vec<i32>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl Iterator for TestIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.items.len() {",
          "                let item = self.items[self.index];",
          "                self.index += 1;",
          "                Some(item)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "        ",
          "        fn size_hint(&self) -> (usize, Option<usize>) {",
          "            (self.items.len() - self.index, Some(self.items.len() - self.index))",
          "        }",
          "    }",
          "",
          "    struct MockRng;",
          "    ",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<usize>) -> usize {",
          "            range.start // deterministic for testing",
          "        }",
          "    }",
          "",
          "    let rng = &mut MockRng;",
          "    let iterator = TestIterator {",
          "        items: vec![1, 2],",
          "        index: 0,",
          "    };",
          "",
          "    let _ = iterator.choose_stable(rng);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(iterator.size_hint(), (2, Some(2))); // precondition: lower >= 2 at line 153 is true",
          "    assert!(iterator.choose_stable(rng).is_some()); // precondition: elem.is_none() at line 169 is false",
          "    assert!(coin_flipper.random_ratio_one_over(consumed + 1)); // precondition: coin_flipper.random_ratio_one_over(consumed + 1) at line 173 is false",
          "    let highest_selected = (0..2).filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1)).last(); // precondition: let Some(ix) = highest_selected at line 161 is true",
          "    assert!(result.is_none()); // precondition: result.is_some() at line 164 is false"
        ],
        "code": [
          "{",
          "    struct TestIterator {",
          "        items: Vec<i32>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl Iterator for TestIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.items.len() {",
          "                let item = self.items[self.index];",
          "                self.index += 1;",
          "                Some(item)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "        ",
          "        fn size_hint(&self) -> (usize, Option<usize>) {",
          "            (self.items.len() - self.index, Some(self.items.len() - self.index))",
          "        }",
          "    }",
          "",
          "    struct MockRng;",
          "    ",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<usize>) -> usize {",
          "            range.start // deterministic for testing",
          "        }",
          "    }",
          "",
          "    let rng = &mut MockRng;",
          "    let iterator = TestIterator {",
          "        items: vec![1, 2],",
          "        index: 0,",
          "    };",
          "",
          "    let _ = iterator.choose_stable(rng);",
          "    assert_eq!(iterator.size_hint(), (2, Some(2))); // precondition: lower >= 2 at line 153 is true",
          "    assert!(iterator.choose_stable(rng).is_some()); // precondition: elem.is_none() at line 169 is false",
          "    assert!(coin_flipper.random_ratio_one_over(consumed + 1)); // precondition: coin_flipper.random_ratio_one_over(consumed + 1) at line 173 is false",
          "    let highest_selected = (0..2).filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1)).last(); // precondition: let Some(ix) = highest_selected at line 161 is true",
          "    assert!(result.is_none()); // precondition: result.is_some() at line 164 is false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIterator {",
          "        items: Vec<i32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for TestIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.items.len() {",
          "                let item = self.items[self.index];",
          "                self.index += 1;",
          "                Some(item)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "",
          "        fn size_hint(&self) -> (usize, Option<usize>) {",
          "            (2, Some(2))",
          "        }",
          "    }",
          "",
          "    struct MockRng;",
          "    ",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<usize>) -> usize {",
          "            range.end - 1 // deterministic for testing",
          "        }",
          "    }",
          "",
          "    let rng = &mut MockRng;",
          "    let iterator = TestIterator {",
          "        items: vec![1, 2],",
          "        index: 0,",
          "    };",
          "",
          "    let _ = iterator.choose_stable(rng);",
          "}"
        ],
        "oracle": [
          "    let result = iterator.choose_stable(rng);",
          "    assert_eq!(result, Some(2)); // assert result is expected value with lower == 2",
          "    assert!(result.is_some()); // assert result is some value",
          "    assert!(iterator.size_hint().0 >= 2); // assert size hint lower bound condition",
          "    assert!(!iterator.nth(0).is_none()); // assert nth call does not yield none",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    assert!(!coin_flipper.random_ratio_one_over(1)); // assert random_ratio_one_over is false on this condition",
          "    assert!(coin_flipper.random_ratio_one_over(3)); // assert random_ratio_one_over returns true for consumed + 1",
          "    assert!(iterator.nth(1).is_some()); // assert nth for next is available",
          "    assert!(iterator.nth(2).is_none()); // assert nth beyond bounds returns none",
          "    assert_eq!(iterator.size_hint(), (2, Some(2))); // assert size hint matches expectations"
        ],
        "code": [
          "{",
          "    struct TestIterator {",
          "        items: Vec<i32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for TestIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.items.len() {",
          "                let item = self.items[self.index];",
          "                self.index += 1;",
          "                Some(item)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "",
          "        fn size_hint(&self) -> (usize, Option<usize>) {",
          "            (2, Some(2))",
          "        }",
          "    }",
          "",
          "    struct MockRng;",
          "    ",
          "    impl Rng for MockRng {",
          "        fn random_range(&mut self, range: std::ops::Range<usize>) -> usize {",
          "            range.end - 1 // deterministic for testing",
          "        }",
          "    }",
          "",
          "    let rng = &mut MockRng;",
          "    let iterator = TestIterator {",
          "        items: vec![1, 2],",
          "        index: 0,",
          "    };",
          "",
          "    let _ = iterator.choose_stable(rng);",
          "    let result = iterator.choose_stable(rng);",
          "    assert_eq!(result, Some(2)); // assert result is expected value with lower == 2",
          "    assert!(result.is_some()); // assert result is some value",
          "    assert!(iterator.size_hint().0 >= 2); // assert size hint lower bound condition",
          "    assert!(!iterator.nth(0).is_none()); // assert nth call does not yield none",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    assert!(!coin_flipper.random_ratio_one_over(1)); // assert random_ratio_one_over is false on this condition",
          "    assert!(coin_flipper.random_ratio_one_over(3)); // assert random_ratio_one_over returns true for consumed + 1",
          "    assert!(iterator.nth(1).is_some()); // assert nth for next is available",
          "    assert!(iterator.nth(2).is_none()); // assert nth beyond bounds returns none",
          "    assert_eq!(iterator.size_hint(), (2, Some(2))); // assert size hint matches expectations",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]