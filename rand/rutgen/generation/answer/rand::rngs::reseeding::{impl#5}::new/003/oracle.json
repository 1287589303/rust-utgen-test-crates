[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ValidRng;",
          "    impl SeedableRng for ValidRng {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Ok(ValidRng)",
          "        }",
          "    }",
          "    struct ValidReseeder;",
          "    impl TryRngCore for ValidReseeder {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Ok(ValidReseeder)",
          "        }",
          "    }",
          "",
          "    let threshold = 0;",
          "    let reseeder = ValidReseeder;",
          "    let _ = ReseedingCore::<ValidRng, ValidReseeder>::new(threshold, reseeder);",
          "}"
        ],
        "oracle": [
          "    let threshold = 0;",
          "    let reseeder = ValidReseeder;",
          "    let result = ReseedingCore::<ValidRng, ValidReseeder>::new(threshold, reseeder);",
          "    assert!(result.is_ok());",
          "    let core = result.unwrap();",
          "    assert_eq!(core.threshold, i64::MAX);",
          "    assert_eq!(core.bytes_until_reseed, i64::MAX);"
        ],
        "code": [
          "{",
          "    struct ValidRng;",
          "    impl SeedableRng for ValidRng {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Ok(ValidRng)",
          "        }",
          "    }",
          "    struct ValidReseeder;",
          "    impl TryRngCore for ValidReseeder {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Ok(ValidReseeder)",
          "        }",
          "    }",
          "",
          "    let threshold = 0;",
          "    let reseeder = ValidReseeder;",
          "    let _ = ReseedingCore::<ValidRng, ValidReseeder>::new(threshold, reseeder);",
          "    let threshold = 0;",
          "    let reseeder = ValidReseeder;",
          "    let result = ReseedingCore::<ValidRng, ValidReseeder>::new(threshold, reseeder);",
          "    assert!(result.is_ok());",
          "    let core = result.unwrap();",
          "    assert_eq!(core.threshold, i64::MAX);",
          "    assert_eq!(core.bytes_until_reseed, i64::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ValidRng;",
          "    impl SeedableRng for ValidRng {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Ok(ValidRng)",
          "        }",
          "    }",
          "    struct ValidReseeder;",
          "    impl TryRngCore for ValidReseeder {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Ok(ValidReseeder)",
          "        }",
          "    }",
          "",
          "    let threshold = i64::MAX as u64;",
          "    let reseeder = ValidReseeder;",
          "    let _ = ReseedingCore::<ValidRng, ValidReseeder>::new(threshold, reseeder);",
          "}"
        ],
        "oracle": [
          "    let threshold_zero = 0;",
          "    let threshold_max_i64 = i64::MAX as u64;",
          "    let reseeder_err = InvalidReseeder;",
          "    assert_eq!(ReseedingCore::<ValidRng, InvalidReseeder>::new(threshold_zero, reseeder_err).is_err(), true);",
          "    assert_eq!(ReseedingCore::<ValidRng, ValidReseeder>::new(threshold_max_i64, reseeder).is_ok(), true);",
          "    assert_eq!(ReseedingCore::<InvalidRng, ValidReseeder>::new(threshold_max_i64, reseeder).is_err(), true);",
          "    assert_eq!(ReseedingCore::<ValidRng, ValidReseeder>::new(threshold_zero, reseeder).unwrap().threshold, i64::MAX);",
          "    assert_eq!(ReseedingCore::<ValidRng, ValidReseeder>::new(threshold_max_i64, reseeder).unwrap().threshold, i64::MAX);"
        ],
        "code": [
          "{",
          "    struct ValidRng;",
          "    impl SeedableRng for ValidRng {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Ok(ValidRng)",
          "        }",
          "    }",
          "    struct ValidReseeder;",
          "    impl TryRngCore for ValidReseeder {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Ok(ValidReseeder)",
          "        }",
          "    }",
          "",
          "    let threshold = i64::MAX as u64;",
          "    let reseeder = ValidReseeder;",
          "    let _ = ReseedingCore::<ValidRng, ValidReseeder>::new(threshold, reseeder);",
          "    let threshold_zero = 0;",
          "    let threshold_max_i64 = i64::MAX as u64;",
          "    let reseeder_err = InvalidReseeder;",
          "    assert_eq!(ReseedingCore::<ValidRng, InvalidReseeder>::new(threshold_zero, reseeder_err).is_err(), true);",
          "    assert_eq!(ReseedingCore::<ValidRng, ValidReseeder>::new(threshold_max_i64, reseeder).is_ok(), true);",
          "    assert_eq!(ReseedingCore::<InvalidRng, ValidReseeder>::new(threshold_max_i64, reseeder).is_err(), true);",
          "    assert_eq!(ReseedingCore::<ValidRng, ValidReseeder>::new(threshold_zero, reseeder).unwrap().threshold, i64::MAX);",
          "    assert_eq!(ReseedingCore::<ValidRng, ValidReseeder>::new(threshold_max_i64, reseeder).unwrap().threshold, i64::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct ValidRng;",
          "    impl SeedableRng for ValidRng {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Err(())",
          "        }",
          "    }",
          "    struct InvalidReseeder;",
          "    impl TryRngCore for InvalidReseeder {",
          "        type Error = ();",
          "    }",
          "",
          "    let threshold = 0;",
          "    let reseeder = InvalidReseeder;",
          "    let _ = ReseedingCore::<ValidRng, InvalidReseeder>::new(threshold, reseeder);",
          "}"
        ],
        "oracle": [
          "    plaintext",
          "    assert_eq!(ReseedingCore::<ValidRng, InvalidReseeder>::new(0, InvalidReseeder), Err(()));",
          "    assert_eq!(ReseedingCore::<ValidRng, InvalidReseeder>::new(i64::MAX as u64, InvalidReseeder), Err(()));"
        ],
        "code": [
          "{",
          "    struct ValidRng;",
          "    impl SeedableRng for ValidRng {",
          "        type Error = ();",
          "        fn try_from_rng<R: RngCore>(rng: &mut R) -> Result<Self, Self::Error> {",
          "            Err(())",
          "        }",
          "    }",
          "    struct InvalidReseeder;",
          "    impl TryRngCore for InvalidReseeder {",
          "        type Error = ();",
          "    }",
          "",
          "    let threshold = 0;",
          "    let reseeder = InvalidReseeder;",
          "    let _ = ReseedingCore::<ValidRng, InvalidReseeder>::new(threshold, reseeder);",
          "    plaintext",
          "    assert_eq!(ReseedingCore::<ValidRng, InvalidReseeder>::new(0, InvalidReseeder), Err(()));",
          "    assert_eq!(ReseedingCore::<ValidRng, InvalidReseeder>::new(i64::MAX as u64, InvalidReseeder), Err(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]