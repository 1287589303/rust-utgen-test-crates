[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl RngCore for MockRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 1 }; // controllable output",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    let d = 1; // minimal positive d",
          "    coin_flipper.chunk = 0b11; // setting chunk to ensure flip_c_heads returns true",
          "    coin_flipper.chunk_remaining = 2; // enough remaining bits",
          "",
          "    let result = coin_flipper.random_ratio_one_over(d);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true); // expected true since flip_c_heads is true and d=1",
          "    assert_eq!(coin_flipper.chunk_remaining, 0); // should consume all bits",
          "    assert_eq!(coin_flipper.chunk, 0b00); // should clear the chunk after successful flipping",
          "    assert!(coin_flipper.random_ratio(1, 1)); // ensure random_ratio behaves as expected with valid inputs",
          "    assert_eq!(coin_flipper.chunk_remaining, 0); // should not have remaining bits after one successful random_ratio call",
          "    assert_eq!(coin_flipper.chunk, 0b00); // chunk should be empty after processing"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl RngCore for MockRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 1 }; // controllable output",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    let d = 1; // minimal positive d",
          "    coin_flipper.chunk = 0b11; // setting chunk to ensure flip_c_heads returns true",
          "    coin_flipper.chunk_remaining = 2; // enough remaining bits",
          "",
          "    let result = coin_flipper.random_ratio_one_over(d);",
          "    assert_eq!(result, true); // expected true since flip_c_heads is true and d=1",
          "    assert_eq!(coin_flipper.chunk_remaining, 0); // should consume all bits",
          "    assert_eq!(coin_flipper.chunk, 0b00); // should clear the chunk after successful flipping",
          "    assert!(coin_flipper.random_ratio(1, 1)); // ensure random_ratio behaves as expected with valid inputs",
          "    assert_eq!(coin_flipper.chunk_remaining, 0); // should not have remaining bits after one successful random_ratio call",
          "    assert_eq!(coin_flipper.chunk, 0b00); // chunk should be empty after processing",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl RngCore for MockRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 2 }; // controllable output",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    let d = 4294967295; // maximum valid d",
          "    coin_flipper.chunk = 0b11; // setting chunk to ensure flip_c_heads returns true",
          "    coin_flipper.chunk_remaining = 2; // enough remaining bits",
          "",
          "    let result = coin_flipper.random_ratio_one_over(d);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    assert_eq!(coin_flipper.chunk_remaining, 0);",
          "    assert_eq!(coin_flipper.chunk, 0);",
          "    assert!(coin_flipper.flip_c_heads(2));",
          "    assert!(coin_flipper.random_ratio(4, d));",
          "    assert!(coin_flipper.chunk_remaining <= 32);",
          "    assert!(coin_flipper.chunk == 0);",
          "    assert!(coin_flipper.random_ratio_one_over(1));",
          "    assert!(coin_flipper.random_ratio_one_over(2));"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl RngCore for MockRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 2 }; // controllable output",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    let d = 4294967295; // maximum valid d",
          "    coin_flipper.chunk = 0b11; // setting chunk to ensure flip_c_heads returns true",
          "    coin_flipper.chunk_remaining = 2; // enough remaining bits",
          "",
          "    let result = coin_flipper.random_ratio_one_over(d);",
          "    assert_eq!(result, true);",
          "    assert_eq!(coin_flipper.chunk_remaining, 0);",
          "    assert_eq!(coin_flipper.chunk, 0);",
          "    assert!(coin_flipper.flip_c_heads(2));",
          "    assert!(coin_flipper.random_ratio(4, d));",
          "    assert!(coin_flipper.chunk_remaining <= 32);",
          "    assert!(coin_flipper.chunk == 0);",
          "    assert!(coin_flipper.random_ratio_one_over(1));",
          "    assert!(coin_flipper.random_ratio_one_over(2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl RngCore for MockRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 3 }; // controllable output",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    let d = 0; // d should not be zero",
          "",
          "    let result = coin_flipper.random_ratio_one_over(d);",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| coin_flipper.random_ratio_one_over(0)).is_err());",
          "    assert_eq!(coin_flipper.chunk_remaining, 0);",
          "    assert!(coin_flipper.chunk == 3);"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl RngCore for MockRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 3 }; // controllable output",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    let d = 0; // d should not be zero",
          "",
          "    let result = coin_flipper.random_ratio_one_over(d);",
          "    assert!(std::panic::catch_unwind(|| coin_flipper.random_ratio_one_over(0)).is_err());",
          "    assert_eq!(coin_flipper.chunk_remaining, 0);",
          "    assert!(coin_flipper.chunk == 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl RngCore for MockRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 4 }; // controllable output",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    let d = 123456; // arbitrary valid d",
          "    coin_flipper.chunk = 0b11; // setting chunk to ensure flip_c_heads returns true",
          "    coin_flipper.chunk_remaining = 2; // enough remaining bits",
          "",
          "    let result = coin_flipper.random_ratio_one_over(d);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    assert_eq!(coin_flipper.chunk, 0b1100);",
          "    assert_eq!(coin_flipper.chunk_remaining, 0);",
          "    assert!(coin_flipper.flip_c_heads((usize::BITS - 1 - d.leading_zeros()).min(32)));",
          "    assert!(coin_flipper.random_ratio(1 << ((usize::BITS - 1 - d.leading_zeros()).min(32)), d));"
        ],
        "code": [
          "{",
          "    struct MockRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl RngCore for MockRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = MockRng { value: 4 }; // controllable output",
          "    let mut coin_flipper = CoinFlipper::new(rng);",
          "    let d = 123456; // arbitrary valid d",
          "    coin_flipper.chunk = 0b11; // setting chunk to ensure flip_c_heads returns true",
          "    coin_flipper.chunk_remaining = 2; // enough remaining bits",
          "",
          "    let result = coin_flipper.random_ratio_one_over(d);",
          "    assert_eq!(result, true);",
          "    assert_eq!(coin_flipper.chunk, 0b1100);",
          "    assert_eq!(coin_flipper.chunk_remaining, 0);",
          "    assert!(coin_flipper.flip_c_heads((usize::BITS - 1 - d.leading_zeros()).min(32)));",
          "    assert!(coin_flipper.random_ratio(1 << ((usize::BITS - 1 - d.leading_zeros()).min(32)), d));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]