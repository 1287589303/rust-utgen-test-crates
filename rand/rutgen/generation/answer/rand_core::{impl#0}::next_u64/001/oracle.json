[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ValidRng;",
          "",
          "    impl RngCore for ValidRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            42",
          "        }",
          "        fn next_u64(&mut self) -> u64 {",
          "            123456789",
          "        }",
          "        fn fill_bytes(&mut self, _dst: &mut [u8]) {",
          "            // No-op",
          "        }",
          "    }",
          "",
          "    let mut rng = ValidRng;",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 123456789);"
        ],
        "code": [
          "{",
          "    struct ValidRng;",
          "",
          "    impl RngCore for ValidRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            42",
          "        }",
          "        fn next_u64(&mut self) -> u64 {",
          "            123456789",
          "        }",
          "        fn fill_bytes(&mut self, _dst: &mut [u8]) {",
          "            // No-op",
          "        }",
          "    }",
          "",
          "    let mut rng = ValidRng;",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, 123456789);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct InvalidRng;",
          "",
          "    impl RngCore for InvalidRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            0",
          "        }",
          "        fn next_u64(&mut self) -> u64 {",
          "            0",
          "        }",
          "        fn fill_bytes(&mut self, _dst: &mut [u8]) {",
          "            // No-op",
          "        }",
          "    }",
          "",
          "    let mut rng = InvalidRng;",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0);"
        ],
        "code": [
          "{",
          "    struct InvalidRng;",
          "",
          "    impl RngCore for InvalidRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            0",
          "        }",
          "        fn next_u64(&mut self) -> u64 {",
          "            0",
          "        }",
          "        fn fill_bytes(&mut self, _dst: &mut [u8]) {",
          "            // No-op",
          "        }",
          "    }",
          "",
          "    let mut rng = InvalidRng;",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct EmptySliceRng;",
          "",
          "    impl RngCore for EmptySliceRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            0",
          "        }",
          "        fn next_u64(&mut self) -> u64 {",
          "            0",
          "        }",
          "        fn fill_bytes(&mut self, _dst: &mut [u8]) {",
          "            // No-op",
          "        }",
          "    }",
          "",
          "    let mut rng = EmptySliceRng;",
          "    let empty_slice: &mut [u8] = &mut [];",
          "    rng.fill_bytes(empty_slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.next_u64(), 0);",
          "    assert_eq!(rng.next_u32(), 0);",
          "    rng.fill_bytes(&mut []);"
        ],
        "code": [
          "{",
          "    struct EmptySliceRng;",
          "",
          "    impl RngCore for EmptySliceRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            0",
          "        }",
          "        fn next_u64(&mut self) -> u64 {",
          "            0",
          "        }",
          "        fn fill_bytes(&mut self, _dst: &mut [u8]) {",
          "            // No-op",
          "        }",
          "    }",
          "",
          "    let mut rng = EmptySliceRng;",
          "    let empty_slice: &mut [u8] = &mut [];",
          "    rng.fill_bytes(empty_slice);",
          "    assert_eq!(rng.next_u64(), 0);",
          "    assert_eq!(rng.next_u32(), 0);",
          "    rng.fill_bytes(&mut []);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct NonEmptySliceRng;",
          "",
          "    impl RngCore for NonEmptySliceRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            0",
          "        }",
          "        fn next_u64(&mut self) -> u64 {",
          "            0",
          "        }",
          "        fn fill_bytes(&mut self, dst: &mut [u8]) {",
          "            for byte in dst.iter_mut() {",
          "                *byte = 1; // Fill with 1s",
          "            }",
          "        }",
          "    }",
          "",
          "    let mut rng = NonEmptySliceRng;",
          "    let mut slice = [0; 10];",
          "    rng.fill_bytes(&mut slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.next_u64(), 0);",
          "    assert_eq!(slice, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);"
        ],
        "code": [
          "{",
          "    struct NonEmptySliceRng;",
          "",
          "    impl RngCore for NonEmptySliceRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            0",
          "        }",
          "        fn next_u64(&mut self) -> u64 {",
          "            0",
          "        }",
          "        fn fill_bytes(&mut self, dst: &mut [u8]) {",
          "            for byte in dst.iter_mut() {",
          "                *byte = 1; // Fill with 1s",
          "            }",
          "        }",
          "    }",
          "",
          "    let mut rng = NonEmptySliceRng;",
          "    let mut slice = [0; 10];",
          "    rng.fill_bytes(&mut slice);",
          "    assert_eq!(rng.next_u64(), 0);",
          "    assert_eq!(slice, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]