[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FiniteType;",
          "    impl SampleUniform for FiniteType {",
          "        type Sampler = FiniteSampler;",
          "    }",
          "",
          "    struct FiniteSampler;",
          "",
          "    impl UniformSampler for FiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Ok(FiniteSampler)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<FiniteType>::new_inclusive(1.0, 5.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, 5.0).is_ok(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(5.0, 1.0).is_err(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(f32::NAN, 5.0).is_err(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, f32::NAN).is_err(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(f32::INFINITY, 5.0).is_err(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, f32::INFINITY).is_err(), true);"
        ],
        "code": [
          "{",
          "    struct FiniteType;",
          "    impl SampleUniform for FiniteType {",
          "        type Sampler = FiniteSampler;",
          "    }",
          "",
          "    struct FiniteSampler;",
          "",
          "    impl UniformSampler for FiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Ok(FiniteSampler)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<FiniteType>::new_inclusive(1.0, 5.0);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, 5.0).is_ok(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(5.0, 1.0).is_err(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(f32::NAN, 5.0).is_err(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, f32::NAN).is_err(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(f32::INFINITY, 5.0).is_err(), true);",
          "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, f32::INFINITY).is_err(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FiniteType;",
          "    impl SampleUniform for FiniteType {",
          "        type Sampler = FiniteSampler;",
          "    }",
          "",
          "    struct FiniteSampler;",
          "",
          "    impl UniformSampler for FiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Ok(FiniteSampler)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<FiniteType>::new_inclusive(3.0, 3.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Ok(Uniform(FiniteSampler)));",
          "    let _result_empty_range = Uniform::<FiniteType>::new_inclusive(4.0, 3.0);",
          "    assert_eq!(_result_empty_range, Err(Error::EmptyRange));",
          "    let _result_non_finite_low = Uniform::<FiniteType>::new_inclusive(f64::NAN, 5.0);",
          "    assert_eq!(_result_non_finite_low, Err(Error::NonFinite));",
          "    let _result_non_finite_high = Uniform::<FiniteType>::new_inclusive(1.0, f64::INFINITY);",
          "    assert_eq!(_result_non_finite_high, Err(Error::NonFinite));",
          "    let _result_non_finite_range = Uniform::<FiniteType>::new_inclusive(f64::NAN, f64::NAN);",
          "    assert_eq!(_result_non_finite_range, Err(Error::NonFinite));"
        ],
        "code": [
          "{",
          "    struct FiniteType;",
          "    impl SampleUniform for FiniteType {",
          "        type Sampler = FiniteSampler;",
          "    }",
          "",
          "    struct FiniteSampler;",
          "",
          "    impl UniformSampler for FiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Ok(FiniteSampler)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<FiniteType>::new_inclusive(3.0, 3.0);",
          "    assert_eq!(_result, Ok(Uniform(FiniteSampler)));",
          "    let _result_empty_range = Uniform::<FiniteType>::new_inclusive(4.0, 3.0);",
          "    assert_eq!(_result_empty_range, Err(Error::EmptyRange));",
          "    let _result_non_finite_low = Uniform::<FiniteType>::new_inclusive(f64::NAN, 5.0);",
          "    assert_eq!(_result_non_finite_low, Err(Error::NonFinite));",
          "    let _result_non_finite_high = Uniform::<FiniteType>::new_inclusive(1.0, f64::INFINITY);",
          "    assert_eq!(_result_non_finite_high, Err(Error::NonFinite));",
          "    let _result_non_finite_range = Uniform::<FiniteType>::new_inclusive(f64::NAN, f64::NAN);",
          "    assert_eq!(_result_non_finite_range, Err(Error::NonFinite));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FiniteType;",
          "    impl SampleUniform for FiniteType {",
          "        type Sampler = FiniteSampler;",
          "    }",
          "",
          "    struct FiniteSampler;",
          "",
          "    impl UniformSampler for FiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::EmptyRange)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<FiniteType>::new_inclusive(5.0, 2.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Err(Error::EmptyRange));"
        ],
        "code": [
          "{",
          "    struct FiniteType;",
          "    impl SampleUniform for FiniteType {",
          "        type Sampler = FiniteSampler;",
          "    }",
          "",
          "    struct FiniteSampler;",
          "",
          "    impl UniformSampler for FiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::EmptyRange)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<FiniteType>::new_inclusive(5.0, 2.0);",
          "    assert_eq!(_result, Err(Error::EmptyRange));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct NonFiniteType;",
          "    impl SampleUniform for NonFiniteType {",
          "        type Sampler = NonFiniteSampler;",
          "    }",
          "",
          "    struct NonFiniteSampler;",
          "",
          "    impl UniformSampler for NonFiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::NonFinite)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, 5.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, 5.0);",
          "    assert_eq!(_result, Ok(Uniform::<NonFiniteType>::new_inclusive(5.0, 5.0).unwrap()));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(-std::f32::INFINITY, 5.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, std::f32::INFINITY);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::INFINITY, 5.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, 10.0);",
          "    assert!(matches!(_result, Ok(_)));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(10.0, 5.0);",
          "    assert_eq!(_result, Err(Error::EmptyRange));"
        ],
        "code": [
          "{",
          "    struct NonFiniteType;",
          "    impl SampleUniform for NonFiniteType {",
          "        type Sampler = NonFiniteSampler;",
          "    }",
          "",
          "    struct NonFiniteSampler;",
          "",
          "    impl UniformSampler for NonFiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::NonFinite)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, 5.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, 5.0);",
          "    assert_eq!(_result, Ok(Uniform::<NonFiniteType>::new_inclusive(5.0, 5.0).unwrap()));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(-std::f32::INFINITY, 5.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, std::f32::INFINITY);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::INFINITY, 5.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, 10.0);",
          "    assert!(matches!(_result, Ok(_)));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(10.0, 5.0);",
          "    assert_eq!(_result, Err(Error::EmptyRange));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct NonFiniteType;",
          "    impl SampleUniform for NonFiniteType {",
          "        type Sampler = NonFiniteSampler;",
          "    }",
          "",
          "    struct NonFiniteSampler;",
          "",
          "    impl UniformSampler for NonFiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::NonFinite)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(1.0, std::f32::NAN);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, 1.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(1.0, 0.0);",
          "    assert_eq!(_result, Err(Error::EmptyRange));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(0.0, 1.0);",
          "    assert!(matches!(_result, Ok(_)));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(0.0, 0.0);",
          "    assert!(matches!(_result, Ok(_)));"
        ],
        "code": [
          "{",
          "    struct NonFiniteType;",
          "    impl SampleUniform for NonFiniteType {",
          "        type Sampler = NonFiniteSampler;",
          "    }",
          "",
          "    struct NonFiniteSampler;",
          "",
          "    impl UniformSampler for NonFiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::NonFinite)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(1.0, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, 1.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(1.0, 0.0);",
          "    assert_eq!(_result, Err(Error::EmptyRange));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(0.0, 1.0);",
          "    assert!(matches!(_result, Ok(_)));",
          "    let _result = Uniform::<NonFiniteType>::new_inclusive(0.0, 0.0);",
          "    assert!(matches!(_result, Ok(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct InfiniteType;",
          "    impl SampleUniform for InfiniteType {",
          "        type Sampler = InfiniteSampler;",
          "    }",
          "",
          "    struct InfiniteSampler;",
          "",
          "    impl UniformSampler for InfiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::NonFinite)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(std::f32::NEG_INFINITY, 5.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    ",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(1.0, std::f32::INFINITY);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    ",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(std::f32::NAN, 5.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    ",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(5.0, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    ",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(10.0, 5.0);",
          "    assert_eq!(_result, Err(Error::EmptyRange));"
        ],
        "code": [
          "{",
          "    struct InfiniteType;",
          "    impl SampleUniform for InfiniteType {",
          "        type Sampler = InfiniteSampler;",
          "    }",
          "",
          "    struct InfiniteSampler;",
          "",
          "    impl UniformSampler for InfiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::NonFinite)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(std::f32::NEG_INFINITY, 5.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    ",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(1.0, std::f32::INFINITY);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    ",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(std::f32::NAN, 5.0);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    ",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(5.0, std::f32::NAN);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "    ",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(10.0, 5.0);",
          "    assert_eq!(_result, Err(Error::EmptyRange));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct InfiniteType;",
          "    impl SampleUniform for InfiniteType {",
          "        type Sampler = InfiniteSampler;",
          "    }",
          "",
          "    struct InfiniteSampler;",
          "",
          "    impl UniformSampler for InfiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::NonFinite)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(1.0, std::f32::INFINITY);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Err(Error::NonFinite));"
        ],
        "code": [
          "{",
          "    struct InfiniteType;",
          "    impl SampleUniform for InfiniteType {",
          "        type Sampler = InfiniteSampler;",
          "    }",
          "",
          "    struct InfiniteSampler;",
          "",
          "    impl UniformSampler for InfiniteSampler {",
          "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
          "            Err(Error::NonFinite)",
          "        }",
          "    }",
          "",
          "    let _result = Uniform::<InfiniteType>::new_inclusive(1.0, std::f32::INFINITY);",
          "    assert_eq!(_result, Err(Error::NonFinite));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]