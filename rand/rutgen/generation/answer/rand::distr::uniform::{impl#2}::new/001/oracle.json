[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct SampleStruct;",
          "",
          "    impl SampleUniform for SampleStruct {",
          "        type Sampler = SampleStruct;",
          "    }",
          "",
          "    let result = Uniform::<SampleStruct>::new(1, 10);",
          "    let _ = result.unwrap(); // Unwrap to ensure it is Ok(Uniform<X>)",
          "}"
        ],
        "oracle": [
          "    result.expect(\"Expected Ok variant for valid range [1, 10]\");",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(result.as_ref().is_ok());",
          "    let error_result = Uniform::<SampleStruct>::new(10, 10);",
          "    assert_eq!(error_result.is_err(), true);",
          "    assert_eq!(error_result.unwrap_err(), Error::EmptyRange);",
          "    let non_finite_result = Uniform::<SampleStruct>::new(f32::NAN, 10.0);",
          "    assert_eq!(non_finite_result.is_err(), true);",
          "    assert_eq!(non_finite_result.unwrap_err(), Error::NonFinite);",
          "    let low_greater_than_high = Uniform::<SampleStruct>::new(5, 3);",
          "    assert!(low_greater_than_high.is_err());",
          "    assert_eq!(low_greater_than_high.unwrap_err(), Error::EmptyRange);"
        ],
        "code": [
          "{",
          "    struct SampleStruct;",
          "",
          "    impl SampleUniform for SampleStruct {",
          "        type Sampler = SampleStruct;",
          "    }",
          "",
          "    let result = Uniform::<SampleStruct>::new(1, 10);",
          "    let _ = result.unwrap(); // Unwrap to ensure it is Ok(Uniform<X>)",
          "    result.expect(\"Expected Ok variant for valid range [1, 10]\");",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(result.as_ref().is_ok());",
          "    let error_result = Uniform::<SampleStruct>::new(10, 10);",
          "    assert_eq!(error_result.is_err(), true);",
          "    assert_eq!(error_result.unwrap_err(), Error::EmptyRange);",
          "    let non_finite_result = Uniform::<SampleStruct>::new(f32::NAN, 10.0);",
          "    assert_eq!(non_finite_result.is_err(), true);",
          "    assert_eq!(non_finite_result.unwrap_err(), Error::NonFinite);",
          "    let low_greater_than_high = Uniform::<SampleStruct>::new(5, 3);",
          "    assert!(low_greater_than_high.is_err());",
          "    assert_eq!(low_greater_than_high.unwrap_err(), Error::EmptyRange);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct SampleFloat;",
          "",
          "    impl SampleUniform for SampleFloat {",
          "        type Sampler = SampleFloat;",
          "    }",
          "",
          "    let result = Uniform::<SampleFloat>::new(0.1f32, 0.5f32);",
          "    let _ = result.unwrap(); // Unwrap to ensure it is Ok(Uniform<X>)",
          "}"
        ],
        "oracle": [
          "    let result = Uniform::<SampleFloat>::new(0.1f32, 0.5f32); assert!(result.is_ok());",
          "    let result = Uniform::<SampleFloat>::new(1.0f32, 0.5f32); assert!(result.is_err());",
          "    let result = Uniform::<SampleFloat>::new(f32::INFINITY, 0.5f32); assert!(result.is_err());",
          "    let result = Uniform::<SampleFloat>::new(0.1f32, f32::NAN); assert!(result.is_err());",
          "    let result = Uniform::<SampleFloat>::new(0.5f32, 0.5f32); assert!(result.is_err());",
          "    let result = Uniform::<SampleFloat>::new(0.0f32, f32::MAX); assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    struct SampleFloat;",
          "",
          "    impl SampleUniform for SampleFloat {",
          "        type Sampler = SampleFloat;",
          "    }",
          "",
          "    let result = Uniform::<SampleFloat>::new(0.1f32, 0.5f32);",
          "    let _ = result.unwrap(); // Unwrap to ensure it is Ok(Uniform<X>)",
          "    let result = Uniform::<SampleFloat>::new(0.1f32, 0.5f32); assert!(result.is_ok());",
          "    let result = Uniform::<SampleFloat>::new(1.0f32, 0.5f32); assert!(result.is_err());",
          "    let result = Uniform::<SampleFloat>::new(f32::INFINITY, 0.5f32); assert!(result.is_err());",
          "    let result = Uniform::<SampleFloat>::new(0.1f32, f32::NAN); assert!(result.is_err());",
          "    let result = Uniform::<SampleFloat>::new(0.5f32, 0.5f32); assert!(result.is_err());",
          "    let result = Uniform::<SampleFloat>::new(0.0f32, f32::MAX); assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct SampleStruct;",
          "",
          "    impl SampleUniform for SampleStruct {",
          "        type Sampler = SampleStruct;",
          "    }",
          "",
          "    let _ = Uniform::<SampleStruct>::new(5, 5); // Should panic",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Uniform::<SampleStruct>::new(5, 5).is_err(), true); // Should fail with Error::EmptyRange",
          "    assert_eq!(Uniform::<SampleStruct>::new(10.0, 5.0).is_err(), true); // Should fail with Error::EmptyRange",
          "    assert_eq!(Uniform::<SampleStruct>::new(0, 0).is_err(), true); // Should fail with Error::EmptyRange",
          "    assert_eq!(Uniform::<SampleStruct>::new(f32::INFINITY, 5.0).is_err(), true); // Should fail with Error::NonFinite",
          "    assert_eq!(Uniform::<SampleStruct>::new(-1.0, f32::NAN).is_err(), true); // Should fail with Error::NonFinite",
          "    assert_eq!(Uniform::<SampleStruct>::new(0.0, 1.0).is_ok(), true); // Should succeed with valid range"
        ],
        "code": [
          "{",
          "    struct SampleStruct;",
          "",
          "    impl SampleUniform for SampleStruct {",
          "        type Sampler = SampleStruct;",
          "    }",
          "",
          "    let _ = Uniform::<SampleStruct>::new(5, 5); // Should panic",
          "    assert_eq!(Uniform::<SampleStruct>::new(5, 5).is_err(), true); // Should fail with Error::EmptyRange",
          "    assert_eq!(Uniform::<SampleStruct>::new(10.0, 5.0).is_err(), true); // Should fail with Error::EmptyRange",
          "    assert_eq!(Uniform::<SampleStruct>::new(0, 0).is_err(), true); // Should fail with Error::EmptyRange",
          "    assert_eq!(Uniform::<SampleStruct>::new(f32::INFINITY, 5.0).is_err(), true); // Should fail with Error::NonFinite",
          "    assert_eq!(Uniform::<SampleStruct>::new(-1.0, f32::NAN).is_err(), true); // Should fail with Error::NonFinite",
          "    assert_eq!(Uniform::<SampleStruct>::new(0.0, 1.0).is_ok(), true); // Should succeed with valid range",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct SampleStruct;",
          "",
          "    impl SampleUniform for SampleStruct {",
          "        type Sampler = SampleStruct;",
          "    }",
          "",
          "    let _ = Uniform::<SampleStruct>::new(10, 5); // Should panic",
          "}"
        ],
        "oracle": [
          "    let _ = Uniform::<SampleStruct>::new(10, 5); // Should return Err(Error::EmptyRange)",
          "    let _ = Uniform::<SampleStruct>::new(5, 5); // Should return Err(Error::EmptyRange)",
          "    let _ = Uniform::<SampleStruct>::new(f64::INFINITY, f64::NEG_INFINITY); // Should return Err(Error::NonFinite)",
          "    let _ = Uniform::<SampleStruct>::new(f32::NAN, 10.0); // Should return Err(Error::NonFinite)",
          "    let _ = Uniform::<SampleStruct>::new(1.0, f64::INFINITY); // Should return Err(Error::NonFinite)"
        ],
        "code": [
          "{",
          "    struct SampleStruct;",
          "",
          "    impl SampleUniform for SampleStruct {",
          "        type Sampler = SampleStruct;",
          "    }",
          "",
          "    let _ = Uniform::<SampleStruct>::new(10, 5); // Should panic",
          "    let _ = Uniform::<SampleStruct>::new(10, 5); // Should return Err(Error::EmptyRange)",
          "    let _ = Uniform::<SampleStruct>::new(5, 5); // Should return Err(Error::EmptyRange)",
          "    let _ = Uniform::<SampleStruct>::new(f64::INFINITY, f64::NEG_INFINITY); // Should return Err(Error::NonFinite)",
          "    let _ = Uniform::<SampleStruct>::new(f32::NAN, 10.0); // Should return Err(Error::NonFinite)",
          "    let _ = Uniform::<SampleStruct>::new(1.0, f64::INFINITY); // Should return Err(Error::NonFinite)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct SampleFloat;",
          "",
          "    impl SampleUniform for SampleFloat {",
          "        type Sampler = SampleFloat;",
          "    }",
          "",
          "    let _ = Uniform::<SampleFloat>::new(f32::NAN, 10.0); // Should panic",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Uniform::<SampleFloat>::new(5.0, 10.0).is_ok(), true); // Low is less than high",
          "    assert_eq!(Uniform::<SampleFloat>::new(10.0, 10.0).is_err(), true); // Low is equal to high",
          "    assert_eq!(Uniform::<SampleFloat>::new(10.0, f32::NAN).is_err(), true); // High is non-finite",
          "    assert_eq!(Uniform::<SampleFloat>::new(f32::NAN, 10.0).is_err(), true); // Low is non-finite",
          "    assert_eq!(Uniform::<SampleFloat>::new(f32::INFINITY, 10.0).is_err(), true); // Low is infinite",
          "    assert_eq!(Uniform::<SampleFloat>::new(5.0, f32::INFINITY).is_ok(), true); // High is infinite",
          "    assert_eq!(Uniform::<SampleFloat>::new(f32::NEG_INFINITY, 10.0).is_err(), true); // Low is negative infinite"
        ],
        "code": [
          "{",
          "    struct SampleFloat;",
          "",
          "    impl SampleUniform for SampleFloat {",
          "        type Sampler = SampleFloat;",
          "    }",
          "",
          "    let _ = Uniform::<SampleFloat>::new(f32::NAN, 10.0); // Should panic",
          "    assert_eq!(Uniform::<SampleFloat>::new(5.0, 10.0).is_ok(), true); // Low is less than high",
          "    assert_eq!(Uniform::<SampleFloat>::new(10.0, 10.0).is_err(), true); // Low is equal to high",
          "    assert_eq!(Uniform::<SampleFloat>::new(10.0, f32::NAN).is_err(), true); // High is non-finite",
          "    assert_eq!(Uniform::<SampleFloat>::new(f32::NAN, 10.0).is_err(), true); // Low is non-finite",
          "    assert_eq!(Uniform::<SampleFloat>::new(f32::INFINITY, 10.0).is_err(), true); // Low is infinite",
          "    assert_eq!(Uniform::<SampleFloat>::new(5.0, f32::INFINITY).is_ok(), true); // High is infinite",
          "    assert_eq!(Uniform::<SampleFloat>::new(f32::NEG_INFINITY, 10.0).is_err(), true); // Low is negative infinite",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct SampleFloat;",
          "",
          "    impl SampleUniform for SampleFloat {",
          "        type Sampler = SampleFloat;",
          "    }",
          "",
          "    let _ = Uniform::<SampleFloat>::new(0.0, f32::INFINITY); // Should panic",
          "}"
        ],
        "oracle": [
          "    let _ = Uniform::<SampleFloat>::new(1.0, 1.0); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(f32::NAN, 1.0); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(1.0, f32::NAN); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(-f32::INFINITY, 1.0); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(0.0, -f32::INFINITY); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(100.0, 10.0); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(-5.0, f32::INFINITY); // Should panic"
        ],
        "code": [
          "{",
          "    struct SampleFloat;",
          "",
          "    impl SampleUniform for SampleFloat {",
          "        type Sampler = SampleFloat;",
          "    }",
          "",
          "    let _ = Uniform::<SampleFloat>::new(0.0, f32::INFINITY); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(1.0, 1.0); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(f32::NAN, 1.0); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(1.0, f32::NAN); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(-f32::INFINITY, 1.0); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(0.0, -f32::INFINITY); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(100.0, 10.0); // Should panic",
          "    let _ = Uniform::<SampleFloat>::new(-5.0, f32::INFINITY); // Should panic",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]