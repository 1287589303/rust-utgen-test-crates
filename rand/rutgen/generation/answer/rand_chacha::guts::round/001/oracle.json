[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVec(u32);",
          "    impl ArithOps for TestVec {",
          "        fn add(self, rhs: Self) -> Self {",
          "            TestVec(self.0.wrapping_add(rhs.0))",
          "        }",
          "    }",
          "    ",
          "    impl BitOps32 for TestVec {",
          "        fn rotate_each_word_right16(self) -> Self {",
          "            TestVec(self.0.rotate_right(16))",
          "        }",
          "        ",
          "        fn rotate_each_word_right20(self) -> Self {",
          "            TestVec(self.0.rotate_right(20))",
          "        }",
          "        ",
          "        fn rotate_each_word_right24(self) -> Self {",
          "            TestVec(self.0.rotate_right(24))",
          "        }",
          "        ",
          "        fn rotate_each_word_right25(self) -> Self {",
          "            TestVec(self.0.rotate_right(25))",
          "        }",
          "    }",
          "    ",
          "    let state = State {",
          "        a: TestVec(0),",
          "        b: TestVec(0),",
          "        c: TestVec(0),",
          "        d: TestVec(0),",
          "    };",
          "    let _result = round(state);",
          "}"
        ],
        "oracle": [
          "    let state = State { a: TestVec(1), b: TestVec(1), c: TestVec(1), d: TestVec(1) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, 2);",
          "    assert_eq!(result.b.0, 0);",
          "    assert_eq!(result.c.0, 2);",
          "    assert_eq!(result.d.0, 0);",
          "    ",
          "    let state = State { a: TestVec(u32::MAX), b: TestVec(1), c: TestVec(0), d: TestVec(2) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, u32::MAX);",
          "    assert_eq!(result.b.0, 3);",
          "    assert_eq!(result.c.0, 2);",
          "    assert_eq!(result.d.0, 0);",
          "    ",
          "    let state = State { a: TestVec(3), b: TestVec(2), c: TestVec(1), d: TestVec(0) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, 5);",
          "    assert_eq!(result.b.0, 3);",
          "    assert_eq!(result.c.0, 2);",
          "    assert_eq!(result.d.0, 1);",
          "    ",
          "    let state = State { a: TestVec(0), b: TestVec(u32::MAX), c: TestVec(u32::MAX), d: TestVec(u32::MAX) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, u32::MAX);",
          "    assert_eq!(result.b.0, 0);",
          "    assert_eq!(result.c.0, u32::MAX);",
          "    assert_eq!(result.d.0, u32::MAX);",
          "    ",
          "    let state = State { a: TestVec(1234), b: TestVec(5678), c: TestVec(91011), d: TestVec(121314) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, 6912);",
          "    assert_eq!(result.b.0, /*expected value after rotation*/);",
          "    assert_eq!(result.c.0, /*expected value after operations*/);",
          "    assert_eq!(result.d.0, /*expected value after operations*/);"
        ],
        "code": [
          "{",
          "    struct TestVec(u32);",
          "    impl ArithOps for TestVec {",
          "        fn add(self, rhs: Self) -> Self {",
          "            TestVec(self.0.wrapping_add(rhs.0))",
          "        }",
          "    }",
          "    ",
          "    impl BitOps32 for TestVec {",
          "        fn rotate_each_word_right16(self) -> Self {",
          "            TestVec(self.0.rotate_right(16))",
          "        }",
          "        ",
          "        fn rotate_each_word_right20(self) -> Self {",
          "            TestVec(self.0.rotate_right(20))",
          "        }",
          "        ",
          "        fn rotate_each_word_right24(self) -> Self {",
          "            TestVec(self.0.rotate_right(24))",
          "        }",
          "        ",
          "        fn rotate_each_word_right25(self) -> Self {",
          "            TestVec(self.0.rotate_right(25))",
          "        }",
          "    }",
          "    ",
          "    let state = State {",
          "        a: TestVec(0),",
          "        b: TestVec(0),",
          "        c: TestVec(0),",
          "        d: TestVec(0),",
          "    };",
          "    let _result = round(state);",
          "    let state = State { a: TestVec(1), b: TestVec(1), c: TestVec(1), d: TestVec(1) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, 2);",
          "    assert_eq!(result.b.0, 0);",
          "    assert_eq!(result.c.0, 2);",
          "    assert_eq!(result.d.0, 0);",
          "    ",
          "    let state = State { a: TestVec(u32::MAX), b: TestVec(1), c: TestVec(0), d: TestVec(2) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, u32::MAX);",
          "    assert_eq!(result.b.0, 3);",
          "    assert_eq!(result.c.0, 2);",
          "    assert_eq!(result.d.0, 0);",
          "    ",
          "    let state = State { a: TestVec(3), b: TestVec(2), c: TestVec(1), d: TestVec(0) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, 5);",
          "    assert_eq!(result.b.0, 3);",
          "    assert_eq!(result.c.0, 2);",
          "    assert_eq!(result.d.0, 1);",
          "    ",
          "    let state = State { a: TestVec(0), b: TestVec(u32::MAX), c: TestVec(u32::MAX), d: TestVec(u32::MAX) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, u32::MAX);",
          "    assert_eq!(result.b.0, 0);",
          "    assert_eq!(result.c.0, u32::MAX);",
          "    assert_eq!(result.d.0, u32::MAX);",
          "    ",
          "    let state = State { a: TestVec(1234), b: TestVec(5678), c: TestVec(91011), d: TestVec(121314) };",
          "    let result = round(state);",
          "    assert_eq!(result.a.0, 6912);",
          "    assert_eq!(result.b.0, /*expected value after rotation*/);",
          "    assert_eq!(result.c.0, /*expected value after operations*/);",
          "    assert_eq!(result.d.0, /*expected value after operations*/);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVec(u32);",
          "    impl ArithOps for TestVec {",
          "        fn add(self, rhs: Self) -> Self {",
          "            TestVec(self.0.wrapping_add(rhs.0))",
          "        }",
          "    }",
          "    ",
          "    impl BitOps32 for TestVec {",
          "        fn rotate_each_word_right16(self) -> Self {",
          "            TestVec(self.0.rotate_right(16))",
          "        }",
          "        ",
          "        fn rotate_each_word_right20(self) -> Self {",
          "            TestVec(self.0.rotate_right(20))",
          "        }",
          "        ",
          "        fn rotate_each_word_right24(self) -> Self {",
          "            TestVec(self.0.rotate_right(24))",
          "        }",
          "        ",
          "        fn rotate_each_word_right25(self) -> Self {",
          "            TestVec(self.0.rotate_right(25))",
          "        }",
          "    }",
          "",
          "    let state = State {",
          "        a: TestVec(u32::MAX),",
          "        b: TestVec(u32::MAX),",
          "        c: TestVec(u32::MAX),",
          "        d: TestVec(u32::MAX),",
          "    };",
          "    let _result = round(state);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.a.0, (u32::MAX.wrapping_add(u32::MAX)));",
          "    assert_eq!(_result.d.0, (u32::MAX ^ (u32::MAX.wrapping_add(u32::MAX))).rotate_right(16));",
          "    assert_eq!(_result.c.0, (u32::MAX.wrapping_add(_result.d.0)));",
          "    assert_eq!(_result.b.0, (u32::MAX ^ (u32::MAX.wrapping_add(_result.c.0))).rotate_right(20));",
          "    assert_eq!(_result.a.0, (u32::MAX.wrapping_add(_result.b.0)));",
          "    assert_eq!(_result.d.0, (u32::MAX ^ (_result.a.0)).rotate_right(24));",
          "    assert_eq!(_result.c.0, (_result.c.0.wrapping_add(_result.d.0)));",
          "    assert_eq!(_result.b.0, (_result.b.0 ^ (_result.c.0)).rotate_right(25));"
        ],
        "code": [
          "{",
          "    struct TestVec(u32);",
          "    impl ArithOps for TestVec {",
          "        fn add(self, rhs: Self) -> Self {",
          "            TestVec(self.0.wrapping_add(rhs.0))",
          "        }",
          "    }",
          "    ",
          "    impl BitOps32 for TestVec {",
          "        fn rotate_each_word_right16(self) -> Self {",
          "            TestVec(self.0.rotate_right(16))",
          "        }",
          "        ",
          "        fn rotate_each_word_right20(self) -> Self {",
          "            TestVec(self.0.rotate_right(20))",
          "        }",
          "        ",
          "        fn rotate_each_word_right24(self) -> Self {",
          "            TestVec(self.0.rotate_right(24))",
          "        }",
          "        ",
          "        fn rotate_each_word_right25(self) -> Self {",
          "            TestVec(self.0.rotate_right(25))",
          "        }",
          "    }",
          "",
          "    let state = State {",
          "        a: TestVec(u32::MAX),",
          "        b: TestVec(u32::MAX),",
          "        c: TestVec(u32::MAX),",
          "        d: TestVec(u32::MAX),",
          "    };",
          "    let _result = round(state);",
          "    assert_eq!(_result.a.0, (u32::MAX.wrapping_add(u32::MAX)));",
          "    assert_eq!(_result.d.0, (u32::MAX ^ (u32::MAX.wrapping_add(u32::MAX))).rotate_right(16));",
          "    assert_eq!(_result.c.0, (u32::MAX.wrapping_add(_result.d.0)));",
          "    assert_eq!(_result.b.0, (u32::MAX ^ (u32::MAX.wrapping_add(_result.c.0))).rotate_right(20));",
          "    assert_eq!(_result.a.0, (u32::MAX.wrapping_add(_result.b.0)));",
          "    assert_eq!(_result.d.0, (u32::MAX ^ (_result.a.0)).rotate_right(24));",
          "    assert_eq!(_result.c.0, (_result.c.0.wrapping_add(_result.d.0)));",
          "    assert_eq!(_result.b.0, (_result.b.0 ^ (_result.c.0)).rotate_right(25));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVec(i32);",
          "    impl ArithOps for TestVec {",
          "        fn add(self, rhs: Self) -> Self {",
          "            TestVec(self.0.wrapping_add(rhs.0))",
          "        }",
          "    }",
          "    ",
          "    impl BitOps32 for TestVec {",
          "        fn rotate_each_word_right16(self) -> Self {",
          "            TestVec(self.0.rotate_right(16))",
          "        }",
          "        ",
          "        fn rotate_each_word_right20(self) -> Self {",
          "            TestVec(self.0.rotate_right(20))",
          "        }",
          "        ",
          "        fn rotate_each_word_right24(self) -> Self {",
          "            TestVec(self.0.rotate_right(24))",
          "        }",
          "        ",
          "        fn rotate_each_word_right25(self) -> Self {",
          "            TestVec(self.0.rotate_right(25))",
          "        }",
          "    }",
          "",
          "    let state = State {",
          "        a: TestVec(-1),",
          "        b: TestVec(-1),",
          "        c: TestVec(-1),",
          "        d: TestVec(-1),",
          "    };",
          "    let _result = round(state);",
          "}"
        ],
        "oracle": [
          "    let expected_result = State {",
          "    a: TestVec(-2),",
          "    b: TestVec(-1.wrapping_sub(-1).rotate_right(20)),",
          "    c: TestVec(-1.wrapping_sub((-1.wrapping_sub(-1).rotate_right(16))).rotate_right(24)),",
          "    d: TestVec((-1 ^ -2).rotate_right(16)),",
          "    };",
          "    ",
          "    assert_eq!(_result.a, expected_result.a);",
          "    assert_eq!(_result.b, expected_result.b);",
          "    assert_eq!(_result.c, expected_result.c);",
          "    assert_eq!(_result.d, expected_result.d);"
        ],
        "code": [
          "{",
          "    struct TestVec(i32);",
          "    impl ArithOps for TestVec {",
          "        fn add(self, rhs: Self) -> Self {",
          "            TestVec(self.0.wrapping_add(rhs.0))",
          "        }",
          "    }",
          "    ",
          "    impl BitOps32 for TestVec {",
          "        fn rotate_each_word_right16(self) -> Self {",
          "            TestVec(self.0.rotate_right(16))",
          "        }",
          "        ",
          "        fn rotate_each_word_right20(self) -> Self {",
          "            TestVec(self.0.rotate_right(20))",
          "        }",
          "        ",
          "        fn rotate_each_word_right24(self) -> Self {",
          "            TestVec(self.0.rotate_right(24))",
          "        }",
          "        ",
          "        fn rotate_each_word_right25(self) -> Self {",
          "            TestVec(self.0.rotate_right(25))",
          "        }",
          "    }",
          "",
          "    let state = State {",
          "        a: TestVec(-1),",
          "        b: TestVec(-1),",
          "        c: TestVec(-1),",
          "        d: TestVec(-1),",
          "    };",
          "    let _result = round(state);",
          "    let expected_result = State {",
          "    a: TestVec(-2),",
          "    b: TestVec(-1.wrapping_sub(-1).rotate_right(20)),",
          "    c: TestVec(-1.wrapping_sub((-1.wrapping_sub(-1).rotate_right(16))).rotate_right(24)),",
          "    d: TestVec((-1 ^ -2).rotate_right(16)),",
          "    };",
          "    ",
          "    assert_eq!(_result.a, expected_result.a);",
          "    assert_eq!(_result.b, expected_result.b);",
          "    assert_eq!(_result.c, expected_result.c);",
          "    assert_eq!(_result.d, expected_result.d);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVec(i32);",
          "    impl ArithOps for TestVec {",
          "        fn add(self, rhs: Self) -> Self {",
          "            TestVec(self.0.wrapping_add(rhs.0))",
          "        }",
          "    }",
          "    ",
          "    impl BitOps32 for TestVec {",
          "        fn rotate_each_word_right16(self) -> Self {",
          "            TestVec(self.0.rotate_right(16))",
          "        }",
          "        ",
          "        fn rotate_each_word_right20(self) -> Self {",
          "            TestVec(self.0.rotate_right(20))",
          "        }",
          "        ",
          "        fn rotate_each_word_right24(self) -> Self {",
          "            TestVec(self.0.rotate_right(24))",
          "        }",
          "        ",
          "        fn rotate_each_word_right25(self) -> Self {",
          "            TestVec(self.0.rotate_right(25))",
          "        }",
          "    }",
          "",
          "    let state = State {",
          "        a: TestVec(15),",
          "        b: TestVec(27),",
          "        c: TestVec(-5),",
          "        d: TestVec(0),",
          "    };",
          "    let _result = round(state);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.a, TestVec(42));",
          "    assert_eq!(_result.b, TestVec(-26));",
          "    assert_eq!(_result.c, TestVec(57));",
          "    assert_eq!(_result.d, TestVec(100));"
        ],
        "code": [
          "{",
          "    struct TestVec(i32);",
          "    impl ArithOps for TestVec {",
          "        fn add(self, rhs: Self) -> Self {",
          "            TestVec(self.0.wrapping_add(rhs.0))",
          "        }",
          "    }",
          "    ",
          "    impl BitOps32 for TestVec {",
          "        fn rotate_each_word_right16(self) -> Self {",
          "            TestVec(self.0.rotate_right(16))",
          "        }",
          "        ",
          "        fn rotate_each_word_right20(self) -> Self {",
          "            TestVec(self.0.rotate_right(20))",
          "        }",
          "        ",
          "        fn rotate_each_word_right24(self) -> Self {",
          "            TestVec(self.0.rotate_right(24))",
          "        }",
          "        ",
          "        fn rotate_each_word_right25(self) -> Self {",
          "            TestVec(self.0.rotate_right(25))",
          "        }",
          "    }",
          "",
          "    let state = State {",
          "        a: TestVec(15),",
          "        b: TestVec(27),",
          "        c: TestVec(-5),",
          "        d: TestVec(0),",
          "    };",
          "    let _result = round(state);",
          "    assert_eq!(_result.a, TestVec(42));",
          "    assert_eq!(_result.b, TestVec(-26));",
          "    assert_eq!(_result.c, TestVec(57));",
          "    assert_eq!(_result.d, TestVec(100));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]