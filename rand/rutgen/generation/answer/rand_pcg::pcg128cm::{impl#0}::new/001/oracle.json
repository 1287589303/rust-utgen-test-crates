[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state: u128 = 0;",
          "    let stream: u128 = 0;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "}"
        ],
        "oracle": [
          "    let rng = Lcg128CmDxsm64::new(0xcafef00dd15ea5e5, 0xa02bdbf7bb3c0a7ac28fa16a64abf96);",
          "    assert_eq!(rng.state, 0xcafef00dd15ea5e5.wrapping_add((0xa02bdbf7bb3c0a7ac28fa16a64abf96 << 1) | 1));",
          "    let rng = Lcg128CmDxsm64::new(1, 2);",
          "    assert_eq!(rng.state, 1.wrapping_add((2 << 1) | 1));",
          "    let rng = Lcg128CmDxsm64::new(u128::MAX, u128::MAX);",
          "    assert_eq!(rng.state, u128::MAX.wrapping_add((u128::MAX << 1) | 1));",
          "    let rng = Lcg128CmDxsm64::new(0, 0);",
          "    assert_eq!(rng.state, 0.wrapping_add((0 << 1) | 1));"
        ],
        "code": [
          "{",
          "    let state: u128 = 0;",
          "    let stream: u128 = 0;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    let rng = Lcg128CmDxsm64::new(0xcafef00dd15ea5e5, 0xa02bdbf7bb3c0a7ac28fa16a64abf96);",
          "    assert_eq!(rng.state, 0xcafef00dd15ea5e5.wrapping_add((0xa02bdbf7bb3c0a7ac28fa16a64abf96 << 1) | 1));",
          "    let rng = Lcg128CmDxsm64::new(1, 2);",
          "    assert_eq!(rng.state, 1.wrapping_add((2 << 1) | 1));",
          "    let rng = Lcg128CmDxsm64::new(u128::MAX, u128::MAX);",
          "    assert_eq!(rng.state, u128::MAX.wrapping_add((u128::MAX << 1) | 1));",
          "    let rng = Lcg128CmDxsm64::new(0, 0);",
          "    assert_eq!(rng.state, 0.wrapping_add((0 << 1) | 1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state: u128 = 0;",
          "    let stream: u128 = u128::MAX;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 0.wrapping_add((u128::MAX << 1) | 1));",
          "    assert_eq!(rng.increment, (u128::MAX << 1) | 1);",
          "    assert_eq!(rng.state, 0);",
          "    assert_eq!(rng.increment & 1, 1);"
        ],
        "code": [
          "{",
          "    let state: u128 = 0;",
          "    let stream: u128 = u128::MAX;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    assert_eq!(rng.state, 0.wrapping_add((u128::MAX << 1) | 1));",
          "    assert_eq!(rng.increment, (u128::MAX << 1) | 1);",
          "    assert_eq!(rng.state, 0);",
          "    assert_eq!(rng.increment & 1, 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state: u128 = u128::MAX;",
          "    let stream: u128 = 0;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, u128::MAX.wrapping_add(1));",
          "    assert_eq!(rng.increment, 1);",
          "    assert_eq!(rng.state & 1, 1);",
          "    assert_ne!(rng.state, 0);"
        ],
        "code": [
          "{",
          "    let state: u128 = u128::MAX;",
          "    let stream: u128 = 0;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    assert_eq!(rng.state, u128::MAX.wrapping_add(1));",
          "    assert_eq!(rng.increment, 1);",
          "    assert_eq!(rng.state & 1, 1);",
          "    assert_ne!(rng.state, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state: u128 = u128::MAX;",
          "    let stream: u128 = u128::MAX;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, u128::MAX.wrapping_add((u128::MAX << 1) | 1));",
          "    assert_eq!(rng.increment, (u128::MAX << 1) | 1);"
        ],
        "code": [
          "{",
          "    let state: u128 = u128::MAX;",
          "    let stream: u128 = u128::MAX;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    assert_eq!(rng.state, u128::MAX.wrapping_add((u128::MAX << 1) | 1));",
          "    assert_eq!(rng.increment, (u128::MAX << 1) | 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state: u128 = 0x1234567890abcdef1234567890abcdef;",
          "    let stream: u128 = 0xabcdefabcdefabcdefabcdefabcdefabcdef >> 1; // ensure highest bit is discarded",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, state.wrapping_add((stream << 1) | 1));",
          "    assert_eq!(rng.increment, (stream << 1) | 1);",
          "    assert!(rng.increment % 2 == 1);",
          "    assert!(rng.state < u128::MAX);",
          "    assert!(rng.increment < u128::MAX);",
          "    assert_eq!(rng.state, 0x1234567890abcdef1234567890abcdef.wrapping_add(0xabcdefabcdefabcdefabcdefabcdefabcdef >> 1 << 1 | 1);"
        ],
        "code": [
          "{",
          "    let state: u128 = 0x1234567890abcdef1234567890abcdef;",
          "    let stream: u128 = 0xabcdefabcdefabcdefabcdefabcdefabcdef >> 1; // ensure highest bit is discarded",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    assert_eq!(rng.state, state.wrapping_add((stream << 1) | 1));",
          "    assert_eq!(rng.increment, (stream << 1) | 1);",
          "    assert!(rng.increment % 2 == 1);",
          "    assert!(rng.state < u128::MAX);",
          "    assert!(rng.increment < u128::MAX);",
          "    assert_eq!(rng.state, 0x1234567890abcdef1234567890abcdef.wrapping_add(0xabcdefabcdefabcdefabcdefabcdefabcdef >> 1 << 1 | 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state: u128 = 0xdeadbeefcafef00dd15ea5e5;",
          "    let stream: u128 = 0x7fffffffffffffff; // odd stream value after discarding highest bit",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "}"
        ],
        "oracle": [
          "    let state: u128 = 0xdeadbeefcafef00dd15ea5e5;",
          "    let stream: u128 = 0x7fffffffffffffff;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    let expected_increment: u128 = (stream << 1) | 1;",
          "    assert_eq!(rng.increment, expected_increment);",
          "    assert_eq!(rng.state, state.wrapping_add(expected_increment));",
          "    assert_eq!(rng.increment.is_odd(), true);",
          "    assert_eq!(rng.state, 0xdeadbeefcafef00dd15ea5e5.wrapping_add(0x7fffffffffffffff << 1 | 1));"
        ],
        "code": [
          "{",
          "    let state: u128 = 0xdeadbeefcafef00dd15ea5e5;",
          "    let stream: u128 = 0x7fffffffffffffff; // odd stream value after discarding highest bit",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    let state: u128 = 0xdeadbeefcafef00dd15ea5e5;",
          "    let stream: u128 = 0x7fffffffffffffff;",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    let expected_increment: u128 = (stream << 1) | 1;",
          "    assert_eq!(rng.increment, expected_increment);",
          "    assert_eq!(rng.state, state.wrapping_add(expected_increment));",
          "    assert_eq!(rng.increment.is_odd(), true);",
          "    assert_eq!(rng.state, 0xdeadbeefcafef00dd15ea5e5.wrapping_add(0x7fffffffffffffff << 1 | 1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state: u128 = 0x1;",
          "    let stream: u128 = 0x2; // this will cause increment to be odd after shifting",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(rng.state, 0x1.wrapping_add(0x2 << 1 | 1));",
          "    assert_eq!(rng.increment, 0x2 << 1 | 1);"
        ],
        "code": [
          "{",
          "    let state: u128 = 0x1;",
          "    let stream: u128 = 0x2; // this will cause increment to be odd after shifting",
          "    let rng = Lcg128CmDxsm64::new(state, stream);",
          "    assert_eq!(rng.state, 0x1.wrapping_add(0x2 << 1 | 1));",
          "    assert_eq!(rng.increment, 0x2 << 1 | 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]