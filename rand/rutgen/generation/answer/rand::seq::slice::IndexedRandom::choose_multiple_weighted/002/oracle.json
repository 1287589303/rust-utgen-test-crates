[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSlice<'a>(&'a [(char, f64)]);",
          "",
          "    impl<'a> IndexedRandom for TestSlice<'a> {",
          "        type Output = (char, f64);",
          "        ",
          "        fn len(&self) -> usize {",
          "            self.0.len()",
          "        }",
          "",
          "        #[inline]",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "        ",
          "        fn choose<R>(&self, _: &mut R) -> Option<&Self::Output>",
          "        where R: Rng + ?Sized {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let choices = TestSlice(&[('a', 2.0), ('b', 1.0), ('c', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    let _ = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "}"
        ],
        "oracle": [
          "    assert!(choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok());",
          "    ",
          "    let result = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert_eq!(result.indices.len(), 2);",
          "    ",
          "    let empty_choices = TestSlice(&[]);",
          "    assert!(empty_choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok());",
          "    ",
          "    let choices_equal_weight = TestSlice(&[('d', 0.0), ('e', 0.0), ('f', 0.0)]);",
          "    assert!(choices_equal_weight.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok());",
          "    ",
          "    let invalid_choices = TestSlice(&[('g', f64::NAN), ('h', 1.0)]);",
          "    assert!(invalid_choices.choose_multiple_weighted(&mut rng, 1, |item| item.1).is_err());",
          "    ",
          "    let choices_edge_cases = TestSlice(&[('i', 1.0), ('j', 2.0)]);",
          "    let result_edge = choices_edge_cases.choose_multiple_weighted(&mut rng, 1, |item| item.1).unwrap();",
          "    assert!(result_edge.slice.len() == 2);",
          "    assert!(result_edge.indices.len() == 1);"
        ],
        "code": [
          "{",
          "    struct TestSlice<'a>(&'a [(char, f64)]);",
          "",
          "    impl<'a> IndexedRandom for TestSlice<'a> {",
          "        type Output = (char, f64);",
          "        ",
          "        fn len(&self) -> usize {",
          "            self.0.len()",
          "        }",
          "",
          "        #[inline]",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "        ",
          "        fn choose<R>(&self, _: &mut R) -> Option<&Self::Output>",
          "        where R: Rng + ?Sized {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let choices = TestSlice(&[('a', 2.0), ('b', 1.0), ('c', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    let _ = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "    assert!(choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok());",
          "    ",
          "    let result = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert_eq!(result.indices.len(), 2);",
          "    ",
          "    let empty_choices = TestSlice(&[]);",
          "    assert!(empty_choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok());",
          "    ",
          "    let choices_equal_weight = TestSlice(&[('d', 0.0), ('e', 0.0), ('f', 0.0)]);",
          "    assert!(choices_equal_weight.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok());",
          "    ",
          "    let invalid_choices = TestSlice(&[('g', f64::NAN), ('h', 1.0)]);",
          "    assert!(invalid_choices.choose_multiple_weighted(&mut rng, 1, |item| item.1).is_err());",
          "    ",
          "    let choices_edge_cases = TestSlice(&[('i', 1.0), ('j', 2.0)]);",
          "    let result_edge = choices_edge_cases.choose_multiple_weighted(&mut rng, 1, |item| item.1).unwrap();",
          "    assert!(result_edge.slice.len() == 2);",
          "    assert!(result_edge.indices.len() == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSlice<'a>(&'a [(char, f64)]);",
          "",
          "    impl<'a> IndexedRandom for TestSlice<'a> {",
          "        type Output = (char, f64);",
          "        ",
          "        fn len(&self) -> usize {",
          "            self.0.len()",
          "        }",
          "",
          "        #[inline]",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "",
          "        fn choose<R>(&self, _: &mut R) -> Option<&Self::Output>",
          "        where R: Rng + ?Sized {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let choices = TestSlice(&[('x', 1.0), ('y', 1.0), ('z', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    let _ = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "}"
        ],
        "oracle": [
          "    let choices = TestSlice(&[('a', 2.0), ('b', 1.0), ('c', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    assert_eq!(choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok(), true);",
          "    ",
          "    let choices_empty = TestSlice(&[]);",
          "    let mut rng_empty = rand::thread_rng();",
          "    assert_eq!(choices_empty.choose_multiple_weighted(&mut rng_empty, 1, |item| item.1).is_err(), true);",
          "    ",
          "    let choices_invalid_weights = TestSlice(&[('a', -1.0), ('b', 2.0)]);",
          "    let mut rng_invalid = rand::thread_rng();",
          "    assert_eq!(choices_invalid_weights.choose_multiple_weighted(&mut rng_invalid, 1, |item| item.1).is_err(), true);",
          "    ",
          "    let choices_equal_weights = TestSlice(&[('x', 0.0), ('y', 0.0), ('z', 0.0)]);",
          "    let mut rng_equal = rand::thread_rng();",
          "    assert_eq!(choices_equal_weights.choose_multiple_weighted(&mut rng_equal, 2, |item| item.1).is_ok(), true);"
        ],
        "code": [
          "{",
          "    struct TestSlice<'a>(&'a [(char, f64)]);",
          "",
          "    impl<'a> IndexedRandom for TestSlice<'a> {",
          "        type Output = (char, f64);",
          "        ",
          "        fn len(&self) -> usize {",
          "            self.0.len()",
          "        }",
          "",
          "        #[inline]",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "",
          "        fn choose<R>(&self, _: &mut R) -> Option<&Self::Output>",
          "        where R: Rng + ?Sized {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let choices = TestSlice(&[('x', 1.0), ('y', 1.0), ('z', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    let _ = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "    let choices = TestSlice(&[('a', 2.0), ('b', 1.0), ('c', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    assert_eq!(choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok(), true);",
          "    ",
          "    let choices_empty = TestSlice(&[]);",
          "    let mut rng_empty = rand::thread_rng();",
          "    assert_eq!(choices_empty.choose_multiple_weighted(&mut rng_empty, 1, |item| item.1).is_err(), true);",
          "    ",
          "    let choices_invalid_weights = TestSlice(&[('a', -1.0), ('b', 2.0)]);",
          "    let mut rng_invalid = rand::thread_rng();",
          "    assert_eq!(choices_invalid_weights.choose_multiple_weighted(&mut rng_invalid, 1, |item| item.1).is_err(), true);",
          "    ",
          "    let choices_equal_weights = TestSlice(&[('x', 0.0), ('y', 0.0), ('z', 0.0)]);",
          "    let mut rng_equal = rand::thread_rng();",
          "    assert_eq!(choices_equal_weights.choose_multiple_weighted(&mut rng_equal, 2, |item| item.1).is_ok(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSlice<'a>(&'a [(char, f64)]);",
          "",
          "    impl<'a> IndexedRandom for TestSlice<'a> {",
          "        type Output = (char, f64);",
          "        ",
          "        fn len(&self) -> usize {",
          "            self.0.len()",
          "        }",
          "",
          "        #[inline]",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "",
          "        fn choose<R>(&self, _: &mut R) -> Option<&Self::Output>",
          "        where R: Rng + ?Sized {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let choices = TestSlice(&[('k', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    let _ = choices.choose_multiple_weighted(&mut rng, 1, |item| item.1);",
          "}"
        ],
        "oracle": [
          "    assert!(choices.choose_multiple_weighted(&mut rng, 1, |item| item.1).is_ok());",
          "    let result = choices.choose_multiple_weighted(&mut rng, 1, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert_eq!(result.indices.len(), 1);",
          "    assert!(result.indices.next().is_some());",
          "    let weights = [1.0];",
          "    let choices = TestSlice(&[('a', weights[0]), ('b', weights[0]), ('c', weights[0])]);",
          "    let result = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert_eq!(result.indices.len(), 2);",
          "    assert!(result.indices.all(|idx| idx < choices.len()));",
          "    let choices = TestSlice(&[('a', 0.0), ('b', 0.0), ('c', 0.0)]);",
          "    assert!(choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok());",
          "    let result = choices.choose_multiple_weighted(&mut rng, 0, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert_eq!(result.indices.len(), 0);",
          "    let weights = [1.0, 3.0];",
          "    let choices = TestSlice(&[('x', weights[0]), ('y', weights[1])]);",
          "    assert!(choices.choose_multiple_weighted(&mut rng, 1, |item| item.1).is_ok());",
          "    let result = choices.choose_multiple_weighted(&mut rng, 3, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert!(result.indices.len() <= 2);"
        ],
        "code": [
          "{",
          "    struct TestSlice<'a>(&'a [(char, f64)]);",
          "",
          "    impl<'a> IndexedRandom for TestSlice<'a> {",
          "        type Output = (char, f64);",
          "        ",
          "        fn len(&self) -> usize {",
          "            self.0.len()",
          "        }",
          "",
          "        #[inline]",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "",
          "        fn choose<R>(&self, _: &mut R) -> Option<&Self::Output>",
          "        where R: Rng + ?Sized {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let choices = TestSlice(&[('k', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    let _ = choices.choose_multiple_weighted(&mut rng, 1, |item| item.1);",
          "    assert!(choices.choose_multiple_weighted(&mut rng, 1, |item| item.1).is_ok());",
          "    let result = choices.choose_multiple_weighted(&mut rng, 1, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert_eq!(result.indices.len(), 1);",
          "    assert!(result.indices.next().is_some());",
          "    let weights = [1.0];",
          "    let choices = TestSlice(&[('a', weights[0]), ('b', weights[0]), ('c', weights[0])]);",
          "    let result = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert_eq!(result.indices.len(), 2);",
          "    assert!(result.indices.all(|idx| idx < choices.len()));",
          "    let choices = TestSlice(&[('a', 0.0), ('b', 0.0), ('c', 0.0)]);",
          "    assert!(choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).is_ok());",
          "    let result = choices.choose_multiple_weighted(&mut rng, 0, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert_eq!(result.indices.len(), 0);",
          "    let weights = [1.0, 3.0];",
          "    let choices = TestSlice(&[('x', weights[0]), ('y', weights[1])]);",
          "    assert!(choices.choose_multiple_weighted(&mut rng, 1, |item| item.1).is_ok());",
          "    let result = choices.choose_multiple_weighted(&mut rng, 3, |item| item.1).unwrap();",
          "    assert_eq!(result.slice, choices);",
          "    assert!(result.indices.len() <= 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSlice<'a>(&'a [(char, f64)]);",
          "",
          "    impl<'a> IndexedRandom for TestSlice<'a> {",
          "        type Output = (char, f64);",
          "        ",
          "        fn len(&self) -> usize {",
          "            self.0.len()",
          "        }",
          "",
          "        #[inline]",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "",
          "        fn choose<R>(&self, _: &mut R) -> Option<&Self::Output>",
          "        where R: Rng + ?Sized {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let choices = TestSlice(&[('p', 3.0), ('q', 2.0), ('r', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    let _ = choices.choose_multiple_weighted(&mut rng, 3, |item| item.1);",
          "}"
        ],
        "oracle": [
          "    let choices = TestSlice(&[('a', 2.0), ('b', 1.0), ('c', 1.0)]);",
          "    let result = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "    assert!(result.is_ok());",
          "    let indices = result.unwrap().indices;",
          "    assert_eq!(indices.len(), 2);",
          "    ",
          "    let choices_empty = TestSlice(&[]);",
          "    let result_empty = choices_empty.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let choices_weights_zero = TestSlice(&[('a', 0.0), ('b', 0.0)]);",
          "    let result_weights_zero = choices_weights_zero.choose_multiple_weighted(&mut rng, 1, |item| item.1);",
          "    assert!(result_weights_zero.is_err());",
          "    ",
          "    let choices_weights_insufficient = TestSlice(&[('a', 1.0), ('b', 0.0)]);",
          "    let result_weights_insufficient = choices_weights_insufficient.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "    assert!(result_weights_insufficient.is_err());"
        ],
        "code": [
          "{",
          "    struct TestSlice<'a>(&'a [(char, f64)]);",
          "",
          "    impl<'a> IndexedRandom for TestSlice<'a> {",
          "        type Output = (char, f64);",
          "        ",
          "        fn len(&self) -> usize {",
          "            self.0.len()",
          "        }",
          "",
          "        #[inline]",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "",
          "        fn choose<R>(&self, _: &mut R) -> Option<&Self::Output>",
          "        where R: Rng + ?Sized {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let choices = TestSlice(&[('p', 3.0), ('q', 2.0), ('r', 1.0)]);",
          "    let mut rng = rand::thread_rng();",
          "    let _ = choices.choose_multiple_weighted(&mut rng, 3, |item| item.1);",
          "    let choices = TestSlice(&[('a', 2.0), ('b', 1.0), ('c', 1.0)]);",
          "    let result = choices.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "    assert!(result.is_ok());",
          "    let indices = result.unwrap().indices;",
          "    assert_eq!(indices.len(), 2);",
          "    ",
          "    let choices_empty = TestSlice(&[]);",
          "    let result_empty = choices_empty.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let choices_weights_zero = TestSlice(&[('a', 0.0), ('b', 0.0)]);",
          "    let result_weights_zero = choices_weights_zero.choose_multiple_weighted(&mut rng, 1, |item| item.1);",
          "    assert!(result_weights_zero.is_err());",
          "    ",
          "    let choices_weights_insufficient = TestSlice(&[('a', 1.0), ('b', 0.0)]);",
          "    let result_weights_insufficient = choices_weights_insufficient.choose_multiple_weighted(&mut rng, 2, |item| item.1);",
          "    assert!(result_weights_insufficient.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]