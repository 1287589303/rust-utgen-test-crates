[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(0, 1);",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0x5DA4019D9B07D8C0);",
          "    assert!(result >= 0);",
          "    assert!(result <= u64::MAX);",
          "    assert_ne!(result, rng.next_u64());",
          "    let mut rng2 = Lcg128Xsl64::new(0, 1);",
          "    assert_eq!(result, rng2.next_u64());"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(0, 1);",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, 0x5DA4019D9B07D8C0);",
          "    assert!(result >= 0);",
          "    assert!(result <= u64::MAX);",
          "    assert_ne!(result, rng.next_u64());",
          "    let mut rng2 = Lcg128Xsl64::new(0, 1);",
          "    assert_eq!(result, rng2.next_u64());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(u128::MAX, 1);",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, expected_value);",
          "    assert!(result <= u64::MAX);",
          "    assert_ne!(result, 0);",
          "    assert!(result > previous_result);",
          "    assert!(result != rng.state as u64);",
          "    assert!(result >= 0);",
          "    let next_result = rng.next_u64();",
          "    assert!(next_result != result);",
          "    rng.advance(1);",
          "    let advanced_result = rng.next_u64();",
          "    assert!(advanced_result > result);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(u128::MAX, 1);",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, expected_value);",
          "    assert!(result <= u64::MAX);",
          "    assert_ne!(result, 0);",
          "    assert!(result > previous_result);",
          "    assert!(result != rng.state as u64);",
          "    assert!(result >= 0);",
          "    let next_result = rng.next_u64();",
          "    assert!(next_result != result);",
          "    rng.advance(1);",
          "    let advanced_result = rng.next_u64();",
          "    assert!(advanced_result > result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(1_000_000, u128::MAX);",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, expected_value);",
          "    assert!(result <= u64::MAX);",
          "    assert!(result >= 0);",
          "    assert!(result != rng.next_u64());",
          "    assert!(result == output_xsl_rr(rng.state));",
          "    rng.advance(1);",
          "    let next_result = rng.next_u64();",
          "    assert!(next_result != result);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(1_000_000, u128::MAX);",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, expected_value);",
          "    assert!(result <= u64::MAX);",
          "    assert!(result >= 0);",
          "    assert!(result != rng.next_u64());",
          "    assert!(result == output_xsl_rr(rng.state));",
          "    rng.advance(1);",
          "    let next_result = rng.next_u64();",
          "    assert!(next_result != result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let increments = [1, 10, 100, 1_000, u128::MAX];",
          "    for &increment in increments.iter() {",
          "        let mut rng = Lcg128Xsl64::new(1, increment);",
          "        let result = rng.next_u64();",
          "    }",
          "}"
        ],
        "oracle": [
          "    let increments = [1, 10, 100, 1_000, u128::MAX];",
          "    for &increment in increments.iter() {",
          "    let mut rng = Lcg128Xsl64::new(1, increment);",
          "    let result = rng.next_u64();",
          "    assert!(result <= u64::MAX);",
          "    }",
          "    assert_ne!(rng.next_u64(), rng.next_u64());",
          "    assert_eq!(Lcg128Xsl64::new(1, 1).next_u64(), Lcg128Xsl64::new(1, 1).next_u64());",
          "    assert_eq!(Lcg128Xsl64::new(1, 10).next_u64(), Lcg128Xsl64::new(1, 10).next_u64());"
        ],
        "code": [
          "{",
          "    let increments = [1, 10, 100, 1_000, u128::MAX];",
          "    for &increment in increments.iter() {",
          "        let mut rng = Lcg128Xsl64::new(1, increment);",
          "        let result = rng.next_u64();",
          "    }",
          "    let increments = [1, 10, 100, 1_000, u128::MAX];",
          "    for &increment in increments.iter() {",
          "    let mut rng = Lcg128Xsl64::new(1, increment);",
          "    let result = rng.next_u64();",
          "    assert!(result <= u64::MAX);",
          "    }",
          "    assert_ne!(rng.next_u64(), rng.next_u64());",
          "    assert_eq!(Lcg128Xsl64::new(1, 1).next_u64(), Lcg128Xsl64::new(1, 1).next_u64());",
          "    assert_eq!(Lcg128Xsl64::new(1, 10).next_u64(), Lcg128Xsl64::new(1, 10).next_u64());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(u128::MAX - 1, 2);",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, expected_value);",
          "    assert!(result <= u64::MAX);",
          "    assert!(result >= 0);",
          "    assert!(rng.state != u128::MAX - 1);",
          "    assert!(rng.increment == 5);",
          "    assert!(result.is_power_of_two() || result.is_odd());",
          "    assert!(rng.state > 0);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(u128::MAX - 1, 2);",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, expected_value);",
          "    assert!(result <= u64::MAX);",
          "    assert!(result >= 0);",
          "    assert!(rng.state != u128::MAX - 1);",
          "    assert!(rng.increment == 5);",
          "    assert!(result.is_power_of_two() || result.is_odd());",
          "    assert!(rng.state > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(0, 2);",
          "    let result = rng.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, expected_result);",
          "    assert!(result <= u64::MAX);",
          "    assert!(result >= 0);",
          "    assert!(rng.state != 0);",
          "    assert_eq!(rng.increment, 5);",
          "    assert_eq!(rng.state, initial_state);",
          "    assert_ne!(result, previous_result);",
          "    assert!(result > 0);"
        ],
        "code": [
          "{",
          "    let mut rng = Lcg128Xsl64::new(0, 2);",
          "    let result = rng.next_u64();",
          "    assert_eq!(result, expected_result);",
          "    assert!(result <= u64::MAX);",
          "    assert!(result >= 0);",
          "    assert!(rng.state != 0);",
          "    assert_eq!(rng.increment, 5);",
          "    assert_eq!(rng.state, initial_state);",
          "    assert_ne!(result, previous_result);",
          "    assert!(result > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut rng1 = Lcg128Xsl64::new(u128::MAX - 1, u128::MAX);",
          "    let result1 = rng1.next_u64();",
          "",
          "    let mut rng2 = Lcg128Xsl64::new(0, u128::MAX);",
          "    let result2 = rng2.next_u64();",
          "}"
        ],
        "oracle": [
          "    assert!(result1 != result2);",
          "    assert_eq!(result1, output_xsl_rr(rng1.state));",
          "    assert_eq!(result2, output_xsl_rr(rng2.state));"
        ],
        "code": [
          "{",
          "    let mut rng1 = Lcg128Xsl64::new(u128::MAX - 1, u128::MAX);",
          "    let result1 = rng1.next_u64();",
          "",
          "    let mut rng2 = Lcg128Xsl64::new(0, u128::MAX);",
          "    let result2 = rng2.next_u64();",
          "    assert!(result1 != result2);",
          "    assert_eq!(result1, output_xsl_rr(rng1.state));",
          "    assert_eq!(result2, output_xsl_rr(rng2.state));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]