[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestArray<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'a> Index<usize> for TestArray<'a> {",
          "        type Output = u8;",
          "",
          "        fn index(&self, index: usize) -> &Self::Output {",
          "            &self.data[index]",
          "        }",
          "    }",
          "",
          "    impl<'a> IndexedRandom for TestArray<'a> {",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "    }",
          "",
          "    let mut rng = &mut rand::rng();",
          "    let sample = b\"Hello, audience!\";",
          "    let array = TestArray { data: sample };",
          "",
          "    let a: [u8; 3] = array.choose_multiple_array(&mut rng).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(array.len(), 16);",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().len() == 3);",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().iter().all(|&x| array.data.contains(&x)));",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().windows(2).all(|w| w[0] != w[1]));"
        ],
        "code": [
          "{",
          "    struct TestArray<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'a> Index<usize> for TestArray<'a> {",
          "        type Output = u8;",
          "",
          "        fn index(&self, index: usize) -> &Self::Output {",
          "            &self.data[index]",
          "        }",
          "    }",
          "",
          "    impl<'a> IndexedRandom for TestArray<'a> {",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "    }",
          "",
          "    let mut rng = &mut rand::rng();",
          "    let sample = b\"Hello, audience!\";",
          "    let array = TestArray { data: sample };",
          "",
          "    let a: [u8; 3] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(array.len(), 16);",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().len() == 3);",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().iter().all(|&x| array.data.contains(&x)));",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().windows(2).all(|w| w[0] != w[1]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestArray<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'a> Index<usize> for TestArray<'a> {",
          "        type Output = u8;",
          "",
          "        fn index(&self, index: usize) -> &Self::Output {",
          "            &self.data[index]",
          "        }",
          "    }",
          "",
          "    impl<'a> IndexedRandom for TestArray<'a> {",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "    }",
          "",
          "    let mut rng = &mut rand::rng();",
          "    let sample = b\"Hello!\";",
          "    let array = TestArray { data: sample };",
          "",
          "    let a: [u8; 6] = array.choose_multiple_array(&mut rng).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(array.len(), 6);",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    let result = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(result.len(), 6);",
          "    assert!(result.iter().all(|&x| array.data.contains(&x)));",
          "    assert!(result.iter().collect::<std::collections::HashSet<_>>().len() == result.len());",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    assert!(array.choose_multiple_array(&mut rng).is_ok());",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().iter().count() == 6);"
        ],
        "code": [
          "{",
          "    struct TestArray<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'a> Index<usize> for TestArray<'a> {",
          "        type Output = u8;",
          "",
          "        fn index(&self, index: usize) -> &Self::Output {",
          "            &self.data[index]",
          "        }",
          "    }",
          "",
          "    impl<'a> IndexedRandom for TestArray<'a> {",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "    }",
          "",
          "    let mut rng = &mut rand::rng();",
          "    let sample = b\"Hello!\";",
          "    let array = TestArray { data: sample };",
          "",
          "    let a: [u8; 6] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(array.len(), 6);",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    let result = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(result.len(), 6);",
          "    assert!(result.iter().all(|&x| array.data.contains(&x)));",
          "    assert!(result.iter().collect::<std::collections::HashSet<_>>().len() == result.len());",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    assert!(array.choose_multiple_array(&mut rng).is_ok());",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().iter().count() == 6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestArray<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'a> Index<usize> for TestArray<'a> {",
          "        type Output = u8;",
          "",
          "        fn index(&self, index: usize) -> &Self::Output {",
          "            &self.data[index]",
          "        }",
          "    }",
          "",
          "    impl<'a> IndexedRandom for TestArray<'a> {",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "    }",
          "",
          "    let mut rng = &mut rand::rng();",
          "    let sample = b\"Data\";",
          "    let array = TestArray { data: sample };",
          "",
          "    let a: [u8; 0] = array.choose_multiple_array(&mut rng).unwrap();",
          "}"
        ],
        "oracle": [
          "    let rng = &mut rand::rng();",
          "    let sample = b\"Data\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 0] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a, []);",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"ABCD\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 4] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a.len(), 4);",
          "    assert!(a.iter().all(|&x| sample.contains(&x)));",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"Hello\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 3] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a.len(), 3);",
          "    assert!(a.iter().all(|&x| sample.contains(&x)));",
          "    assert_eq!(a.iter().collect::<std::collections::HashSet<_>>().len(), 3);",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"\";",
          "    let array = TestArray { data: sample };",
          "    let result: Option<[u8; 1]> = array.choose_multiple_array(&mut rng);",
          "    assert!(result.is_none());",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"XYZ\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 2] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a.len(), 2);",
          "    assert!(a.iter().all(|&x| sample.contains(&x)));",
          "    assert_eq!(a.iter().collect::<std::collections::HashSet<_>>().len(), 2);",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"ABCDE\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 5] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a.len(), 5);",
          "    assert!(a.iter().all(|&x| sample.contains(&x)));",
          "    assert_eq!(a.iter().collect::<std::collections::HashSet<_>>().len(), 5);"
        ],
        "code": [
          "{",
          "    struct TestArray<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'a> Index<usize> for TestArray<'a> {",
          "        type Output = u8;",
          "",
          "        fn index(&self, index: usize) -> &Self::Output {",
          "            &self.data[index]",
          "        }",
          "    }",
          "",
          "    impl<'a> IndexedRandom for TestArray<'a> {",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "    }",
          "",
          "    let mut rng = &mut rand::rng();",
          "    let sample = b\"Data\";",
          "    let array = TestArray { data: sample };",
          "",
          "    let a: [u8; 0] = array.choose_multiple_array(&mut rng).unwrap();",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"Data\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 0] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a, []);",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"ABCD\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 4] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a.len(), 4);",
          "    assert!(a.iter().all(|&x| sample.contains(&x)));",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"Hello\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 3] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a.len(), 3);",
          "    assert!(a.iter().all(|&x| sample.contains(&x)));",
          "    assert_eq!(a.iter().collect::<std::collections::HashSet<_>>().len(), 3);",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"\";",
          "    let array = TestArray { data: sample };",
          "    let result: Option<[u8; 1]> = array.choose_multiple_array(&mut rng);",
          "    assert!(result.is_none());",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"XYZ\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 2] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a.len(), 2);",
          "    assert!(a.iter().all(|&x| sample.contains(&x)));",
          "    assert_eq!(a.iter().collect::<std::collections::HashSet<_>>().len(), 2);",
          "    ",
          "    let rng = &mut rand::rng();",
          "    let sample = b\"ABCDE\";",
          "    let array = TestArray { data: sample };",
          "    let a: [u8; 5] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(a.len(), 5);",
          "    assert!(a.iter().all(|&x| sample.contains(&x)));",
          "    assert_eq!(a.iter().collect::<std::collections::HashSet<_>>().len(), 5);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestArray<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'a> Index<usize> for TestArray<'a> {",
          "        type Output = u8;",
          "",
          "        fn index(&self, index: usize) -> &Self::Output {",
          "            &self.data[index]",
          "        }",
          "    }",
          "",
          "    impl<'a> IndexedRandom for TestArray<'a> {",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "    }",
          "",
          "    let mut rng = &mut rand::rng();",
          "    let sample = b\"Hello, audience!\";",
          "    let array = TestArray { data: sample };",
          "",
          "    // N is larger than the length of the slice",
          "    let _a: [u8; 20] = array.choose_multiple_array(&mut rng).unwrap();",
          "}"
        ],
        "oracle": [
          "    let _a: [u8; 3] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(_a.len(), 3);",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    let valid_array = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert!(valid_array.iter().all(|&x| array.data.contains(&x)));",
          "    assert_eq!(valid_array.len(), 3);",
          "    assert!(valid_array.iter().collect::<std::collections::HashSet<_>>().len() == valid_array.len());",
          "    let empty_array = TestArray { data: &[] };",
          "    assert!(empty_array.choose_multiple_array(&mut rng).is_none());",
          "    let _b: [u8; 2] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert!(array.len() >= 2);",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().iter().all(|&x| array.data.contains(&x)));"
        ],
        "code": [
          "{",
          "    struct TestArray<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'a> Index<usize> for TestArray<'a> {",
          "        type Output = u8;",
          "",
          "        fn index(&self, index: usize) -> &Self::Output {",
          "            &self.data[index]",
          "        }",
          "    }",
          "",
          "    impl<'a> IndexedRandom for TestArray<'a> {",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn is_empty(&self) -> bool {",
          "            self.len() == 0",
          "        }",
          "    }",
          "",
          "    let mut rng = &mut rand::rng();",
          "    let sample = b\"Hello, audience!\";",
          "    let array = TestArray { data: sample };",
          "",
          "    // N is larger than the length of the slice",
          "    let _a: [u8; 20] = array.choose_multiple_array(&mut rng).unwrap();",
          "    let _a: [u8; 3] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert_eq!(_a.len(), 3);",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    let valid_array = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert!(valid_array.iter().all(|&x| array.data.contains(&x)));",
          "    assert_eq!(valid_array.len(), 3);",
          "    assert!(valid_array.iter().collect::<std::collections::HashSet<_>>().len() == valid_array.len());",
          "    let empty_array = TestArray { data: &[] };",
          "    assert!(empty_array.choose_multiple_array(&mut rng).is_none());",
          "    let _b: [u8; 2] = array.choose_multiple_array(&mut rng).unwrap();",
          "    assert!(array.len() >= 2);",
          "    assert!(array.choose_multiple_array(&mut rng).is_some());",
          "    assert!(array.choose_multiple_array(&mut rng).unwrap().iter().all(|&x| array.data.contains(&x)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]