{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// rand_core/src/impls.rs\n// crate name is rand_core\nuse crate::RngCore;\n#[deprecated(since = \"0.9.3\", note = \"use BlockRng64 instead\")]\npub fn fill_via_u64_chunks(src: &mut [u64], dest: &mut [u8]) -> (usize, usize) {\n    fill_via_chunks(src, dest)\n}\npub(crate) fn fill_via_chunks<T: Observable>(\n    src: &[T],\n    dest: &mut [u8],\n) -> (usize, usize) {\n    let size = core::mem::size_of::<T>();\n    let mut dest = dest.chunks_exact_mut(size);\n    let mut src = src.iter();\n    let zipped = dest.by_ref().zip(src.by_ref());\n    let num_chunks = zipped.len();\n    zipped.for_each(|(dest, src)| dest.copy_from_slice(src.to_le_bytes().as_ref()));\n    let byte_len = num_chunks * size;\n    if let Some(src) = src.next() {\n        let dest = dest.into_remainder();\n        let n = dest.len();\n        if n > 0 {\n            dest.copy_from_slice(&src.to_le_bytes().as_ref()[..n]);\n            return (num_chunks + 1, byte_len + n);\n        }\n    }\n    (num_chunks, byte_len)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Implement `fill_bytes` by reading chunks from the output buffer of a block\n/// based RNG.\n///\n/// The return values are `(consumed_u64, filled_u8)`.\n///\n/// `src` is not modified; it is taken as a `&mut` reference for backward\n/// compatibility with previous versions that did change it.\n///\n/// `filled_u8` is the number of filled bytes in `dest`, which may be less than\n/// the length of `dest`.\n/// `consumed_u64` is the number of words consumed from `src`, which is the same\n/// as `filled_u8 / 8` rounded up.\n///\n/// See `fill_via_u32_chunks` for an example.\n156 pub fn fill_via_u64_chunks(src: &mut [u64], dest: &mut [u8]) -> (usize, usize) {\n157     fill_via_chunks(src, dest)\n158 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}