{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/coin_flipper.rs\n// crate name is rand\nuse crate::RngCore;\npub(crate) struct CoinFlipper<R: RngCore> {\n    pub rng: R,\n    chunk: u32,\n    chunk_remaining: u32,\n}\nimpl<R: RngCore> CoinFlipper<R> {\n    pub fn new(rng: R) -> Self {\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }\n    #[inline]\n    pub fn random_ratio_one_over(&mut self, d: usize) -> bool {}\n    #[inline]\n    fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n        while n < d {\n            let c = n.leading_zeros().saturating_sub(d.leading_zeros() + 1).clamp(1, 32);\n            if self.flip_c_heads(c) {\n                n = n.saturating_mul(2_usize.pow(c));\n            } else {\n                if c == 1 {\n                    let next_n = n.wrapping_add(n).wrapping_sub(d);\n                    if next_n == 0 || next_n > n {\n                        return false;\n                    }\n                    n = next_n;\n                } else {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n    fn flip_c_heads(&mut self, mut c: u32) -> bool {\n        debug_assert!(c <= 32);\n        loop {\n            let zeros = self.chunk.leading_zeros();\n            if zeros < c {\n                self.chunk = self.chunk.wrapping_shl(zeros + 1);\n                self.chunk_remaining = self.chunk_remaining.saturating_sub(zeros + 1);\n                return false;\n            } else {\n                if let Some(new_remaining) = self.chunk_remaining.checked_sub(c) {\n                    self.chunk_remaining = new_remaining;\n                    self.chunk <<= c;\n                    return true;\n                } else {\n                    c -= self.chunk_remaining;\n                    self.chunk = self.rng.next_u32();\n                    self.chunk_remaining = 32;\n                }\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns true with a probability of n / d\n/// Uses an expected two bits of randomness\n 49 fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n 50     // Explanation:\n 51     // We are trying to return true with a probability of n / d\n 52     // If n >= d, we can just return true\n 53     // Otherwise there are two possibilities 2n < d and 2n >= d\n 54     // In either case we flip a coin.\n 55     // If 2n < d\n 56     //  If it comes up tails, return false\n 57     //  If it comes up heads, double n and start again\n 58     //  This is fair because (0.5 * 0) + (0.5 * 2n / d) = n / d and 2n is less than d\n 59     // (if 2n was greater than d we would effectively round it down to 1\n 60     // by returning true)\n 61     // If 2n >= d\n 62     //  If it comes up tails, set n to 2n - d and start again\n 63     //  If it comes up heads, return true\n 64     //  This is fair because (0.5 * 1) + (0.5 * (2n - d) / d) = n / d\n 65     //  Note that if 2n = d and the coin comes up tails, n will be set to 0\n 66     //  before restarting which is equivalent to returning false.\n 67 \n 68     // As a performance optimization we can flip multiple coins at once\n 69     // This is efficient because we can use the `lzcnt` intrinsic\n 70     // We can check up to 32 flips at once but we only receive one bit of information\n 71     // - all heads or at least one tail.\n 72 \n 73     // Let c be the number of coins to flip. 1 <= c <= 32\n 74     // If 2n < d, n * 2^c < d\n 75     // If the result is all heads, then set n to n * 2^c\n 76     // If there was at least one tail, return false\n 77     // If 2n >= d, the order of results matters so we flip one coin at a time so c = 1\n 78     // Ideally, c will be as high as possible within these constraints\n 79 \n 80     while n < d {\n 81         // Find a good value for c by counting leading zeros\n 82         // This will either give the highest possible c, or 1 less than that\n 83         let c = n\n 84             .leading_zeros()\n 85             .saturating_sub(d.leading_zeros() + 1)\n 86             .clamp(1, 32);\n 87 \n 88         if self.flip_c_heads(c) {\n 89             // All heads\n 90             // Set n to n * 2^c\n 91             // If 2n >= d, the while loop will exit and we will return `true`\n 92             // If n * 2^c > `usize::MAX` we always return `true` anyway\n 93             n = n.saturating_mul(2_usize.pow(c));\n 94         } else {\n 95             // At least one tail\n 96             if c == 1 {\n 97                 // Calculate 2n - d.\n 98                 // We need to use wrapping as 2n might be greater than `usize::MAX`\n 99                 let next_n = n.wrapping_add(n).wrapping_sub(d);\n100                 if next_n == 0 || next_n > n {\n101                     // This will happen if 2n < d\n102                     return false;\n103                 }\n104                 n = next_n;\n105             } else {\n106                 // c > 1 so 2n < d so we can return false\n107                 return false;\n108             }\n109         }\n110     }\n111     true\n112 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}