{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/coin_flipper.rs\n// crate name is rand\nuse crate::RngCore;\npub(crate) struct CoinFlipper<R: RngCore> {\n    pub rng: R,\n    chunk: u32,\n    chunk_remaining: u32,\n}\nimpl<R: RngCore> CoinFlipper<R> {\n    pub fn new(rng: R) -> Self {\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }\n    #[inline]\n    pub fn random_ratio_one_over(&mut self, d: usize) -> bool {}\n    #[inline]\n    fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n        while n < d {\n            let c = n.leading_zeros().saturating_sub(d.leading_zeros() + 1).clamp(1, 32);\n            if self.flip_c_heads(c) {\n                n = n.saturating_mul(2_usize.pow(c));\n            } else {\n                if c == 1 {\n                    let next_n = n.wrapping_add(n).wrapping_sub(d);\n                    if next_n == 0 || next_n > n {\n                        return false;\n                    }\n                    n = next_n;\n                } else {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n    fn flip_c_heads(&mut self, mut c: u32) -> bool {\n        debug_assert!(c <= 32);\n        loop {\n            let zeros = self.chunk.leading_zeros();\n            if zeros < c {\n                self.chunk = self.chunk.wrapping_shl(zeros + 1);\n                self.chunk_remaining = self.chunk_remaining.saturating_sub(zeros + 1);\n                return false;\n            } else {\n                if let Some(new_remaining) = self.chunk_remaining.checked_sub(c) {\n                    self.chunk_remaining = new_remaining;\n                    self.chunk <<= c;\n                    return true;\n                } else {\n                    c -= self.chunk_remaining;\n                    self.chunk = self.rng.next_u32();\n                    self.chunk_remaining = 32;\n                }\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns true with a probability of n / d\n/// Uses an expected two bits of randomness\n 49 fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n 50     // Explanation:\n 51     // We are trying to return true with a probability of n / d\n 52     // If n >= d, we can just return true\n 53     // Otherwise there are two possibilities 2n < d and 2n >= d\n 54     // In either case we flip a coin.\n 55     // If 2n < d\n 56     //  If it comes up tails, return false\n 57     //  If it comes up heads, double n and start again\n 58     //  This is fair because (0.5 * 0) + (0.5 * 2n / d) = n / d and 2n is less than d\n 59     // (if 2n was greater than d we would effectively round it down to 1\n 60     // by returning true)\n 61     // If 2n >= d\n 62     //  If it comes up tails, set n to 2n - d and start again\n 63     //  If it comes up heads, return true\n 64     //  This is fair because (0.5 * 1) + (0.5 * (2n - d) / d) = n / d\n 65     //  Note that if 2n = d and the coin comes up tails, n will be set to 0\n 66     //  before restarting which is equivalent to returning false.\n 67 \n 68     // As a performance optimization we can flip multiple coins at once\n 69     // This is efficient because we can use the `lzcnt` intrinsic\n 70     // We can check up to 32 flips at once but we only receive one bit of information\n 71     // - all heads or at least one tail.\n 72 \n 73     // Let c be the number of coins to flip. 1 <= c <= 32\n 74     // If 2n < d, n * 2^c < d\n 75     // If the result is all heads, then set n to n * 2^c\n 76     // If there was at least one tail, return false\n 77     // If 2n >= d, the order of results matters so we flip one coin at a time so c = 1\n 78     // Ideally, c will be as high as possible within these constraints\n 79 \n 80     while n < d {\n 81         // Find a good value for c by counting leading zeros\n 82         // This will either give the highest possible c, or 1 less than that\n 83         let c = n\n 84             .leading_zeros()\n 85             .saturating_sub(d.leading_zeros() + 1)\n 86             .clamp(1, 32);\n 87 \n 88         if self.flip_c_heads(c) {\n 89             // All heads\n 90             // Set n to n * 2^c\n 91             // If 2n >= d, the while loop will exit and we will return `true`\n 92             // If n * 2^c > `usize::MAX` we always return `true` anyway\n 93             n = n.saturating_mul(2_usize.pow(c));\n 94         } else {\n 95             // At least one tail\n 96             if c == 1 {\n 97                 // Calculate 2n - d.\n 98                 // We need to use wrapping as 2n might be greater than `usize::MAX`\n 99                 let next_n = n.wrapping_add(n).wrapping_sub(d);\n100                 if next_n == 0 || next_n > n {\n101                     // This will happen if 2n < d\n102                     return false;\n103                 }\n104                 n = next_n;\n105             } else {\n106                 // c > 1 so 2n < d so we can return false\n107                 return false;\n108             }\n109         }\n110     }\n111     true\n112 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}