{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/iterator.rs\n// crate name is rand\nuse super::coin_flipper::CoinFlipper;\n#[allow(unused)]\nuse super::IndexedRandom;\nuse crate::Rng;\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\npub trait IteratorRandom: Iterator + Sized {\n    fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let (mut lower, mut upper) = self.size_hint();\n        let mut result = None;\n        if upper == Some(lower) {\n            return match lower {\n                0 => None,\n                1 => self.next(),\n                _ => self.nth(rng.random_range(..lower)),\n            };\n        }\n        let mut coin_flipper = CoinFlipper::new(rng);\n        let mut consumed = 0;\n        loop {\n            if lower > 1 {\n                let ix = coin_flipper.rng.random_range(..lower + consumed);\n                let skip = if ix < lower {\n                    result = self.nth(ix);\n                    lower - (ix + 1)\n                } else {\n                    lower\n                };\n                if upper == Some(lower) {\n                    return result;\n                }\n                consumed += lower;\n                if skip > 0 {\n                    self.nth(skip - 1);\n                }\n            } else {\n                let elem = self.next();\n                if elem.is_none() {\n                    return result;\n                }\n                consumed += 1;\n                if coin_flipper.random_ratio_one_over(consumed) {\n                    result = elem;\n                }\n            }\n            let hint = self.size_hint();\n            lower = hint.0;\n            upper = hint.1;\n        }\n    }\n    fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut consumed = 0;\n        let mut result = None;\n        let mut coin_flipper = CoinFlipper::new(rng);\n        loop {\n            let mut next = 0;\n            let (lower, _) = self.size_hint();\n            if lower >= 2 {\n                let highest_selected = (0..lower)\n                    .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n                    .last();\n                consumed += lower;\n                next = lower;\n                if let Some(ix) = highest_selected {\n                    result = self.nth(ix);\n                    next -= ix + 1;\n                    debug_assert!(\n                        result.is_some(), \"iterator shorter than size_hint().0\"\n                    );\n                }\n            }\n            let elem = self.nth(next);\n            if elem.is_none() {\n                return result;\n            }\n            if coin_flipper.random_ratio_one_over(consumed + 1) {\n                result = elem;\n            }\n            consumed += 1;\n        }\n    }\n    fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n    where\n        R: Rng + ?Sized,\n    {\n        let amount = buf.len();\n        let mut len = 0;\n        while len < amount {\n            if let Some(elem) = self.next() {\n                buf[len] = elem;\n                len += 1;\n            } else {\n                return len;\n            }\n        }\n        for (i, elem) in self.enumerate() {\n            let k = rng.random_range(..i + 1 + amount);\n            if let Some(slot) = buf.get_mut(k) {\n                *slot = elem;\n            }\n        }\n        len\n    }\n    #[cfg(feature = \"alloc\")]\n    fn choose_multiple<R>(mut self, rng: &mut R, amount: usize) -> Vec<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut reservoir = Vec::with_capacity(amount);\n        reservoir.extend(self.by_ref().take(amount));\n        if reservoir.len() == amount {\n            for (i, elem) in self.enumerate() {\n                let k = rng.random_range(..i + 1 + amount);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            reservoir.shrink_to_fit();\n        }\n        reservoir\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Uniformly sample `amount` distinct elements into a buffer\n///\n/// Collects values at random from the iterator into a supplied buffer\n/// until that buffer is filled.\n///\n/// Although the elements are selected randomly, the order of elements in\n/// the buffer is neither stable nor fully random. If random ordering is\n/// desired, shuffle the result.\n///\n/// Returns the number of elements added to the buffer. This equals the length\n/// of the buffer unless the iterator contains insufficient elements, in which\n/// case this equals the number of elements available.\n///\n/// Complexity is `O(n)` where `n` is the length of the iterator.\n/// For slices, prefer [`IndexedRandom::choose_multiple`].\n195 fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n196 where\n197     R: Rng + ?Sized,\n198 {\n199     let amount = buf.len();\n200     let mut len = 0;\n201     while len < amount {\n202         if let Some(elem) = self.next() {\n203             buf[len] = elem;\n204             len += 1;\n205         } else {\n206             // Iterator exhausted; stop early\n207             return len;\n208         }\n209     }\n210 \n211     // Continue, since the iterator was not exhausted\n212     for (i, elem) in self.enumerate() {\n213         let k = rng.random_range(..i + 1 + amount);\n214         if let Some(slot) = buf.get_mut(k) {\n215             *slot = elem;\n216         }\n217     }\n218     len\n219 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}