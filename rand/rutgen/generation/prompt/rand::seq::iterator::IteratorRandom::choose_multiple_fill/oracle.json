{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/iterator.rs\n// crate name is rand\nuse super::coin_flipper::CoinFlipper;\n#[allow(unused)]\nuse super::IndexedRandom;\nuse crate::Rng;\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\npub trait IteratorRandom: Iterator + Sized {\n    fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let (mut lower, mut upper) = self.size_hint();\n        let mut result = None;\n        if upper == Some(lower) {\n            return match lower {\n                0 => None,\n                1 => self.next(),\n                _ => self.nth(rng.random_range(..lower)),\n            };\n        }\n        let mut coin_flipper = CoinFlipper::new(rng);\n        let mut consumed = 0;\n        loop {\n            if lower > 1 {\n                let ix = coin_flipper.rng.random_range(..lower + consumed);\n                let skip = if ix < lower {\n                    result = self.nth(ix);\n                    lower - (ix + 1)\n                } else {\n                    lower\n                };\n                if upper == Some(lower) {\n                    return result;\n                }\n                consumed += lower;\n                if skip > 0 {\n                    self.nth(skip - 1);\n                }\n            } else {\n                let elem = self.next();\n                if elem.is_none() {\n                    return result;\n                }\n                consumed += 1;\n                if coin_flipper.random_ratio_one_over(consumed) {\n                    result = elem;\n                }\n            }\n            let hint = self.size_hint();\n            lower = hint.0;\n            upper = hint.1;\n        }\n    }\n    fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut consumed = 0;\n        let mut result = None;\n        let mut coin_flipper = CoinFlipper::new(rng);\n        loop {\n            let mut next = 0;\n            let (lower, _) = self.size_hint();\n            if lower >= 2 {\n                let highest_selected = (0..lower)\n                    .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n                    .last();\n                consumed += lower;\n                next = lower;\n                if let Some(ix) = highest_selected {\n                    result = self.nth(ix);\n                    next -= ix + 1;\n                    debug_assert!(\n                        result.is_some(), \"iterator shorter than size_hint().0\"\n                    );\n                }\n            }\n            let elem = self.nth(next);\n            if elem.is_none() {\n                return result;\n            }\n            if coin_flipper.random_ratio_one_over(consumed + 1) {\n                result = elem;\n            }\n            consumed += 1;\n        }\n    }\n    fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n    where\n        R: Rng + ?Sized,\n    {\n        let amount = buf.len();\n        let mut len = 0;\n        while len < amount {\n            if let Some(elem) = self.next() {\n                buf[len] = elem;\n                len += 1;\n            } else {\n                return len;\n            }\n        }\n        for (i, elem) in self.enumerate() {\n            let k = rng.random_range(..i + 1 + amount);\n            if let Some(slot) = buf.get_mut(k) {\n                *slot = elem;\n            }\n        }\n        len\n    }\n    #[cfg(feature = \"alloc\")]\n    fn choose_multiple<R>(mut self, rng: &mut R, amount: usize) -> Vec<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut reservoir = Vec::with_capacity(amount);\n        reservoir.extend(self.by_ref().take(amount));\n        if reservoir.len() == amount {\n            for (i, elem) in self.enumerate() {\n                let k = rng.random_range(..i + 1 + amount);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            reservoir.shrink_to_fit();\n        }\n        reservoir\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Uniformly sample `amount` distinct elements into a buffer\n///\n/// Collects values at random from the iterator into a supplied buffer\n/// until that buffer is filled.\n///\n/// Although the elements are selected randomly, the order of elements in\n/// the buffer is neither stable nor fully random. If random ordering is\n/// desired, shuffle the result.\n///\n/// Returns the number of elements added to the buffer. This equals the length\n/// of the buffer unless the iterator contains insufficient elements, in which\n/// case this equals the number of elements available.\n///\n/// Complexity is `O(n)` where `n` is the length of the iterator.\n/// For slices, prefer [`IndexedRandom::choose_multiple`].\n195 fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n196 where\n197     R: Rng + ?Sized,\n198 {\n199     let amount = buf.len();\n200     let mut len = 0;\n201     while len < amount {\n202         if let Some(elem) = self.next() {\n203             buf[len] = elem;\n204             len += 1;\n205         } else {\n206             // Iterator exhausted; stop early\n207             return len;\n208         }\n209     }\n210 \n211     // Continue, since the iterator was not exhausted\n212     for (i, elem) in self.enumerate() {\n213         let k = rng.random_range(..i + 1 + amount);\n214         if let Some(slot) = buf.get_mut(k) {\n215             *slot = elem;\n216         }\n217     }\n218     len\n219 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}