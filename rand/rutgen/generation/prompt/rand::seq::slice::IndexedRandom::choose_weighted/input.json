{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/slice.rs\n// crate name is rand\nuse super::increasing_uniform::IncreasingUniform;\nuse super::index;\n#[cfg(feature = \"alloc\")]\nuse crate::distr::uniform::{SampleBorrow, SampleUniform};\n#[cfg(feature = \"alloc\")]\nuse crate::distr::weighted::{Error as WeightError, Weight};\nuse crate::Rng;\nuse core::ops::{Index, IndexMut};\npub trait IndexedRandom: Index<usize> {\n    fn len(&self) -> usize;\n    #[inline]\n    fn is_empty(&self) -> bool;\n    fn choose<R>(&self, rng: &mut R) -> Option<&Self::Output>\n    where\n        R: Rng + ?Sized,\n    {\n        if self.is_empty() { None } else { Some(&self[rng.random_range(..self.len())]) }\n    }\n    #[cfg(feature = \"alloc\")]\n    fn choose_multiple<R>(\n        &self,\n        rng: &mut R,\n        amount: usize,\n    ) -> SliceChooseIter<Self, Self::Output>\n    where\n        Self::Output: Sized,\n        R: Rng + ?Sized,\n    {\n        let amount = core::cmp::min(amount, self.len());\n        SliceChooseIter {\n            slice: self,\n            _phantom: Default::default(),\n            indices: index::sample(rng, self.len(), amount).into_iter(),\n        }\n    }\n    fn choose_multiple_array<R, const N: usize>(\n        &self,\n        rng: &mut R,\n    ) -> Option<[Self::Output; N]>\n    where\n        Self::Output: Clone + Sized,\n        R: Rng + ?Sized,\n    {\n        let indices = index::sample_array(rng, self.len())?;\n        Some(indices.map(|index| self[index].clone()))\n    }\n    #[cfg(feature = \"alloc\")]\n    fn choose_weighted<R, F, B, X>(\n        &self,\n        rng: &mut R,\n        weight: F,\n    ) -> Result<&Self::Output, WeightError>\n    where\n        R: Rng + ?Sized,\n        F: Fn(&Self::Output) -> B,\n        B: SampleBorrow<X>,\n        X: SampleUniform + Weight + PartialOrd<X>,\n    {\n        use crate::distr::{weighted::WeightedIndex, Distribution};\n        let distr = WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?;\n        Ok(&self[distr.sample(rng)])\n    }\n    #[cfg(feature = \"std\")]\n    fn choose_multiple_weighted<R, F, X>(\n        &self,\n        rng: &mut R,\n        amount: usize,\n        weight: F,\n    ) -> Result<SliceChooseIter<Self, Self::Output>, WeightError>\n    where\n        Self::Output: Sized,\n        R: Rng + ?Sized,\n        F: Fn(&Self::Output) -> X,\n        X: Into<f64>,\n    {\n        let amount = core::cmp::min(amount, self.len());\n        Ok(SliceChooseIter {\n            slice: self,\n            _phantom: Default::default(),\n            indices: index::sample_weighted(\n                    rng,\n                    self.len(),\n                    |idx| weight(&self[idx]).into(),\n                    amount,\n                )?\n                .into_iter(),\n        })\n    }\n}\n#[derive(Debug, Clone, PartialEq)]\n#[cfg_attr(feature = \"serde\", derive(Serialize, Deserialize))]\npub struct WeightedIndex<X: SampleUniform + PartialOrd> {\n    cumulative_weights: Vec<X>,\n    total_weight: X,\n    weight_distribution: X::Sampler,\n}\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[non_exhaustive]\npub enum Error {\n    /// The input weight sequence is empty, too long, or wrongly ordered\n    InvalidInput,\n    /// A weight is negative, too large for the distribution, or not a valid number\n    InvalidWeight,\n    /// Not enough non-zero weights are available to sample values\n    ///\n    /// When attempting to sample a single value this implies that all weights\n    /// are zero. When attempting to sample `amount` values this implies that\n    /// less than `amount` weights are greater than zero.\n    InsufficientNonZero,\n    /// Overflow when calculating the sum of weights\n    Overflow,\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Biased sampling for one element\n///\n/// Returns a reference to one element of the slice, sampled according\n/// to the provided weights. Returns `None` only if the slice is empty.\n///\n/// The specified function `weight` maps each item `x` to a relative\n/// likelihood `weight(x)`. The probability of each item being selected is\n/// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n///\n/// For slices of length `n`, complexity is `O(n)`.\n/// For more information about the underlying algorithm,\n/// see the [`WeightedIndex`] distribution.\n///\n/// See also [`choose_weighted_mut`].\n///\n/// # Example\n///\n/// ```\n/// use rand::prelude::*;\n///\n/// let choices = [('a', 2), ('b', 1), ('c', 1), ('d', 0)];\n/// let mut rng = rand::rng();\n/// // 50% chance to print 'a', 25% chance to print 'b', 25% chance to print 'c',\n/// // and 'd' will never be printed\n/// println!(\"{:?}\", choices.choose_weighted(&mut rng, |item| item.1).unwrap().0);\n/// ```\n/// [`choose`]: IndexedRandom::choose\n/// [`choose_weighted_mut`]: IndexedMutRandom::choose_weighted_mut\n/// [`WeightedIndex`]: crate::distr::weighted::WeightedIndex\n158 fn choose_weighted<R, F, B, X>(\n159     &self,\n160     rng: &mut R,\n161     weight: F,\n162 ) -> Result<&Self::Output, WeightError>\n163 where\n164     R: Rng + ?Sized,\n165     F: Fn(&Self::Output) -> B,\n166     B: SampleBorrow<X>,\n167     X: SampleUniform + Weight + PartialOrd<X>,\n168 {\n169     use crate::distr::{weighted::WeightedIndex, Distribution};\n170     let distr = WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?;\n171     Ok(&self[distr.sample(rng)])\n172 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}