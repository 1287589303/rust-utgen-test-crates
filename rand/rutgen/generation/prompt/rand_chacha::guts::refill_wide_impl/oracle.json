{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// rand_chacha/src/guts.rs\n// crate name is rand_chacha\nuse ppv_lite86::{dispatch, dispatch_light128};\npub use ppv_lite86::Machine;\nuse ppv_lite86::{\n    vec128_storage, ArithOps, BitOps32, LaneWords4, MultiLane, StoreBytes, Vec4, Vec4Ext,\n    Vector,\n};\npub(crate) const BLOCK: usize = 16;\npub(crate) const BLOCK64: u64 = BLOCK as u64;\nconst LOG2_BUFBLOCKS: u64 = 2;\nconst BUFBLOCKS: u64 = 1 << LOG2_BUFBLOCKS;\npub(crate) const BUFSZ64: u64 = BLOCK64 * BUFBLOCKS;\npub(crate) const BUFSZ: usize = BUFSZ64 as usize;\nconst STREAM_PARAM_NONCE: u32 = 1;\nconst STREAM_PARAM_BLOCK: u32 = 0;\n#[derive(Clone, PartialEq, Eq)]\npub struct ChaCha {\n    pub(crate) b: vec128_storage,\n    pub(crate) c: vec128_storage,\n    pub(crate) d: vec128_storage,\n}\n#[allow(clippy::many_single_char_names)]\n#[inline(always)]\nfn refill_wide_impl<Mach: Machine>(\n    m: Mach,\n    state: &mut ChaCha,\n    drounds: u32,\n    out: &mut [u32; BUFSZ],\n) {\n    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);\n    let b = m.unpack(state.b);\n    let c = m.unpack(state.c);\n    let mut x = State {\n        a: Mach::u32x4x4::from_lanes([k, k, k, k]),\n        b: Mach::u32x4x4::from_lanes([b, b, b, b]),\n        c: Mach::u32x4x4::from_lanes([c, c, c, c]),\n        d: d0123(m, state.d),\n    };\n    for _ in 0..drounds {\n        x = round(x);\n        x = undiagonalize(round(diagonalize(x)));\n    }\n    let kk = Mach::u32x4x4::from_lanes([k, k, k, k]);\n    let sb = m.unpack(state.b);\n    let sb = Mach::u32x4x4::from_lanes([sb, sb, sb, sb]);\n    let sc = m.unpack(state.c);\n    let sc = Mach::u32x4x4::from_lanes([sc, sc, sc, sc]);\n    let sd = d0123(m, state.d);\n    let results = Mach::u32x4x4::transpose4(x.a + kk, x.b + sb, x.c + sc, x.d + sd);\n    out[0..16].copy_from_slice(&results.0.to_scalars());\n    out[16..32].copy_from_slice(&results.1.to_scalars());\n    out[32..48].copy_from_slice(&results.2.to_scalars());\n    out[48..64].copy_from_slice(&results.3.to_scalars());\n    state.d = add_pos(m, sd.to_lanes()[0], 4).into();\n}\n#[inline(always)]\n#[cfg(target_endian = \"little\")]\nfn d0123<Mach: Machine>(m: Mach, d: vec128_storage) -> Mach::u32x4x4 {\n    let d0: Mach::u64x2 = m.unpack(d);\n    let incr = Mach::u64x2x4::from_lanes([\n        m.vec([0, 0]),\n        m.vec([1, 0]),\n        m.vec([2, 0]),\n        m.vec([3, 0]),\n    ]);\n    m.unpack((Mach::u64x2x4::from_lanes([d0, d0, d0, d0]) + incr).into())\n}\n#[inline(always)]\n#[cfg(target_endian = \"little\")]\nfn add_pos<Mach: Machine>(m: Mach, d: Mach::u32x4, i: u64) -> Mach::u32x4 {\n    let d0: Mach::u64x2 = m.unpack(d.into());\n    let incr = m.vec([i, 0]);\n    m.unpack((d0 + incr).into())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n152 fn refill_wide_impl<Mach: Machine>(\n153     m: Mach,\n154     state: &mut ChaCha,\n155     drounds: u32,\n156     out: &mut [u32; BUFSZ],\n157 ) {\n158     let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);\n159     let b = m.unpack(state.b);\n160     let c = m.unpack(state.c);\n161     let mut x = State {\n162         a: Mach::u32x4x4::from_lanes([k, k, k, k]),\n163         b: Mach::u32x4x4::from_lanes([b, b, b, b]),\n164         c: Mach::u32x4x4::from_lanes([c, c, c, c]),\n165         d: d0123(m, state.d),\n166     };\n167     for _ in 0..drounds {\n168         x = round(x);\n169         x = undiagonalize(round(diagonalize(x)));\n170     }\n171     let kk = Mach::u32x4x4::from_lanes([k, k, k, k]);\n172     let sb = m.unpack(state.b);\n173     let sb = Mach::u32x4x4::from_lanes([sb, sb, sb, sb]);\n174     let sc = m.unpack(state.c);\n175     let sc = Mach::u32x4x4::from_lanes([sc, sc, sc, sc]);\n176     let sd = d0123(m, state.d);\n177     let results = Mach::u32x4x4::transpose4(x.a + kk, x.b + sb, x.c + sc, x.d + sd);\n178     out[0..16].copy_from_slice(&results.0.to_scalars());\n179     out[16..32].copy_from_slice(&results.1.to_scalars());\n180     out[32..48].copy_from_slice(&results.2.to_scalars());\n181     out[48..64].copy_from_slice(&results.3.to_scalars());\n182     state.d = add_pos(m, sd.to_lanes()[0], 4).into();\n183 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}