{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/iterator.rs\n// crate name is rand\nuse super::coin_flipper::CoinFlipper;\n#[allow(unused)]\nuse super::IndexedRandom;\nuse crate::Rng;\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\npub trait IteratorRandom: Iterator + Sized {\n    fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let (mut lower, mut upper) = self.size_hint();\n        let mut result = None;\n        if upper == Some(lower) {\n            return match lower {\n                0 => None,\n                1 => self.next(),\n                _ => self.nth(rng.random_range(..lower)),\n            };\n        }\n        let mut coin_flipper = CoinFlipper::new(rng);\n        let mut consumed = 0;\n        loop {\n            if lower > 1 {\n                let ix = coin_flipper.rng.random_range(..lower + consumed);\n                let skip = if ix < lower {\n                    result = self.nth(ix);\n                    lower - (ix + 1)\n                } else {\n                    lower\n                };\n                if upper == Some(lower) {\n                    return result;\n                }\n                consumed += lower;\n                if skip > 0 {\n                    self.nth(skip - 1);\n                }\n            } else {\n                let elem = self.next();\n                if elem.is_none() {\n                    return result;\n                }\n                consumed += 1;\n                if coin_flipper.random_ratio_one_over(consumed) {\n                    result = elem;\n                }\n            }\n            let hint = self.size_hint();\n            lower = hint.0;\n            upper = hint.1;\n        }\n    }\n    fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut consumed = 0;\n        let mut result = None;\n        let mut coin_flipper = CoinFlipper::new(rng);\n        loop {\n            let mut next = 0;\n            let (lower, _) = self.size_hint();\n            if lower >= 2 {\n                let highest_selected = (0..lower)\n                    .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n                    .last();\n                consumed += lower;\n                next = lower;\n                if let Some(ix) = highest_selected {\n                    result = self.nth(ix);\n                    next -= ix + 1;\n                    debug_assert!(\n                        result.is_some(), \"iterator shorter than size_hint().0\"\n                    );\n                }\n            }\n            let elem = self.nth(next);\n            if elem.is_none() {\n                return result;\n            }\n            if coin_flipper.random_ratio_one_over(consumed + 1) {\n                result = elem;\n            }\n            consumed += 1;\n        }\n    }\n    fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n    where\n        R: Rng + ?Sized;\n    #[cfg(feature = \"alloc\")]\n    fn choose_multiple<R>(mut self, rng: &mut R, amount: usize) -> Vec<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut reservoir = Vec::with_capacity(amount);\n        reservoir.extend(self.by_ref().take(amount));\n        if reservoir.len() == amount {\n            for (i, elem) in self.enumerate() {\n                let k = rng.random_range(..i + 1 + amount);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            reservoir.shrink_to_fit();\n        }\n        reservoir\n    }\n}\npub(crate) struct CoinFlipper<R: RngCore> {\n    pub rng: R,\n    chunk: u32,\n    chunk_remaining: u32,\n}\nimpl<R: RngCore> CoinFlipper<R> {\n    pub fn new(rng: R) -> Self {\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }\n    #[inline]\n    pub fn random_ratio_one_over(&mut self, d: usize) -> bool {\n        debug_assert_ne!(d, 0);\n        let c = (usize::BITS - 1 - d.leading_zeros()).min(32);\n        if self.flip_c_heads(c) {\n            let numerator = 1 << c;\n            self.random_ratio(numerator, d)\n        } else {\n            false\n        }\n    }\n    #[inline]\n    fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {}\n    fn flip_c_heads(&mut self, mut c: u32) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Uniformly sample one element (stable)\n///\n/// This method is very similar to [`choose`] except that the result\n/// only depends on the length of the iterator and the values produced by\n/// `rng`. Notably for any iterator of a given length this will make the\n/// same requests to `rng` and if the same sequence of values are produced\n/// the same index will be selected from `self`. This may be useful if you\n/// need consistent results no matter what type of iterator you are working\n/// with. If you do not need this stability prefer [`choose`].\n///\n/// Note that this method still uses [`Iterator::size_hint`] to skip\n/// constructing elements where possible, however the selection and `rng`\n/// calls are the same in the face of this optimization. If you want to\n/// force every element to be created regardless call `.inspect(|e| ())`.\n///\n/// [`choose`]: IteratorRandom::choose\n137 fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n138 where\n139     R: Rng + ?Sized,\n140 {\n141     let mut consumed = 0;\n142     let mut result = None;\n143     let mut coin_flipper = CoinFlipper::new(rng);\n144 \n145     loop {\n146         // Currently the only way to skip elements is `nth()`. So we need to\n147         // store what index to access next here.\n148         // This should be replaced by `advance_by()` once it is stable:\n149         // https://github.com/rust-lang/rust/issues/77404\n150         let mut next = 0;\n151 \n152         let (lower, _) = self.size_hint();\n153         if lower >= 2 {\n154             let highest_selected = (0..lower)\n155                 .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n156                 .last();\n157 \n158             consumed += lower;\n159             next = lower;\n160 \n161             if let Some(ix) = highest_selected {\n162                 result = self.nth(ix);\n163                 next -= ix + 1;\n164                 debug_assert!(result.is_some(), \"iterator shorter than size_hint().0\");\n165             }\n166         }\n167 \n168         let elem = self.nth(next);\n169         if elem.is_none() {\n170             return result;\n171         }\n172 \n173         if coin_flipper.random_ratio_one_over(consumed + 1) {\n174             result = elem;\n175         }\n176         consumed += 1;\n177     }\n178 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}