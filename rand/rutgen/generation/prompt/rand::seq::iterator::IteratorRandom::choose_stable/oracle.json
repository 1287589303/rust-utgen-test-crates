{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/iterator.rs\n// crate name is rand\nuse super::coin_flipper::CoinFlipper;\n#[allow(unused)]\nuse super::IndexedRandom;\nuse crate::Rng;\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\npub trait IteratorRandom: Iterator + Sized {\n    fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let (mut lower, mut upper) = self.size_hint();\n        let mut result = None;\n        if upper == Some(lower) {\n            return match lower {\n                0 => None,\n                1 => self.next(),\n                _ => self.nth(rng.random_range(..lower)),\n            };\n        }\n        let mut coin_flipper = CoinFlipper::new(rng);\n        let mut consumed = 0;\n        loop {\n            if lower > 1 {\n                let ix = coin_flipper.rng.random_range(..lower + consumed);\n                let skip = if ix < lower {\n                    result = self.nth(ix);\n                    lower - (ix + 1)\n                } else {\n                    lower\n                };\n                if upper == Some(lower) {\n                    return result;\n                }\n                consumed += lower;\n                if skip > 0 {\n                    self.nth(skip - 1);\n                }\n            } else {\n                let elem = self.next();\n                if elem.is_none() {\n                    return result;\n                }\n                consumed += 1;\n                if coin_flipper.random_ratio_one_over(consumed) {\n                    result = elem;\n                }\n            }\n            let hint = self.size_hint();\n            lower = hint.0;\n            upper = hint.1;\n        }\n    }\n    fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut consumed = 0;\n        let mut result = None;\n        let mut coin_flipper = CoinFlipper::new(rng);\n        loop {\n            let mut next = 0;\n            let (lower, _) = self.size_hint();\n            if lower >= 2 {\n                let highest_selected = (0..lower)\n                    .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n                    .last();\n                consumed += lower;\n                next = lower;\n                if let Some(ix) = highest_selected {\n                    result = self.nth(ix);\n                    next -= ix + 1;\n                    debug_assert!(\n                        result.is_some(), \"iterator shorter than size_hint().0\"\n                    );\n                }\n            }\n            let elem = self.nth(next);\n            if elem.is_none() {\n                return result;\n            }\n            if coin_flipper.random_ratio_one_over(consumed + 1) {\n                result = elem;\n            }\n            consumed += 1;\n        }\n    }\n    fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n    where\n        R: Rng + ?Sized;\n    #[cfg(feature = \"alloc\")]\n    fn choose_multiple<R>(mut self, rng: &mut R, amount: usize) -> Vec<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut reservoir = Vec::with_capacity(amount);\n        reservoir.extend(self.by_ref().take(amount));\n        if reservoir.len() == amount {\n            for (i, elem) in self.enumerate() {\n                let k = rng.random_range(..i + 1 + amount);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            reservoir.shrink_to_fit();\n        }\n        reservoir\n    }\n}\npub(crate) struct CoinFlipper<R: RngCore> {\n    pub rng: R,\n    chunk: u32,\n    chunk_remaining: u32,\n}\nimpl<R: RngCore> CoinFlipper<R> {\n    pub fn new(rng: R) -> Self {\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }\n    #[inline]\n    pub fn random_ratio_one_over(&mut self, d: usize) -> bool {\n        debug_assert_ne!(d, 0);\n        let c = (usize::BITS - 1 - d.leading_zeros()).min(32);\n        if self.flip_c_heads(c) {\n            let numerator = 1 << c;\n            self.random_ratio(numerator, d)\n        } else {\n            false\n        }\n    }\n    #[inline]\n    fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {}\n    fn flip_c_heads(&mut self, mut c: u32) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Uniformly sample one element (stable)\n///\n/// This method is very similar to [`choose`] except that the result\n/// only depends on the length of the iterator and the values produced by\n/// `rng`. Notably for any iterator of a given length this will make the\n/// same requests to `rng` and if the same sequence of values are produced\n/// the same index will be selected from `self`. This may be useful if you\n/// need consistent results no matter what type of iterator you are working\n/// with. If you do not need this stability prefer [`choose`].\n///\n/// Note that this method still uses [`Iterator::size_hint`] to skip\n/// constructing elements where possible, however the selection and `rng`\n/// calls are the same in the face of this optimization. If you want to\n/// force every element to be created regardless call `.inspect(|e| ())`.\n///\n/// [`choose`]: IteratorRandom::choose\n137 fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n138 where\n139     R: Rng + ?Sized,\n140 {\n141     let mut consumed = 0;\n142     let mut result = None;\n143     let mut coin_flipper = CoinFlipper::new(rng);\n144 \n145     loop {\n146         // Currently the only way to skip elements is `nth()`. So we need to\n147         // store what index to access next here.\n148         // This should be replaced by `advance_by()` once it is stable:\n149         // https://github.com/rust-lang/rust/issues/77404\n150         let mut next = 0;\n151 \n152         let (lower, _) = self.size_hint();\n153         if lower >= 2 {\n154             let highest_selected = (0..lower)\n155                 .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n156                 .last();\n157 \n158             consumed += lower;\n159             next = lower;\n160 \n161             if let Some(ix) = highest_selected {\n162                 result = self.nth(ix);\n163                 next -= ix + 1;\n164                 debug_assert!(result.is_some(), \"iterator shorter than size_hint().0\");\n165             }\n166         }\n167 \n168         let elem = self.nth(next);\n169         if elem.is_none() {\n170             return result;\n171         }\n172 \n173         if coin_flipper.random_ratio_one_over(consumed + 1) {\n174             result = elem;\n175         }\n176         consumed += 1;\n177     }\n178 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}