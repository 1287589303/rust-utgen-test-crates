{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/iterator.rs\n// crate name is rand\nuse super::coin_flipper::CoinFlipper;\n#[allow(unused)]\nuse super::IndexedRandom;\nuse crate::Rng;\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\npub trait IteratorRandom: Iterator + Sized {\n    fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let (mut lower, mut upper) = self.size_hint();\n        let mut result = None;\n        if upper == Some(lower) {\n            return match lower {\n                0 => None,\n                1 => self.next(),\n                _ => self.nth(rng.random_range(..lower)),\n            };\n        }\n        let mut coin_flipper = CoinFlipper::new(rng);\n        let mut consumed = 0;\n        loop {\n            if lower > 1 {\n                let ix = coin_flipper.rng.random_range(..lower + consumed);\n                let skip = if ix < lower {\n                    result = self.nth(ix);\n                    lower - (ix + 1)\n                } else {\n                    lower\n                };\n                if upper == Some(lower) {\n                    return result;\n                }\n                consumed += lower;\n                if skip > 0 {\n                    self.nth(skip - 1);\n                }\n            } else {\n                let elem = self.next();\n                if elem.is_none() {\n                    return result;\n                }\n                consumed += 1;\n                if coin_flipper.random_ratio_one_over(consumed) {\n                    result = elem;\n                }\n            }\n            let hint = self.size_hint();\n            lower = hint.0;\n            upper = hint.1;\n        }\n    }\n    fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut consumed = 0;\n        let mut result = None;\n        let mut coin_flipper = CoinFlipper::new(rng);\n        loop {\n            let mut next = 0;\n            let (lower, _) = self.size_hint();\n            if lower >= 2 {\n                let highest_selected = (0..lower)\n                    .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n                    .last();\n                consumed += lower;\n                next = lower;\n                if let Some(ix) = highest_selected {\n                    result = self.nth(ix);\n                    next -= ix + 1;\n                    debug_assert!(\n                        result.is_some(), \"iterator shorter than size_hint().0\"\n                    );\n                }\n            }\n            let elem = self.nth(next);\n            if elem.is_none() {\n                return result;\n            }\n            if coin_flipper.random_ratio_one_over(consumed + 1) {\n                result = elem;\n            }\n            consumed += 1;\n        }\n    }\n    fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n    where\n        R: Rng + ?Sized;\n    #[cfg(feature = \"alloc\")]\n    fn choose_multiple<R>(mut self, rng: &mut R, amount: usize) -> Vec<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut reservoir = Vec::with_capacity(amount);\n        reservoir.extend(self.by_ref().take(amount));\n        if reservoir.len() == amount {\n            for (i, elem) in self.enumerate() {\n                let k = rng.random_range(..i + 1 + amount);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            reservoir.shrink_to_fit();\n        }\n        reservoir\n    }\n}\npub(crate) struct CoinFlipper<R: RngCore> {\n    pub rng: R,\n    chunk: u32,\n    chunk_remaining: u32,\n}\nimpl<R: RngCore> CoinFlipper<R> {\n    pub fn new(rng: R) -> Self {\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }\n    #[inline]\n    pub fn random_ratio_one_over(&mut self, d: usize) -> bool {\n        debug_assert_ne!(d, 0);\n        let c = (usize::BITS - 1 - d.leading_zeros()).min(32);\n        if self.flip_c_heads(c) {\n            let numerator = 1 << c;\n            self.random_ratio(numerator, d)\n        } else {\n            false\n        }\n    }\n    #[inline]\n    fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {}\n    fn flip_c_heads(&mut self, mut c: u32) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Uniformly sample one element\n///\n/// Assuming that the [`Iterator::size_hint`] is correct, this method\n/// returns one uniformly-sampled random element of the slice, or `None`\n/// only if the slice is empty. Incorrect bounds on the `size_hint` may\n/// cause this method to incorrectly return `None` if fewer elements than\n/// the advertised `lower` bound are present and may prevent sampling of\n/// elements beyond an advertised `upper` bound (i.e. incorrect `size_hint`\n/// is memory-safe, but may result in unexpected `None` result and\n/// non-uniform distribution).\n///\n/// With an accurate [`Iterator::size_hint`] and where [`Iterator::nth`] is\n/// a constant-time operation, this method can offer `O(1)` performance.\n/// Where no size hint is\n/// available, complexity is `O(n)` where `n` is the iterator length.\n/// Partial hints (where `lower > 0`) also improve performance.\n///\n/// Note further that [`Iterator::size_hint`] may affect the number of RNG\n/// samples used as well as the result (while remaining uniform sampling).\n/// Consider instead using [`IteratorRandom::choose_stable`] to avoid\n/// [`Iterator`] combinators which only change size hints from affecting the\n/// results.\n///\n/// # Example\n///\n/// ```\n/// use rand::seq::IteratorRandom;\n///\n/// let words = \"Mary had a little lamb\".split(' ');\n/// println!(\"{}\", words.choose(&mut rand::rng()).unwrap());\n/// ```\n 66 fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n 67 where\n 68     R: Rng + ?Sized,\n 69 {\n 70     let (mut lower, mut upper) = self.size_hint();\n 71     let mut result = None;\n 72 \n 73     // Handling for this condition outside the loop allows the optimizer to eliminate the loop\n 74     // when the Iterator is an ExactSizeIterator. This has a large performance impact on e.g.\n 75     // seq_iter_choose_from_1000.\n 76     if upper == Some(lower) {\n 77         return match lower {\n 78             0 => None,\n 79             1 => self.next(),\n 80             _ => self.nth(rng.random_range(..lower)),\n 81         };\n 82     }\n 83 \n 84     let mut coin_flipper = CoinFlipper::new(rng);\n 85     let mut consumed = 0;\n 86 \n 87     // Continue until the iterator is exhausted\n 88     loop {\n 89         if lower > 1 {\n 90             let ix = coin_flipper.rng.random_range(..lower + consumed);\n 91             let skip = if ix < lower {\n 92                 result = self.nth(ix);\n 93                 lower - (ix + 1)\n 94             } else {\n 95                 lower\n 96             };\n 97             if upper == Some(lower) {\n 98                 return result;\n 99             }\n100             consumed += lower;\n101             if skip > 0 {\n102                 self.nth(skip - 1);\n103             }\n104         } else {\n105             let elem = self.next();\n106             if elem.is_none() {\n107                 return result;\n108             }\n109             consumed += 1;\n110             if coin_flipper.random_ratio_one_over(consumed) {\n111                 result = elem;\n112             }\n113         }\n114 \n115         let hint = self.size_hint();\n116         lower = hint.0;\n117         upper = hint.1;\n118     }\n119 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}