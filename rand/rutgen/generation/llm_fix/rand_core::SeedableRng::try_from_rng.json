{
  "name": "rand_core::SeedableRng::try_from_rng",
  "mod_info": {
    "name": "",
    "loc": "rand_core/src/lib.rs:10:1:771:2"
  },
  "visible": true,
  "loc": "rand_core/src/lib.rs:530:5:534:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: rng.try_fill_bytes(seed.as_mut())? at line 532 is Err/None\n"
      ],
      "input_infer": "Test input conditions or ranges: \n- rng is an instance of TryRngCore that returns Err when calling try_fill_bytes() on any input, or \n- rng is an instance of TryRngCore that returns None when calling try_fill_bytes() on any input, or \n- rng is a mock or stub that simulates failure scenarios on attempt to fill the bytes of seed.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockRng;",
                "    ",
                "    impl TryRngCore for MockRng {",
                "        type Error = &'static str;",
                "",
                "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Err(\"mock error\")",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng;",
                "    let result: Result<_, _> = MyRng::try_from_rng(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Err(\"mock error\"));",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(_)));",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), \"mock error\");"
              ],
              "code": [
                "{",
                "    struct MockRng;",
                "    ",
                "    impl TryRngCore for MockRng {",
                "        type Error = &'static str;",
                "",
                "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Err(\"mock error\")",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng;",
                "    let result: Result<_, _> = MyRng::try_from_rng(&mut rng);",
                "    assert_eq!(result, Err(\"mock error\"));",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(_)));",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), \"mock error\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NoneRng;",
                "    ",
                "    impl TryRngCore for NoneRng {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            // Simulating a None-like scenario; actual implementation may differ.",
                "            Err(())",
                "        }",
                "    }",
                "",
                "    let mut rng = NoneRng;",
                "    let result: Result<_, _> = MyRng::try_from_rng(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "    assert_eq!(result, Err(()));",
                "    assert!(result.is_none());",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(_)));"
              ],
              "code": [
                "{",
                "    struct NoneRng;",
                "    ",
                "    impl TryRngCore for NoneRng {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            // Simulating a None-like scenario; actual implementation may differ.",
                "            Err(())",
                "        }",
                "    }",
                "",
                "    let mut rng = NoneRng;",
                "    let result: Result<_, _> = MyRng::try_from_rng(&mut rng);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "    assert_eq!(result, Err(()));",
                "    assert!(result.is_none());",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct PartialFailureRng {",
                "        attempt: usize,",
                "    }",
                "",
                "    impl TryRngCore for PartialFailureRng {",
                "        type Error = &'static str;",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            if self.attempt < 2 {",
                "                self.attempt += 1;",
                "                Err(\"mock error\")",
                "            } else {",
                "                dest.fill(0);",
                "                Ok(())",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut rng = PartialFailureRng { attempt: 0 };",
                "    let result: Result<_, _> = MyRng::try_from_rng(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, Err(\"mock error\")));",
                "    assert_eq!(rng.attempt, 2);",
                "    assert!(result.is_err());"
              ],
              "code": [
                "{",
                "    struct PartialFailureRng {",
                "        attempt: usize,",
                "    }",
                "",
                "    impl TryRngCore for PartialFailureRng {",
                "        type Error = &'static str;",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            if self.attempt < 2 {",
                "                self.attempt += 1;",
                "                Err(\"mock error\")",
                "            } else {",
                "                dest.fill(0);",
                "                Ok(())",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut rng = PartialFailureRng { attempt: 0 };",
                "    let result: Result<_, _> = MyRng::try_from_rng(&mut rng);",
                "    assert!(matches!(result, Err(\"mock error\")));",
                "    assert_eq!(rng.attempt, 2);",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: rng.try_fill_bytes(seed.as_mut())? at line 532 is Ok/Some\n",
        "expected return value/type: Ok(Self::from_seed(seed))\n"
      ],
      "input_infer": "Rng must be a mutable reference to an instance of a type implementing TryRngCore that successfully fills seed with at least enough bytes equal to Self::Seed's size; scenarios to cover include both successful and failed attempts to fill seed invoking rng.try_fill_bytes.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng {",
                "        bytes: Vec<u8>,",
                "        filled: bool,",
                "    }",
                "",
                "    impl TryRngCore for TestRng {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            if self.filled {",
                "                let to_fill = std::cmp::min(dest.len(), self.bytes.len());",
                "                dest[..to_fill].copy_from_slice(&self.bytes[..to_fill]);",
                "                Ok(())",
                "            } else {",
                "                Err(())",
                "            }",
                "        }",
                "    }",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 16];",
                "",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            // Normally you'd construct a RNG from the seed",
                "            TestRng { bytes: Vec::new(), filled: false }",
                "        }",
                "    }",
                "",
                "    let mut rng = TestRng {",
                "        bytes: vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],",
                "        filled: true,",
                "    };",
                "    let _ = TestRng::try_from_rng(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(TestRng::try_from_rng(&mut rng).is_ok(), true);",
                "    assert_eq!(TestRng::try_from_rng(&mut rng).unwrap(), TestRng::from_seed([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));",
                "    rng.filled = false;",
                "    assert_eq!(TestRng::try_from_rng(&mut rng).is_err(), true);"
              ],
              "code": [
                "{",
                "    struct TestRng {",
                "        bytes: Vec<u8>,",
                "        filled: bool,",
                "    }",
                "",
                "    impl TryRngCore for TestRng {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            if self.filled {",
                "                let to_fill = std::cmp::min(dest.len(), self.bytes.len());",
                "                dest[..to_fill].copy_from_slice(&self.bytes[..to_fill]);",
                "                Ok(())",
                "            } else {",
                "                Err(())",
                "            }",
                "        }",
                "    }",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 16];",
                "",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            // Normally you'd construct a RNG from the seed",
                "            TestRng { bytes: Vec::new(), filled: false }",
                "        }",
                "    }",
                "",
                "    let mut rng = TestRng {",
                "        bytes: vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],",
                "        filled: true,",
                "    };",
                "    let _ = TestRng::try_from_rng(&mut rng);",
                "    assert_eq!(TestRng::try_from_rng(&mut rng).is_ok(), true);",
                "    assert_eq!(TestRng::try_from_rng(&mut rng).unwrap(), TestRng::from_seed([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));",
                "    rng.filled = false;",
                "    assert_eq!(TestRng::try_from_rng(&mut rng).is_err(), true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng {",
                "        bytes: Vec<u8>,",
                "        filled: bool,",
                "    }",
                "",
                "    impl TryRngCore for TestRng {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            if self.filled {",
                "                let to_fill = std::cmp::min(dest.len(), self.bytes.len());",
                "                dest[..to_fill].copy_from_slice(&self.bytes[..to_fill]);",
                "                Ok(())",
                "            } else {",
                "                Err(())",
                "            }",
                "        }",
                "    }",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 16];",
                "",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng { bytes: Vec::new(), filled: false }",
                "        }",
                "    }",
                "",
                "    let mut rng = TestRng {",
                "        bytes: vec![],",
                "        filled: false,",
                "    };",
                "    let _ = TestRng::try_from_rng(&mut rng).unwrap_err();",
                "}"
              ],
              "oracle": [
                "    assert!(TestRng::try_from_rng(&mut rng).is_err());",
                "    rng.filled = true;",
                "    rng.bytes = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];",
                "    assert_eq!(TestRng::try_from_rng(&mut rng).unwrap(), TestRng::from_seed([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));",
                "    assert!(TestRng::try_from_rng(&mut rng).is_ok());"
              ],
              "code": [
                "{",
                "    struct TestRng {",
                "        bytes: Vec<u8>,",
                "        filled: bool,",
                "    }",
                "",
                "    impl TryRngCore for TestRng {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            if self.filled {",
                "                let to_fill = std::cmp::min(dest.len(), self.bytes.len());",
                "                dest[..to_fill].copy_from_slice(&self.bytes[..to_fill]);",
                "                Ok(())",
                "            } else {",
                "                Err(())",
                "            }",
                "        }",
                "    }",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 16];",
                "",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng { bytes: Vec::new(), filled: false }",
                "        }",
                "    }",
                "",
                "    let mut rng = TestRng {",
                "        bytes: vec![],",
                "        filled: false,",
                "    };",
                "    let _ = TestRng::try_from_rng(&mut rng).unwrap_err();",
                "    assert!(TestRng::try_from_rng(&mut rng).is_err());",
                "    rng.filled = true;",
                "    rng.bytes = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];",
                "    assert_eq!(TestRng::try_from_rng(&mut rng).unwrap(), TestRng::from_seed([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));",
                "    assert!(TestRng::try_from_rng(&mut rng).is_ok());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng {",
                "        bytes: Vec<u8>,",
                "        filled: bool,",
                "    }",
                "",
                "    impl TryRngCore for TestRng {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            if self.filled {",
                "                let to_fill = std::cmp::min(dest.len(), 16); // Boundary case for size",
                "                dest[..to_fill].copy_from_slice(&self.bytes[..to_fill]);",
                "                Ok(())",
                "            } else {",
                "                Err(())",
                "            }",
                "        }",
                "    }",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 16];",
                "",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng { bytes: Vec::new(), filled: false }",
                "        }",
                "    }",
                "",
                "    let mut rng = TestRng {",
                "        bytes: vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],",
                "        filled: true,",
                "    };",
                "    let _ = TestRng::try_from_rng(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(TestRng::try_from_rng(&mut rng).is_ok(), true);",
                "    assert!(TestRng::try_from_rng(&mut rng).unwrap() instanceof TestRng);",
                "    assert_eq!(rng.bytes.len(), 16);",
                "    assert_eq!(rng.bytes[..8], vec![1, 2, 3, 4, 5, 6, 7, 8]);",
                "    assert_eq!(rng.filled, true);"
              ],
              "code": [
                "{",
                "    struct TestRng {",
                "        bytes: Vec<u8>,",
                "        filled: bool,",
                "    }",
                "",
                "    impl TryRngCore for TestRng {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            if self.filled {",
                "                let to_fill = std::cmp::min(dest.len(), 16); // Boundary case for size",
                "                dest[..to_fill].copy_from_slice(&self.bytes[..to_fill]);",
                "                Ok(())",
                "            } else {",
                "                Err(())",
                "            }",
                "        }",
                "    }",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 16];",
                "",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng { bytes: Vec::new(), filled: false }",
                "        }",
                "    }",
                "",
                "    let mut rng = TestRng {",
                "        bytes: vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],",
                "        filled: true,",
                "    };",
                "    let _ = TestRng::try_from_rng(&mut rng);",
                "    assert_eq!(TestRng::try_from_rng(&mut rng).is_ok(), true);",
                "    assert!(TestRng::try_from_rng(&mut rng).unwrap() instanceof TestRng);",
                "    assert_eq!(rng.bytes.len(), 16);",
                "    assert_eq!(rng.bytes[..8], vec![1, 2, 3, 4, 5, 6, 7, 8]);",
                "    assert_eq!(rng.filled, true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}