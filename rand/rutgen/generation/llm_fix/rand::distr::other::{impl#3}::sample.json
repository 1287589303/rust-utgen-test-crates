{
  "name": "rand::distr::other::{impl#3}::sample",
  "mod_info": {
    "name": "distr::other",
    "loc": "src/distr/mod.rs:93:1:93:11"
  },
  "visible": true,
  "loc": "src/distr/other.rs:156:5:163:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: offset + (offset > b'Z') as u8 * (b'a' - b'Z' - 1)\n"
      ],
      "input_infer": "rng must be a valid randomness generator, RANGE must be 0 to 52 (inclusive) for random_range, the expected return values must be within the ASCII range of uppercase and lowercase alphabetic characters (A-Z, a-z) which corresponds to u8 values between 65 and 122.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockRng {",
                "        value: u8,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
                "            self.value = range.start; // set to minimum for testing",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphabetic = Alphabetic;",
                "    let result = alphabetic.sample(&mut rng);",
                "}"
              ],
              "oracle": [
                "    let mut rng = MockRng { value: 0 };",
                "    let alphabetic = Alphabetic;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'A');",
                "    rng.value = 25;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'Z');",
                "    rng.value = 26;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'a');",
                "    rng.value = 51;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'z');",
                "    rng.value = 27;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert!(result >= b'A' && result <= b'z');",
                "    rng.value = 24;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'Y');"
              ],
              "code": [
                "{",
                "    struct MockRng {",
                "        value: u8,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
                "            self.value = range.start; // set to minimum for testing",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphabetic = Alphabetic;",
                "    let result = alphabetic.sample(&mut rng);",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphabetic = Alphabetic;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'A');",
                "    rng.value = 25;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'Z');",
                "    rng.value = 26;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'a');",
                "    rng.value = 51;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'z');",
                "    rng.value = 27;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert!(result >= b'A' && result <= b'z');",
                "    rng.value = 24;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'Y');",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockRng {",
                "        value: u8,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
                "            self.value = range.end - 1; // set to maximum for testing",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphabetic = Alphabetic;",
                "    let result = alphabetic.sample(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result >= b'A' && result <= b'z', \"Result out of bounds: {}\", result);",
                "    assert!(result < 128, \"Result exceeds valid ASCII range: {}\", result);",
                "    assert!(result > b'Z' || result < b'a', \"Result does not correctly handle character wrapping: {}\", result);",
                "    assert_eq!(result, b'Z' + 1 + (b'a' - b'Z' - 1), \"Unexpected result for upper-case overflow: {}\", result);"
              ],
              "code": [
                "{",
                "    struct MockRng {",
                "        value: u8,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
                "            self.value = range.end - 1; // set to maximum for testing",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphabetic = Alphabetic;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert!(result >= b'A' && result <= b'z', \"Result out of bounds: {}\", result);",
                "    assert!(result < 128, \"Result exceeds valid ASCII range: {}\", result);",
                "    assert!(result > b'Z' || result < b'a', \"Result does not correctly handle character wrapping: {}\", result);",
                "    assert_eq!(result, b'Z' + 1 + (b'a' - b'Z' - 1), \"Unexpected result for upper-case overflow: {}\", result);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockRng {",
                "        value: u8,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
                "            self.value = range.start + 26; // test middle of the range",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphabetic = Alphabetic;",
                "    let result = alphabetic.sample(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, b'Z' + (b'Z' > b'Z') as u8 * (b'a' - b'Z' - 1));",
                "    assert!(result >= b'A' && result <= b'z');",
                "    assert!(result < 52);",
                "    assert_eq!(result, b'Z' + (1) * (b'a' - b'Z' - 1));",
                "    assert_eq!(result, b'a');",
                "    assert!(result >= b'A' && result <= b'z');",
                "    assert_eq!(result, b'Z' + (0) * (b'a' - b'Z' - 1));",
                "    assert_eq!(result, b'Z');"
              ],
              "code": [
                "{",
                "    struct MockRng {",
                "        value: u8,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn random_range(&mut self, range: std::ops::Range<u8>) -> u8 {",
                "            self.value = range.start + 26; // test middle of the range",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphabetic = Alphabetic;",
                "    let result = alphabetic.sample(&mut rng);",
                "    assert_eq!(result, b'Z' + (b'Z' > b'Z') as u8 * (b'a' - b'Z' - 1));",
                "    assert!(result >= b'A' && result <= b'z');",
                "    assert!(result < 52);",
                "    assert_eq!(result, b'Z' + (1) * (b'a' - b'Z' - 1));",
                "    assert_eq!(result, b'a');",
                "    assert!(result >= b'A' && result <= b'z');",
                "    assert_eq!(result, b'Z' + (0) * (b'a' - b'Z' - 1));",
                "    assert_eq!(result, b'Z');",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}