{
  "name": "rand::rngs::mock::{impl#1}::next_u32",
  "mod_info": {
    "name": "rngs::mock",
    "loc": "src/rngs/mod.rs:83:1:83:14"
  },
  "visible": true,
  "loc": "src/rngs/mock.rs:61:5:63:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: self.next_u64() as u32\n"
      ],
      "input_infer": "v: u64 (initial value can be 0 to max u64), a: u64 (initial value can be 0 to max u64), must call next_u32() at least once\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = StepRng { v: 0, a: 0 };",
                "    let _ = rng.next_u32();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.v, 0);",
                "    assert_eq!(rng.a, 0);",
                "    assert_eq!(rng.next_u32(), 0);",
                "    rng.v = 1;",
                "    rng.a = 1;",
                "    assert_eq!(rng.next_u32(), 1);",
                "    rng.v = 2;",
                "    rng.a = 3;",
                "    assert_eq!(rng.next_u32(), 2);",
                "    rng.v = u64::MAX;",
                "    rng.a = 1;",
                "    assert_eq!(rng.next_u32(), u32::MAX);"
              ],
              "code": [
                "{",
                "    let mut rng = StepRng { v: 0, a: 0 };",
                "    let _ = rng.next_u32();",
                "    assert_eq!(rng.v, 0);",
                "    assert_eq!(rng.a, 0);",
                "    assert_eq!(rng.next_u32(), 0);",
                "    rng.v = 1;",
                "    rng.a = 1;",
                "    assert_eq!(rng.next_u32(), 1);",
                "    rng.v = 2;",
                "    rng.a = 3;",
                "    assert_eq!(rng.next_u32(), 2);",
                "    rng.v = u64::MAX;",
                "    rng.a = 1;",
                "    assert_eq!(rng.next_u32(), u32::MAX);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = StepRng { v: 1, a: 0 };",
                "    let _ = rng.next_u32();",
                "}"
              ],
              "oracle": [
                "    let mut rng = StepRng { v: 1, a: 0 };",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 1);",
                "    rng.v = 2;",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 2);",
                "    rng.a = 2;",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 4);",
                "    rng.v = 0;",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 0);"
              ],
              "code": [
                "{",
                "    let mut rng = StepRng { v: 1, a: 0 };",
                "    let _ = rng.next_u32();",
                "    let mut rng = StepRng { v: 1, a: 0 };",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 1);",
                "    rng.v = 2;",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 2);",
                "    rng.a = 2;",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 4);",
                "    rng.v = 0;",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = StepRng { v: u64::MAX, a: 0 };",
                "    let _ = rng.next_u32();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.v, u64::MAX);",
                "    assert_eq!(rng.a, 0);",
                "    assert_eq!(rng.next_u32(), u64::MAX as u32);"
              ],
              "code": [
                "{",
                "    let mut rng = StepRng { v: u64::MAX, a: 0 };",
                "    let _ = rng.next_u32();",
                "    assert_eq!(rng.v, u64::MAX);",
                "    assert_eq!(rng.a, 0);",
                "    assert_eq!(rng.next_u32(), u64::MAX as u32);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = StepRng { v: 0, a: u64::MAX };",
                "    let _ = rng.next_u32();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.v, 0);  // Ensure initial value of v is 0",
                "    assert_eq!(rng.a, u64::MAX);  // Ensure initial value of a is u64::MAX",
                "    assert_eq!(rng.next_u32(), 0);  // First call to next_u32() should return 0",
                "    rng.v = 1;",
                "    assert_eq!(rng.next_u32(), 1);  // After changing v to 1, next_u32() should return 1",
                "    rng.a = 1;",
                "    assert_eq!(rng.next_u32(), 2);  // next_u32() should return 2 with a set to 1",
                "    rng.v = u64::MAX - 1;",
                "    assert_eq!(rng.next_u32(), u64::MAX - 1);  // Check upper limit behavior",
                "    rng.v = u64::MAX;",
                "    assert_eq!(rng.next_u32(), u64::MAX);  // Check behavior at u64::MAX",
                "    assert_eq!(rng.next_u32(), 0);  // Wrapping behavior should reset to 0 after max value"
              ],
              "code": [
                "{",
                "   let mut rng = StepRng { v: 0, a: u64::MAX };",
                "   let _ = rng.next_u32();",
                "   assert_eq!(rng.v, 0);  // Ensure initial value of v is 0",
                "   assert_eq!(rng.a, u64::MAX);  // Ensure initial value of a is u64::MAX",
                "   assert_eq!(rng.next_u32(), 0);  // First call to next_u32() should return 0",
                "   rng.v = 1;",
                "   assert_eq!(rng.next_u32(), 1);  // After changing v to 1, next_u32() should return 1",
                "   rng.a = 1;",
                "   assert_eq!(rng.next_u32(), 2);  // next_u32() should return 2 with a set to 1",
                "   rng.v = u64::MAX - 1;",
                "   assert_eq!(u64::from(rng.next_u32()), u64::MAX - 1);  // Check upper limit behavior",
                "   rng.v = u64::MAX;",
                "   assert_eq!(u64::from(rng.next_u32()), u64::MAX);  // Check behavior at u64::MAX",
                "   assert_eq!(rng.next_u32(), 0);  // Wrapping behavior should reset to 0 after max value",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = StepRng { v: u64::MAX, a: u64::MAX };",
                "    let _ = rng.next_u32();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.v, u64::MAX);",
                "    assert_eq!(rng.a, u64::MAX);",
                "    assert_eq!(rng.next_u32(), u64::MAX as u32);",
                "    rng.next_u32(); // First call to move v to the next state",
                "    assert_eq!(rng.v, u64::MAX.wrapping_add(u64::MAX));",
                "    assert_eq!(rng.next_u32(), (u64::MAX as u64).wrapping_add(u64::MAX) as u32);"
              ],
              "code": [
                "{",
                "    let mut rng = StepRng { v: u64::MAX, a: u64::MAX };",
                "    let _ = rng.next_u32();",
                "    assert_eq!(rng.v, u64::MAX);",
                "    assert_eq!(rng.a, u64::MAX);",
                "    assert_eq!(rng.next_u32(), u64::MAX as u32);",
                "    rng.next_u32(); // First call to move v to the next state",
                "    assert_eq!(rng.v, u64::MAX.wrapping_add(u64::MAX));",
                "    assert_eq!(rng.next_u32(), (u64::MAX as u64).wrapping_add(u64::MAX) as u32);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = StepRng { v: 123456789, a: 987654321 };",
                "    let _ = rng.next_u32();",
                "}"
              ],
              "oracle": [
                "    let mut rng = StepRng { v: 123456789, a: 987654321 };",
                "    let result_u32 = rng.next_u32();",
                "    let expected_u64 = 123456789;",
                "    assert_eq!(result_u32 as u64, expected_u64);",
                "    rng.v = rng.v.wrapping_add(rng.a);",
                "    let result_u32_next = rng.next_u32();",
                "    let expected_u64_next = rng.v;",
                "    assert_eq!(result_u32_next as u64, expected_u64_next);"
              ],
              "code": [
                "{",
                "    let mut rng = StepRng { v: 123456789, a: 987654321 };",
                "    let _ = rng.next_u32();",
                "    let mut rng = StepRng { v: 123456789, a: 987654321 };",
                "    let result_u32 = rng.next_u32();",
                "    let expected_u64 = 123456789;",
                "    assert_eq!(result_u32 as u64, expected_u64);",
                "    rng.v = rng.v.wrapping_add(rng.a);",
                "    let result_u32_next = rng.next_u32();",
                "    let expected_u64_next = rng.v;",
                "    assert_eq!(result_u32_next as u64, expected_u64_next);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}