{
  "name": "rand::distr::uniform::{impl#2}::new_inclusive",
  "mod_info": {
    "name": "distr::uniform",
    "loc": "src/distr/mod.rs:101:1:101:17"
  },
  "visible": true,
  "loc": "src/distr/uniform.rs:246:5:252:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "low and high must be finite values where low ≤ high, covering cases such as low = high, low < high, low = -∞, high = +∞, low = NaN, high = NaN, and low > high, which should yield an error.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct FiniteType;",
                "    impl SampleUniform for FiniteType {",
                "        type Sampler = FiniteSampler;",
                "    }",
                "",
                "    struct FiniteSampler;",
                "",
                "    impl UniformSampler for FiniteSampler {",
                "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "            Ok(FiniteSampler)",
                "        }",
                "    }",
                "",
                "    let _result = Uniform::<FiniteType>::new_inclusive(1.0, 5.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, 5.0).is_ok(), true);",
                "    assert_eq!(Uniform::<FiniteType>::new_inclusive(5.0, 1.0).is_err(), true);",
                "    assert_eq!(Uniform::<FiniteType>::new_inclusive(f32::NAN, 5.0).is_err(), true);",
                "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, f32::NAN).is_err(), true);",
                "    assert_eq!(Uniform::<FiniteType>::new_inclusive(f32::INFINITY, 5.0).is_err(), true);",
                "    assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, f32::INFINITY).is_err(), true);"
              ],
              "code": [
                "{",
                "   struct FiniteType;",
                "   impl SampleUniform for FiniteType {",
                "       type Sampler = FiniteSampler;",
                "   }",
                "",
                "   struct FiniteSampler;",
                "",
                "   impl UniformSampler for FiniteSampler {",
                "       fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> ",
                "       where",
                "           B1: SampleBorrow<FiniteType>,",
                "           B2: SampleBorrow<FiniteType>,",
                "       {",
                "           Ok(FiniteSampler)",
                "       }",
                "   }",
                "",
                "   let _result = Uniform::<FiniteType>::new_inclusive(1.0, 5.0);",
                "   assert_eq!(Uniform::<FiniteType>::new_inclusive(1.0, 5.0).is_ok(), true);",
                "   assert_eq!(Uniform::<FiniteType>::new_inclusive(5.0, 1.0).is_err(), true);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct FiniteType;",
                "    impl SampleUniform for FiniteType {",
                "        type Sampler = FiniteSampler;",
                "    }",
                "",
                "    struct FiniteSampler;",
                "",
                "    impl UniformSampler for FiniteSampler {",
                "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "            Ok(FiniteSampler)",
                "        }",
                "    }",
                "",
                "    let _result = Uniform::<FiniteType>::new_inclusive(3.0, 3.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(Uniform(FiniteSampler)));",
                "    let _result_empty_range = Uniform::<FiniteType>::new_inclusive(4.0, 3.0);",
                "    assert_eq!(_result_empty_range, Err(Error::EmptyRange));",
                "    let _result_non_finite_low = Uniform::<FiniteType>::new_inclusive(f64::NAN, 5.0);",
                "    assert_eq!(_result_non_finite_low, Err(Error::NonFinite));",
                "    let _result_non_finite_high = Uniform::<FiniteType>::new_inclusive(1.0, f64::INFINITY);",
                "    assert_eq!(_result_non_finite_high, Err(Error::NonFinite));",
                "    let _result_non_finite_range = Uniform::<FiniteType>::new_inclusive(f64::NAN, f64::NAN);",
                "    assert_eq!(_result_non_finite_range, Err(Error::NonFinite));"
              ],
              "code": [
                "{",
                " struct FiniteType;  ",
                " impl SampleUniform for FiniteType {  ",
                "     type Sampler = FiniteSampler;  ",
                " }  ",
                "   ",
                " struct FiniteSampler;  ",
                "   ",
                " impl UniformSampler for FiniteSampler {  ",
                "     type X = FiniteType; // Changed to match expected type  ",
                "     fn new<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {  ",
                "          Ok(FiniteSampler)",
                "      }",
                "      ",
                "      fn sample<R: Rng + ?Sized>(&self, _: &mut R) -> Self::X {",
                "          // Dummy implementation",
                "          todo!()",
                "      }",
                "      ",
                "      fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> { // Added missing trait item",
                "          Ok(FiniteSampler)",
                "      }",
                "  }",
                "  ",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct FiniteType;",
                "    impl SampleUniform for FiniteType {",
                "        type Sampler = FiniteSampler;",
                "    }",
                "",
                "    struct FiniteSampler;",
                "",
                "    impl UniformSampler for FiniteSampler {",
                "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "            Err(Error::EmptyRange)",
                "        }",
                "    }",
                "",
                "    let _result = Uniform::<FiniteType>::new_inclusive(5.0, 2.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(Error::EmptyRange));"
              ],
              "code": [
                "{",
                "   #[derive(PartialEq)]",
                "   struct FiniteType;",
                "   impl SampleUniform for FiniteType {",
                "       type Sampler = FiniteSampler;",
                "   }",
                "   ",
                "   #[derive(PartialEq)]",
                "   struct FiniteSampler;",
                "   ",
                "   impl UniformSampler for FiniteSampler {",
                "       fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "           Err(Error::EmptyRange)",
                "       }",
                "   }",
                "   let _result = Uniform::<FiniteType>::new_inclusive(5.0, 2.0);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NonFiniteType;",
                "    impl SampleUniform for NonFiniteType {",
                "        type Sampler = NonFiniteSampler;",
                "    }",
                "",
                "    struct NonFiniteSampler;",
                "",
                "    impl UniformSampler for NonFiniteSampler {",
                "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "            Err(Error::NonFinite)",
                "        }",
                "    }",
                "",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, 5.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, std::f32::NAN);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, std::f32::NAN);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, 5.0);",
                "    assert_eq!(_result, Ok(Uniform::<NonFiniteType>::new_inclusive(5.0, 5.0).unwrap()));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(-std::f32::INFINITY, 5.0);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, std::f32::INFINITY);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::INFINITY, 5.0);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, 10.0);",
                "    assert!(matches!(_result, Ok(_)));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(10.0, 5.0);",
                "    assert_eq!(_result, Err(Error::EmptyRange));"
              ],
              "code": [
                "{",
                " #[derive(PartialEq)]",
                " struct NonFiniteType;",
                " impl SampleUniform for NonFiniteType {",
                "     type Sampler = NonFiniteSampler;",
                " }",
                " }",
                "  ",
                " #[derive(PartialEq)]",
                " struct NonFiniteSampler; // Added definition for NonFiniteSampler",
                " impl UniformSampler for NonFiniteSampler {",
                "     fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "         Err(Error::NonFinite)",
                "     }",
                " }",
                "",
                " use std::borrow::Borrow;  // Add this line to import Borrow",
                " impl Borrow<NonFiniteType> for NonFiniteType { // Implement Borrow trait",
                "     fn borrow(&self) -> &NonFiniteType { self }",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, std::f32::NAN);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, 5.0);",
                "    assert_eq!(_result, Ok(Uniform::<NonFiniteType>::new_inclusive(5.0, 5.0).unwrap()));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(-std::f32::INFINITY, 5.0);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, std::f32::INFINITY);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::INFINITY, 5.0);",
                "    assert_eq!(_result.as_ref(), Err(Error::NonFinite));  ",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(5.0, 10.0);",
                "    assert!(matches!(_result, Ok(_)));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(10.0, 5.0);",
                "    assert_eq!(_result, Err(Error::EmptyRange));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NonFiniteType;",
                "    impl SampleUniform for NonFiniteType {",
                "        type Sampler = NonFiniteSampler;",
                "    }",
                "",
                "    struct NonFiniteSampler;",
                "",
                "    impl UniformSampler for NonFiniteSampler {",
                "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "            Err(Error::NonFinite)",
                "        }",
                "    }",
                "",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(1.0, std::f32::NAN);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, 1.0);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, std::f32::NAN);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(1.0, 0.0);",
                "    assert_eq!(_result, Err(Error::EmptyRange));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(0.0, 1.0);",
                "    assert!(matches!(_result, Ok(_)));",
                "    let _result = Uniform::<NonFiniteType>::new_inclusive(0.0, 0.0);",
                "    assert!(matches!(_result, Ok(_)));"
              ],
              "code": [
                "{",
                " #[derive(PartialEq, Debug)]  ",
                " struct NonFiniteType;  ",
                "",
                "  impl SampleUniform for NonFiniteType {",
                "      type Sampler = NonFiniteSampler;",
                "  }",
                "  ",
                "  #[derive(PartialEq, Debug)] // Added Debug here",
                "  struct NonFiniteSampler;",
                "  ",
                "  impl UniformSampler for NonFiniteSampler {",
                "       fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "           Err(Error::NonFinite)",
                "       }",
                "   }",
                "   ",
                "   let _result = Uniform::<NonFiniteType>::new_inclusive(1.0, std::f32::NAN);",
                "   assert_eq!(_result, Err(Error::NonFinite));",
                "   let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, 1.0);",
                "   assert_eq!(_result, Err(Error::NonFinite));",
                "   let _result = Uniform::<NonFiniteType>::new_inclusive(std::f32::NAN, std::f32::NAN);",
                "   assert_eq!(_result, Err(Error::NonFinite));",
                "   let _result = Uniform::<NonFiniteType>::new_inclusive(1.0, 0.0);",
                "   assert_eq!(_result, Err(Error::EmptyRange));",
                "   let _result = Uniform::<NonFiniteType>::new_inclusive(0.0, 1.0);",
                "   assert!(matches!(_result, Ok(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct InfiniteType;",
                "    impl SampleUniform for InfiniteType {",
                "        type Sampler = InfiniteSampler;",
                "    }",
                "",
                "    struct InfiniteSampler;",
                "",
                "    impl UniformSampler for InfiniteSampler {",
                "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "            Err(Error::NonFinite)",
                "        }",
                "    }",
                "",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(std::f32::NEG_INFINITY, 5.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    ",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(1.0, std::f32::INFINITY);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    ",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(std::f32::NAN, 5.0);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    ",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(5.0, std::f32::NAN);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    ",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(10.0, 5.0);",
                "    assert_eq!(_result, Err(Error::EmptyRange));"
              ],
              "code": [
                "{",
                "  #[derive(Debug)]",
                "  struct InfiniteSampler;",
                "  impl SampleUniform for InfiniteSampler {",
                "      type Sampler = InfiniteSampler;",
                "  }",
                "   ",
                "",
                "    impl UniformSampler for InfiniteSampler {",
                "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "            Err(Error::NonFinite)",
                "        }",
                "    }",
                "",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(std::f32::NEG_INFINITY, 5.0);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    ",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(1.0, std::f32::INFINITY);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    ",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(std::f32::NAN, 5.0);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    ",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(5.0, std::f32::NAN);",
                "    assert_eq!(_result, Err(Error::NonFinite));",
                "    ",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(10.0, 5.0);",
                "    assert_eq!(_result, Err(Error::EmptyRange));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct InfiniteType;",
                "    impl SampleUniform for InfiniteType {",
                "        type Sampler = InfiniteSampler;",
                "    }",
                "",
                "    struct InfiniteSampler;",
                "",
                "    impl UniformSampler for InfiniteSampler {",
                "        fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "            Err(Error::NonFinite)",
                "        }",
                "    }",
                "",
                "    let _result = Uniform::<InfiniteType>::new_inclusive(1.0, std::f32::INFINITY);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(Error::NonFinite));"
              ],
              "code": [
                "{",
                "   #[derive(Debug)]",
                "   struct InfiniteType;",
                "   impl SampleUniform for InfiniteType {",
                "       type Sampler = InfiniteSampler;",
                "   }",
                "   ",
                "   #[derive(Debug)]",
                "   struct InfiniteSampler;",
                "   ",
                "   impl UniformSampler for InfiniteSampler {",
                "       fn new_inclusive<B1, B2>(_low: B1, _high: B2) -> Result<Self, Error> {",
                "           Err(Error::NonFinite)",
                "       }",
                "   }",
                "   ",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}