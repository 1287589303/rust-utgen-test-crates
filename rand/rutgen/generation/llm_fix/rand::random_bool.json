{
  "name": "rand::random_bool",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:10:1:331:2"
  },
  "visible": true,
  "loc": "src/lib.rs:241:1:243:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "p must be a floating-point number in the range [-0.1, 1.1] to test lower and upper boundaries, including edge cases 0.0 and 1.0, and testing invalid cases like -0.1 and 1.1.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = rand::random_bool(0.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);",
                "    assert!(std::panic::catch_unwind(|| rand::random_bool(-0.1)).is_err());",
                "    assert!(std::panic::catch_unwind(|| rand::random_bool(1.1)).is_err());",
                "    result = rand::random_bool(0.5);",
                "    assert!(result == true || result == false);",
                "    result = rand::random_bool(0.0);",
                "    assert_eq!(result, false);",
                "    result = rand::random_bool(1.0);",
                "    assert_eq!(result, true);",
                "    result = rand::random_bool(0.25);",
                "    assert!(result == true || result == false);",
                "    result = rand::random_bool(0.75);",
                "    assert!(result == true || result == false);"
              ],
              "code": [
                "{",
                "  let mut result = random_bool(0.0);",
                "  assert_eq!(result, false);",
                "  assert!(std::panic::catch_unwind(|| random_bool(-0.1)).is_err());",
                "  assert!(std::panic::catch_unwind(|| random_bool(1.1)).is_err());",
                "  result = random_bool(0.5);",
                "  assert!(result == true || result == false);",
                "  result = random_bool(0.0);",
                "  assert_eq!(result, false);",
                "  result = random_bool(1.0);",
                "  assert_eq!(result, true);",
                "  result = random_bool(0.25);",
                "  assert!(result == true || result == false);",
                "  result = random_bool(0.75);",
                "  assert!(result == true || result == false);",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = rand::random_bool(1.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    #[test]",
                "    fn test_random_bool_zero() {",
                "    let result = rand::random_bool(0.0);",
                "    assert_eq!(result, false);",
                "    }",
                "    #[test]",
                "    #[should_panic]",
                "    fn test_random_bool_negative() {",
                "    rand::random_bool(-0.1);",
                "    }",
                "    #[test]",
                "    #[should_panic]",
                "    fn test_random_bool_above_one() {",
                "    rand::random_bool(1.1);",
                "    }",
                "    #[test]",
                "    fn test_random_bool_third_probability() {",
                "    let p = 1.0 / 3.0;",
                "    let result = rand::random_bool(p);",
                "    assert!(result == true || result == false);",
                "    }",
                "    #[test]",
                "    fn test_random_bool_half_probability() {",
                "    let p = 0.5;",
                "    let result = rand::random_bool(p);",
                "    assert!(result == true || result == false);",
                "    }"
              ],
              "code": [
                "{",
                "   let result = random_bool(1.0);",
                "   assert_eq!(result, true);",
                "   #[test]",
                "   fn test_random_bool_zero() {",
                "   let result = random_bool(0.0);",
                "   assert_eq!(result, false);",
                "   }",
                "   #[test]",
                "   #[should_panic]",
                "   fn test_random_bool_negative() {",
                "   random_bool(-0.1);",
                "   }",
                "   #[test]",
                "   #[should_panic]",
                "   fn test_random_bool_above_one() {",
                "   random_bool(1.1);",
                "   }",
                "   #[test]",
                "   fn test_random_bool_third_probability() {",
                "   let p = 1.0 / 3.0;",
                "   let result = random_bool(p);",
                "   assert!(result == true || result == false);",
                "   }",
                "   #[test]",
                "   fn test_random_bool_half_probability() {",
                "   let p = 0.5;",
                "   let result = random_bool(p);",
                "    assert!(result == true || result == false);",
                "    }",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let result = rand::random_bool(-0.1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(std::panic::catch_unwind(|| rand::random_bool(-0.1)).is_err(), true);",
                "    assert_eq!(std::panic::catch_unwind(|| rand::random_bool(1.1)).is_err(), true);",
                "    assert_eq!(std::panic::catch_unwind(|| rand::random_bool(0.0)).is_err(), false);",
                "    assert_eq!(std::panic::catch_unwind(|| rand::random_bool(1.0)).is_err(), false);",
                "    assert_eq!(std::panic::catch_unwind(|| rand::random_bool(0.5)).is_err(), false);"
              ],
              "code": [
                "{",
                "",
                "",
                "",
                "",
                "",
                "",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let result = rand::random_bool(1.1);",
                "}"
              ],
              "oracle": [
                "    assert!(std::panic::catch_unwind(|| rand::random_bool(1.1)).is_err());",
                "    assert!(std::panic::catch_unwind(|| rand::random_bool(-0.1)).is_err());",
                "    assert!(std::panic::catch_unwind(|| rand::random_bool(1.0)).is_ok());",
                "    assert!(std::panic::catch_unwind(|| rand::random_bool(0.0)).is_ok());",
                "    assert!(std::panic::catch_unwind(|| rand::random_bool(0.5)).is_ok());"
              ],
              "code": [
                "{",
                "   let result = random_bool(1.1);",
                "   assert!(std::panic::catch_unwind(|| random_bool(1.1)).is_err());",
                "   assert!(std::panic::catch_unwind(|| random_bool(-0.1)).is_err());",
                "   assert!(std::panic::catch_unwind(|| random_bool(1.0)).is_ok());",
                "   assert!(std::panic::catch_unwind(|| random_bool(0.0)).is_ok());",
                "   assert!(std::panic::catch_unwind(|| random_bool(0.5)).is_ok());",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}