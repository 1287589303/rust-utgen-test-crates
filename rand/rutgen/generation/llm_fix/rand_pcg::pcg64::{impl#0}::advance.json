{
  "name": "rand_pcg::pcg64::{impl#0}::advance",
  "mod_info": {
    "name": "pcg64",
    "loc": "rand_pcg/src/lib.rs:94:1:94:11"
  },
  "visible": true,
  "loc": "rand_pcg/src/pcg64.rs:60:5:77:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 67 is true\n",
        "precondition: (mdelta & 1) != 0 at line 68 is true\n",
        "precondition: mdelta > 0 at line 67 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "state: 0 to u64::MAX, increment: 1 to u64::MAX, delta: 1 to u64::MAX, including boundary cases for delta like 1, u64::MAX and 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(1); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "}"
              ],
              "oracle": [
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(1); // Expected state after advance should be computed",
                "    assert_ne!(rng.state, 1); // Check that state has changed",
                "    rng.advance(0); // mdelta > 0 false, bound mdelta == 0",
                "    assert_eq!(rng.state, 1); // State should remain unchanged after zero advance"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(1); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(1); // Expected state after advance should be computed",
                "    assert_ne!(rng.state, 1); // Check that state has changed",
                "    rng.advance(0); // mdelta > 0 false, bound mdelta == 0",
                "    assert_eq!(rng.state, 1); // State should remain unchanged after zero advance",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(2); // mdelta > 0 true, (mdelta & 1) != 0 false",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, expected_state_after_first_advance); // Validate state after advance with delta = 2 (mdelta > 0 true, (mdelta & 1) != 0 false)",
                "    rng.advance(4); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    assert_eq!(rng.state, expected_state_after_second_advance); // Validate state after advance with delta = 4 (mdelta > 0 true, (mdelta & 1) != 0 true)",
                "    rng.advance(0); // mdelta > 0 false, mdelta == 0",
                "    assert_eq!(rng.state, initial_state); // Validate state remains the same after advance with delta = 0"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(2); // mdelta > 0 true, (mdelta & 1) != 0 false",
                "    assert_eq!(rng.state, expected_state_after_first_advance); // Validate state after advance with delta = 2 (mdelta > 0 true, (mdelta & 1) != 0 false)",
                "    rng.advance(4); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    assert_eq!(rng.state, expected_state_after_second_advance); // Validate state after advance with delta = 4 (mdelta > 0 true, (mdelta & 1) != 0 true)",
                "    rng.advance(0); // mdelta > 0 false, mdelta == 0",
                "    assert_eq!(rng.state, initial_state); // Validate state remains the same after advance with delta = 0",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(u64::MAX - 1, 1);",
                "    rng.advance(u64::MAX); // mdelta > 0 true, (mdelta & 1) != 0 false",
                "}"
              ],
              "oracle": [
                "    rng.advance(u64::MAX); // mdelta > 0 true",
                "    assert_ne!(rng.state, u64::MAX - 1); // Verify state has changed",
                "    ",
                "    rng.advance(1); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    assert!(rng.state > 0); // Verify state is positive",
                "    ",
                "    rng.advance(0); // mdelta > 0 false, mdelta is now 0",
                "    assert_eq!(rng.state, u64::MAX + (MULTIPLIER * (u64::MAX - 1) + 2)); // Verify final state matches expected calculation"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(u64::MAX - 1, 1);",
                "    rng.advance(u64::MAX); // mdelta > 0 true, (mdelta & 1) != 0 false",
                "    rng.advance(u64::MAX); // mdelta > 0 true",
                "    assert_ne!(rng.state, u64::MAX - 1); // Verify state has changed",
                "    ",
                "    rng.advance(1); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    assert!(rng.state > 0); // Verify state is positive",
                "    ",
                "    rng.advance(0); // mdelta > 0 false, mdelta is now 0",
                "    assert_eq!(rng.state, u64::MAX + (MULTIPLIER * (u64::MAX - 1) + 2)); // Verify final state matches expected calculation",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(u64::MAX, 1);",
                "    rng.advance(u64::MAX - 2); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "}"
              ],
              "oracle": [
                "    rng.advance(1); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    rng.advance(2); // mdelta > 0 true, (mdelta & 1) == 0 true",
                "    rng.advance(3); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    rng.advance(u64::MAX); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    rng.advance(0); // mdelta > 0 false, mdelta == 0"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(u64::MAX, 1);",
                "    rng.advance(u64::MAX - 2); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    rng.advance(1); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    rng.advance(2); // mdelta > 0 true, (mdelta & 1) == 0 true",
                "    rng.advance(3); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    rng.advance(u64::MAX); // mdelta > 0 true, (mdelta & 1) != 0 true",
                "    rng.advance(0); // mdelta > 0 false, mdelta == 0",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(0); // mdelta == 0, false case",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 2); // Check state after calling advance(0) with initial state of 1 and increment of 1.",
                "    ",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(1); // mdelta > 0, true case",
                "    assert!(rng.state > 1); // Check that state has advanced from initial value.",
                "    ",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(2); // mdelta > 0, true case, testing multiple step advancement",
                "    assert!(rng.state > 1); // Ensure state is updated after multiple steps.",
                "    ",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(3); // mdelta > 0, true case",
                "    assert!(rng.state > 1); // Confirm state is advanced when delta is odd.",
                "    ",
                "    let mut rng = Lcg64Xsh32::new(5, 3);",
                "    rng.advance(2); // Test with different initial state and increment",
                "    assert!(rng.state > 5); // Check if state is incremented properly."
              ],
              "code": [
                "{",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(0); // mdelta == 0, false case",
                "    assert_eq!(rng.state, 2); // Check state after calling advance(0) with initial state of 1 and increment of 1.",
                "    ",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(1); // mdelta > 0, true case",
                "    assert!(rng.state > 1); // Check that state has advanced from initial value.",
                "    ",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(2); // mdelta > 0, true case, testing multiple step advancement",
                "    assert!(rng.state > 1); // Ensure state is updated after multiple steps.",
                "    ",
                "    let mut rng = Lcg64Xsh32::new(1, 1);",
                "    rng.advance(3); // mdelta > 0, true case",
                "    assert!(rng.state > 1); // Confirm state is advanced when delta is odd.",
                "    ",
                "    let mut rng = Lcg64Xsh32::new(5, 3);",
                "    rng.advance(2); // Test with different initial state and increment",
                "    assert!(rng.state > 5); // Check if state is incremented properly.",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 67 is true\n",
        "precondition: (mdelta & 1) != 0 at line 68 is false\n",
        "precondition: mdelta > 0 at line 67 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "mdelta > 0 (e.g., 1 to maximum u64 value), mdelta == 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(2); // mdelta > 0 and will ensure (mdelta & 1) != 0 is false.",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pcg.state, 1.wrapping_mul(1.wrapping_add(1)).wrapping_add(0)); // Check for false condition in line 68",
                "    assert_eq!(pcg.state, 1); // Check for the case where mdelta == 0 at line 67",
                "    pcg.advance(0); // Test with mdelta == 0",
                "    assert_eq!(pcg.state, 1); // State should remain unchanged with delta 0"
              ],
              "code": [
                "{",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(2); // mdelta > 0 and will ensure (mdelta & 1) != 0 is false.",
                "    assert_eq!(pcg.state, 1.wrapping_mul(1.wrapping_add(1)).wrapping_add(0)); // Check for false condition in line 68",
                "    assert_eq!(pcg.state, 1); // Check for the case where mdelta == 0 at line 67",
                "    pcg.advance(0); // Test with mdelta == 0",
                "    assert_eq!(pcg.state, 1); // State should remain unchanged with delta 0",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(u64::MAX); // mdelta > 0 (maximum u64) to cover boundary.",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pcg.state, expected_state_after_max_delta); // Check state after advancing with maximum delta",
                "    pcg.advance(1); // mdelta > 0 but (mdelta & 1) != 0 case",
                "    assert_eq!(pcg.state, expected_state_after_advance_one); // Validate state after advancing with delta 1",
                "    pcg.advance(0); // mdelta == 0 case",
                "    assert_eq!(pcg.state, expected_state_after_zero_delta); // State should remain the same after 0 advance"
              ],
              "code": [
                "{",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(u64::MAX); // mdelta > 0 (maximum u64) to cover boundary.",
                "    assert_eq!(pcg.state, expected_state_after_max_delta); // Check state after advancing with maximum delta",
                "    pcg.advance(1); // mdelta > 0 but (mdelta & 1) != 0 case",
                "    assert_eq!(pcg.state, expected_state_after_advance_one); // Validate state after advancing with delta 1",
                "    pcg.advance(0); // mdelta == 0 case",
                "    assert_eq!(pcg.state, expected_state_after_zero_delta); // State should remain the same after 0 advance",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(0); // mdelta == 0 to check boundary condition where while loop is skipped.",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pcg.state, 1); // State should remain the same when advance is called with delta == 0.",
                "    ",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(2); // mdelta > 0, with (mdelta & 1) != 0 being false.",
                "    ",
                "    assert_eq!(pcg.state, (1.wrapping_mul(MULTIPLIER.wrapping_mul(1)).wrapping_add(3))); // Expected new state after advance with delta = 2.",
                "    ",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(3); // mdelta > 0, with (mdelta & 1) != 0 being true.",
                "    ",
                "    assert_eq!(pcg.state, (1.wrapping_mul(MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_mul(1).wrapping_add(3))).wrapping_add(2))); // Expected new state after advance with delta = 3."
              ],
              "code": [
                "{",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(0); // mdelta == 0 to check boundary condition where while loop is skipped.",
                "    assert_eq!(pcg.state, 1); // State should remain the same when advance is called with delta == 0.",
                "    ",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(2); // mdelta > 0, with (mdelta & 1) != 0 being false.",
                "    ",
                "    assert_eq!(pcg.state, (1.wrapping_mul(MULTIPLIER.wrapping_mul(1)).wrapping_add(3))); // Expected new state after advance with delta = 2.",
                "    ",
                "    let mut pcg = Lcg64Xsh32::new(1, 1);",
                "    pcg.advance(3); // mdelta > 0, with (mdelta & 1) != 0 being true.",
                "    ",
                "    assert_eq!(pcg.state, (1.wrapping_mul(MULTIPLIER.wrapping_mul(MULTIPLIER.wrapping_mul(1).wrapping_add(3))).wrapping_add(2))); // Expected new state after advance with delta = 3.",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: mdelta > 0 at line 67 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "Test input conditions or ranges: delta = 0, state = any valid u64 value, increment = any valid u64 value\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state: u64 = 12345; // any valid u64 value",
                "    let stream: u64 = 67890; // any valid u64 value",
                "    let mut rng = Lcg64Xsh32::new(state, stream);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, 12346);"
              ],
              "code": [
                "{",
                "    let state: u64 = 12345; // any valid u64 value",
                "    let stream: u64 = 67890; // any valid u64 value",
                "    let mut rng = Lcg64Xsh32::new(state, stream);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, 12346);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state: u64 = 0; // minimum valid u64 value",
                "    let stream: u64 = 1; // any valid u64 value",
                "    let mut rng = Lcg64Xsh32::new(state, stream);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, (state.wrapping_add(stream << 1 | 1)));"
              ],
              "code": [
                "{",
                "    let state: u64 = 0; // minimum valid u64 value",
                "    let stream: u64 = 1; // any valid u64 value",
                "    let mut rng = Lcg64Xsh32::new(state, stream);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, (state.wrapping_add(stream << 1 | 1)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state: u64 = u64::MAX; // maximum valid u64 value",
                "    let stream: u64 = 1; // any valid u64 value",
                "    let mut rng = Lcg64Xsh32::new(state, stream);",
                "    rng.advance(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.state, state.wrapping_add(stream << 1 | 1));"
              ],
              "code": [
                "{",
                "    let state: u64 = u64::MAX; // maximum valid u64 value",
                "    let stream: u64 = 1; // any valid u64 value",
                "    let mut rng = Lcg64Xsh32::new(state, stream);",
                "    rng.advance(0);",
                "    assert_eq!(rng.state, state.wrapping_add(stream << 1 | 1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}