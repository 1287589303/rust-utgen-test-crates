{
  "name": "rand::distr::other::{impl#2}::sample",
  "mod_info": {
    "name": "distr::other",
    "loc": "src/distr/mod.rs:93:1:93:11"
  },
  "visible": true,
  "loc": "src/distr/other.rs:137:5:152:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: var < RANGE at line 148 is true\n",
        "expected return value/type: GEN_ASCII_STR_CHARSET[var as usize]\n"
      ],
      "input_infer": "RNG must return a u32 value in the range [0, 63] (inclusive) for successful sampling; expected values must correspond to indices 0-61 of GEN_ASCII_STR_CHARSET for valid character output.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockRng {",
                "        value: u32,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphanumeric = Alphanumeric;",
                "    alphanumeric.sample(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(rng.next_u32(), 0);",
                "    let expected_char = GEN_ASCII_STR_CHARSET[0];",
                "    assert_eq!(alphanumeric.sample(&mut rng), expected_char);",
                "    rng.value = 1;",
                "    let expected_char = GEN_ASCII_STR_CHARSET[1];",
                "    assert_eq!(alphanumeric.sample(&mut rng), expected_char);",
                "    rng.value = 61;",
                "    let expected_char = GEN_ASCII_STR_CHARSET[61];",
                "    assert_eq!(alphanumeric.sample(&mut rng), expected_char);",
                "    rng.value = 64;",
                "    assert!(rng.next_u32() >> (32 - 6) >= RANGE);"
              ],
              "code": [
                "{",
                "    struct MockRng {",
                "        value: u32,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 0 };",
                "    let alphanumeric = Alphanumeric;",
                "    alphanumeric.sample(&mut rng);",
                "    assert_eq!(rng.next_u32(), 0);",
                "    let expected_char = GEN_ASCII_STR_CHARSET[0];",
                "    assert_eq!(alphanumeric.sample(&mut rng), expected_char);",
                "    rng.value = 1;",
                "    let expected_char = GEN_ASCII_STR_CHARSET[1];",
                "    assert_eq!(alphanumeric.sample(&mut rng), expected_char);",
                "    rng.value = 61;",
                "    let expected_char = GEN_ASCII_STR_CHARSET[61];",
                "    assert_eq!(alphanumeric.sample(&mut rng), expected_char);",
                "    rng.value = 64;",
                "    assert!(rng.next_u32() >> (32 - 6) >= RANGE);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockRng {",
                "        value: u32,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 31 };",
                "    let alphanumeric = Alphanumeric;",
                "    alphanumeric.sample(&mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(alphanumeric.sample(&mut rng), b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[31 as usize]);"
              ],
              "code": [
                "{",
                "    struct MockRng {",
                "        value: u32,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 31 };",
                "    let alphanumeric = Alphanumeric;",
                "    alphanumeric.sample(&mut rng);",
                "    assert_eq!(alphanumeric.sample(&mut rng), b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[31 as usize]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockRng {",
                "        value: u32,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 63 };",
                "    let alphanumeric = Alphanumeric;",
                "    alphanumeric.sample(&mut rng);",
                "}"
              ],
              "oracle": [
                "    let mut rng = MockRng { value: 63 };",
                "    let alphanumeric = Alphanumeric;",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert!(result >= b'A' && result <= b'Z' || result >= b'a' && result <= b'z' || result >= b'0' && result <= b'9');",
                "    assert_eq!(result, GEN_ASCII_STR_CHARSET[63]);"
              ],
              "code": [
                "{",
                "    struct MockRng {",
                "        value: u32,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 63 };",
                "    let alphanumeric = Alphanumeric;",
                "    alphanumeric.sample(&mut rng);",
                "    let mut rng = MockRng { value: 63 };",
                "    let alphanumeric = Alphanumeric;",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert!(result >= b'A' && result <= b'Z' || result >= b'a' && result <= b'z' || result >= b'0' && result <= b'9');",
                "    assert_eq!(result, GEN_ASCII_STR_CHARSET[63]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockRng {",
                "        value: u32,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 64 }; // This would be rejected, for coverage",
                "    let alphanumeric = Alphanumeric;",
                "    alphanumeric.sample(&mut rng);",
                "}"
              ],
              "oracle": [
                "    let mut rng = MockRng { value: 0 }; // This should return 'A'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'A');",
                "    ",
                "    let mut rng = MockRng { value: 25 }; // This should return 'Z'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'Z');",
                "    ",
                "    let mut rng = MockRng { value: 26 }; // This should return 'a'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'a');",
                "    ",
                "    let mut rng = MockRng { value: 51 }; // This should return 'z'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'z');",
                "    ",
                "    let mut rng = MockRng { value: 52 }; // This should return '0'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'0');",
                "    ",
                "    let mut rng = MockRng { value: 61 }; // This should return '9'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'9');",
                "    ",
                "    let mut rng = MockRng { value: 62 }; // This should not enter the loop, var >= RANGE",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_ne!(result, b'A');",
                "    assert_ne!(result, b'Z');",
                "    assert_ne!(result, b'a');",
                "    assert_ne!(result, b'z');",
                "    assert_ne!(result, b'0');",
                "    assert_ne!(result, b'9');"
              ],
              "code": [
                "{",
                "    struct MockRng {",
                "        value: u32,",
                "    }",
                "",
                "    impl Rng for MockRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "",
                "    let mut rng = MockRng { value: 64 }; // This would be rejected, for coverage",
                "    let alphanumeric = Alphanumeric;",
                "    alphanumeric.sample(&mut rng);",
                "    let mut rng = MockRng { value: 0 }; // This should return 'A'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'A');",
                "    ",
                "    let mut rng = MockRng { value: 25 }; // This should return 'Z'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'Z');",
                "    ",
                "    let mut rng = MockRng { value: 26 }; // This should return 'a'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'a');",
                "    ",
                "    let mut rng = MockRng { value: 51 }; // This should return 'z'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'z');",
                "    ",
                "    let mut rng = MockRng { value: 52 }; // This should return '0'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'0');",
                "    ",
                "    let mut rng = MockRng { value: 61 }; // This should return '9'",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_eq!(result, b'9');",
                "    ",
                "    let mut rng = MockRng { value: 62 }; // This should not enter the loop, var >= RANGE",
                "    let result = alphanumeric.sample(&mut rng);",
                "    assert_ne!(result, b'A');",
                "    assert_ne!(result, b'Z');",
                "    assert_ne!(result, b'a');",
                "    assert_ne!(result, b'z');",
                "    assert_ne!(result, b'0');",
                "    assert_ne!(result, b'9');",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: var < RANGE at line 148 is false, with bound var == RANGE\n",
        "precondition: var < RANGE at line 148 is true\n",
        "expected return value/type: GEN_ASCII_STR_CHARSET[var as usize]\n"
      ],
      "input_infer": "var == 62 (boundary case for false precondition) and var < 62 (valid inputs for true precondition)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng {",
                "        value: u32,",
                "    }",
                "    impl Rng for TestRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "    ",
                "    let rng = &mut TestRng { value: 62 };",
                "    let alphanumeric = Alphanumeric;",
                "    let result = alphanumeric.sample(rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, b'0'); // when var < RANGE is false, expect 62 to map to the last character '0'",
                "    ",
                "    let rng_valid = &mut TestRng { value: 61 };",
                "    let result_valid = alphanumeric.sample(rng_valid);",
                "    assert_eq!(result_valid, b'9'); // when var < RANGE is true, expect 61 to map to '9'",
                "    ",
                "    let rng_lower_boundary = &mut TestRng { value: 0 };",
                "    let result_lower_boundary = alphanumeric.sample(rng_lower_boundary);",
                "    assert_eq!(result_lower_boundary, b'A'); // when var < RANGE is true, expect 0 to map to 'A'"
              ],
              "code": [
                "{",
                "    struct TestRng {",
                "        value: u32,",
                "    }",
                "    impl Rng for TestRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "    ",
                "    let rng = &mut TestRng { value: 62 };",
                "    let alphanumeric = Alphanumeric;",
                "    let result = alphanumeric.sample(rng);",
                "    assert_eq!(result, b'0'); // when var < RANGE is false, expect 62 to map to the last character '0'",
                "    ",
                "    let rng_valid = &mut TestRng { value: 61 };",
                "    let result_valid = alphanumeric.sample(rng_valid);",
                "    assert_eq!(result_valid, b'9'); // when var < RANGE is true, expect 61 to map to '9'",
                "    ",
                "    let rng_lower_boundary = &mut TestRng { value: 0 };",
                "    let result_lower_boundary = alphanumeric.sample(rng_lower_boundary);",
                "    assert_eq!(result_lower_boundary, b'A'); // when var < RANGE is true, expect 0 to map to 'A'",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng {",
                "        value: u32,",
                "    }",
                "    impl Rng for TestRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "    ",
                "    let rng = &mut TestRng { value: 61 };",
                "    let alphanumeric = Alphanumeric;",
                "    let result = alphanumeric.sample(rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, b\"0123456789\"[1]); // Testing with var == RANGE (61)",
                "    ",
                "    let rng = &mut TestRng { value: 60 };",
                "    let result = alphanumeric.sample(rng);",
                "    assert!(result <= b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[61]); // Testing with var < RANGE"
              ],
              "code": [
                "{",
                "    struct TestRng {",
                "        value: u32,",
                "    }",
                "    impl Rng for TestRng {",
                "        fn next_u32(&mut self) -> u32 {",
                "            self.value",
                "        }",
                "    }",
                "    ",
                "    let rng = &mut TestRng { value: 61 };",
                "    let alphanumeric = Alphanumeric;",
                "    let result = alphanumeric.sample(rng);",
                "    assert_eq!(result, b\"0123456789\"[1]); // Testing with var == RANGE (61)",
                "    ",
                "    let rng = &mut TestRng { value: 60 };",
                "    let result = alphanumeric.sample(rng);",
                "    assert!(result <= b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[61]); // Testing with var < RANGE",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}