{
  "name": "rand_pcg::pcg128cm::{impl#3}::next_u64",
  "mod_info": {
    "name": "pcg128cm",
    "loc": "rand_pcg/src/lib.rs:93:1:93:14"
  },
  "visible": true,
  "loc": "rand_pcg/src/pcg128cm.rs:151:5:155:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: res\n"
      ],
      "input_infer": "state: 0 to 2^128-1, increment: 1 to 2^128-1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, 1);",
                "    let result = rng.next_u64();",
                "}"
              ],
              "oracle": [
                "    let mut rng = Lcg128CmDxsm64::new(0, 1);",
                "    let expected_result = output_dxsm(0.wrapping_mul(MULTIPLIER as u128).wrapping_add(1));",
                "    assert_eq!(result, expected_result);",
                "    rng.state = 1;",
                "    let expected_result_1 = output_dxsm(1.wrapping_mul(MULTIPLIER as u128).wrapping_add(1));",
                "    assert_eq!(rng.next_u64(), expected_result_1);",
                "    rng.state = 2;",
                "    let expected_result_2 = output_dxsm(2.wrapping_mul(MULTIPLIER as u128).wrapping_add(1));",
                "    assert_eq!(rng.next_u64(), expected_result_2);",
                "    rng.state = u128::MAX;",
                "    let expected_result_max = output_dxsm(u128::MAX.wrapping_mul(MULTIPLIER as u128).wrapping_add(1));",
                "    assert_eq!(rng.next_u64(), expected_result_max);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(0, 1);",
                "    let result = rng.next_u64();",
                "    let mut rng = Lcg128CmDxsm64::new(0, 1);",
                "    let expected_result = output_dxsm(0.wrapping_mul(MULTIPLIER as u128).wrapping_add(1));",
                "    assert_eq!(result, expected_result);",
                "    rng.state = 1;",
                "    let expected_result_1 = output_dxsm(1.wrapping_mul(MULTIPLIER as u128).wrapping_add(1));",
                "    assert_eq!(rng.next_u64(), expected_result_1);",
                "    rng.state = 2;",
                "    let expected_result_2 = output_dxsm(2.wrapping_mul(MULTIPLIER as u128).wrapping_add(1));",
                "    assert_eq!(rng.next_u64(), expected_result_2);",
                "    rng.state = u128::MAX;",
                "    let expected_result_max = output_dxsm(u128::MAX.wrapping_mul(MULTIPLIER as u128).wrapping_add(1));",
                "    assert_eq!(rng.next_u64(), expected_result_max);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(u128::MAX, 1);",
                "    let result = rng.next_u64();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, output_dxsm(u128::MAX));"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(u128::MAX, 1);",
                "    let result = rng.next_u64();",
                "    assert_eq!(result, output_dxsm(u128::MAX));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    let result = rng.next_u64();",
                "}"
              ],
              "oracle": [
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    let result = rng.next_u64();",
                "    assert_eq!(result, output_dxsm(1));",
                "    rng.step();",
                "    assert_eq!(rng.state, 1.wrapping_mul(MULTIPLIER as u128).wrapping_add(3));",
                "    rng.advance(5);",
                "    assert_eq!(rng.state, rng.state.wrapping_add(5));",
                "    assert_eq!(rng.next_u64(), output_dxsm(rng.state));"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    let result = rng.next_u64();",
                "    let mut rng = Lcg128CmDxsm64::new(1, 2);",
                "    let result = rng.next_u64();",
                "    assert_eq!(result, output_dxsm(1));",
                "    rng.step();",
                "    assert_eq!(rng.state, 1.wrapping_mul(MULTIPLIER as u128).wrapping_add(3));",
                "    rng.advance(5);",
                "    assert_eq!(rng.state, rng.state.wrapping_add(5));",
                "    assert_eq!(rng.next_u64(), output_dxsm(rng.state));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(100, 1);",
                "    let result = rng.next_u64();",
                "}"
              ],
              "oracle": [
                "    let mut rng = Lcg128CmDxsm64::new(100, 1);",
                "    assert_eq!(rng.state, 100.wrapping_add(3));",
                "    assert_eq!(rng.increment, 3);",
                "    let result = rng.next_u64();",
                "    assert!(result > 0);",
                "    let expected_res = output_dxsm(100.wrapping_add(3));",
                "    assert_eq!(result, expected_res);",
                "    rng.step();",
                "    assert_eq!(rng.state, (100.wrapping_add(3).wrapping_mul(MULTIPLIER)).wrapping_add(3));",
                "    assert!(result != rng.next_u64());"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(100, 1);",
                "    let result = rng.next_u64();",
                "    let mut rng = Lcg128CmDxsm64::new(100, 1);",
                "    assert_eq!(rng.state, 100.wrapping_add(3));",
                "    assert_eq!(rng.increment, 3);",
                "    let result = rng.next_u64();",
                "    assert!(result > 0);",
                "    let expected_res = output_dxsm(100.wrapping_add(3));",
                "    assert_eq!(result, expected_res);",
                "    rng.step();",
                "    assert_eq!(rng.state, (100.wrapping_add(3).wrapping_mul(MULTIPLIER)).wrapping_add(3));",
                "    assert!(result != rng.next_u64());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(100, u128::MAX);",
                "    let result = rng.next_u64();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, output_dxsm(100.wrapping_add(u128::MAX << 1 | 1)));",
                "    assert!(result.is_some());",
                "    assert!(result <= u64::MAX);",
                "    assert_ne!(result, 0);",
                "    assert_eq!(rng.state, 100.wrapping_mul(MULTIPLIER).wrapping_add(u128::MAX << 1 | 1));"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(100, u128::MAX);",
                "    let result = rng.next_u64();",
                "    assert_eq!(result, output_dxsm(100.wrapping_add(u128::MAX << 1 | 1)));",
                "    assert!(result.is_some());",
                "    assert!(result <= u64::MAX);",
                "    assert_ne!(result, 0);",
                "    assert_eq!(rng.state, 100.wrapping_mul(MULTIPLIER).wrapping_add(u128::MAX << 1 | 1));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(u128::MAX - 1, u128::MAX - 1);",
                "    let result = rng.next_u64();",
                "}"
              ],
              "oracle": [
                "    assert!(result <= u64::MAX);",
                "    assert!(result > 0);",
                "    assert_eq!(result, output_dxsm(u128::MAX - 1));",
                "    assert_eq!(rng.state, (u128::MAX - 1).wrapping_mul(MULTIPLIER as u128).wrapping_add(u128::MAX - 1));",
                "    assert_ne!(result, rng.next_u64());",
                "    assert_eq!(rng.state, (rng.state.wrapping_add(u128::MAX - 1)));"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(u128::MAX - 1, u128::MAX - 1);",
                "    let result = rng.next_u64();",
                "    assert!(result <= u64::MAX);",
                "    assert!(result > 0);",
                "    assert_eq!(result, output_dxsm(u128::MAX - 1));",
                "    assert_eq!(rng.state, (u128::MAX - 1).wrapping_mul(MULTIPLIER as u128).wrapping_add(u128::MAX - 1));",
                "    assert_ne!(result, rng.next_u64());",
                "    assert_eq!(rng.state, (rng.state.wrapping_add(u128::MAX - 1)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(12, 17);",
                "    let result = rng.next_u64();",
                "}"
              ],
              "oracle": [
                "    let mut rng = Lcg128CmDxsm64::new(12, 17);",
                "    let expected_output = output_dxsm(12);",
                "    assert_eq!(result, expected_output);",
                "    assert_eq!(rng.state, (12.wrapping_mul(MULTIPLIER as u128).wrapping_add(17)));",
                "    rng.step();",
                "    assert_eq!(rng.state, (12.wrapping_mul(MULTIPLIER as u128).wrapping_add(17)));",
                "    assert!(result > 0);"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(12, 17);",
                "    let result = rng.next_u64();",
                "    let mut rng = Lcg128CmDxsm64::new(12, 17);",
                "    let expected_output = output_dxsm(12);",
                "    assert_eq!(result, expected_output);",
                "    assert_eq!(rng.state, (12.wrapping_mul(MULTIPLIER as u128).wrapping_add(17)));",
                "    rng.step();",
                "    assert_eq!(rng.state, (12.wrapping_mul(MULTIPLIER as u128).wrapping_add(17)));",
                "    assert!(result > 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng1 = Lcg128CmDxsm64::new(10, 3);",
                "    let result1 = rng1.next_u64();",
                "    ",
                "    let mut rng2 = Lcg128CmDxsm64::new(10, 5);",
                "    let result2 = rng2.next_u64();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result1, output_dxsm(rng1.state));",
                "    assert_eq!(result2, output_dxsm(rng2.state));",
                "    assert_ne!(result1, result2);",
                "    assert!(result1 > 0);",
                "    assert!(result2 > 0);",
                "    assert!(result1 <= u64::MAX);",
                "    assert!(result2 <= u64::MAX);"
              ],
              "code": [
                "{",
                "    let mut rng1 = Lcg128CmDxsm64::new(10, 3);",
                "    let result1 = rng1.next_u64();",
                "    ",
                "    let mut rng2 = Lcg128CmDxsm64::new(10, 5);",
                "    let result2 = rng2.next_u64();",
                "    assert_eq!(result1, output_dxsm(rng1.state));",
                "    assert_eq!(result2, output_dxsm(rng2.state));",
                "    assert_ne!(result1, result2);",
                "    assert!(result1 > 0);",
                "    assert!(result2 > 0);",
                "    assert!(result1 <= u64::MAX);",
                "    assert!(result2 <= u64::MAX);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(50, 1);",
                "    let result1 = rng.next_u64();",
                "    let result2 = rng.next_u64();",
                "    let result3 = rng.next_u64();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result1, output_dxsm(50));",
                "    assert_eq!(result2, output_dxsm(rng.state));",
                "    assert_eq!(result3, output_dxsm(rng.state));"
              ],
              "code": [
                "{",
                "    let mut rng = Lcg128CmDxsm64::new(50, 1);",
                "    let result1 = rng.next_u64();",
                "    let result2 = rng.next_u64();",
                "    let result3 = rng.next_u64();",
                "    assert_eq!(result1, output_dxsm(50));",
                "    assert_eq!(result2, output_dxsm(rng.state));",
                "    assert_eq!(result3, output_dxsm(rng.state));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}