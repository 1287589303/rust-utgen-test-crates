{
  "name": "rand::distr::uniform::UniformSampler::sample_single_inclusive",
  "mod_info": {
    "name": "distr::uniform",
    "loc": "src/distr/mod.rs:101:1:101:17"
  },
  "visible": true,
  "loc": "src/distr/uniform.rs:358:5:369:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: UniformSampler::new_inclusive(low, high)? at line 367 is Err/None\n"
      ],
      "input_infer": "low and high values must be such that low > high, low or high are non-finite, or both low and high are equal for exclusive sampling.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = 10;",
                "    let high = 5;",
                "    let result = <UniformInt as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(Error::EmptyRange));"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = 10;",
                "    let high = 5;",
                "    let result = <UniformInt as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(Error::EmptyRange));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = 5;",
                "    let high = 5;",
                "    let result = <UniformInt as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::EmptyRange);",
                "    assert_eq!(result.unwrap_err(), Error::NonFinite);",
                "    assert!(matches!(result, Err(Error::EmptyRange)));",
                "    assert!(matches!(result, Err(Error::NonFinite)));"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = 5;",
                "    let high = 5;",
                "    let result = <UniformInt as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::EmptyRange);",
                "    assert_eq!(result.unwrap_err(), Error::NonFinite);",
                "    assert!(matches!(result, Err(Error::EmptyRange)));",
                "    assert!(matches!(result, Err(Error::NonFinite)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = f64::INFINITY;",
                "    let high = 10.0;",
                "    let result = <UniformFloat as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::NonFinite);"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = f64::INFINITY;",
                "    let high = 10.0;",
                "    let result = <UniformFloat as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::NonFinite);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = 0.0;",
                "    let high = f64::NAN;",
                "    let result = <UniformFloat as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(Error::NonFinite));"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = 0.0;",
                "    let high = f64::NAN;",
                "    let result = <UniformFloat as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(Error::NonFinite));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = f64::NAN;",
                "    let high = f64::NAN;",
                "    let result = <UniformFloat as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::NonFinite);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::EmptyRange);"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl RngCore for TestRng {",
                "        // Implement required methods here",
                "    }",
                "",
                "    let mut rng = TestRng;",
                "    let low = f64::NAN;",
                "    let high = f64::NAN;",
                "    let result = <UniformFloat as UniformSampler>::sample_single_inclusive(low, high, &mut rng);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::NonFinite);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::EmptyRange);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: UniformSampler::new_inclusive(low, high)? at line 367 is Ok/Some\n",
        "expected return value/type: Ok(uniform.sample(rng))\n"
      ],
      "input_infer": "low and high must be within the bounds of the defined range for Self::X, ensure low <= high for inclusive range, check if low and high generate non-finite values for relevant types, test with low = high for edge case, test with various data types supported by SampleBorrow, test with empty range where low > high to trigger EmptyRange error\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let result1 = UniformSampler::sample_single_inclusive(1, 10, &mut rng);",
                "    let result2 = UniformSampler::sample_single_inclusive(0, 0, &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result1.is_ok());",
                "    assert_eq!(result1.unwrap(), sample_in_range(1, 10, &mut rng));",
                "    assert!(result2.is_ok());",
                "    assert_eq!(result2.unwrap(), 0);",
                "    assert!(UniformSampler::sample_single_inclusive(f64::NAN, 1.0, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(1.0, f64::NAN, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(10, 1, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(f64::INFINITY, 1.0, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(1.0, f64::INFINITY, &mut rng).is_err());"
              ],
              "code": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let result1 = UniformSampler::sample_single_inclusive(1, 10, &mut rng);",
                "    let result2 = UniformSampler::sample_single_inclusive(0, 0, &mut rng);",
                "    assert!(result1.is_ok());",
                "    assert_eq!(result1.unwrap(), sample_in_range(1, 10, &mut rng));",
                "    assert!(result2.is_ok());",
                "    assert_eq!(result2.unwrap(), 0);",
                "    assert!(UniformSampler::sample_single_inclusive(f64::NAN, 1.0, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(1.0, f64::NAN, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(10, 1, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(f64::INFINITY, 1.0, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(1.0, f64::INFINITY, &mut rng).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let result1 = UniformSampler::sample_single_inclusive(1.0, 10.0, &mut rng);",
                "    let result2 = UniformSampler::sample_single_inclusive(5.5, 5.5, &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result1.is_ok());",
                "    assert_eq!(result1.unwrap(), 1.0..=10.0);",
                "    assert!(result2.is_ok());",
                "    assert_eq!(result2.unwrap(), 5.5);"
              ],
              "code": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let result1 = UniformSampler::sample_single_inclusive(1.0, 10.0, &mut rng);",
                "    let result2 = UniformSampler::sample_single_inclusive(5.5, 5.5, &mut rng);",
                "    assert!(result1.is_ok());",
                "    assert_eq!(result1.unwrap(), 1.0..=10.0);",
                "    assert!(result2.is_ok());",
                "    assert_eq!(result2.unwrap(), 5.5);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let _ = UniformSampler::sample_single_inclusive(10, 1, &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(UniformSampler::new_inclusive(1, 10).is_ok(), true);",
                "    assert_eq!(UniformSampler::sample_single_inclusive(1, 10, &mut rng).is_ok(), true);",
                "    assert_eq!(UniformSampler::sample_single_inclusive(0.0, 5.0, &mut rng).is_ok(), true);",
                "    assert!(UniformSampler::sample_single_inclusive(10, 1, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(f64::NAN, 10.0, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(10.0, f64::INFINITY, &mut rng).is_err());"
              ],
              "code": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let _ = UniformSampler::sample_single_inclusive(10, 1, &mut rng);",
                "    assert_eq!(UniformSampler::new_inclusive(1, 10).is_ok(), true);",
                "    assert_eq!(UniformSampler::sample_single_inclusive(1, 10, &mut rng).is_ok(), true);",
                "    assert_eq!(UniformSampler::sample_single_inclusive(0.0, 5.0, &mut rng).is_ok(), true);",
                "    assert!(UniformSampler::sample_single_inclusive(10, 1, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(f64::NAN, 10.0, &mut rng).is_err());",
                "    assert!(UniformSampler::sample_single_inclusive(10.0, f64::INFINITY, &mut rng).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let result1 = UniformSampler::sample_single_inclusive('a', 'z', &mut rng);",
                "    let result2 = UniformSampler::sample_single_inclusive('g', 'g', &mut rng);",
                "}"
              ],
              "oracle": [
                "    assert!(result1.is_ok());",
                "    assert!(result2.is_ok());",
                "    assert!(result1.unwrap() >= 'a' && result1.unwrap() <= 'z');",
                "    assert_eq!(result2.unwrap(), 'g');"
              ],
              "code": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let result1 = UniformSampler::sample_single_inclusive('a', 'z', &mut rng);",
                "    let result2 = UniformSampler::sample_single_inclusive('g', 'g', &mut rng);",
                "    assert!(result1.is_ok());",
                "    assert!(result2.is_ok());",
                "    assert!(result1.unwrap() >= 'a' && result1.unwrap() <= 'z');",
                "    assert_eq!(result2.unwrap(), 'g');",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let _ = UniformSampler::sample_single_inclusive(f32::INFINITY, 1.0, &mut rng);",
                "}"
              ],
              "oracle": [
                "    let result = UniformSampler::sample_single_inclusive(f32::INFINITY, 1.0, &mut rng); assert_eq!(result, Err(Error::NonFinite));",
                "    let result = UniformSampler::sample_single_inclusive(1.0, f32::INFINITY, &mut rng); assert_eq!(result, Err(Error::NonFinite));",
                "    let result = UniformSampler::sample_single_inclusive(f32::NAN, 1.0, &mut rng); assert_eq!(result, Err(Error::NonFinite));",
                "    let result = UniformSampler::sample_single_inclusive(-1.0, 1.0, &mut rng); assert!(result.is_ok());",
                "    let result = UniformSampler::sample_single_inclusive(0.0, 0.0, &mut rng); assert!(result.is_ok());"
              ],
              "code": [
                "{",
                "    struct SimpleRng;",
                "    ",
                "    impl RngCore for SimpleRng {",
                "        // Implement required methods...",
                "    }",
                "    ",
                "    let mut rng = SimpleRng;",
                "    ",
                "    let _ = UniformSampler::sample_single_inclusive(f32::INFINITY, 1.0, &mut rng);",
                "    let result = UniformSampler::sample_single_inclusive(f32::INFINITY, 1.0, &mut rng); assert_eq!(result, Err(Error::NonFinite));",
                "    let result = UniformSampler::sample_single_inclusive(1.0, f32::INFINITY, &mut rng); assert_eq!(result, Err(Error::NonFinite));",
                "    let result = UniformSampler::sample_single_inclusive(f32::NAN, 1.0, &mut rng); assert_eq!(result, Err(Error::NonFinite));",
                "    let result = UniformSampler::sample_single_inclusive(-1.0, 1.0, &mut rng); assert!(result.is_ok());",
                "    let result = UniformSampler::sample_single_inclusive(0.0, 0.0, &mut rng); assert!(result.is_ok());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}