{
  "name": "rand::rngs::reseeding::{impl#0}::new",
  "mod_info": {
    "name": "rngs::reseeding",
    "loc": "src/rngs/mod.rs:80:1:80:15"
  },
  "visible": true,
  "loc": "src/rngs/reseeding.rs:90:5:94:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: ReseedingCore::new(\n            threshold, reseeder,\n        )? at line 91 is Err/None\n"
      ],
      "input_infer": "threshold: 0 to 2^64 - 1, reseeder: valid instance of Rsdr or an instance that returns Err\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyRng;",
                "    impl SeedableRng for DummyRng {}",
                "    impl BlockRngCore for DummyRng {}",
                "    struct DummyReseeder;",
                "    impl TryRngCore for DummyReseeder {",
                "        type Error = ();",
                "    }",
                "    ",
                "    let reseeder = DummyReseeder;",
                "    ",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(0, reseeder);",
                "}"
              ],
              "oracle": [
                "    result.is_err();",
                "    assert_eq!(result.err(), Some(()));",
                "    result.is_ok();",
                "    assert!(result.is_err());",
                "    result.unwrap_err();"
              ],
              "code": [
                "{",
                "    struct DummyRng;",
                "    impl SeedableRng for DummyRng {}",
                "    impl BlockRngCore for DummyRng {}",
                "    struct DummyReseeder;",
                "    impl TryRngCore for DummyReseeder {",
                "        type Error = ();",
                "    }",
                "    ",
                "    let reseeder = DummyReseeder;",
                "    ",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(0, reseeder);",
                "    result.is_err();",
                "    assert_eq!(result.err(), Some(()));",
                "    result.is_ok();",
                "    assert!(result.is_err());",
                "    result.unwrap_err();",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyRng;",
                "    impl SeedableRng for DummyRng {}",
                "    impl BlockRngCore for DummyRng {}",
                "    struct DummyReseeder;",
                "    impl TryRngCore for DummyReseeder {",
                "        type Error = ();",
                "    }",
                "    ",
                "    let reseeder = DummyReseeder;",
                "    ",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(1 << 64, reseeder);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap(), ());",
                "    assert!(result.is_err());",
                "    let reseeder = DummyReseeder;",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(0, reseeder);",
                "    assert!(result.is_ok());",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(u64::MAX, reseeder);",
                "    assert!(result.is_err());",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(1, reseeder);",
                "    assert!(result.is_ok());"
              ],
              "code": [
                "{",
                "    struct DummyRng;",
                "    impl SeedableRng for DummyRng {}",
                "    impl BlockRngCore for DummyRng {}",
                "    struct DummyReseeder;",
                "    impl TryRngCore for DummyReseeder {",
                "        type Error = ();",
                "    }",
                "    ",
                "    let reseeder = DummyReseeder;",
                "    ",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(1 << 64, reseeder);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap(), ());",
                "    assert!(result.is_err());",
                "    let reseeder = DummyReseeder;",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(0, reseeder);",
                "    assert!(result.is_ok());",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(u64::MAX, reseeder);",
                "    assert!(result.is_err());",
                "    let result = ReseedingRng::<DummyRng, DummyReseeder>::new(1, reseeder);",
                "    assert!(result.is_ok());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyRng;",
                "    impl SeedableRng for DummyRng {}",
                "    impl BlockRngCore for DummyRng {}",
                "    struct InvalidReseeder;",
                "    impl TryRngCore for InvalidReseeder {",
                "        type Error = ();",
                "    }",
                "    ",
                "    let invalid_reseeder = InvalidReseeder;",
                "    ",
                "    let result = ReseedingRng::<DummyRng, InvalidReseeder>::new(100, invalid_reseeder);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "    assert!(result.unwrap_err().is_err());",
                "    assert!(result.unwrap_err().is_none());",
                "    assert_eq!(size_of_val(&result), 0);",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(_)));",
                "    assert_eq!(result.err(), Some(()));",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(()));"
              ],
              "code": [
                "{",
                "    struct DummyRng;",
                "    impl SeedableRng for DummyRng {}",
                "    impl BlockRngCore for DummyRng {}",
                "    struct InvalidReseeder;",
                "    impl TryRngCore for InvalidReseeder {",
                "        type Error = ();",
                "    }",
                "    ",
                "    let invalid_reseeder = InvalidReseeder;",
                "    ",
                "    let result = ReseedingRng::<DummyRng, InvalidReseeder>::new(100, invalid_reseeder);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "    assert!(result.unwrap_err().is_err());",
                "    assert!(result.unwrap_err().is_none());",
                "    assert_eq!(size_of_val(&result), 0);",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(_)));",
                "    assert_eq!(result.err(), Some(()));",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: ReseedingCore::new(\n            threshold, reseeder,\n        )? at line 91 is Ok/Some\n",
        "expected return value/type: Ok(ReseedingRng(BlockRng::new(ReseedingCore::new(\n            threshold, reseeder,\n        )?)))\n"
      ],
      "input_infer": "threshold: 0, 1 to 2^63-1; reseeder: any valid TryRngCore implementor instance\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 32];",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng",
                "        }",
                "    }",
                "",
                "    impl BlockRngCore for TestRng {",
                "        type Results = ();",
                "",
                "        fn try_from_rng<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self, R::Error> {",
                "            Ok(TestRng)",
                "        }",
                "    }",
                "",
                "    struct TestReseeder;",
                "",
                "    impl TryRngCore for TestReseeder {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let reseeder = TestReseeder;",
                "    let threshold = 0;",
                "",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "}"
              ],
              "oracle": [
                "    assert!(rng_result.is_ok());",
                "    let rng = rng_result.unwrap();",
                "    assert_eq!(rng.inner.threshold, i64::MAX);",
                "    assert_eq!(rng.inner.bytes_until_reseed, i64::MAX);",
                "    let reseeder = TestReseeder;",
                "    let threshold = 1;",
                "    ",
                "    let rng_result2 = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "    assert!(rng_result2.is_ok());",
                "    let rng2 = rng_result2.unwrap();",
                "    assert_eq!(rng2.inner.threshold, 1);",
                "    assert_eq!(rng2.inner.bytes_until_reseed, 1);"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 32];",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng",
                "        }",
                "    }",
                "",
                "    impl BlockRngCore for TestRng {",
                "        type Results = ();",
                "",
                "        fn try_from_rng<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self, R::Error> {",
                "            Ok(TestRng)",
                "        }",
                "    }",
                "",
                "    struct TestReseeder;",
                "",
                "    impl TryRngCore for TestReseeder {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let reseeder = TestReseeder;",
                "    let threshold = 0;",
                "",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "    assert!(rng_result.is_ok());",
                "    let rng = rng_result.unwrap();",
                "    assert_eq!(rng.inner.threshold, i64::MAX);",
                "    assert_eq!(rng.inner.bytes_until_reseed, i64::MAX);",
                "    let reseeder = TestReseeder;",
                "    let threshold = 1;",
                "    ",
                "    let rng_result2 = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "    assert!(rng_result2.is_ok());",
                "    let rng2 = rng_result2.unwrap();",
                "    assert_eq!(rng2.inner.threshold, 1);",
                "    assert_eq!(rng2.inner.bytes_until_reseed, 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 32];",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng",
                "        }",
                "    }",
                "",
                "    impl BlockRngCore for TestRng {",
                "        type Results = ();",
                "",
                "        fn try_from_rng<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self, R::Error> {",
                "            Ok(TestRng)",
                "        }",
                "    }",
                "",
                "    struct TestReseeder;",
                "",
                "    impl TryRngCore for TestReseeder {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let reseeder = TestReseeder;",
                "    let threshold = 1;",
                "",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "}"
              ],
              "oracle": [
                "    assert!(rng_result.is_ok());",
                "    let rng = rng_result.unwrap();",
                "    assert!(matches!(rng, ReseedingRng(_)));",
                "    assert_eq!(rng.0.threshold, 1);",
                "    assert_eq!(rng.0.bytes_until_reseed, 1);"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 32];",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng",
                "        }",
                "    }",
                "",
                "    impl BlockRngCore for TestRng {",
                "        type Results = ();",
                "",
                "        fn try_from_rng<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self, R::Error> {",
                "            Ok(TestRng)",
                "        }",
                "    }",
                "",
                "    struct TestReseeder;",
                "",
                "    impl TryRngCore for TestReseeder {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let reseeder = TestReseeder;",
                "    let threshold = 1;",
                "",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "    assert!(rng_result.is_ok());",
                "    let rng = rng_result.unwrap();",
                "    assert!(matches!(rng, ReseedingRng(_)));",
                "    assert_eq!(rng.0.threshold, 1);",
                "    assert_eq!(rng.0.bytes_until_reseed, 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 32];",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng",
                "        }",
                "    }",
                "",
                "    impl BlockRngCore for TestRng {",
                "        type Results = ();",
                "",
                "        fn try_from_rng<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self, R::Error> {",
                "            Ok(TestRng)",
                "        }",
                "    }",
                "",
                "    struct TestReseeder;",
                "",
                "    impl TryRngCore for TestReseeder {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let reseeder = TestReseeder;",
                "    let threshold = i64::MAX as u64;",
                "",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "}"
              ],
              "oracle": [
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "    assert!(rng_result.is_ok());",
                "    ",
                "    let result = rng_result.unwrap();",
                "    assert!(size_of_val(&result) > 0);",
                "    ",
                "    let reseeded_rng = rng_result.unwrap();",
                "    assert_eq!(reseeded_rng.0.inner.threshold, i64::MAX);",
                "    ",
                "    let rng_result_zero_threshold = ReseedingRng::<TestRng, TestReseeder>::new(0, reseeder);",
                "    assert!(rng_result_zero_threshold.is_ok());",
                "    ",
                "    let reseeded_rng_zero_threshold = rng_result_zero_threshold.unwrap();",
                "    assert_eq!(reseeded_rng_zero_threshold.0.inner.threshold, i64::MAX);"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 32];",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng",
                "        }",
                "    }",
                "",
                "    impl BlockRngCore for TestRng {",
                "        type Results = ();",
                "",
                "        fn try_from_rng<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self, R::Error> {",
                "            Ok(TestRng)",
                "        }",
                "    }",
                "",
                "    struct TestReseeder;",
                "",
                "    impl TryRngCore for TestReseeder {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let reseeder = TestReseeder;",
                "    let threshold = i64::MAX as u64;",
                "",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "    assert!(rng_result.is_ok());",
                "    ",
                "    let result = rng_result.unwrap();",
                "    assert!(size_of_val(&result) > 0);",
                "    ",
                "    let reseeded_rng = rng_result.unwrap();",
                "    assert_eq!(reseeded_rng.0.inner.threshold, i64::MAX);",
                "    ",
                "    let rng_result_zero_threshold = ReseedingRng::<TestRng, TestReseeder>::new(0, reseeder);",
                "    assert!(rng_result_zero_threshold.is_ok());",
                "    ",
                "    let reseeded_rng_zero_threshold = rng_result_zero_threshold.unwrap();",
                "    assert_eq!(reseeded_rng_zero_threshold.0.inner.threshold, i64::MAX);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestRng;",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 32];",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng",
                "        }",
                "    }",
                "",
                "    impl BlockRngCore for TestRng {",
                "        type Results = ();",
                "",
                "        fn try_from_rng<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self, R::Error> {",
                "            Ok(TestRng)",
                "        }",
                "    }",
                "",
                "    struct TestReseeder;",
                "",
                "    impl TryRngCore for TestReseeder {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let reseeder = TestReseeder;",
                "    let threshold = u64::MAX; // exceeds i64::MAX",
                "",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "}"
              ],
              "oracle": [
                "    assert!(rng_result.is_ok());",
                "    ",
                "    let reseeding_rng = rng_result.unwrap();",
                "    assert_eq!(size_of_val(&reseeding_rng), size_of_val(&ReseedingRng::<TestRng, TestReseeder>::new(0, reseeder).unwrap()));",
                "    assert_eq!(reseeding_rng.bytes_until_reseed, i64::MAX);",
                "    ",
                "    let threshold_zero = 0;",
                "    let rng_result_zero = ReseedingRng::<TestRng, TestReseeder>::new(threshold_zero, reseeder);",
                "    assert!(rng_result_zero.is_ok());",
                "    ",
                "    let reseeding_rng_zero = rng_result_zero.unwrap();",
                "    assert_eq!(reseeding_rng_zero.bytes_until_reseed, i64::MAX);",
                "    ",
                "    let threshold_neg = u64::MAX; // still valid for threshold, should be i64::MAX",
                "    let rng_result_neg = ReseedingRng::<TestRng, TestReseeder>::new(threshold_neg, reseeder);",
                "    assert!(rng_result_neg.is_ok());",
                "    ",
                "    let reseeding_rng_neg = rng_result_neg.unwrap();",
                "    assert_eq!(reseeding_rng_neg.bytes_until_reseed, i64::MAX);"
              ],
              "code": [
                "{",
                "    struct TestRng;",
                "",
                "    impl SeedableRng for TestRng {",
                "        type Seed = [u8; 32];",
                "        fn from_seed(seed: Self::Seed) -> Self {",
                "            TestRng",
                "        }",
                "    }",
                "",
                "    impl BlockRngCore for TestRng {",
                "        type Results = ();",
                "",
                "        fn try_from_rng<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self, R::Error> {",
                "            Ok(TestRng)",
                "        }",
                "    }",
                "",
                "    struct TestReseeder;",
                "",
                "    impl TryRngCore for TestReseeder {",
                "        type Error = ();",
                "",
                "        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Self::Error> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let reseeder = TestReseeder;",
                "    let threshold = u64::MAX; // exceeds i64::MAX",
                "",
                "    let rng_result = ReseedingRng::<TestRng, TestReseeder>::new(threshold, reseeder);",
                "    assert!(rng_result.is_ok());",
                "    ",
                "    let reseeding_rng = rng_result.unwrap();",
                "    assert_eq!(size_of_val(&reseeding_rng), size_of_val(&ReseedingRng::<TestRng, TestReseeder>::new(0, reseeder).unwrap()));",
                "    assert_eq!(reseeding_rng.bytes_until_reseed, i64::MAX);",
                "    ",
                "    let threshold_zero = 0;",
                "    let rng_result_zero = ReseedingRng::<TestRng, TestReseeder>::new(threshold_zero, reseeder);",
                "    assert!(rng_result_zero.is_ok());",
                "    ",
                "    let reseeding_rng_zero = rng_result_zero.unwrap();",
                "    assert_eq!(reseeding_rng_zero.bytes_until_reseed, i64::MAX);",
                "    ",
                "    let threshold_neg = u64::MAX; // still valid for threshold, should be i64::MAX",
                "    let rng_result_neg = ReseedingRng::<TestRng, TestReseeder>::new(threshold_neg, reseeder);",
                "    assert!(rng_result_neg.is_ok());",
                "    ",
                "    let reseeding_rng_neg = rng_result_neg.unwrap();",
                "    assert_eq!(reseeding_rng_neg.bytes_until_reseed, i64::MAX);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}